/**
 * @namespace Namespace for the Earth Server Generic Client
 * @version 0.7 alpha 25.11.1013
 */
var EarthServerGenericClient =  {};

/**
 * @ignore Just Inheritance Helper
 */
Function.prototype.inheritsFrom = function( parentClassOrObject )
{
    if ( parentClassOrObject.constructor == Function )
    {
        //Normal Inheritance
        this.prototype = new parentClassOrObject;
        this.prototype.constructor = this;
        this.prototype.parent = parentClassOrObject.prototype;
    }
    else
    {
        //Pure Virtual Inheritance
        this.prototype = parentClassOrObject;
        this.prototype.constructor = this;
        this.prototype.parent = parentClassOrObject;
    }
    return this;
};

/**
 * @ignore remove function for arrays - By John Resig
 */
EarthServerGenericClient.arrayRemove = function(array, from, to) {
    var rest = array.slice((to || from) + 1 || array.length);
    array.length = from < 0 ? array.length + from : from;
    return array.push.apply(array, rest);
};

/**
 * @ignore Helper function to replace all occurrences in strings
 */
EarthServerGenericClient.replaceAllFindsInString = function (str,find,replace)
{
    return str.split(find).join(replace);
};

/**
 * @ignore Helper function to check if an input is numeric.
 * @param input
 * @returns {boolean}
 * @constructor
 */
EarthServerGenericClient.IsNumeric = function(input)
{
    return (input - 0) == input && (input+'').replace(/^\s+|\s+$/g, "").length > 0;
};

/**
 * This function checks if this code is running is on a mobile platform.
 * @return true if mobile platform, false if not
 */
EarthServerGenericClient.isMobilePlatform = function ()
{
    var mobilePlatform = (function(a)
    {
        if(/android.+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge|maemo|midp|mmp|opera m(ob|in)i|palm(os)?|phone|p(ixi|re)\/|plucker|pocket|psp|symbian|treo|up\.(browser|link)|vodafone|wap|windows(ce|phone)|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|awa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r|s)|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp(i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac(|\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt(|\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg(g|\/(k|l|u)|50|54|e\-|e\/|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(di|rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-||o|v)|zz)|mt(50|p1|v)|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v)|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-|)|webc|whit|wi(g|nc|nw)|wmlb|wonu|x700|xda(\-|2|g)|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))
        {return true} else {return false}
    })(navigator.userAgent||window.opera);

    return mobilePlatform;
};

/**
 * @ignore Helper function to delete all children of a dom element.
 */
EarthServerGenericClient.deleteAllChildsFromDomElement = function(domElementID)
{
    var domElement = document.getElementById(domElementID);

    if(domElement)
    {
        while(domElement.firstChild)
        {
            domElement.removeChild(domElement.firstChild);
        }
    }
};

/**
 * @class Creates a light to enlighten the scene.
 * @param domElement - Dom element to append the light to.
 * @param index - Index of the light.
 * @param position - Position of the light (local coordinates)
 * @param radius - Radius of the light.
 * @param color - Color if the Light
 * @constructor
 */
EarthServerGenericClient.Light = function(domElement,index,position,radius,color)
{
    var ambientIntensity = "0.5";
    var intensity        = "0.8";
    var location         = "0 1000 0";

    if(position === undefined){  location = position;    }
    if(radius === undefined ) {  radius = "8000";    }
    if(color === undefined)   {  color = "1 1 1"; }

    if(domElement !== undefined && domElement !== null)
    {
        var light = document.createElement("PointLight");
        light.setAttribute("id", "EarthServerGenericClient_Light_"+index);
        light.setAttribute("ambientIntensity",ambientIntensity);
        light.setAttribute("color",color);
        light.setAttribute("intensity",intensity);
        light.setAttribute("radius",radius);
        light.setAttribute("location",location);

        domElement.appendChild(light);
        light = null;
    }
};

/**
 * @class SceneManager is the main class of the unified client.
 * All scene models are registered in this class with the add() function.
 * The createScene() function creates a x3dom scene with all scene models.
 * The createUI() function creates the UI.
 */
EarthServerGenericClient.SceneManager = function()
{
    var models = [];               // Array of scene models
    var modelLoadingProgress = []; // Array to store the models loading progress
    var totalLoadingProgress = 0;  // Value for the loading progress bar (all model loading combined)
    var baseElevation = [];        // Every Model has it's base elevation on the Y-Axis. Needed to change and restore the elevation.
    var baseWidth = [];            // Every Model has it's base width on the X-Axis. Needed to change and restore the width.
    var baseLength = [];            // Every Model has it's base length on the Z-Axis. Needed to change and restore the length.
    var progressCallback = undefined;// Callback function for the progress update.
    var annotationLayers = [];      // Array of AnnotationsLayer to display annotations in the cube
    var viewpoints = [];            // Array of user created viewpoints
    var cameraDefs = [];            // Name and ID of the specified cameras. Format: "NAME:ID"
    var lights = [];                // Array of (Point)lights
    var lightInScene = false;       // Flag if a light should be added to the scene
    var nextFrameCallback = [];     // Array of callbacks that should be done in any next frame.
    var lastFrameInsert = Number.MAX_VALUE; // Frame counter since the last insertion of data into the dom
    var framesBetweenDomInsertion = 1; // Number of frames between two insertions into the dom.
    var oculusRift = false;         // Flag if the scene is rendered for the oculus rift.
    var InstantIOPort = undefined;  // Port to Instant IO to connect the oculus rift.
    var drawCube = true;            // Flag if the cube should be drawn.
    var defaultSpecularColor = "0.25,0.25,0.25"; // default specular color for materials
    var defaultDiffuseColor = "1 1 1"; // default diffuse color for materials
    var keyMapping = {};            // Stores the keys for certain events
    var globalElevationValue = 10;  // Stores the last used global elevation value

    // Default cube sizes
    var cubeSizeX = 1000;
    var cubeSizeY = 1000;
    var cubeSizeZ = 1000;

    // Background
    var Background_groundAngle = "0.9 1.5 1.57";
    var Background_groundColor = "0.8 0.8 0.95 0.4 0.5 0.85 0.3 0.5 0.85 0.31 0.52 0.85";
    var Background_skyAngle    = "0.9 1.5 1.57";
    var Background_skyColor    = "0.8 0.8 0.95 0.4 0.5 0.85 0.3 0.5 0.85 0.31 0.52 0.85";

    /**
     * The maximum resolution in one axis of one scene model.
     * @default 2000
     * @type {number}
     */
    var maxResolution = 2000;

    /**
     * Enables/Disables the logging of Server requests, building of terrain etc.
     * @default false
     * @type {boolean}
     */
    var timeLog= false;

    /**
     * This variable contains the AxisLabel object.
     * This object manages the labels and its appearances on each axis.
     * @default null
     * @type {Object}
     */
    var axisLabels = null;

    /**
     * Initiates the default key mapping.
     */
    this.initKeyMapping = function()
    {
        // Go to viewpoint x
        keyMapping.vp1 = 49; // key: 1
        keyMapping.vp2 = 50; // key: 2
        keyMapping.vp3 = 51; // key: 3
        keyMapping.vp3 = 51; // key: 3
        keyMapping.vp4 = 52; // key: 4
        keyMapping.vp5 = 53; // key: 5
        keyMapping.vp6 = 54; // key: 6

        // modify light
        keyMapping.lightDown = 57; // key: 9
        keyMapping.lightUp   = 48; // key: 0

        // global elevation
        keyMapping.globalElevUp   = 105; // key: i
        keyMapping.globalElevDown = 107; // key: k

        // prompts the current viewpoint
        keyMapping.cvp = 66; // key: B
    };

    /**
     * Sets a custom short cut key. Events can be:
     * "ViewPointX": While x is a number between 1-6. Goes to viewpoint x.
     * "ShowViewPoint": Prompts the current viewpoint.
     * "LightDown"/"LightUp": changes the intensity of the light source.
     * "ElevationDown"/ElevationUp": changes the global elevation.
     * @param event - The event.
     * @param key - The key as char.
     */
    this.setShortCut = function(event,key)
    {
        // get the char value
        var value = String(key).charCodeAt(0);

        if(event.toLowerCase() === "viewpoint1") keyMapping.vp1 = value;
        if(event.toLowerCase() === "viewpoint2") keyMapping.vp2 = value;
        if(event.toLowerCase() === "viewpoint3") keyMapping.vp3 = value;
        if(event.toLowerCase() === "viewpoint4") keyMapping.vp4 = value;
        if(event.toLowerCase() === "viewpoint5") keyMapping.vp5 = value;
        if(event.toLowerCase() === "viewpoint6") keyMapping.vp6 = value;

        if(event.toLowerCase() === "showviewpoint") keyMapping.cvp = value;
        if(event.toLowerCase() === "elevationdown") keyMapping.globalElevDown = value;
        if(event.toLowerCase() === "elevationup")   keyMapping.globalElevUp = value;
        if(event.toLowerCase() === "lightup")       keyMapping.lightUp = value;
        if(event.toLowerCase() === "lightdwon")     keyMapping.lightDown = value;
    };

    /**
     * Handles the pressed key.
     */
    this.handleKeys = function (e)
    {
        var key = e.charCode;

        switch(key)
        {
            case keyMapping.vp1: this.setViewByCameraDefIndex(0);  break;
            case keyMapping.vp2: this.setViewByCameraDefIndex(1);  break;
            case keyMapping.vp3: this.setViewByCameraDefIndex(2);  break;
            case keyMapping.vp4: this.setViewByCameraDefIndex(3);  break;
            case keyMapping.vp5: this.setViewByCameraDefIndex(4);  break;
            case keyMapping.vp6: this.setViewByCameraDefIndex(5);  break;

            case keyMapping.cvp:        this.showCurrentViewPoint(); break;
            case keyMapping.lightUp:    this.increaseLightIntensity(0); break;
            case keyMapping.lightDown:  this.decreaseLightIntensity(0); break;
            case keyMapping.globalElevUp: this.increaseGlobalElevation(); break;
            case keyMapping.globalElevDown: this.decreaseGlobalElevation(); break;
            //default: console.log("No key defined for char: " + key);
        }
    };

    /**
     * Shows an alert with the current viewpoint.
     */
    this.showCurrentViewPoint = function()
    {
        var e = document.getElementById('x3d');
        var mat_view = e.runtime.viewMatrix().inverse();

        var rotation = new x3dom.fields.Quaternion(0, 0, 1, 0);
        rotation.setValue(mat_view);
        var rot = rotation.toAxisAngle();
        var translation = mat_view.e3();

        var text = '"' + translation.x.toFixed(5) + ' '
            + translation.y.toFixed(5) + ' ' + translation.z.toFixed(5) + '", ' +
            '"' + rot[0].x.toFixed(5) + ' ' + rot[0].y.toFixed(5) + ' '
            + rot[0].z.toFixed(5) + ' ' + rot[1].toFixed(5)+'"';

        window.prompt ("Copy to clipboard: Ctrl+C, Enter", text);
    };

    /**
     * Sets if the x3dom oculus rift mode shall be enabled.
     * @param value - True/False
     * @param port - Instant IO Port
     */
    this.setOculusRift = function( value, port )
    {
        oculusRift = value;
        InstantIOPort = port;
    };

    /**
     * Adds custom viewpoints to the scene and UI.
     * Viewpoints can be put out to the debug console by pressing 'd' and 'v'.
     * @param name - Name of the Viewpoint for the UI.
     * @param Position - Position of the viewpoint.
     * @param Orientation - Orientation of the viewpoint.
     */
    this.addCustomViewPoint = function(name,Position,Orientation)
    {
        // check if viewpoint with this name already exist
        for(var i=0; i<viewpoints.length;i++)
        {
            if( viewpoints[i].name === name)
            {
                console.log("EarthServerClient::MainScene::addCustomViewPoint: Viewpoint with name" + name + " already exist.");
                return;
            }
        }

        var vp = {};
        vp.name = name;
        vp.position = Position;
        vp.orientation = Orientation;

        viewpoints.push( vp );
    };

    /**
     * Resets the X3D Scene. All global setting of the scene keeps the the same.
     */
    this.resetScene = function()
    {
        // TODO: TEST function with different setups
        // clear all models and terrains
        for(var i=0; i<models.length; i++)
        {
            if (models[i].terrain) {
                models[i].terrain.clearMaterials();
                models[i].terrain.clearDefinedAppearances();
                models[i].terrain = null;
            }
        }

        // reset vars
        models = [];
        modelLoadingProgress = [];
        totalLoadingProgress = 0;
        baseElevation = [];
        baseWidth = [];
        baseLength = [];
        progressCallback = undefined;
        annotationLayers = [];
        cameraDefs = [];
        lights = [];
        nextFrameCallback = [];
        lastFrameInsert = Number.MAX_VALUE;

        // reset x3d scene
        EarthServerGenericClient.deleteAllChildsFromDomElement( this.x3dID );

        // destroy UI
        EarthServerGenericClient.deleteAllChildsFromDomElement( this.UIID );
        EarthServerGenericClient.destroyBasicUI( this.UIID );

        // add root and scene group nodes
        var root = document.createElement("group");
        root.setAttribute("id","root");
        var scene = document.createElement("group");
        scene.setAttribute("id",this.sceneID);

        root.appendChild(scene);
        var x3d = document.getElementById( this.x3dID);
        if(x3d)
            x3d.appendChild(root);
    };

    /**
     * Sets the default specular color for all modules.
     * The color set directly for a module overwrite this color.
     * @param color - Default Color in rgb e.g.: 0.25 0.25 0.25
     */
    this.setDefaultSpecularColor = function(color)
    {
        defaultSpecularColor = color;
    };


    /**
     * Return the default specular color.
     * @returns {string} - Default specular color in rgb.
     */
    this.getDefaultSpecularColor = function()
    {
        return defaultSpecularColor;
    };

    /**
     * Sets the default specular color for all modules.
     * The color set directly for a module overwrite this color.
     * @param color - Default Color in rgb e.g.: 0.25 0.25 0.25
     */
    this.setDefaultDiffuseColor = function(color)
    {
        defaultDiffuseColor = color;
    };

    /**
     * Return the default diffuse color.
     * @returns {string} - Default diffuse color in rgb.
     */
    this.getDefaultDiffuseColor = function()
    {
        return defaultDiffuseColor;
    };

    /**
     * Return the size of the cube in the x axis
     * @returns {number}
     */
    this.getCubeSizeX = function()
    {   return cubeSizeX;   };

    /**
     * Return the size of the cube in the y axis
     * @returns {number}
     */
    this.getCubeSizeY = function()
    {   return cubeSizeY;   };

    /**
     * Return the size of the cube in the z axis
     * @returns {number}
     */
    this.getCubeSizeZ = function()
    {   return cubeSizeZ;   };

    /**
     * Sets if a light is inserted into the scene.
     * @param value - Boolean value.
     */
    this.addLightToScene = function(value)
    {
        lightInScene = value;
    };

    /**
     * Sets if the cube should be drawn.
     * @param value - Boolean value.
     */
    this.setDrawCube = function(value)
    {
        drawCube = value;
    };

    /**
     * Returns the number of scene lights.
     * @returns {Number}
     */
    this.getLightCount = function()
    {
        return lights.length;
    };

    /**
     * This function sets the background of the X3Dom render window. The Background is basically a sphere
     * where the user can sets colors and defines angles to which the colors float.
     * Colors are RGB with floats [0-1] separated by whitespaces. ( "0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9" )
     * Angles are in [0-1.57] (1.57 is PI/2) and also separated by whitespaces. ( "0.9 1.57" )
     * You need exactly one more color than angles like the examples.
     * @param skyColors - Colors of the sky from top to horizon. Three RGB values for each color.
     * @param skyAngles - Angles to where the sky colors are drawn. 1.57 for full sky.
     * @param groundColors - Colors of the ground from bottom to horizon. Three RGB values for each color.
     * @param groundAngles - Angles to where the ground colors are drawn. 1.57 for full ground.
     */
    this.setBackground = function(skyColors,skyAngles,groundColors,groundAngles)
    {
        Background_groundAngle = groundAngles;
        Background_groundColor = groundColors;
        Background_skyAngle    = skyAngles;
        Background_skyColor    = skyColors;
    };

    /**
     * Returns the number of registered scene models.
     * @returns {Number}
     */
    this.getModelCount = function()
    {
        return models.length;
    };

    /**
     * Returns the name of the scene model with the given index.
     * @param modelIndex - Index of the model.
     * @returns {String}
     */
    this.getModelName = function(modelIndex)
    {
        if(modelIndex < models.length)
        {   return models[modelIndex].name; }
        else
        {   return "No model with ID " + modelIndex;    }
    };

    /**
     * Returns the X offset of the model with the given index.
     * @param modelIndex - Index of the model.
     * @returns {Number}
     */
    this.getModelOffsetX= function(modelIndex)
    {
        if(modelIndex < models.length)
        {   return models[modelIndex].xOffset; }
        else
        {
            console.log("MainScene::getModelOffsetX: No model with ID " + modelIndex);
            return 0;
        }
    };

    /**
     * Returns the Y offset of the model with the given index.
     * @param modelIndex - Index of the model.
     * @returns {Number}
     */
    this.getModelOffsetY= function(modelIndex)
    {
        if(modelIndex < models.length)
        {   return models[modelIndex].yOffset; }
        else
        {
            console.log("MainScene::getModelOffsetY: No model with ID " + modelIndex);
            return 0;
        }
    };

    /**
     * Returns the Z offset of the model with the given index.
     * @param modelIndex - Index of the model.
     * @returns {Number}
     */
    this.getModelOffsetZ= function(modelIndex)
    {
        if(modelIndex < models.length)
        {   return models[modelIndex].zOffset; }
        else
        {
            console.log("MainScene::getModelOffsetZ: No model with ID " + modelIndex);
            return 0;
        }
    };

    /**
     * Returns the transparency of the model with the given index.
     * @param modelIndex - Index of the model.
     * @returns {Number}
     */
    this.getModelTransparency = function(modelIndex)
    {
        if(modelIndex < models.length)
        {   return models[modelIndex].transparency; }
        else
        {
            console.log("MainScene::getModelTransparency: No model with ID " + modelIndex);
            return 0;
        }
    };

    /**
     * Let the scene model set it's specific UI element in the given domElement.
     * @param modelIndex - Index of the model.
     * @param domElement - domElement to put the UI element into.
     */
    this.setSpecificElement = function(modelIndex,domElement)
    {
        if(modelIndex < models.length)
        {   models[modelIndex].setSpecificElement(domElement); }
        else
        {
            console.log("MainScene::SetSpecificElement: No model with ID " + modelIndex);
        }
    };

    /**
     * @default 2000 / 200 on a mobile platform
     * @type {Number}
     */
    if( EarthServerGenericClient.isMobilePlatform())  //and for mobile Clients
        maxResolution = 200;

    /**
     * Enables or disables the logging.
     * @param value - Boolean
     */
    this.setTimeLog = function(value)
    {   timeLog = value; };

    /**
     * Starts the timer for a logging event with the given name.
     * @param eventName
     */
    this.timeLogStart = function(eventName)
    {
        if( timeLog)
        {   console.time(eventName); }
    };

    /**
     * Ends the timer for a logging event with the given name and prints the result.
     * @param eventName
     */
    this.timeLogEnd = function(eventName)
    {
        if( timeLog)
        {   console.timeEnd(eventName); }
    };

    /**
     * Returns the index of a scene model with a given name.
     * @param modelName - Name of the model.
     * @returns {number} - Index of the model or -1 if no model with the given name was found.
     */
    this.getModelIndex = function(modelName)
    {
        for(var i=0;i<models.length;i++)
        {
            if( models[i].name === modelName)
            {
                return i;
            }
        }

        return -1;
    };

    /**
     * This function returns the position within the cube for a specific point, if the cube represents the given area.
     * Returned object has "x","y","z" members and "valid" as a flag whether the point is within the area or not.
     * IF valid is false, "x","y" and "z" are not set and undefined.
     * @param modelIndex - Index of the model the point is used for. Used to determine the height on the y-axis.
     * @param latitude - Latitude coordinate of the point.
     * @param longitude - Longitude coordinate of the point.
     * @param area - Area of the cube.
     * @returns {{}} - Coordinates in scene space of the point.
     */
    this.getCubePositionForPoint = function(modelIndex,latitude,longitude,area)
    {
        var position = {};
        position.valid = false;

        var xPercent = (latitude  - area.minx) / (area.maxx - area.minx);
        var zPercent = (longitude - area.miny) / (area.maxy - area.miny);

        // Check bounds
        if( xPercent <0 || xPercent > 1 || zPercent <0 || zPercent >1)
        {   console.log("EarthServerGenericClient::SceneManager::getCubePositionForPoint: Point is not in the given area"); }
        else
        {
            position.x = (-cubeSizeX/2.0) + xPercent*cubeSizeX;
            position.y = (-cubeSizeY/2.0) + this.getModelOffsetY(modelIndex) * cubeSizeY;
            position.z = (-cubeSizeZ/2.0) + zPercent*cubeSizeZ;
            position.valid = true;
        }

        return position;
    };

    /**
     * Determines if an annotation layer will be drawn.
     * @param layerName - Name of the annotation layer.
     * @param drawValue - boolean value.
     */
    this.drawAnnotationLayer = function(layerName,drawValue)
    {
        var index = this.getAnnotationLayerIndex(layerName);
        if( index < annotationLayers.length )
        {   annotationLayers[index].renderLayer(drawValue); }
        else
        {   console.log("MainScene::drawAnnotationLayer: No Layer with name " + layerName);  }
    };

    /**
     * Returns the annotation texts of a given annotation layer as an array of strings.
     * @param layerName - Name of the Annotation Layer.
     * @returns {*} - Array of Annotations as strings.
     */
    this.getAnnotationLayerTexts = function(layerName)
    {
        var index = this.getAnnotationLayerIndex(layerName);
        if( index < annotationLayers.length )
        {   return annotationLayers[index].getAnnotationTexts(); }
        else
        {
            var val = [];
            val.push("MainScene::getAnnotationLayerTexts: No Layer with name " + layerName);
            return val;
        }
    };

    /**
     * Returns the number of registered AnnotationLayers.
     * @returns {Number}
     */
    this.getAnnotationLayerCount = function()
    {
        return annotationLayers.length;
    };

    /**
     * Returns the name of the AnnotationLayer with the given index.
     * @param layerIndex - Index of the AnnotationLayer.
     * @returns {*} - Either the Name of the AnnotationLayer or "No Name"
     */
    this.getAnnotationLayerName = function(layerIndex)
    {
        if( layerIndex < annotationLayers.length)
        {   return annotationLayers[layerIndex].name; }
        else
        {
            console.log("MainScene::getAnnotationLayerName: No Layer with ID " + layerIndex);
            return "No Name";
        }
    };

    /**
     * Returns the index of an existing AnnotationLayer in the array or -1 if no layer with the given name was found.
     * @param AnnotationLayerName - Name of the Layer
     * @returns {number} - Either index in the array or -1 if not found
     */
    this.getAnnotationLayerIndex = function(AnnotationLayerName)
    {
        for(var i=0;i<annotationLayers.length;i++)
        {
            if( annotationLayers[i].name === AnnotationLayerName)
            {
                return i;
            }
        }

        return -1;
    };

    /**
     * Adds an AnnotationsLayer to the scene.
     * @param layerName - Name of the Layer. You need the name of a layer to add annotations to it.
     * @param modelName - Name of the scene model to bind the layer to. Can be empty if no binding is intended.
     * @param fontSize - Font size of all annotations added to this layer.
     * @param fontColor - Color of all annotations added to this layer.
     * @param fontHover - The annotation text hovers above the annotation marker by this value.
     * @param markerSize - The size if the annotation marker
     * @param markerColor - Color of the annotation marker
     */
    this.addAnnotationsLayer = function(layerName,modelName,fontSize,fontColor,fontHover,markerSize,markerColor)
    {
        var root = document.getElementById("AnnotationsGroup");
        if( root)
        {
            if( this.getAnnotationLayerIndex(layerName) < 0)
            {
                var layer = new EarthServerGenericClient.AnnotationLayer(layerName,root,fontSize,fontColor,fontHover,markerSize,markerColor);
                annotationLayers.push(layer);
                var modelIndex = this.getModelIndex(modelName);
                if( modelIndex >= 0)
                {
                    //layer.setBoundModuleIndex(modelIndex);
                    models[modelIndex].addBinding(layer);
                }
            }
            else
            {   console.log("AnnotationLayer with this name already created.");   }
        }
        else
        {   console.log("Please add Layers after creating the scene.");   }
    };

    /**
     * Adds an annotation to an existing annotation layer.
     * @param AnnotationLayerName - Name of the annotation layer to add the annotation to.
     * @param xPos - Position on the x-axis of the annotation.
     * @param yPos - Position on the y-axis of the annotation.
     * @param zPos - Position on the z-axis of the annotation.
     * @param Text - Text of the annotation.
     */
    this.addAnnotation = function(AnnotationLayerName,xPos,yPos,zPos,Text)
    {
        var index = this.getAnnotationLayerIndex(AnnotationLayerName);
        if( index >= 0)
        {
            annotationLayers[index].addAnnotation(xPos,yPos,zPos,Text);
        }
        else
        {
           console.log("Could not found a AnnotationLayer with name: " + AnnotationLayerName);
        }
    };

    /**
     * Adds an annotation to an existing annotation layer.
     * The position is given in latitude/longitude and has to be in the bounding box of
     * the model the annotation layer is bound to. The annotation is automatically positioned
     * above the model as soon as it's loaded.
     * @param AnnotationLayerName - Name of the annotation layer to add the annotation to.
     * @param latitude - Position in latitude of the annotation.
     * @param longitude - Position in longitude of the annotation.
     * @param Text - Text of the annotation.
     */
    this.addAnnotationAtPosition = function(AnnotationLayerName,latitude,longitude,Text)
    {
        var layerIndex = this.getAnnotationLayerIndex(AnnotationLayerName);
        if( layerIndex >= 0)
        {
            // Check if layer is bound to a model
            var modelIndex = annotationLayers[layerIndex].getBoundModuleIndex();
            if( modelIndex >= 0)// is bound
            {
                // Get model's local area and calc the position in the fishtank
                var area = models[modelIndex].getAreaOfInterest();
                var xPercent = (latitude  - area.minx) / (area.maxx - area.minx);
                var zPercent = (longitude - area.miny) / (area.maxy - area.miny);

                // Check bounds
                if( xPercent <0 || xPercent > 1 || zPercent <0 || zPercent >1)
                {   console.log("Annotation " + Text + " is not in the module's " + models[modelIndex].getName() + " boundaries."); }
                else
                {
                    var xPos = (-cubeSizeX/2.0) + xPercent*cubeSizeX;
                    // We can't tell the real y position unless the model is fully loaded
                    var yPos = (-cubeSizeY/2.0) + this.getModelOffsetY(modelIndex) * cubeSizeY;
                    var zPos = (-cubeSizeZ/2.0) + zPercent*cubeSizeZ;

                    annotationLayers[layerIndex].addAnnotation(xPos,yPos,zPos,Text);
                }
            }
            else// unbound: can't get lat/long positions so can't insert this annotation.
            {
                console.log("AnnotationLayer with name: "+ AnnotationLayerName + " is not bound to a model.");
                console.log("Can't insert annotation " + Text + " at latitude/longitude position.");
            }
        }
        else
        {
            console.log("Could not found a AnnotationLayer with name: " + AnnotationLayerName);
        }
    };

    /**
     * Sets the callback function for the progress update. The progress function gives a parameter between 0-100.
     * You can set callback = null for no progress update at all. If no callback is given at all the progress is
     * printed to the console.
     * @param callback
     */
    this.setProgressCallback=function(callback)
    {
        progressCallback = callback;
    };

    /**
     * All Modules and Terrain shall report their loading progress.
     * Modules when they receive data and terrains if they are done building the terrain.
     * Every time this function is called 1 is added to the total progress. It is assumed that for every
     * request a terrain is build thus 100% = model.requests*2
     * If a callback is registered the function is called, otherwise the progress is printed to the console or ignored.
     * @param modelIndex - Index of the model.
     */
    this.reportProgress = function(modelIndex)
    {
        //If null no progress update is wished
        if( progressCallback !== null)
        {
            modelLoadingProgress[modelIndex] += 1;

            //Reset total loading progress to 0 and calc it with the new value
            totalLoadingProgress = 0;
            for(var i=0; i<modelLoadingProgress.length; i++)
            {
                var tmp = modelLoadingProgress[i] / ( models[i].requests *2 );
                if( tmp > 1.0) tmp = 1;
                totalLoadingProgress += tmp;
            }
            totalLoadingProgress = (totalLoadingProgress / modelLoadingProgress.length)*100;

            //Callback function or console?
            if( progressCallback !== undefined)
            {   progressCallback(totalLoadingProgress);    }
            else
            {   console.log(totalLoadingProgress); }
        }
    };

    /**
     * Returns the maximum resolution per dimension of a scene model.
     * This number depends on power templates (e.g. mobile device).
     * @return {Number}
     */
    this.getMaxResolution = function()
    {   return maxResolution;   };

    /**
     * Adds any scene model to the scene.
     * @param model - Any type of scene model.
     */
    this.addModel = function( model )
    {
        //Model ID is the current length of the models array. That means to IDs start at 0 and increase by 1.
        model.index = models.length;
        //Store model in the array
        models.push(model);
        //Initialize it's loading progress to 0
        modelLoadingProgress[model.index] = 0;
    };

    /**
     * Sets the view of the X3Dom window to the predefined camera.
     * @param camID - ID of the Camera dom object.
     */
    this.setView =function(camID)
    {
        var cam = document.getElementById(camID);
        if(cam)
        {
            if( oculusRift ) // there is always one viewpoint in oculus mode, change it
            {
                var oculusVP = document.getElementById("EarthServerClient_VR_vpp");
                var pos = cam.getAttribute("position");
                oculusVP.setAttribute("position",pos);
            }
            else
            {
                //If the user changes the camera, then moves around the camera has to be set to false to be able to bin again
                cam.setAttribute('set_bind','false');
                cam.setAttribute('set_bind','true');
            }
        }
        else
            console.log("EarthServerGenericClient::SceneManager::SetView can't find Camera with ID ", camID);
    };

    /**
     * Sets the view of the X3Dom window to the predefined camera.
     * @param cameraDefIndex - Index of the camera as stored in cameraDef.
     */
    this.setViewByCameraDefIndex =function(cameraDefIndex)
    {
        if(cameraDefIndex >= cameraDefs.length)
        {   console.log("EarthServerGenericClient::SceneManager::SetViewByCameraDefIndex has no camera with index ", cameraDefIndex);   }
        else
        {   var cameraDef = cameraDefs[ cameraDefIndex];    }

        var camName = cameraDef.split(":");
        if(camName.length <2 )
        {   console.log("EarthServerGenericClient::SceneManager::SetViewByCameraDefIndex can't find Camera with DEF ", cameraDef);   }
        else
        {   var camID = camName[1];}

        this.setView(camID);
    };


    /**
     * Returns the number of defined cameras
     * @returns {Number}
     */
    this.getCameraDefCount = function()
    {
        return cameraDefs.length;
    };

    /**
     * Returns the definition of the camera with the given index.
     * Format: "CameraName:CameraID"
     * CameraName is for the UI (show on a button or label)
     * CameraID is the ID of the dom element
     * @param cameraIndex - Index of the camera.
     * @returns {String}
     */
    this.getCameraDef = function(cameraIndex)
    {
        if(cameraIndex < cameraDefs.length)
        {   return cameraDefs[cameraIndex]; }
        else
        {   return "Camera:NotDefined"}
    };

    /**
     * Creates the whole X3DOM Scene in the fishtank/cube with all added scene models.
     * The Sizes of the cube are assumed as aspect ratios with values between 0 and 1.
     * Example createScene("x3dom_div",1.0, 0.3, 0.5 ) Cube has 30% height and 50 depth compared to the width.
     * @param x3dID - ID of the x3d scene dom element.
     * @param sceneID - ID of the x3dom root element.
     * @param SizeX - width of the cube.
     * @param SizeY - height of the cube.
     * @param SizeZ - depth of the cube.
     */
    this.createScene = function(x3dID,sceneID, SizeX, SizeY, SizeZ )
    {
        if( SizeX <= 0 || SizeX > 1.0) SizeX = 1.0;
        if( SizeY <= 0 || SizeY > 1.0) SizeY = 1.0;
        if( SizeZ <= 0 || SizeZ > 1.0) SizeZ = 1.0;

        cubeSizeX = (parseFloat(SizeX) * 1000);
        cubeSizeY = (parseFloat(SizeY) * 1000);
        cubeSizeZ = (parseFloat(SizeZ) * 1000);

        var x3d = document.getElementById(x3dID);
        var scene = document.getElementById(sceneID);
        if( !scene || !x3d)
        {
            alert("No X3D Scene found with id " + sceneID);
            return;
        }
        else
        {
            this.x3dID = x3dID;
            this.sceneID = sceneID;
        }

        // Navigation <navigationInfo id="navi" type='"TURNTABLE" "ANY"' typeParams="-0.4, 60, 0.5, 1.55"></navigationInfo>
        var navigation = document.createElement("navigationInfo");
        navigation.setAttribute("type",'"TURNTABLE" "ANY"');
        navigation.setAttribute("typeParams","-0.4, 60, 0.5, 2.55");
        scene.appendChild(navigation);

        // Light
        if( lightInScene)
        {
            var lightTransform = document.createElement("transform");
            lightTransform.setAttribute("id","EarthServerGenericClient_lightTransform0");
            lightTransform.setAttribute("translation","0 0 0");
            lights.push(new EarthServerGenericClient.Light(lightTransform,0, "0 0 0"));
            x3d.appendChild(lightTransform);
        }

        // Background
        if( !oculusRift ) // in oculus mode the background is the rendertextures and declared in this.appendVRShader()
        {
            var background = document.createElement("Background");
            background.setAttribute("groundAngle",Background_groundAngle);
            background.setAttribute("groundColor",Background_groundColor);
            background.setAttribute("skyAngle",Background_skyAngle);
            background.setAttribute("skyColor",Background_skyColor);
            x3d.appendChild(background);

            background = null;
        }

        // Cameras
       // if no custom viewpoints are set create three default ones
       if( viewpoints.length ===0 )
       {
           var cam1 = document.createElement('Viewpoint');
           cam1.setAttribute("id","EarthServerGenericClient_Cam_Front");
           cam1.setAttribute("position", "0 0 " + cubeSizeZ*2);
           cam1.setAttribute("description","EarthServerGenericClient_Cam_Front");
           cameraDefs.push("Front:EarthServerGenericClient_Cam_Front");

           var cam2 = document.createElement('Viewpoint');
           cam2.setAttribute("id","EarthServerGenericClient_Cam_Top");
           cam2.setAttribute("position", "0 " + cubeSizeY*2.5 + " 0");
           cam2.setAttribute("orientation", "1.0 0.0 0.0 -1.55");
           cam2.setAttribute("description","EarthServerGenericClient_Cam_Top");
           cameraDefs.push("Top:EarthServerGenericClient_Cam_Top");

           var cam3 = document.createElement('Viewpoint');
           cam3.setAttribute("id","EarthServerGenericClient_Cam_Side");
           cam3.setAttribute("position", "" + -cubeSizeX*2+ " 0 0");
           cam3.setAttribute("orientation", "0 1 0 -1.55");
           cam3.setAttribute("description","EarthServerGenericClient_Cam_Side");
           cameraDefs.push("Side:EarthServerGenericClient_Cam_Side");

           x3d.appendChild(cam1);
           x3d.appendChild(cam2);
           x3d.appendChild(cam3);

           cam1 = null;
           cam2 = null;
           cam3 = null;
       }

       // insert custom viewpoints
       for(var o=0;o<viewpoints.length;o++)
       {
           var customCam = document.createElement('Viewpoint');
           customCam.setAttribute("id","EarthServerGenericClient_Cam_"+viewpoints[o].name);
           customCam.setAttribute("description","EarthServerGenericClient_Cam_"+viewpoints[o].name);
           customCam.setAttribute("position", viewpoints[o].position);
           // check if orientation is set, else use default
           if( viewpoints[o].orientation !== undefined && viewpoints[o].orientation !== null )
           {   customCam.setAttribute("orientation",viewpoints[o].orientation );   }

           cameraDefs.push(""+viewpoints[o].name+":EarthServerGenericClient_Cam_"+viewpoints[o].name);

           x3d.appendChild(customCam);
           customCam = null;
       }


        // Cube
        if( drawCube)
        {
            var shape = document.createElement('Shape');
            var appearance = document.createElement('Appearance');
            //appearance.setAttribute("sorttype","opaque");
            var material = document.createElement('Material');
            material.setAttribute("emissiveColor","1 1 0");

            var lineset = document.createElement('IndexedLineSet');
            lineset.setAttribute("colorPerVertex", "false");
            lineset.setAttribute("coordIndex","0 1 2 3 0 -1 4 5 6 7 4 -1 0 4 -1 1 5 -1 2 6 -1 3 7 -1");

            var coords = document.createElement('Coordinate');
            coords.setAttribute("id", "cube");

            var cubeX = cubeSizeX/2.0;
            var cubeY = cubeSizeY/2.0;
            var cubeZ = cubeSizeZ/2.0;
            var cubeXNeg = -cubeSizeX/2.0;
            var cubeYNeg = -cubeSizeY/2.0;
            var cubeZNeg = -cubeSizeZ/2.0;

            var p = {};
            p[0] = ""+ cubeXNeg + " " + cubeYNeg + " " + cubeZNeg + " ";
            p[1] = ""+ cubeX + " " + cubeYNeg + " " + cubeZNeg + " ";
            p[2] = ""+ cubeX + " " + cubeY + " " + cubeZNeg + " ";
            p[3] = ""+ cubeXNeg + " " + cubeY + " " + cubeZNeg + " ";
            p[4] = ""+ cubeXNeg + " " + cubeYNeg + " " + cubeZ + " ";
            p[5] = ""+ cubeX + " " + cubeYNeg + " " + cubeZ + " ";
            p[6] = ""+ cubeX + " " + cubeY + " " + cubeZ + " ";
            p[7] = ""+ cubeXNeg + " " + cubeY + " " + cubeZ + " ";
            var points="";
            for(var i=0; i<8;i++)
            {   points = points+p[i];   }
            coords.setAttribute("point", points);

            lineset.appendChild(coords);
            appearance.appendChild(material);
            shape.appendChild(appearance);
            shape.appendChild(lineset);
            scene.appendChild(shape);

            shape = null;
            appearance = null;
            material = null;
            lineset = null;
            coords = null;
            points = null;
        }

        var trans = document.createElement('Transform');
        trans.setAttribute("id", "trans");

        scene.appendChild(trans);
        this.trans = trans;
        trans = null;

        var annotationTrans = document.createElement("transform");
        annotationTrans.setAttribute("id","AnnotationsGroup");
        scene.appendChild(annotationTrans);
        annotationTrans = null;

        if( oculusRift )
        {   this.appendVRShader(x3dID,sceneID);  }
    };

    this.appendVRShader = function(x3dID,sceneID)
    {
        var scene = document.getElementById(x3dID);
        if( !scene)
        {
            console.log("EarthServerClient::Scene::appendVRShader: Could not find scene element.");
            return;
        }

        var navigation = document.createElement("navigationInfo");
        //navigation.setAttribute("headlight","false");
        navigation.setAttribute("type",'"EXAMINE" "WALK"');
        scene.appendChild(navigation);

        var viewpoint = document.createElement("viewpoint");
        viewpoint.setAttribute("id","EarthServerClient_VR_vpp");
        viewpoint.setAttribute("DEF","EarthServerClient_VR_vp");
        viewpoint.setAttribute("orientation",'0 1 0 -2.99229');
        viewpoint.setAttribute("position",'0 120 0');// TODO: AUTOGENERATE
        viewpoint.setAttribute("zNear","0.1");
        viewpoint.setAttribute("zFar","4000");
        //viewpoint.setAttribute("fieldOfView","1.74");
        scene.appendChild(viewpoint);

        var background = document.createElement("background");
        background.setAttribute("skyColor","0 0 0"); // this has to be black.
        background.setAttribute("DEF","bgnd");
        scene.appendChild(background);

        var groupLEFT = document.createElement("group");
        groupLEFT.setAttribute("DEF","left");

        var shape = document.createElement("shape");
        var plane = document.createElement("plane");
        plane.setAttribute("solid","false");
        var app   = document.createElement("appearance");
        var renderTex = document.createElement("renderedTexture");
        renderTex.setAttribute("id","rtLeft");
        renderTex.setAttribute("stereoMode","LEFT_EYE");
        renderTex.setAttribute("update","ALWAYS");
        renderTex.setAttribute("dimensions",'1280 1600 4');
        renderTex.setAttribute("repeatS",'false');
        renderTex.setAttribute("repeatT",'false');
        renderTex.setAttribute("interpupillaryDistance","0.09");

        var viewpointLeft = document.createElement("viewpoint");
        viewpointLeft.setAttribute("USE","EarthServerClient_VR_vp");
        viewpointLeft.setAttribute("containerField",'viewpoint');
        renderTex.appendChild(viewpointLeft);

        var backgroundLeft = document.createElement("background");
        backgroundLeft.setAttribute("groundAngle",Background_groundAngle);
        backgroundLeft.setAttribute("groundColor",Background_groundColor);
        backgroundLeft.setAttribute("skyAngle",Background_skyAngle);
        backgroundLeft.setAttribute("skyColor",Background_skyColor);
        backgroundLeft.setAttribute("containerField",'background');
        renderTex.appendChild(backgroundLeft);

        var groupLeft = document.createElement("group");
        groupLeft.setAttribute("USE",sceneID);
        groupLeft.setAttribute("containerField","scene");
        renderTex.appendChild(groupLeft);

        var cShader = document.createElement("composedShader");
        var field1  = document.createElement("field");
        field1.setAttribute("name","tex");
        field1.setAttribute("type","SFInt32");
        field1.setAttribute("value","0");
        var field2  = document.createElement("field");
        field2.setAttribute("name","LeftEye");
        field2.setAttribute("type","SFFloat");
        field2.setAttribute("value","1");
        cShader.appendChild(field1);
        cShader.appendChild(field2);

        var vsl = "attribute vec3 position; \n";
        vsl += "attribute vec2 texcoord; \n";
        vsl += "uniform mat4 modelViewProjectionMatrix; \n";
        vsl += "varying vec2 fragTexCoord; \n";
        vsl += "void main() { \n";
        vsl += "vec2 pos = sign(position.xy); \n";
        vsl += "fragTexCoord = texcoord; \n";
        vsl += "gl_Position = vec4((pos.x - 1.0) / 2.0, pos.y, 0.0, 1.0); } \n";

        var vsr = "attribute vec3 position; \n";
        vsr += "attribute vec2 texcoord; \n";
        vsr += "uniform mat4 modelViewProjectionMatrix; \n";
        vsr += "varying vec2 fragTexCoord; \n";
        vsr += "void main() { \n";
        vsr += "vec2 pos = sign(position.xy); \n";
        vsr += "fragTexCoord = texcoord; \n";
        vsr += "gl_Position = vec4((pos.x + 1.0) / 2.0, pos.y, 0.0, 1.0); } \n";

        var vsf = "#ifdef GL_ES \n";
        vsf += "precision highp float; \n";
        vsf += "#endif \n";
        vsf += "uniform sampler2D tex; \n";
        vsf += "uniform float leftEye; \n";
        vsf += "varying vec2 fragTexCoord; \n";
        vsf += "void main() { \n";
        vsf += "float distortionScale = 0.7; \n";
        vsf += "vec2 lensCenter = vec2(0.151976495726, 0.0); \n";
        vsf += "if (leftEye == 0.0) { \n";
        vsf += "lensCenter.x *= -1.0; } \n";
        vsf += "vec2 theta = (fragTexCoord * 2.0) - 1.0; \n";
        vsf += "float rSq = theta.x * theta.x + theta.y * theta.y; \n";
        vsf += "vec2 rvec = theta * (1.0 + 0.22 * rSq + 0.24 * rSq * rSq); \n";
        vsf += "vec2 texCoord = (distortionScale*rvec+(1.0-distortionScale)*lensCenter + 1.0) / 2.0; \n";
        vsf += "if (any(notEqual(clamp(texCoord, vec2(0.0, 0.0), vec2(1.0, 1.0)) - texCoord,vec2(0.0, 0.0)))) \n";
        vsf += "{ discard; } \n";
        vsf += "else { \n";
        vsf += "vec3 col = texture2D(tex, texCoord).rgb; \n";
        vsf += "gl_FragColor = vec4(col, 1.0); }  } \n";

        var shaderPartVertex = document.createElement("shaderPart");
        shaderPartVertex.setAttribute("type","VERTEX");
        shaderPartVertex.innerHTML = vsl;
        cShader.appendChild(shaderPartVertex);

        var shaderPartFragment = document.createElement("shaderPart");
        shaderPartFragment.setAttribute("type","FRAGMENT");
        shaderPartFragment.innerHTML = vsf;
        shaderPartFragment.setAttribute("DEF","frag");
        cShader.appendChild(shaderPartFragment);

        var groupRIGHT = document.createElement("group");
        groupRIGHT.setAttribute("DEF","right");

        var shapeR = document.createElement("shape");
        var planeR = document.createElement("plane");
        planeR.setAttribute("solid","false");
        var appR   = document.createElement("appearance");
        var renderTexR = document.createElement("renderedTexture");
        renderTexR.setAttribute("id","rtRight");
        renderTexR.setAttribute("stereoMode","RIGHT_EYE");
        renderTexR.setAttribute("update","ALWAYS");
        renderTexR.setAttribute("dimensions",'1280 1600 4');
        renderTexR.setAttribute("repeatS",'false');
        renderTexR.setAttribute("repeatT",'false');
        renderTexR.setAttribute("interpupillaryDistance","0.09");

        var viewpointRight = document.createElement("viewpoint");
        viewpointRight.setAttribute("USE","EarthServerClient_VR_vp");
        viewpointRight.setAttribute("containerField",'viewpoint');
        renderTexR.appendChild(viewpointRight);

        var backgroundRight = document.createElement("background");
        backgroundRight.setAttribute("groundAngle",Background_groundAngle);
        backgroundRight.setAttribute("groundColor",Background_groundColor);
        backgroundRight.setAttribute("skyAngle",Background_skyAngle);
        backgroundRight.setAttribute("skyColor",Background_skyColor);
        backgroundRight.setAttribute("containerField",'background');
        renderTexR.appendChild(backgroundRight);

        var groupRight = document.createElement("group");
        groupRight.setAttribute("USE",sceneID);
        groupRight.setAttribute("containerField","scene");
        renderTexR.appendChild(groupRight);

        var cShaderR = document.createElement("composedShader");
        var field1R  = document.createElement("field");
        field1R.setAttribute("name","tex");
        field1R.setAttribute("type","SFInt32");
        field1R.setAttribute("value","0");
        var field2R = document.createElement("field");
        field2R.setAttribute("name","LeftEye");
        field2R.setAttribute("type","SFFloat");
        field2R.setAttribute("value","1");
        cShaderR.appendChild(field1R);
        cShaderR.appendChild(field2R);

        var shaderPartVertexR = document.createElement("shaderPart");
        shaderPartVertexR.setAttribute("type","VERTEX");
        //shaderPartVertexR.setAttribute("url","shader/oculusVertexShaderRight.glsl");
        shaderPartVertexR.innerHTML = vsr;

        cShaderR.appendChild(shaderPartVertexR);

        var shaderPartFragmentR = document.createElement("shaderPart");
        shaderPartFragmentR.setAttribute("type","FRAGMENT");
        shaderPartFragmentR.setAttribute("USE", "frag");
        cShaderR.appendChild(shaderPartFragmentR);

        app.appendChild(renderTex);
        app.appendChild(cShader);
        shape.appendChild(app);
        shape.appendChild(plane);
        groupLEFT.appendChild(shape);
        appR.appendChild(renderTexR);
        appR.appendChild(cShaderR);
        shapeR.appendChild(appR);
        shapeR.appendChild(planeR);
        groupRIGHT.appendChild(shapeR);
        scene.appendChild(groupLEFT);
        scene.appendChild(groupRIGHT);
    };

    /**
     * Creates the axis labels around the cube.
     */
    this.createAxisLabels = function(xLabel,yLabel,zLabel)
    {
        //Use given parameters or default values if parameters are not defined
        xLabel = xLabel || "X";
        yLabel = yLabel || "Y";
        zLabel = zLabel || "Z";

        axisLabels = new EarthServerGenericClient.AxisLabels(cubeSizeX/2, cubeSizeY/2, cubeSizeZ/2);
        axisLabels.createAxisLabels(xLabel,yLabel,zLabel);
    };

    /**
     * @ignore
     * Open a websocket
     * @param location
     * @returns {*}
     */
    this.websocket = function (location)
    {
        if (window.MozWebSocket)
            return new MozWebSocket(location);
        else
            return new WebSocket(location);
    };

    /**
     * @ignore
     * Starts the connection to InstantIO.
     * @param location
     * @param name
     */
    this.start_log = function (location, name)
    {
        var viewpoint = document.getElementById('EarthServerClient_VR_vpp');

        socket_ass = this.websocket(location);
        socket_ass.onmessage = function(event)
        {
            var h = x3dom.fields.SFVec4f.parse(event.data);
            var q = new x3dom.fields.Quaternion(h.x, h.y, h.z, h.w);

            var aa = q.toAxisAngle();

            viewpoint.setAttribute("orientation", aa[0].x + " " + aa[0].y + " " + aa[0].z + " " + aa[1]);
        }
    };

    /**
     * This function starts to load all models. You call this when the html is loaded or later on a click.
     */
    this.createModels = function()
    {
        // overwrite the enterFrame and exitFrame methods of the x3dom runtime (see doc below).
        var element = document.getElementById("x3d");
        element.runtime.enterFrame = EarthServerGenericClient.MainScene.nextFrame;

        // add event listener for keyboard
        document.addEventListener('keypress', function (e) {
            EarthServerGenericClient.MainScene.handleKeys(e);
        }, false);

        if( !oculusRift ) // oculus mode overwrites exit frame itself
        {   element.runtime.exitFrame  = EarthServerGenericClient.MainScene.exitFrame;  }
        else // oculus mode + this.exitframe
        {
            var runtime = null;
            var rtLeft, rtRight;
            var lastW, lastH;

            runtime = document.getElementById('x3d').runtime;
            rtLeft = document.getElementById('rtLeft');
            rtRight = document.getElementById('rtRight');

            lastW = +runtime.getWidth();
            lastH = +runtime.getHeight();

            var hw = Math.round(lastW / 2);
            rtLeft.setAttribute('dimensions',  hw + ' ' + lastH + ' 4');
            rtRight.setAttribute('dimensions', hw + ' ' + lastH + ' 4');

            runtime.exitFrame = function ()
            {
                var w = +runtime.getWidth();
                var h = +runtime.getHeight();

                if (w != lastW || h != lastH)
                {
                    var half = Math.round(w / 2);
                    rtLeft.setAttribute('dimensions',  half + ' ' + h + ' 4');
                    rtRight.setAttribute('dimensions', half + ' ' + h + ' 4');

                    lastW = w;
                    lastH = h;
                }

                EarthServerGenericClient.MainScene.exitFrame();
            };

            this.start_log("ws://localhost:" + InstantIOPort + "/InstantIO/element/ovr/Orientation/data.string", "image");
        }

        // Append the child into the scene
        if( oculusRift ) // oculus mode needs the root node to NOT rendered
        {
            var root = document.getElementById("root");
            root.setAttribute("render","false");
        }

        for(var i=0; i< models.length; i++)
        {
            models[i].createModel(this.trans,cubeSizeX,cubeSizeY,cubeSizeZ);
        }
    };

    /**
     * This function forces the x3dom runtime to render a next frame even if no change to the scene or any
     * movement to from the user occurred. This is needed during the building process of the scene.
     * Data is inserted into the dom with a few frames between them to prevent stalls.
     * If the user does not move the mouse no new frame is drawn and no new data in inserted.
     *
     * This function forces new frames and therefor the insertion of new data.
     */
    this.exitFrame = function()
    {
        if( nextFrameCallback.length !== 0)
        {
            var element = document.getElementById("x3d");
            // NOTE: If the 'x3d' element gets hidden while there are nextFrameCallbacks the element will not be found.
            // In this case we can do nothing else than try it again:
            if (element) {
                element.runtime.canvas.doc.needRender = 1; //set this to true to render even without movement
            }
        }
    };

    /**
     * This function is executed every frame. If a terrain whats to add a chunk
     * it has registered the request and this function let one terrain add a single
     * chunk and wait for a few frames afterwards.
     */
    this.nextFrame = function()
    {
        if( nextFrameCallback.length !== 0)
        {   lastFrameInsert++;  }

        if( nextFrameCallback.length !== 0 && lastFrameInsert >= framesBetweenDomInsertion)
        {
            var callbackIndex = nextFrameCallback.shift();
            models[callbackIndex].terrain.nextFrame();
            lastFrameInsert = 0;
        }
    };

    /**
     * This function lets terrains register their request to add a chunk to the scene.
     * @param modelIndex - Index of the model that uses the terrain.
     */
    this.enterCallbackForNextFrame = function( modelIndex )
    {
        nextFrameCallback.push( modelIndex );
    };

    /**
     * Updates the position of a light.
     * @param lightIndex - Index of the light
     * @param which - Which Axis will be changed (0:X 1:Y 2:Z)
     * @param value - the new position
     */
    this.updateLightPosition = function(lightIndex,which,value)
    {
        var trans = document.getElementById("EarthServerGenericClient_lightTransform"+lightIndex);

        if( trans && which !== undefined && value !== undefined )
        {
            var oldTrans = trans.getAttribute("translation");
            oldTrans = oldTrans.split(" ");
            oldTrans[which] = value;
            trans.setAttribute("translation",oldTrans[0] + " " + oldTrans[1] + " " + oldTrans[2]);
        }
        else
        {
            console.log("EarthServerGenericClient::SceneManager: Can't update light position.");
            console.log("Index " + lightIndex + ", Axis "+ which + " and Position " + value);
        }
    };

    /**
     * Updates the radius of the light with the given index.
     * @param lightIndex - Index of the light.
     * @param value - New radius.
     */
    this.updateLightRadius = function(lightIndex,value)
    {
        var light = document.getElementById("EarthServerGenericClient_Light_"+lightIndex);
        if(light)
        {
            light.setAttribute("radius",value);
        }
        else
        {   console.log("EarthServerGenericClient::SceneManager: Can't find light with index " + lightIndex +".");}
    };

    /**
     * Updates the intensity of the light with the given index.
     * @param lightIndex - Index of the light.
     * @param value - New intensity.
     */
    this.updateLightIntensity = function(lightIndex,value)
    {
        var light = document.getElementById("EarthServerGenericClient_Light_"+lightIndex);
        if(light)
        {
            light.setAttribute("intensity",value);
        }
        else
        {   console.log("EarthServerGenericClient::SceneManager: Can't find light with index " + lightIndex +".");}
    };

    /**
     * Increases the intensity value of the light with the given index by a constant value.
     * @param lightIndex
     */
    this.increaseLightIntensity = function(lightIndex)
    {
        var light = document.getElementById("EarthServerGenericClient_Light_"+lightIndex);
        if(light)
        {
            var currentValue = light.getAttribute("intensity");
            var newValue = parseFloat(currentValue) + 0.1;
            light.setAttribute("intensity",String(newValue));
        }
        else
        {   console.log("EarthServerGenericClient::SceneManager: Can't find light with index " + lightIndex +".");}
    };

    /**
     * Decreases the intensity value of the light with the given index by a constant value.
     * @param lightIndex
     */
    this.decreaseLightIntensity = function(lightIndex)
    {
        var light = document.getElementById("EarthServerGenericClient_Light_"+lightIndex);
        if(light)
        {
            var currentValue = light.getAttribute("intensity");
            var newValue = parseFloat(currentValue) - 0.1;
            light.setAttribute("intensity",String(newValue));
        }
        else
        {   console.log("EarthServerGenericClient::SceneManager: Can't find light with index " + lightIndex +".");}
    };

    /**
     * Update Offset changes the position selected SceneModel on the x-,y- or z-Axis.
     * @param modelIndex - Index of the model that should be altered
     * @param which - Which Axis will be changed (0:X 1:Y 2:Z)
     * @param value - The new position
     */
    this.updateOffset = function(modelIndex,which,value)
    {
        var trans = document.getElementById("EarthServerGenericClient_modelTransform"+modelIndex);

        if( trans )
        {
            var offset=0;
            switch(which)
            {
                case 0: offset = cubeSizeX/2.0;
                        break;
                case 1: offset = cubeSizeY/2.0;
                        break;
                case 2: offset = cubeSizeZ/2.0;
                        break;
            }

            var oldTrans = trans.getAttribute("translation");
            oldTrans = oldTrans.split(" ");
            var delta = oldTrans[which] - (value - offset);
            oldTrans[which] = value - offset;
            trans.setAttribute("translation",oldTrans[0] + " " + oldTrans[1] + " " + oldTrans[2]);
            models[modelIndex].movementUpdateBindings(which,delta);
        }
    };

    /**
     * Changes the position of the selected SceneModel on the x-,y- or z-Axis by the given delta.
     * @param modelIndex - Index of the model that should be altered
     * @param which - Which Axis will be changed (0:X 1:Y 2:Z)
     * @param delta - Delta to change the current position.
     */
    this.updateOffsetByDelta = function(modelIndex,which,delta)
    {
        var trans = document.getElementById("EarthServerGenericClient_modelTransform"+modelIndex);

        if( trans )
        {
            var oldTrans = trans.getAttribute("translation");
            oldTrans = oldTrans.split(" ");
            oldTrans[which] = parseFloat(oldTrans[which]) - parseFloat(delta);
            trans.setAttribute("translation",oldTrans[0] + " " + oldTrans[1] + " " + oldTrans[2]);
            models[modelIndex].movementUpdateBindings(which,delta);
        }
        else
        {   console.log("EarthServerGenericClient::SceneManager: Can't find transformation for model with index " + modelIndex);}
    };

    /**
     * Updates the model's number of shown elements/layers.
     * @param moduleIndex - Index of the model
     * @param value - Number of elements
     */
    this.updateMaxShownElements = function(moduleIndex,value)
    {
        if( moduleIndex <models.length && moduleIndex >=0)
            models[moduleIndex].updateMaxShownElements(value);
    };

    /**
     * This changes the scaling of all models on the Y-Axis.
     * @param value - The base elevation is multiplied by this value
     */
    this.updateElevationOfAllModels = function(value)
    {
        globalElevationValue = value;

        for(var i=0; i< models.length; i++)
        {
            this.updateElevation(i,value);
        }
    };

    /**
     * Increases the global elevation by a constant factor.
     */
    this.increaseGlobalElevation = function()
    {
        globalElevationValue++;
        this.updateElevationOfAllModels(globalElevationValue);
    };

    /**
     * Decreases the global elevation by a constant factor.
     */
    this.decreaseGlobalElevation = function()
    {
        if(globalElevationValue > 1) // don't let global elevation value get negative or 0
        {
            globalElevationValue--;
            this.updateElevationOfAllModels(globalElevationValue);
        }
    };

    /**
     * This changes the scaling on the Y-Axis(Elevation).
     * @param modelIndex - Index of the model that should be altered
     * @param value - The base elevation is multiplied by this value
     */
    this.updateElevation = function(modelIndex,value)
    {
        var trans = document.getElementById("EarthServerGenericClient_modelTransform"+modelIndex);

        if( trans )
        {
            var transValue = trans.getAttribute("scale");
            var oldTrans = transValue.split(" ");

            if( baseElevation[modelIndex] === undefined)
            {
                baseElevation[modelIndex] = oldTrans[1];
            }

            oldTrans[1] = value*baseElevation[modelIndex]/10;

            trans.setAttribute("scale",oldTrans[0] + " " + oldTrans[1] + " " + oldTrans[2]);

            models[modelIndex].updateTranslationForElevation(oldTrans[1]);
            models[modelIndex].elevationUpdateBinding(value);
        }
    };

    /**
     * This changes the scaling on the X-Axis(Width).
     * @param modelIndex - Index of the model that should be altered
     * @param value - The base elevation is multiplied by this value
     */
    this.updateWidth = function(modelIndex,value)
    {
        var trans = document.getElementById("EarthServerGenericClient_modelTransform"+modelIndex);

        if( trans )
        {
            var oldTrans = trans.getAttribute("scale");
            oldTrans = oldTrans.split(" ");

            if( baseWidth[modelIndex] === undefined)
            {
                baseWidth[modelIndex] = oldTrans[0];
            }

            oldTrans[0] = value*baseWidth[modelIndex]/10;

            trans.setAttribute("scale",oldTrans[0] + " " + oldTrans[1] + " " + oldTrans[2]);
            models[modelIndex].elevationUpdateBinding();
        }
    };

    /**
     * This changes the scaling on the Z-Axis(Length).
     * @param modelIndex - Index of the model that should be altered
     * @param value - The base elevation is multiplied by this value
     */
    this.updateLength = function(modelIndex,value)
    {
        var trans = document.getElementById("EarthServerGenericClient_modelTransform"+modelIndex);

        if( trans )
        {
            var oldTrans = trans.getAttribute("scale");
            oldTrans = oldTrans.split(" ");

            if( baseLength[modelIndex] === undefined)
            {
                baseLength[modelIndex] = oldTrans[2];
            }

            oldTrans[2] = value*baseLength[modelIndex]/10;

            trans.setAttribute("scale",oldTrans[0] + " " + oldTrans[1] + " " + oldTrans[2]);
            models[modelIndex].elevationUpdateBinding();
        }
    };

    /**
     * Updates the model's size for rendering points.
     * @param modelIndex - Index of the model that should be altered
     * @param value - New point size
     */
    this.updatePointSize = function(modelIndex,value)
    {
        if( modelIndex <models.length && modelIndex >=0)
            models[modelIndex].updatePointSize(value);

    };

    /**
     * Returns the elevation value of a scene model at a specific point in the 3D scene.
     * The point is checked in the current state of the scene with all transformations.
     * @param modelIndex - Index of the model.
     * @param xPos - Position on the x-axis.
     * @param zPos - Position on the z-axis.
     * @returns {number} - The height on the y-axis.
     */
    this.getHeightAt3DPosition = function(modelIndex,xPos,zPos)
    {
        if(modelIndex >= 0 && modelIndex < models.length)
        {
            return models[modelIndex].getHeightAt3DPosition(xPos,zPos);
        }
        else
        {   return 0;   }
    };

    /**
     * Returns the dem value of a scene model at a specific point in the 3D scene.
     * @param modelIndex - Index of the model.
     * @param xPos - Position on the x-axis.
     * @param zPos - Position on the z-axis.
     * @returns {number} - The height of the dem.
     */
    this.getDemValueAt3DPosition = function(modelIndex,xPos,zPos)
    {
        if(modelIndex >= 0 && modelIndex < models.length)
        {
            return models[modelIndex].getDemValueAt3DPosition(xPos,zPos);
        }
        else
        {   return 0;   }
    };

    /**
     * Changes the transparency of the Scene Model.
     * @param modelIndex - Index of the model that should be altered
     * @param value - New Transparency between 0-1 (Fully Opaque - Fully Transparent)
     */
    this.updateTransparency = function(modelIndex,value)
    {
        if(modelIndex < models.length)
        {   models[modelIndex].updateTransparency(value);   }
    };

    /**
     * Example function for the onClick event.
     * @param modelIndex - Index of the clicked model.
     * @param hitPoint - Array with the coordinates in screen space.
     */
    this.OnClickFunction = function(modelIndex,hitPoint)
    {
        /*
            Does nothing per default but provide a small example.
            Overwrite this function with custom code.
        */
        //var height = this.getHeightAt3DPosition(modelIndex,hitPoint[0],hitPoint[2]);
        //var height = this.getDemValueAt3DPosition(modelIndex,hitPoint[0],hitPoint[2]);
        //alert(height);
    };

    /**
     * This creates the UI for the Scene.
     * @param domElementID - The dom element where to append the UI.
     */
    this.createUI = function(domElementID)
    {
        this.UIID = domElementID;
        EarthServerGenericClient.createBasicUI(domElementID);
    };

    // init keymapping
    this.initKeyMapping();
};

// Create main scene
EarthServerGenericClient.MainScene = new EarthServerGenericClient.SceneManager();
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Annotation Layer to create multiple Annotations with the same style who belong together.
 * @param Name - Name of the Layer. To be displayed and to add annotations to it.
 * @param root - X3dom element to append the annotations.
 * @param fontSize - Font size of the annotations.
 * @param fontColor - Font color of the annotations
 * @param fontHover - The annotations hovers above the marker by this value.
 * @param markerSize - Size of the annotations marker.
 * @param markerColor - Color of the annotations marker.
 * @constructor
 */
EarthServerGenericClient.AnnotationLayer = function(Name,root,fontSize,fontColor,fontHover,markerSize,markerColor)
{

    this.name = Name;   // Name of this layer
    var annotationTransforms = []; // Array with all annotation text transforms
    var annotations = [];   // The text of the annotations (displayed in the UI)
    var markerTransforms = []; // Array with all marker transforms
    var modelIndex = -1;    // Index of the model this layer is bound to (-1 for unbound)

    /**
     * Sets the index of the scene model this annotation layer is bound to.
     * @param index - Index of the scene model.
     */
    this.setBoundModuleIndex = function(index)
    {
        modelIndex = index;
    };

    /**
     * Returns the index of the model this layer is bound to.
     * @returns {number} - Index of the model or -1 if unbound.
     */
    this.getBoundModuleIndex = function()
    {
        return modelIndex;
    };

    /**
     * Resets the modelIndex this annotation layer is bound to back to -1 and marks it as unbound.
     */
    this.releaseBinding = function()
    {
        modelIndex = -1;
    };

    /**
     * If the annotation layer is bound to a module the annotations shall move when the module is moved.
     * This function shall receive the delta of the positions every time the module is moved.
     * @param axis - Axis of the movement.
     * @param delta - Delta to the last position.
     */
    this.movementUpdateBoundModule = function(axis,delta)
    {
        if( axis >= 0 && axis < 3)
        {
            for(var i=0; i<annotationTransforms.length;i++)
            {
                var trans = annotationTransforms[i].getAttribute("translation");
                var transValue = trans.split(" ");

                if( transValue.length < 3)
                { transValue = trans.split(",");}

                if(i%2 === 0 || axis === 1)
                {   transValue[axis] = parseInt(transValue[axis]) - parseInt(delta); }
                else
                {   transValue[axis] = parseInt(transValue[axis]) + parseInt(delta); }

                annotationTransforms[i].setAttribute("translation",transValue[0] + " " + transValue[1] + " " + transValue[2]);
            }
            for( i=0; i<markerTransforms.length;i++)
            {
                trans = markerTransforms[i].getAttribute("translation");
                transValue = trans.split(" ");

                if( transValue.length < 3)
                { transValue = trans.split(",");}

                transValue[axis] = parseInt(transValue[axis]) - parseInt(delta);
                markerTransforms[i].setAttribute("translation",transValue[0] + " " + transValue[1] + " " + transValue[2]);
            }
        }


    };

    /**
     * This function notifies the annotation layer that the scene model's elevation was changed.
     * All annotation will be checked and altered in their position.
     */
    this.elevationUpdateBoundModule = function()
    {
        for(var i=0; i<annotationTransforms.length;i++)
        {
            var trans = annotationTransforms[i].getAttribute("translation");
            var transValue = trans.split(" ");
            var mirror = 1;//We have to multiply the backside text positions with -1

            if( transValue.length < 3)
            { transValue = trans.split(",");}


            if(i%2 === 1)
            {   mirror = -1;    }

            transValue[1] = EarthServerGenericClient.MainScene.getHeightAt3DPosition(modelIndex,parseInt(transValue[0])*mirror,parseInt(transValue[2])*mirror) + fontHover;
            annotationTransforms[i].setAttribute("translation",transValue[0] + " " + transValue[1] + " " + transValue[2]);
        }

        for( i=0; i<markerTransforms.length;i++)
        {
            trans = markerTransforms[i].getAttribute("translation");
            transValue = trans.split(" ");

            if( transValue.length < 3)
            { transValue = trans.split(",");}

            transValue[1] = EarthServerGenericClient.MainScene.getHeightAt3DPosition(modelIndex,parseInt(transValue[0]),parseInt(transValue[2]));
            markerTransforms[i].setAttribute("translation",transValue[0] + " " + transValue[1] + " " + transValue[2]);
        }

    };

    /**
     * Adds an annotation marker and -text to the annotation layer.
     * @param xPos - Position on the X-Axis of the marker and center of the annotation.
     * @param yPos - Position on the Y-Axis of the marker and center of the annotation.
     * @param zPos - Position on the Z-Axis of the marker and center of the annotation.
     * @param Text - Text for the annotation.
     */
    this.addAnnotation = function(xPos,yPos,zPos,Text)
    {

        annotations.push(Text);//save the text for later queries

        //We draw 2 texts without their back faces.
        //So the user can see the text from most angles and not mirror inverted.
        for(var i=0;i<2;i++)
        {
            var textTransform = document.createElement('transform');
            textTransform.setAttribute('scale', fontSize + " " + fontSize + " " + fontSize);
            var shape = document.createElement('shape');
            var appearance = document.createElement('appearance');
            appearance.setAttribute("id","Layer_Appearance_"+Name);
            var material = document.createElement('material');
            material.setAttribute('emissiveColor', fontColor);
            material.setAttribute('diffuseColor', fontColor);
            var text = document.createElement('text');
            text.setAttribute('string', Text);
            var fontStyle = document.createElement('fontStyle');
            fontStyle.setAttribute('family', 'calibri');
            fontStyle.setAttribute('style', 'bold');
            text.appendChild(fontStyle);
            appearance.appendChild(material);
            shape.appendChild(appearance);
            shape.appendChild(text);
            textTransform.appendChild(shape);

            //one marker is enough
            if(i===0)
            {
                var sphere_trans = document.createElement("Transform");
                sphere_trans.setAttribute("scale",markerSize + " " + markerSize + " "+markerSize);
                sphere_trans.setAttribute('translation', xPos + " " + yPos + " " + zPos);
                var sphere_shape = document.createElement("Shape");
                var sphere = document.createElement("Sphere");
                var sphere_app = document.createElement("Appearance");
                var sphere_material = document.createElement('material');
                sphere_material.setAttribute('diffusecolor', markerColor);
                sphere_app.appendChild(sphere_material);
                sphere_shape.appendChild(sphere_app);
                sphere_shape.appendChild(sphere);
                sphere_trans.appendChild(sphere_shape);

                root.appendChild(sphere_trans);
                //annotationTransforms.push(sphere_trans);
                markerTransforms.push(sphere_trans);

                sphere_trans = null;
                sphere_shape = null;
                sphere = null;
                sphere_app = null;
                sphere_material = null;
            }

            var rootTransform = document.createElement('transform');

            textTransform.setAttribute('translation', xPos + " " + (yPos+fontHover) + " " + zPos);
            textTransform.setAttribute('scale', (-fontSize) + " " + (-fontSize) + " " + fontSize);

            //One text "normal" and one "mirror inverted"
            if(i===0)
            {
                textTransform.setAttribute('rotation', '0 0 1 3.14');
            }
            else
            {
                textTransform.setAttribute('rotation', '0 0 1 3.14');
                textTransform.setAttribute('translation', -xPos + " " + (yPos+fontHover) + " " + -zPos);
                rootTransform.setAttribute('rotation', '0 1 0 3.14');
            }

            //annotationTransforms.push(rootTransform);//save the transform to toggle rendering
            annotationTransforms.push(textTransform);
            rootTransform.appendChild(textTransform);
            root.appendChild( rootTransform );
        }

        textTransform = null;
        shape = null;
        appearance = null;
        material = null;
        text = null;
        fontStyle = null;
    };

    /**
     * Determine the rendering of this layer.
     * @param value - boolean
     */
    this.renderLayer = function( value )
    {
        for(var i=0; i<annotationTransforms.length;i++)
        {
            annotationTransforms[i].setAttribute("render",value);
        }
        for(i=0; i<markerTransforms.length;i++)
        {
            markerTransforms[i].setAttribute("render",value);
        }
    };


    /**
     * Returns an array with the annotation text.
     * @returns {Array}
     */
    this.getAnnotationTexts = function()
    {
        var arrayReturn = [];

        for(var i=0; i<annotations.length;i++)
        {   arrayReturn.push(annotations[i]);    }

        return arrayReturn;
    };
};

/**
 * @class AxisLabels
 * @description This class generates labels for each axis and side (except bottom) of the bounding box.
 *
 * @param xSize - The width of the bounding box.
 * @param ySize - The height of the bounding box.
 * @param zSize - The depth of the bounding box.
 * @param textHover - Distance between the bounding box and the text.
 */
EarthServerGenericClient.AxisLabels = function(xSize, ySize, zSize, textHover)
{
    /**
     * @description Defines the color of the text. Default at start: emissiveColor attribute is set, the diffuseColor one isn't.
     * @type {string}
     * @default "0.7 0.7 0.5"
     */
    var fontColor = "0.7 0.7 0.5";

    /**
     * Distance between the bounding box and the text.
     * @type {number}
     */
    var hover = textHover || ((xSize + ySize + zSize) / 150);

    /**
     * @description Array stores all X3DOM transform nodes. Each transform contains the shape, material, text and fontStyle node.
     * @type {Array}
     * @default Empty
     */
    var transforms = [];
    /**
     * @description Array stores all text nodes of the x-axis.
     * @type {Array}
     * @default Empty
     */
    var textNodesX = [];
    /**
     * @description Array stores all text nodes of the y-axis.
     * @type {Array}
     * @default Empty
     */
    var textNodesY = [];
    /**
     * @description Array stores all text nodes of the z-axis.
     * @type {Array}
     * @default Empty
     */
    var textNodesZ = [];

    /**
     * @description This function changes the text size of each label independent of its axis.
     * @param size
     * The parameter (positive value expected) represents the desired size of the font.
     * Remember, the parameter represents the size in x3dom units not in pt like css.
     * Hence the size value could be large.
     */
    this.changeFontSize = function(size)
    {
        size = Math.abs(size);
        for(var i=0; i<transforms.length; i++)
        {
            var scale =x3dom.fields.SFVec3f.parse(transforms[i].getAttribute('scale'));

            if(scale.x>=0) scale.x = size; else scale.x = -1 * size;
            if(scale.y>=0) scale.y = size; else scale.y = -1 * size;
            if(scale.z>=0) scale.z = size; else scale.z = -1 * size;

            transforms[i].setAttribute('scale', scale.x + " " + scale.y + " " + scale.z);
        }
    };

    /**
     * This function changes the color of each label independent of its axis.
     * @param color
     * This parameter changes the current color value of each label.
     * It expects a string in x3d color format.
     * E.g. "1.0 1.0 1.0" for white and "0.0 0.0 0.0" for black.
     */
    this.changeColor = function(color)
    {
        for(var i=0; i<transforms.length; i++)
        {
            var material = transforms[i].getElementsByTagName('material');

            for(var j=0; j<material.length; j++)
            {
                material[j].setAttribute('emissiveColor', color);
                material[j].setAttribute('diffuseColor', color);
            }
        }
    };

    /**
     * @description This function changes the text of each label on the x-axis.
     * @param string
     * Defines the new text.
     */
    this.changeLabelNameX = function(string)
    {
        //Prevent multi line!
        while(string.search("'")!=-1 || string.search("\"")!=-1)
        {
            string = string.replace("'", " ");
            string = string.replace("\"", " ");
        }

        for(var i=0; i<textNodesX.length; i++)
        {
            textNodesX[i].setAttribute('string', string);
        }
    };

    /**
     * @description This function changes the text of each label on the y-axis.
     * @param string
     * Defines the new text.
     */
    this.changeLabelNameY = function(string)
    {
        //Prevent multi line!
        while(string.search("'")!=-1 || string.search("\"")!=-1)
        {
            string = string.replace("'", " ");
            string = string.replace("\"", " ");
        }

        for(var i=0; i<textNodesY.length; i++)
        {
            textNodesY[i].setAttribute('string', string);
        }
    };

    /**
     * @param string
     * Defines the new text.
     */
    this.changeLabelNameZ = function(string)
    {
        //Prevent multi line!
        while(string.search("'")!=-1 || string.search("\"")!=-1)
        {
            string = string.replace("'", " ");
            string = string.replace("\"", " ");
        }

        for(var i=0; i<textNodesZ.length; i++)
        {
            textNodesZ[i].setAttribute('string', string);
        }
    };

    /**
     * @description This function generates labels on all three axis (x,y,z). The labels will be
     * added on each side (except bottom).
     */
    this.createAxisLabels = function(xLabel,yLabel,zLabel)
    {
        createLabel("x", "front", xLabel);
        createLabel("x", "back",  xLabel);
        createLabel("x", "top",   xLabel);

        createLabel("y", "front", yLabel);
        createLabel("y", "back",  yLabel);
        createLabel("y", "left",  yLabel);
        createLabel("y", "right", yLabel);

        createLabel("z", "front", zLabel);
        createLabel("z", "back",  zLabel);
        createLabel("z", "top",   zLabel);
    };

    /**
     * @description This (private) function creates the needed x3dom nodes.
     *
     * @param axis
     * Which axis do you want? Available: x, y, z
     *
     * @param side
     * Choose the side of the axis. <br>
     * Available for x: front (default), back and top. <br>
     * Available for y: front (default), back, left and right. <br>
     * Available for z: front (default), back and top.
     *
     * @param label
     * This text will appear at the given axis.
     */
    function createLabel(axis, side, label)
    {
        //Setup text
        var textTransform = document.createElement('transform');
        textTransform.setAttribute('scale', xSize/5 + " " + ySize/5 + " " + zSize/5);
        var shape = document.createElement('shape');
        var appearance = document.createElement('appearance');
        var material = document.createElement('material');
        material.setAttribute('emissiveColor', fontColor);
        var text = document.createElement('text');
        text.setAttribute('string', label);
        var fontStyle = document.createElement('fontStyle');
        fontStyle.setAttribute('family', 'calibri');
        fontStyle.setAttribute('style', 'bold');
        text.appendChild(fontStyle);
        appearance.appendChild(material);
        shape.appendChild(appearance);
        shape.appendChild(text);
        textTransform.appendChild(shape);

        //var home = document.getElementById('x3dScene');
        var home = document.getElementById('AnnotationsGroup');
        var rotationTransform = document.createElement('transform');

        if(axis=="x")
        {
            textTransform.setAttribute('translation', "0 " + (ySize+hover) + " " + zSize);

            if(side=="back")
            {
                rotationTransform.setAttribute('rotation', '0 1 0 3.14');
            }
            else if(side=="top")
            {
                textTransform.setAttribute('rotation', '1 0 0 -1.57');
                textTransform.setAttribute('translation', "0 " + -ySize + " " + (-zSize-hover));
            }
            textNodesX[textNodesX.length] = text;
        }
        else if(axis=="y")
        {
            textTransform.setAttribute('translation', -(xSize+hover) + " 0 " + zSize);
            textTransform.setAttribute('rotation', '0 0 1 1.57');

            if(side=="back")
            {
                textTransform.setAttribute('translation', (xSize+hover) + " 0 " + zSize);
                textTransform.setAttribute('rotation', '0 0 1 4.74');
                rotationTransform.setAttribute('rotation', '1 0 0 3.14');
            }
            else if(side=="left")
            {
                rotationTransform.setAttribute('rotation', '0 1 0 -1.57');
            }
            else if(side=="right")
            {
                rotationTransform.setAttribute('rotation', '0 1 0 1.57');
            }
            textNodesY[textNodesY.length] = text;
        }
        else if(axis=="z")
        {
            textTransform.setAttribute('translation', xSize + " " + (ySize+hover) + " 0");
            textTransform.setAttribute('rotation', '0 1 0 1.57');
            if(side=="back")
            {
                rotationTransform.setAttribute('rotation', '0 1 0 3.14');
            }
            else if(side=="top")
            {
                textTransform.setAttribute('rotation', '0 1 0 1.57');
                textTransform.setAttribute('translation', "0 0 0");

                rotationTransform.setAttribute('rotation', '0 0 1 -4.71');
                rotationTransform.setAttribute('translation', -(xSize+hover) + " " + -ySize + " 0");
            }
            textNodesZ[textNodesZ.length] = text;
        }

        transforms[transforms.length]=textTransform;
        rotationTransform.appendChild(textTransform);
        home.appendChild(rotationTransform);
    }
};
/**
 * @class Builds one elevation grid chunk. It can consists of several elevation grids to be used in a LOD.
 * For every appearance in the appearances parameter one level is built with 25% size of the last level.
 * @param parentNode - Dom element to append the elevation grids to.
 * @param info - Information about the ID,position of the chunk, the height map's size and the modelIndex.
 * @param hf - The height map to be used for the elevation grid.
 * @param appearances - Array of appearances. For every appearance one level for LOD is built. 1 Level = no LOD.
 * @constructor
 */
function ElevationGrid(parentNode,info, hf,appearances)
{
    /**
     * Creates and inserts elevation grid (terrain chunk) into the DOM.
     */
    function setupChunk()
    {

        try
        {
            var elevationGrid, shape, shf;

            // We build one level of a LOD for every appearance. Example: With 3 children means: [Full Resolution, 1/2 Resolution, 1/4 Resolution]
            for(var i=0; i<appearances.length; i++)
            {
                // All none full resolutions needs to be one element bigger to keep the desired length
                var add = 0;
                if(i !== 0)
                { add = 1;  }

                // Set up: Shape-> Appearance -> ImageTexture +  Texturetransform
                shape = document.createElement('Shape');
                shape.setAttribute("id",info.modelIndex+"_shape_"+info.ID+"_"+i);

                // Build the Elevation Grids
                // shrink the heightfield to the correct size for this detail level
                shf = shrinkHeightMap(hf, info.chunkWidth, info.chunkHeight,Math.pow(2,i));
                elevationGrid = document.createElement('ElevationGrid');
                elevationGrid.setAttribute("id", info.modelIndex+"hm"+ info.ID+"_"+i);
                elevationGrid.setAttribute("solid", "false");
                elevationGrid.setAttribute("xSpacing", String(parseInt(Math.pow(2,i))));// To keep the same size with fewer elements increase the space of one element
                elevationGrid.setAttribute("zSpacing", String(parseInt(Math.pow(2,i))));
                elevationGrid.setAttribute("xDimension", String(info.chunkWidth/Math.pow(2,i)+add));// fewer elements in every step
                elevationGrid.setAttribute("zDimension", String(info.chunkHeight/Math.pow(2,i)+add));
                elevationGrid.setAttribute("height", shf );
                elevationGrid.appendChild(calcTexCoords(info.xpos, info.ypos, info.chunkWidth, info.chunkHeight, info.terrainWidth, info.terrainHeight,Math.pow(2,i)));

                shape.appendChild(appearances[i]);
                shape.appendChild(elevationGrid);

                parentNode.appendChild(shape);

                // set vars null
                shf = null;
                shape = null;
                elevationGrid = null;
            }
            hf = null;
            parentNode = null;
            info = null;
            appearances = null;
        }
        catch(error)
        {
            alert('ElevationGrid::setupChunk(): ' + error);
        }
    }

    /**
     * Shrinks the heightfield with the given factor
     * @param heightfield - The used heihgfield.
     * @param sizex - Width of the heightfield.
     * @param sizey - Height of the heightfield.
     * @param shrinkfactor - Factor to shrink the heightmap. 1:Full heightmap 2: 25% (scaled 50% on each side)
     * @returns {string}
     */
    function shrinkHeightMap(heightfield, sizex, sizey, shrinkfactor)
    {
        var smallGrid, smallx, smally, val,i,k,l,o,div;

        smallGrid = [];
        smallx = parseInt(sizex/shrinkfactor);
        smally = parseInt(sizey/shrinkfactor);
        //IF shrunk, the heightfield needs one more element than the desired length (63 elements for a length of 62)
        if( shrinkfactor !== 1)
        {
            smallx++;
            smally++;
            div=shrinkfactor*shrinkfactor;

            for(i=0; i<smally; i++)
            {
                var i_sf = (i*shrinkfactor);

                for(k=0; k<smallx; k++)
                {
                    var k_sf = (k*shrinkfactor);
                    val = 0;
                    for(l=0; l<shrinkfactor; l++)
                    {
                        for(o=0; o<shrinkfactor; o++)
                        {
                            var x = k_sf + l;
                            var y = i_sf + o;
                            if(x >= sizex) x = sizex -1;
                            if(y >= sizey) y = sizey -1;
                            var tmp = heightfield[y][x];
                            val = val + parseFloat(tmp);
                        }
                    }
                    val = val/div;
                    smallGrid.push(val+ " ");
                }
            }
        }
        else
        {
            for(i=0; i<smally; i++)
            {
                for(k=0; k<smallx; k++)
                {
                    val = parseFloat( heightfield[i][k]);
                    smallGrid.push(val+" ");
                }
            }
        }
        return smallGrid.join(" ");
    }

    /**
     * Calcs the TextureCoordinates for the elevation grid(s).
     * Use the values of the full/most detailed version if using for LOD and adjust only the shrinkfactor parameter.
     * @param xpos - Start position of the elevation grid within the terrain.
     * @param ypos - Start position of the elevation grid within the terrain.
     * @param sizex - Size of the elevation grid on the x-Axis.
     * @param sizey - Size of the elevation grid on the x-Axis.
     * @param terrainWidth - Size of the whole terrain on the x-Axis.
     * @param terrainHeight - Size of the whole terrain on the y-Axis.
     * @param shrinkfactor - The factor the heightmap this TextureCoordinates are was shrunk.
     * @returns {HTMLElement} - X3DOM TextureCoordinate Node.
     */
    function calcTexCoords(xpos,ypos,sizex,sizey,terrainWidth, terrainHeight, shrinkfactor)
    {
        var tmpx, tmpy;

        var smallx = parseInt(sizex/shrinkfactor);
        var smally = parseInt(sizey/shrinkfactor);

        if( shrinkfactor !== 1)
        {
            smallx++;
            smally++;
        }

        var buffer = [];
        //Create Node
        var tcnode = document.createElement("TextureCoordinate");

        //File string
        for (var i = 0; i < smally; i++)
        {
            for (var k = 0; k < smallx; k++)
            {
                tmpx = parseFloat((xpos+(k*shrinkfactor))/(terrainWidth-1));
                tmpy = parseFloat((ypos+(i*shrinkfactor))/(terrainHeight-1));

                buffer.push(tmpx + " ");
                buffer.push(tmpy + " ");
            }
        }
        var tc = buffer.join("");

        tcnode.setAttribute("point", tc);

        return tcnode;
    }

    setupChunk();
}
/**
 * @class Builds one grid that contains gaps (NODATA zones) into a chunk.
 * @param parentNode - Dom element to append the gap grid to.
 * @param info - Information about the ID,position of the chunk, the height map's size and the modelIndex.
 * @param hf - The height map to be used for the elevation grid.
 * @param appearances - Appearances for the Gap Grid.
 * @param NODATA - The NODATA value. Parts with this values are left as a gap in the grid.
 * @constructor
 */
function GapGrid(parentNode,info, hf,appearances,NODATA)
{
    /**
     * Creates and inserts elevation grid (terrain chunk) into the DOM.
     */
    function setupChunk()
    {

        try
        {
            var grid, shape, coords, coordsNode;

            shape = document.createElement('Shape');
            shape.setAttribute("id",info.modelIndex+"_shape_"+info.ID+"_"+0);

            coords = buildCoordinates(hf, info.chunkWidth, info.chunkHeight,NODATA);
            coordsNode = document.createElement('Coordinate');
            coordsNode.setAttribute("point", coords.coords);

            grid = document.createElement('IndexedFaceSet');
            grid.setAttribute("id", info.modelIndex+"hm"+ info.ID+"_"+0);
            grid.setAttribute("solid", "false");
            grid.setAttribute("colorPerVertex", "false");

            grid.setAttribute("creaseAngle", "0.01");
            grid.setAttribute("ccw", "true");

            grid.setAttribute("coordIndex", coords.index);
            grid.appendChild( coordsNode );
            grid.appendChild(calcTexCoords(info.xpos, info.ypos, info.chunkWidth, info.chunkHeight, info.terrainWidth, info.terrainHeight,Math.pow(2,0)));

            if(appearances.length )
            {   shape.appendChild(appearances[0]);  }
            shape.appendChild(grid);

            parentNode.appendChild(shape);

            // set vars null
            coords = null;
            coordsNode = null;
            shape = null;
            grid = null;

            hf = null;
            parentNode = null;
            info = null;
            appearances = null;
        }
        catch(error)
        {
            alert('GapGrid::setupChunk(): ' + error);
        }
    }

    /**
     * Shrinks the heightfield with the given factor
     * @param heightfield - The used heightfield.
     * @param sizex - Width of the heightfield.
     * @param sizey - Height of the heightfield.
     * @param NODATA - The value that a considered as NODATA available and shall be left as a gap
     * @returns {Object}
     */
    function buildCoordinates(heightfield, sizex, sizey, NODATA)
    {
        var coords = {};
        coords.coords = [];
        coords.index  = [];

        // add the coords
        for(var o=0; o< sizey; o++)
        {
            for(var j=0; j<sizex; j++)
            {
                coords.coords.push(""+ j + " " + heightfield[o][j] + " " + o + " ");
            }
        }

        for(var i=0; i+1< sizey; i++)
        {
            for(var k=0; k+1<sizex; k++)
            {
                // check if NONE of the four vertices used for this face as a NODATA value
                if( heightfield[i][k] !== NODATA && heightfield[i+1][k] !== NODATA
                     && heightfield[i+1][k+1] !== NODATA && heightfield[i][k+1] !== NODATA)
                {
                    // add indices
                    coords.index.push( (i*sizex)+k );
                    coords.index.push( ((i*sizex)+1)+k );
                    coords.index.push( (((i+1)*sizex)+1)+k );
                    coords.index.push( ((i+1)*sizex)+k );

                    coords.index.push( -1 );
                }
            }
        }

        return coords;
    }


    /**
     * Calcs the TextureCoordinates for the elevation grid(s).
     * Use the values of the full/most detailed version if using for LOD and adjust only the shrinkfactor parameter.
     * @param xpos - Start position of the elevation grid within the terrain.
     * @param ypos - Start position of the elevation grid within the terrain.
     * @param sizex - Size of the elevation grid on the x-Axis.
     * @param sizey - Size of the elevation grid on the x-Axis.
     * @param terrainWidth - Size of the whole terrain on the x-Axis.
     * @param terrainHeight - Size of the whole terrain on the y-Axis.
     * @param shrinkfactor - The factor the heightmap this TextureCoordinates are was shrunk.
     * @returns {HTMLElement} - X3DOM TextureCoordinate Node.
     */
    function calcTexCoords(xpos,ypos,sizex,sizey,terrainWidth, terrainHeight, shrinkfactor)
    {
        var tmpx, tmpy;

        var smallx = parseInt(sizex/shrinkfactor);
        var smally = parseInt(sizey/shrinkfactor);

        if( shrinkfactor !== 1)
        {
            smallx++;
            smally++;
        }

        var buffer = [];
        //Create Node
        var tcnode = document.createElement("TextureCoordinate");

        //File string
        for (var i = 0; i < smally; i++)
        {
            for (var k = 0; k < smallx; k++)
            {
                tmpx = parseFloat((xpos+(k*shrinkfactor))/(terrainWidth-1));
                tmpy = parseFloat((ypos+(i*shrinkfactor))/(terrainHeight-1));

                buffer.push(tmpx + " ");
                buffer.push(tmpy + " ");
            }
        }
        var tc = buffer.join("");

        tcnode.setAttribute("point", tc);

        return tcnode;
    }

    setupChunk();
}
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Abstract base class for scene models.
 */
EarthServerGenericClient.AbstractSceneModel = function(){
    /**
     * Sets the name of the scene model.
     * @param modelName - Name of the model.
     */
    this.setName = function(modelName){
        this.name = String(modelName);
    };

    /**
     * Returns the name of the model.
     * @returns {String}
     */
    this.getName = function()
    {
        return this.name;
    };

    /**
     * Sets the area of interest for the model. (Lower Corner, Upper Corner)
     * @param minx - Minimum/Lower Latitude
     * @param miny - Minimum/Lower Longitude
     * @param maxx - Maximum/Upper Latitude
     * @param maxy - Maximum/Upper Longitude
     * @param minh - Minimum/Lower Height
     * @param maxh - Maximum/Upper Height
     */
    this.setAreaOfInterest = function(minx,miny,maxx,maxy,minh,maxh){
        this.minx = minx;
        this.miny = miny;
        this.maxx = maxx;
        this.maxy = maxy;
        this.minh = minh;
        this.maxh = maxh;
    };

    /**
     * Returns object with the area of interest of the model. (minx,miny,maxx,maxy)
     * @returns {{}}
     */
    this.getAreaOfInterest = function()
    {
        var aoi = {};
        aoi.minx = this.minx;
        aoi.miny = this.miny;
        aoi.maxx = this.maxx;
        aoi.maxy = this.maxy;

        return aoi;
    };

    /**
     * Sets the height resolution of the model. This effects the scaling of the elevation of the model.
     * The parameter should be the difference between the smallest and biggest value of the DEM.
     * Make the sure the value fits to the model's size.
     * @param value
     */
    this.setHeightResolution = function( value )
    {
        if( !isNaN(value) ) // has to be a number or undefined behavior will occur
        {
            this.YResolution = value;
        }
    };

    /**
     * Sets the resolution of the scene model (if possible).
     * @param xRes - Resolution on the x-axis/Latitude
     * @param zRes - Resolution on the z-axis/Longitude
     */
    this.setResolution = function(xRes,zRes){
        this.XResolution = parseInt(xRes);
        this.ZResolution = parseInt(zRes);

        var maxResolution = EarthServerGenericClient.MainScene.getMaxResolution();
        if( this.XResolution > maxResolution )
        {   this.XResolution = maxResolution;   }
        if( this.ZResolution > maxResolution )
        {   this.ZResolution = maxResolution;   }

    };

    /**
     * Sets the position of the scene model within the fishtank/cube. Values between [0-1]
     * @param xOffset - Offset on the x-axis/width  Default:0
     * @param yOffset - Offset on the y-axis/height Default:0
     * @param zOffset - Offset on the z-axis/depth  Default:0
     */
    this.setOffset = function( xOffset, yOffset, zOffset){
        this.xOffset = parseFloat(xOffset);
        this.yOffset = parseFloat(yOffset);
        this.zOffset = parseFloat(zOffset);
    };
    /**
     * Sets the size of the scene model compared to the fishtank/cube. Values between 0 - 1.
     * @param xScale - Size of the model on the x-axis/width  Default:1   (whole cube)
     * @param yScale - Size of the model on the y-axis/height Default:0.3 (30% of the cube)
     * @param zScale - Size of the model on the x-axis/width  Default:1   (whole cube)
     */
    this.setScale = function( xScale, yScale, zScale){
        this.xScale = parseFloat(xScale);
        this.yScale = parseFloat(yScale);
        this.zScale = parseFloat(zScale);
    };

    /**
     * Sets the image format for the server request.
     * @param imageFormat - Default "png".
     */
    this.setImageFormat = function( imageFormat){
        this.imageFormat = String(imageFormat);
    };

    /**
     * Sets the initial transparency of the scene model.
     * The function accepts a parameter value in the range of 0 (fully opaque) and 1(fully transparent).
     * @param transparency - Value of transparency.
     */
    this.setTransparency = function( transparency ){
        this.transparency = parseFloat(transparency);
    };

    /**
     * Sets the specular color for the scene model.
     * @param color - Color in rgb.
     */
    this.setSpecularColor = function( color )
    {
        this.specularColor = color;
    };

    /**
     * Sets the diffuse color for the scene model.
     * @param color - Color in rgb.
     */
    this.setDiffuseColor = function( color )
    {
        this.diffuseColor = color;
    };

    /**
     * Sets if side panels should be added to the model.
     * @param value
     */
    this.setSidePanels = function( value )
    {
        this.sidePanels = value;
    };



    /**
     * Sets the queries for the four side panels' textures.
     * @param links - Array with four image links.
     */
    this.setSidePanelsImageLinks = function( links )
    {
        if( links.length !== 4)
        {
            console.log("EarthServerClient::ModuleBase: Links array for side panels needs exact 4 queries.");
        }
        else
        {
            this.sidePanelsLinks = links;
        }
    };

    /**
     * Updates the transparency during runtime of the scene model.
     * The function accepts a value in the range of 0 (fully opaque) and 1(fully transparent).
     * @param transparency - Value of transparency.
     */
    this.updateTransparency = function( transparency ){
        this.terrain.setTransparency(transparency);
    };

    /**
     * Modules report their loading progress with this function which reports to the main scene.
     */
    this.reportProgress = function()
    {
        // The total progress of this module depends on the number of requests it does.
        // The progress parameter is the progress of ONE request.
        // ReceivedDataCount is the number of already received responses.
        // it is doubled because for each request one terrain will be build.
        var totalProgress = ((this.receivedDataCount) / (this.requests * 2))*100;
        EarthServerGenericClient.MainScene.reportProgress(this.index,totalProgress);
    };

    /**
     * Sets the RGB value to be considered as NODATA in the TEXTURE. All pixels with this RGB value will be drawn transparent.
     * @param red - Value for the red channel.
     * @param green - Value for the green channel.
     * @param blue - Value for the blue channel.
     */
    this.setTextureNoDataValue = function(red,green,blue)
    {
        this.noData = [];
        this.noData[0] = parseInt(red);
        this.noData[1] = parseInt(green);
        this.noData[2] = parseInt(blue);
    };

    /**
     * Sets the DEM value to be considered as NODATA in the DEM. No Faces will be drawn having a vertex with that value.
     * @param value - No data value
     */
    this.setDemNoDataValue = function( value )
    {
        this.demNoData = value;
    };

    /**
     * Returns the noData Value for the DEM or undefined if not set.
     * @returns {float}
     */
    this.getDemNoDataValue = function()
    {
        return this.demNoData;
    };

    /**
     * Replaces all $xx symbols with the value-
     * @param inputString - Input WCPS query string.
     * @returns {String} - String with symbols replaced by values.
     */
    this.replaceSymbolsInString = function(inputString)
    {
        var out;
        out = EarthServerGenericClient.replaceAllFindsInString(inputString,"$CI",this.coverageImage);
        out = EarthServerGenericClient.replaceAllFindsInString(out,"$CD",this.coverageDEM);
        out = EarthServerGenericClient.replaceAllFindsInString(out,"$CT",this.coverageTime);
        out = EarthServerGenericClient.replaceAllFindsInString(out,"$MINX",this.minx);
        out = EarthServerGenericClient.replaceAllFindsInString(out,"$MINY",this.miny);
        out = EarthServerGenericClient.replaceAllFindsInString(out,"$MAXX",this.maxx);
        out = EarthServerGenericClient.replaceAllFindsInString(out,"$MAXY",this.maxy);
        out = EarthServerGenericClient.replaceAllFindsInString(out,"$CRS" ,'"' + this.CRS + '"');
        out = EarthServerGenericClient.replaceAllFindsInString(out,"$RESX",this.XResolution);
        // allows users to use either $RESY or $RESZ
        out = EarthServerGenericClient.replaceAllFindsInString(out,"$RESZ",this.ZResolution);
        out = EarthServerGenericClient.replaceAllFindsInString(out,"$RESY",this.ZResolution);

        return out;
    };

    /**
     * sets if no texture shall be used. If true the terrain uses the default or specified color only.
     * @param value
     */
    this.setColorOnly = function(value)
    {
        this.colorOnly = value;
    };

    /**
     * Registers a handler for a specific format for preprocessing data received
     * by a data request.
     * @param mimetype - Received data from the server request.
     * @returns {boolean} - TRUE if a handler for the given format is registered,
     * FALSE if not
     */
    this.registerMIMETypeHandler = function(mimetype, handler)
    {
        if (mimetype != "" && handler) {
            if (!this.mimetypeHandlers) {
                this.mimetypeHandlers = {};
            }
            this.mimetypeHandlers[mimetype] = handler;
        } else {
            alert("'registerMIMETypeHandler' called with wrong arguments!");
            console.log("'registerMIMETypeHandler' called with wrong arguments!");
        }
    };

    /**
     * Preprocesses the received data from the server request to extract the 
     * heightmap data dependent on the response format.
     * @param data - Received data from the server request.
     * @param responseData - Instance of the ServerResponseData which has to be filled.
     * @param mimetype - type to select the corresponding handler.
     * @returns {boolean} - TRUE if a handler for the given format is registered,
     * FALSE if not
     */
    this.preprocessReceivedData = function(data, responseData, mimetype)
    {
        if (!this.mimetypeHandlers) {
            return false;
        }
        
        var mimetypeHandler = this.mimetypeHandlers[mimetype];
        if (!mimetypeHandler) {
            return false;
        } else {
            mimetypeHandler(data, responseData);
        }

        return true;
    };

    /**
     * Validates the received data from the server request.
     * Checks if a texture and a heightmap are available at the moment.
     * @param data - Received data from the server request.
     * @returns {boolean} - TRUE if OK, FALSE if some data is missing
     */
    this.checkReceivedData = function(data)
    {
        this.receivedDataCount++;
        this.reportProgress();

        // No texture whished?
        if( this.colorOnly && data !== null && data !== undefined)
        {
            data.validateTexture = false; // disable check for texture
            data.texture = undefined;
        }

        if( data === null || !data.validate() )
        {
            alert(this.name +": Request not successful.");
            console.log(data);
            this.reportProgress();//NO Terrain will be built so report the progress here
            this.removePlaceHolder();//Remove the placeHolder.

            //delete UI elements
            var header = document.getElementById("EarthServerGenericClient_ModelHeader_"+this.index);
            var div = document.getElementById("EarthServerGenericClient_ModelDiv_"+this.index);

            if(header && div)
            {
                var parent = div.parentNode;

                if(parent)
                {
                    parent.removeChild(div);
                    parent.removeChild(header);
                }
            }
            return false;
        }

        // add module specific values
        data.transparency =  this.transparency;
        data.specularColor = this.specularColor || EarthServerGenericClient.MainScene.getDefaultSpecularColor();
        data.diffuseColor = this.diffuseColor || EarthServerGenericClient.MainScene.getDefaultDiffuseColor();

        return true;
    };

    /**
     * Adds an Object that will be informed about movements and alterations of the model.
     * @param bindingObject - Object that will receive the notification.
     */
    this.addBinding = function(bindingObject)
    {
        for(var i=0; i<this.bindings.length;i++)
        {
            if(this.bindings[i] == bindingObject)
            {
                console.log(this.name + "::addBinding: Object already registered.");
                return;
            }
        }
        this.bindings.push(bindingObject);
        bindingObject.setBoundModuleIndex(this.index);
    };

    /**
     * Removes an Object that will be informed about movements and alterations of the model.
     * @param bindingObject - Object that will no longer receive the notification.
     */
    this.removeBinding = function(bindingObject)
    {
        for(var i=0; i<this.bindings.length;i++)
        {
            if( this.bindings[i] === bindingObject)
            {
                this.bindings[i].releaseBinding();
                this.bindings = EarthServerGenericClient.arrayRemove(this.bindings,i,i);
                return;
            }
        }
    };

    /**
     * This function is called if the model is moved in the scene.
     * All bindings will also get the movement update.
     * @param movementType - Type of the movement: xAxis,zAxis,elevation...
     * @param value - Updated position
     */
    this.movementUpdateBindings = function(movementType,value)
    {
        for(var i=0; i<this.bindings.length;i++)
        {
            this.bindings[i].movementUpdateBoundModule(movementType,value);
        }
    };

    /**
     * This function calls every binding object that the elevation of the models was changed.
     * @param value - This is the value the that was given to SceneManager::updateElevation().
     */
    this.elevationUpdateBinding = function(value)
    {
        if(value === undefined)
        {   value = 10; }//TODO DEFINE some basic start values for UI etc.

        for(var i=0; i<this.bindings.length;i++)
        {
            this.bindings[i].elevationUpdateBoundModule(value);
        }
    };

    /**
     * Returns the elevation value of it's terrain at a specific point in the 3D scene.
     * @param xPos - Position on the x-axis.
     * @param zPos - Position on the z-axis.
     * @returns {number} - The height on the y-axis.
     */
    this.getHeightAt3DPosition = function(xPos,zPos)
    {
        if( this.terrain)
        {
            return this.terrain.getHeightAt3DPosition(xPos,zPos);
        }
        else
        {   return 0; }
    };

    /**
     * Returns the dem value of it's terrain at a specific point in the 3D scene.
     * @param xPos - Position on the x-axis.
     * @param zPos - Position on the z-axis.
     * @returns {number} - The height of the dem.
     */
    this.getDemValueAt3DPosition = function(xPos,zPos)
    {
        if( this.terrain)
        {
            return this.terrain.getDemValueAt3DPosition(xPos,zPos);
        }
        else
        {   return 0; }
    };

    /**
     * This creates a placeholder Element for the model. It consists of an simple quad.
     * Models that use this placeholder should remove it of course.
     */
    this.createPlaceHolder = function()
    {
        var appearance = document.createElement('Appearance');
        var material = document.createElement('Material');
        material.setAttribute("emissiveColor","0.4 0.4 0.4");

        var trans = document.createElement('Transform');
        var yoff = (this.cubeSizeY * this.yOffset);
        trans.setAttribute("translation", "0 "+ yoff  + " 0");

        var shape = document.createElement('shape');
        var triangleset = document.createElement('IndexedFaceSet');
        triangleset.setAttribute("colorPerVertex", "false");
        triangleset.setAttribute("coordindex","0 1 2 3 -1");

        var coords = document.createElement('Coordinate');

        var cubeX = this.cubeSizeX/2.0;
        var cubeZ = this.cubeSizeZ/2.0;
        var cubeXNeg = -this.cubeSizeX/2.0;
        var cubeYNeg = -this.cubeSizeY/2.0;
        var cubeZNeg = -this.cubeSizeZ/2.0;

        var p = {};
        p[0] = ""+ cubeXNeg + " " + cubeYNeg + " " + cubeZNeg + " ";
        p[1] = ""+ cubeXNeg + " " + cubeYNeg + " " + cubeZ + " ";
        p[2] = ""+ cubeX    + " " + cubeYNeg + " " + cubeZ    + " ";
        p[3] = ""+ cubeX    + " " + cubeYNeg + " " + cubeZNeg;

        var points="";
        for(var i=0; i<4;i++)
        {   points = points+p[i];   }
        coords.setAttribute("point", points);

        triangleset.appendChild(coords);
        appearance.appendChild(material);
        shape.appendChild(appearance);
        shape.appendChild(triangleset);
        trans.appendChild(shape);

        this.placeHolder = trans;
        this.root.appendChild( this.placeHolder );

        appearance = null;
        material = null;
        shape = null;
        triangleset = null;
        coords = null;
        points = null;
        trans = null;
    };

    /**
     * Removes the PlaceHolder created in createPlaceHolder(). If already deleted nothing happens.
     */
    this.removePlaceHolder = function()
    {
        if( this.placeHolder !== null && this.placeHolder !== undefined )
        {
            this.root.removeChild( this.placeHolder);
            this.placeHolder = null;
        }
    };

    /**
     * Creates the transform for the scene model to fit into the fishtank/cube. This is done automatically by
     * the scene model.
     * @param xRes - Size of the received data on the x-axis (e.g. the requested DEM )
     * @param yRes - Size of the received data on the y-axis
     * @param zRes - Size of the received data on the z-axis
     * @param minHeightvalue - Minimum Value along the y-axis (e.g. minimum value in a DEM, so the model starts at it's wished location)
     * @param minXvalue - Minimum Value along the x-axis
     * @param minZvalue - Minimum Value along the z-axis
     * @return {Element}
     */
    this.createTransform = function(xRes,yRes,zRes,minHeightvalue,minXvalue,minZvalue){
        var trans = document.createElement('Transform');
        trans.setAttribute("id", "EarthServerGenericClient_modelTransform"+this.index);
        trans.setAttribute("onclick","EarthServerGenericClient.MainScene.OnClickFunction("+this.index+",event.hitPnt);");

        this.YResolution = yRes;
        this.minValue = minHeightvalue;

        if(zRes<1) zRes = 2;

       // var scaleX = (this.cubeSizeX*this.xScale)/(Math.ceil(xRes)-1);
        var scaleX = (this.cubeSizeX*this.xScale)/(xRes-1);
        var scaleY = (this.cubeSizeY*this.yScale)/this.YResolution;
        //var scaleZ = (this.cubeSizeZ*this.zScale)/(Math.ceil(zRes)-1);
        var scaleZ = (this.cubeSizeZ*this.zScale)/(zRes-1);
        trans.setAttribute("scale", "" + scaleX + " " + scaleY + " " + scaleZ);

        var xoff = (this.cubeSizeX * this.xOffset) - (this.cubeSizeX/2.0) - (scaleX * minXvalue);
        var yoff = (this.cubeSizeY * this.yOffset) - (minHeightvalue*scaleY) - (this.cubeSizeY/2.0);
        var zoff = (this.cubeSizeZ * this.zOffset) - (this.cubeSizeZ/2.0) - (scaleZ * minZvalue);
        trans.setAttribute("translation", "" + xoff+ " " + yoff  + " " + zoff);

        return trans;
    };

    /**
     * Updates the translation on the y-axis after the elevation was updated
     * so the model will stay in place.
     * @param newScale - The new scale value for the y-axis.
     */
    this.updateTranslationForElevation = function(newScale)
    {
        var trans = document.getElementById("EarthServerGenericClient_modelTransform"+this.index);

        if(trans)
        {
            var yoff = (this.cubeSizeY * this.yOffset) - ( this.minValue*newScale) - (this.cubeSizeY/2.0);
            var translation = trans.getAttribute("translation");
            var values = translation.split(" ");

            trans.setAttribute("translation", "" + values[0]+ " " + yoff  + " " + values[2]);
        }
        else
        {   console.log("EarthServerGenericClient::Module::updateTranslationForElevation " + this.index + ": Can't find transform.");    }

    };

    /**
     * Sets the default values. This is done automatically by the scene model.
     */
    this.setDefaults = function(){
        /**
         * Name of the model. This will be display in the UI.
         * @default Name is given by the module
         * @type {String}
         */
        this.name = "No name given";

        /**
         * All objects that are bound to the module. The will be noticed if the models is moved or altered.
         * Example: Annotation layers should be moved with the module and change the height when the elevation changes.
         * @type {Array}
         */
        this.bindings = [];

        /**
         * Resolution for the latitude.
         * @default 500
         * @type {Number}
         */
        this.XResolution = 500;

        /**
         * Resolution for the longitude
         * @default 500
         * @type {Number}
         */
        this.ZResolution = 500;

        /**
         * Offset on the X-Axis for the model.
         * @default 0
         * @type {Number}
         */
        this.xOffset = 0;

        /**
         * Offset on the Y-Axis for the model.
         * @default 0
         * @type {Number}
         */
        this.yOffset = 0;

        /**
         * Offset on the Z-Axis for the model.
         * @default 0
         * @type {Number}
         */
        this.zOffset = 0;

        /**
         * The models dimension compared to the whole cube on the X-Axis.
         * @default 1
         * @type {Number}
         */
        this.xScale = 1;

        /**
         * The models dimension compared to the whole cube on the Y-Axis.
         * @default 0.3
         * @type {Number}
         */
        this.yScale = 0.3;

        /**
         * The models dimension compared to the whole cube on the Z-Axis.
         * @default 1
         * @type {Number}
         */
        this.zScale = 1;

        /**
         * The used Image format (if one is used)
         * @default "png"
         * @type {String}
         */
        this.imageFormat = "png";

        /**
         * The amount of requests the model do. It is needed to keep track of the loading progress.
         * @default 1
         * @type {number}
         */
        this.requests = 1;

        /**
         * The amount of already received responses. Along with requests this is used to keep track of the loading progress.
         * @default 0
         * @type {number}
         */
        this.receivedDataCount = 0;

        /**
         * The Transparency of the model.
         * @default 0
         * @type {Number}
         */
        this.transparency = 0;

        /**
         * Flag if side panels should be added to the terrain.
         * @default false
         * @type {boolean}
         */
        this.sidePanels = false;

        /**
         * Flag if no texture shall be used. If true the terrain uses the default or specified color only.
         * @default false
         * @type {boolean}
         */
        this.colorOnly = false;

        /**
         * Terrain of the module.
         */
        this.terrain = null;

        /**
         * Index aka. ID of the module.#
         * @type {Number}
         */
        this.index = -1;
    };
};
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Scene Model: Layer and Time. TODO: Add better description
 * 1 URL for the service, 1 Coverage name data.
 * @augments EarthServerGenericClient.AbstractSceneModel
 */
EarthServerGenericClient.Model_LayerAndTime = function()
{
    this.setDefaults();
    this.name = "Coverage with layers and time.";
   
    /**
     * The custom or default WCPS Queries.
     * @type {Array}
     */
    this.WCPSQuery  = [];
    /**
     * Data modifier for the data query. Should be a number as a string.
     * @default: Empty String
     * @type {string}
     */
    this.dataModifier = "";
};
EarthServerGenericClient.Model_LayerAndTime.inheritsFrom( EarthServerGenericClient.AbstractSceneModel );

/**
 * Sets the URL for the service.
 * @param url
 */
EarthServerGenericClient.Model_LayerAndTime.prototype.setURL=function(url){
    /**
     * URL for the WCPS service.
     * @type {String}
     */
    this.URLWCPS = String(url);
};
/**
 * Sets the coverage name.
 * @param coverageLayer - Coverage name for the layered data set.
 */
EarthServerGenericClient.Model_LayerAndTime.prototype.setCoverage = function (coverageLayer) {
    /**
     * Name of the image coverage.
     * @type {String}
     */
    this.coverageLayer = String(coverageLayer);
};
/**
 * Sets the queried layers. E.g. 1:3
 * @param Layers
 */
EarthServerGenericClient.Model_LayerAndTime.prototype.setLayers = function (Layers) {
    /**
     * Queried Layers.
     * @type {String}
     */
    this.queriedLayers = [];

    var tmpLayers = String(Layers);
    tmpLayers = tmpLayers.split(":");

    if( tmpLayers.length === 1)
    {   this.queriedLayers = tmpLayers; }
    else
    {
        for(var i=parseInt(tmpLayers[0]);i<=parseInt(tmpLayers[1]);i++)
        {   this.queriedLayers.push(i);  }
    }

    this.requests = this.queriedLayers.length;
};
/**
 * Sets the coverage time.
 * @param coverageTime
 */
EarthServerGenericClient.Model_LayerAndTime.prototype.setCoverageTime = function (coverageTime) {
    /**
     *
     * @type {String}
     */
    this.coverageTime = String(coverageTime);
};

/**
 * Sets the data modifier to be multiplied with the data. Eg: 10000
 * @param modifier
 */
EarthServerGenericClient.Model_LayerAndTime.prototype.setDataModifier = function( modifier )
{
    this.dataModifier = String(modifier) + "*";
};

/**
 * Sets a specific querystring for the data query.
 * @param queryString - the querystring. Use $CI (coverageImage), $CD (coverageDEM),
 * $MINX,$MINY,$MAXX,$MAXY(AoI) and $RESX,ResZ (Resolution) for automatic replacement.
 * Examples: $CI.red , x($MINX:$MINY)
 */
EarthServerGenericClient.Model_LayerAndTime.prototype.setWCPSForChannelALPHA = function(queryString)
{
    this.WCPSQuery = queryString;
};

/**
 * Sets the Coordinate Reference System.
 * @param value - eg. "http://www.opengis.net/def/crs/EPSG/0/27700"
 */
EarthServerGenericClient.Model_LayerAndTime.prototype.setCoordinateReferenceSystem = function(value)
{
    this.CRS = value;
};

/**
 * Creates the x3d geometry and appends it to the given root node. This is done automatically by the SceneManager.
 * @param root - X3D node to append the model.
 * @param cubeSizeX - Size of the fishtank/cube on the x-axis.
 * @param cubeSizeY - Size of the fishtank/cube on the y-axis.
 * @param cubeSizeZ - Size of the fishtank/cube on the z-axis.
 */
EarthServerGenericClient.Model_LayerAndTime.prototype.createModel=function(root, cubeSizeX, cubeSizeY, cubeSizeZ){
    if( root === undefined)
        alert("root is not defined");

    EarthServerGenericClient.MainScene.timeLogStart("Create Model " + this.name);

    this.cubeSizeX = cubeSizeX;
    this.cubeSizeY = cubeSizeY;
    this.cubeSizeZ = cubeSizeZ;

    this.root = root;

    // Check if mandatory values are set
    if( this.coverageLayer === undefined || this.URLWCPS === undefined ||
        this.coverageTime === undefined || this.queriedLayers === undefined  )
    {
        alert("Not all mandatory values are set. LayerAndTime: " + this.name );
        console.log(this);
        return;
    }

    //IF something is not defined use standard query.
    if( this.WCPSQuery.length === 0 )
    {
        for(var i=0; i< this.queriedLayers.length;i++)
        {
            this.WCPSQuery[i]  = "for data in (" + this.coverageLayer +")";
            this.WCPSQuery[i] += "return encode(("+ this.dataModifier +"data[t(" + this.coverageTime +"),";
            this.WCPSQuery[i] += 'd4('+ this.queriedLayers[i]+ ')]),"png")';
        }
    }
    else //ALL set so use custom query
    {
        this.replaceSymbolsInString(this.WCPSQuery);
    }

    // request data
    EarthServerGenericClient.requestWCPSImages(this,this.URLWCPS,this.WCPSQuery);
};
/**
 * This is a callback method as soon as the ServerRequest in createModel() has received it's data.
 * This is done automatically.
 * @param data - Received data array(!) from the ServerRequest.
 */
EarthServerGenericClient.Model_LayerAndTime.prototype.receiveData = function( data)
{
    var failedData = 0;
    for(var i=0;i<data.length;i++)
    {
        // TODO: delete only the one element and UI only if all failed.
        if( !this.checkReceivedData( data[i] ) )
            failedData++;
    }

    // if all data failed return
    if( failedData == data.length) return;

    // create transform
    this.transformNode = this.createTransform(2,this.queriedLayers.length,2,0);
    this.root.appendChild(this.transformNode);

    // create terrain
    EarthServerGenericClient.MainScene.timeLogStart("Create Terrain " + this.name);
    this.terrain = new EarthServerGenericClient.VolumeTerrain(this.transformNode,data,this.index,this.noDataValue);
    EarthServerGenericClient.MainScene.timeLogEnd("Create Terrain " + this.name);

};

EarthServerGenericClient.Model_LayerAndTime.prototype.updateMaxShownElements = function(value)
{
    if( this.terrain !== undefined )
        this.terrain.updateMaxShownElements(value);
};

/**
 * Every Scene Model creates it's own specific UI elements. This function is called automatically by the SceneManager.
 * @param element - The element where to append the specific UI elements for this model.
 */
EarthServerGenericClient.Model_LayerAndTime.prototype.setSpecificElement= function(element)
{
    EarthServerGenericClient.appendMaxShownElementsSlider(element,this.index,this.requests);
};
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Scene Model: Module for underground data.
 * One service URL, one coverage
 * @augments EarthServerGenericClient.AbstractSceneModel
 */
EarthServerGenericClient.Module_Sharad = function()
{
    this.setDefaults();
    this.boundModelIndex = -1; // sharad modules can be bound to other modules. -1: unbound
    this.name = "Sharad Underground";
};
EarthServerGenericClient.Module_Sharad.inheritsFrom( EarthServerGenericClient.AbstractSceneModel );


EarthServerGenericClient.Module_Sharad.prototype.setURL=function(serviceURL)
{
    this.serviceURL = serviceURL;
};


EarthServerGenericClient.Module_Sharad.prototype.setCoverages = function (coverage)
{
    this.coverage = coverage;
};

/**
 * Sets a complete custom querystring.
 * @param querystring - the querystring. Use $CI (coverageImage), $CD (coverageDEM),
 * $MINX,$MINY,$MAXX,$MAXY(AoI) and $RESX,ResZ (Resolution) for automatic replacement.
 * Examples: $CI.red , x($MINX:$MINY)
 */
EarthServerGenericClient.Module_Sharad.prototype.setWCPSQuery = function(querystring)
{
    /**
     * The custom query.
     * @type {String}
     */
    this.WCPSQuery = String(querystring);
};

/**
 * Creates the x3d geometry and appends it to the given root node. This is done automatically by the SceneManager.
 * @param root - X3D node to append the model.
 * @param cubeSizeX - Size of the fishtank/cube on the x-axis.
 * @param cubeSizeY - Size of the fishtank/cube on the y-axis.
 * @param cubeSizeZ - Size of the fishtank/cube on the z-axis.
 */
EarthServerGenericClient.Module_Sharad.prototype.createModel=function(root,cubeSizeX, cubeSizeY, cubeSizeZ){
    if( root === undefined)
    {   alert("root is not defined");    }

    this.cubeSizeX = cubeSizeX;
    this.cubeSizeY = cubeSizeY;
    this.cubeSizeZ = cubeSizeZ;

    this.root = root;

    //Create Placeholder
    this.createPlaceHolder();

    //1: Check if mandatory values are set
    if( this.serviceURL === undefined || this.coverage === undefined || this.WCPSQuery === undefined )
    {
        alert("Not all mandatory values are set. Sharad: " + this.name );
        console.log(this);
        return;
    }

    //Replace $ symbols with the actual values
    this.WCPSQuery = this.WCPSQuery.replace("$CI",this.coverage);
    this.WCPSQuery = this.WCPSQuery.replace("$MINX",this.minx);
    this.WCPSQuery = this.WCPSQuery.replace("$MINY",this.miny);
    this.WCPSQuery = this.WCPSQuery.replace("$MAXX",this.maxx);
    this.WCPSQuery = this.WCPSQuery.replace("$MAXY",this.maxy);
    this.WCPSQuery = this.WCPSQuery.replace("$CRS" ,'"' + this.CRS + '"');
    this.WCPSQuery = this.WCPSQuery.replace("$CRS" ,'"' + this.CRS + '"');
    this.WCPSQuery = this.WCPSQuery.replace("$RESX",this.XResolution);
    this.WCPSQuery = this.WCPSQuery.replace("$RESZ",this.ZResolution);

    //2: Make ServerRequest
    EarthServerGenericClient.requestWCPSImage(this,this.serviceURL,this.WCPSQuery);
};

EarthServerGenericClient.Module_Sharad.prototype.setMetaData = function( link )
{

    function getBinary(file)
    {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", file, false);
        xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.send(null);
        return xhr.responseText;
    }

    var descov = getBinary(link);

    if(descov)
    {
        descov = descov.match(/gmlcov:metadata>(.+)<\/gmlcov:metadata/);
        if(descov !== null)
        {
            descov = descov[0];
            descov = descov.replace('coords','"coords"');
            descov = '' + descov.substring(16,descov.length - 18);
            var metadata = JSON.parse(descov);

            if( metadata.coords.length > 0)
            {   this.coords = metadata.coords; }
        }
        else
        {
            console.log("EarthServerGenericClient::Module_Sharad: Error in meta data response.") ;
        }
    }
    else
    {
        console.log("EarthServerGenericClient::Module_Sharad: Can't access meta data.") ;
    }
};

/**
 * This is a callback method as soon as the ServerRequest in createModel() has received it's data.
 * This is done automatically.
 * @param data - Received data from the ServerRequest.
 */
EarthServerGenericClient.Module_Sharad.prototype.receiveData = function(data)
{
    if( this.checkReceivedData(data))
    {
        // Remove the placeHolder
        this.removePlaceHolder();

        // This modules creates it's own transformation.
        var trans = document.createElement('Transform');
        trans.setAttribute("id", "EarthServerGenericClient_modelTransform"+this.index);

        if(this.coords === undefined)
        {
            var width = Math.pow(2, Math.round(Math.log(data.texture.width)/Math.log(2)));
            var height = Math.pow(2, Math.round(Math.log(data.texture.height)/Math.log(2)));

            if( width  > x3dom.caps.MAX_TEXTURE_SIZE) width  = x3dom.caps.MAX_TEXTURE_SIZE;
            if( height > x3dom.caps.MAX_TEXTURE_SIZE) height = x3dom.caps.MAX_TEXTURE_SIZE;

            this.YResolution = 1000;

            var scaleX = (this.cubeSizeX*this.xScale)/(parseInt(width)-1);
            var scaleY = (this.cubeSizeY*this.yScale)/1000;
            var scaleZ = (this.cubeSizeY*this.yScale)/(parseInt(height)-1);

            trans.setAttribute("scale", "" + scaleX + " " + scaleY + " " + scaleZ);

            var xoff = (this.cubeSizeX * this.xOffset) - (this.cubeSizeX/2.0);
            var yoff = (this.cubeSizeY * this.yOffset) + (height*scaleY) - (this.cubeSizeY/2.0);
            var zoff = (this.cubeSizeZ * this.zOffset) - (this.cubeSizeZ/2.0);
            trans.setAttribute("translation", "" + xoff+ " " + yoff  + " " + zoff);

            // turn upright
            trans.setAttribute("rotation","1 0 0 1.57");
        }
        else
        {
            height = Math.pow(2, Math.round(Math.log(data.texture.height)/Math.log(2)));
            if( height > x3dom.caps.MAX_TEXTURE_SIZE) height = x3dom.caps.MAX_TEXTURE_SIZE;

            scaleY = (this.cubeSizeY*this.yScale)/height;
            trans.setAttribute("scale", "1 " + scaleY + " 1");

            this.YResolution = height;

            var min = (-this.cubeSizeY/2.0) + EarthServerGenericClient.MainScene.getModelOffsetY(this.index) * this.cubeSizeY;
            yoff = (this.cubeSizeY * this.yOffset) - (min*scaleY) - (this.cubeSizeY/2.0);
            trans.setAttribute("translation", "0 " + yoff  + " 0");
        }


        this.root.appendChild( trans);

        // Create terrain
        var area = {};
        area.minx = this.minx;
        area.miny = this.miny;
        area.maxx = this.maxx;
        area.maxy = this.maxy;
        this.terrain = new EarthServerGenericClient.SharadTerrain(trans, data, this.index,this.noData,this.coords,area);
        this.terrain.createTerrain();
    }
};

/**
 * Sets the index of the scene model the sharad module is bound to.
 * @param index - Index of the scene model.
 */
EarthServerGenericClient.Module_Sharad.prototype.setBoundModuleIndex = function(index)
{
    if(index === this.index)//prevent to bind this module to itself
    {
        console.log("Module_Sharad: Can't bind module to itself.");
    }
    else
    {
        console.log("Module_Sharad: Bound to model: " + index);
        this.boundModelIndex = index;
    }
};

/**
 * Returns the index of the model sharad module is bound to.
 * @returns {number} - Index of the model or -1 if unbound.
 */
EarthServerGenericClient.Module_Sharad.prototype.getBoundModuleIndex = function()
{
    return this.boundModelIndex;
};

/**
 * Resets the modelIndex sharad module is bound to back to -1 and marks it as unbound.
 */
EarthServerGenericClient.Module_Sharad.prototype.releaseBinding = function()
{
    this.boundModelIndex = -1;
};

/**
 * If sharad module is bound to another module the sharad module shall move when the other module is moved.
 * This function shall receive the delta of the positions every time the module is moved.
 * @param axis - Axis of the movement.
 * @param delta - Delta to the last position.
 */
EarthServerGenericClient.Module_Sharad.prototype.movementUpdateBoundModule = function(axis,delta)
{
   EarthServerGenericClient.MainScene.updateOffsetByDelta(this.index,axis,delta);
};

/**
 * This function notifies sharad module that the bound module's elevation was changed.
 * All annotation will be checked and altered in their position.
 */
EarthServerGenericClient.Module_Sharad.prototype.elevationUpdateBoundModule = function(value)
{
    if(this.boundModelIndex >= 0)
    {
        var x = 0;
        var z = 0;

        // call elevation update to it self
        EarthServerGenericClient.MainScene.updateElevation(this.index,value);
        // get height of the bound module. (for now at the center of the cube
        var value = EarthServerGenericClient.MainScene.getHeightAt3DPosition(this.boundModelIndex,x,z);
        console.log(value);
        // get own transformation by name "EarthServerGenericClient_modelTransform"+this.index);
        var trans = document.getElementById("EarthServerGenericClient_modelTransform"+this.index);
        if( trans)
        {
            var scale = trans.getAttribute("scale");
            scale = scale.split(" ");
            // determine exact value
            value = value + (this.cubeSizeY/2) - ( this.YResolution * scale[1] * this.yScale );
            //update offset
            EarthServerGenericClient.MainScene.updateOffset(this.index,1,value);
        }
        else
        {   console.log("EarthServerClient::Module_Sharad not able to find transform.");    }

        trans = null;
    }
    else
    {   console.log("EarthServerClient::Module_Sharad not bound to a model.");  }
};



/**
 * Every Scene Model creates it's own specific UI elements. This function is called automatically by the SceneManager.
 * @param element - The element where to append the specific UI elements for this model
 */
EarthServerGenericClient.Module_Sharad.prototype.setSpecificElement= function(element)
{
    // updateLength() is called for elevation because the model is rotated. Scaling it's length
    // scales the size on the y-axis in fact.
    if(this.coords === undefined)
    {
        EarthServerGenericClient.appendGenericSlider(element,"EarthServerGenericClient_Slider_E_"+this.index,"Elevation",
                                                this.index,0,100,10,EarthServerGenericClient.MainScene.updateLength);
    }
    else//normal elevation
    {   EarthServerGenericClient.appendElevationSlider(element,this.index); }
};

//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @ignore <-- REMOVE ME FOR DOCUMENTATION
 * @class Scene Model: <Add Description>
 * <amount of service urls + coverages>
 * @augments EarthServerGenericClient.AbstractSceneModel
 */
EarthServerGenericClient.Model_Name = function()
{
    this.setDefaults();
    this.name = "Some Name";

    //Initialise variables her
    //this.var = 0;
};
EarthServerGenericClient.Model_Name.inheritsFrom( EarthServerGenericClient.AbstractSceneModel );

//A function for URL(s)
//EarthServerGenericClient.Model_Name.prototype.setURLs=function(URL1,..)

//A function for Coverage(s)
//EarthServerGenericClient.Model_Name.prototype.setCoverages = function (coverage1, ...)

//A function for Version(s)
//EarthServerGenericClient.Model_Name.prototype.setxxxVersion = function (version)

//Any additional functions
//EarthServerGenericClient.Model_Name.prototype.functionName = function(parameters)

/**
 * @ignore <-- REMOVE ME FOR DOCUMENTATION
 * Creates the x3d geometry and appends it to the given root node. This is done automatically by the SceneManager.
 * @param root - X3D node to append the model.
 * @param cubeSizeX - Size of the fishtank/cube on the x-axis.
 * @param cubeSizeY - Size of the fishtank/cube on the y-axis.
 * @param cubeSizeZ - Size of the fishtank/cube on the z-axis.
 */
EarthServerGenericClient.Model_Name.prototype.createModel=function(root,cubeSizeX, cubeSizeY, cubeSizeZ){
    if( root === undefined)
        alert("root is not defined");

    this.cubeSizeX = cubeSizeX;
    this.cubeSizeY = cubeSizeY;
    this.cubeSizeZ = cubeSizeZ;

    this.root = root;

    //Create Placeholder
    this.createPlaceHolder();

    //1: Check if mandatory values are set
    /*if( this.var === undefined || ....)
    {
        alert("Not all mandatory values are set. ModuleDescription: " + this.name );
        console.log(this);
        return;
    }*/

    //2: Make ServerRequest
    /* Exmaple:
    EarthServerGenericClient.requestWMSImageWCSDem(this,bb,this.XResolution,this.ZResolution,
        this.URLWMS,this.coverageImage,this.WMSVersion,this.CRS,this.imageFormat,
        this.URLDEM,this.coverageDEM,this.WCSVersion);
        */
};

/**
 * @ignore <-- REMOVE ME FOR DOCUMENTATION
 * This is a callback method as soon as the ServerRequest in createModel() has received it's data.
 * This is done automatically.
 * @param data - Received data from the ServerRequest.
 */
EarthServerGenericClient.Model_Name.prototype.receiveData= function( data)
{
    if( this.checkReceivedData(data))
    {
        //Remove the placeHolder
        this.removePlaceHolder();

        var YResolution = (parseFloat(data.maxHMvalue) - parseFloat(data.minHMvalue) );
        var transform = this.createTransform(data.width,YResolution,data.height,parseFloat(data.minHMvalue));
        this.root.appendChild( transform);

        //Set transparency
        data.transparency = this.transparency;

        //Create Terrain out of the received data
        //Example LOD Terrain
        //this.terrain = new EarthServerGenericClient.LODTerrain(transform, data, this.index);
        //this.terrain.createTerrain();

    }
};


/**
 * @ignore <-- REMOVE ME FOR DOCUMENTATION
 * Every Scene Model creates it's own specific UI elements. This function is called automatically by the SceneManager.
 * @param element - The element where to append the specific UI elements for this model
 */
EarthServerGenericClient.Model_Name.prototype.setSpecificElement= function(element)
{
    //Example:
    //EarthServerGenericClient.appendElevationSlider(element,this.index);
};
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Scene Model: WCPS Image with DEM from second WCPS Query
 * 2 URLs for the service, 2 Coverage names for the image and dem.
 * @augments EarthServerGenericClient.AbstractSceneModel
 */
EarthServerGenericClient.Model_WCPSDemWCPS = function()
{
    this.setDefaults();
    this.name = "WCPS Image with DEM from second WCPS Query.";
};
EarthServerGenericClient.Model_WCPSDemWCPS.inheritsFrom( EarthServerGenericClient.AbstractSceneModel );
/**
 * Sets the urls for both WCPS Queries. If only one url is given it is used for both requests.
 * @param imageURL - Service URL for the WCPS Image Request
 * @param demURL - Service URL for the WCPS Dem Request
 */
EarthServerGenericClient.Model_WCPSDemWCPS.prototype.setURLs=function(imageURL, demURL){
    /**
     * URL for the WCPS image service.
     * @type {String}
     */
    this.imageURL = String(imageURL);
    /**
     * URL for the WCPS Dem service.
     * @type {String}
     */
    this.demURL;
    if(demURL === undefined) // if demURL is not defined use imageURL
    {   this.demURL = String(imageURL); }
    else
    {   this.demURL  = String(demURL);  }
};
/**
 * Sets both coveragenames
 * @param coverageImage - Coverage name for the image dataset.
 * @param coverageDem   - Coverage name for the dem dataset.
 */
EarthServerGenericClient.Model_WCPSDemWCPS.prototype.setCoverages = function (coverageImage, coverageDem) {
    /**
     * Name of the image coverage.
     * @type {String}
     */
    this.coverageImage = String(coverageImage);
    /**
     * Name if the dem coverage.
     * @type {String}
     */
    this.coverageDEM = String(coverageDem);
};
/**
 * Sets a complete custom querystring.
 * @param querystring - the querystring. Use $CI (coverageImage), $CD (coverageDEM),
 * $MINX,$MINY,$MAXX,$MAXY(AoI) and $RESX,ResZ (Resolution) for automatic replacement.
 * Examples: $CI.red , x($MINX:$MINY)
 */
EarthServerGenericClient.Model_WCPSDemWCPS.prototype.setWCPSImageQuery = function(querystring)
{
    /**
     * The custom WCPS image query.
     * @type {String}
     */
    this.WCPSImageQuery = String(querystring);
};

/**
 * Sets a custom query for the WCPS Dem request.
 * @param querystring - WCPS as a string.
 */
EarthServerGenericClient.Model_WCPSDemWCPS.prototype.setWCPSDemQuery = function(querystring)
{
    /**
     * The custom WCPS Dem query.
     * @type {String}
     */
    this.WCPSDemQuery = String(querystring);
};


/**
 * Sets the Coordinate Reference System.
 * @param value - eg. "http://www.opengis.net/def/crs/EPSG/0/27700"
 */
EarthServerGenericClient.Model_WCPSDemWCPS.prototype.setCoordinateReferenceSystem = function(value)
{
    this.CRS = value;
};

/**
 * Creates the x3d geometry and appends it to the given root node. This is done automatically by the SceneManager.
 * @param root - X3D node to append the model.
 * @param cubeSizeX - Size of the fishtank/cube on the x-axis.
 * @param cubeSizeY - Size of the fishtank/cube on the y-axis.
 * @param cubeSizeZ - Size of the fishtank/cube on the z-axis.
 */
EarthServerGenericClient.Model_WCPSDemWCPS.prototype.createModel=function(root, cubeSizeX, cubeSizeY, cubeSizeZ){
    if( root === undefined)
        alert("root is not defined");

    EarthServerGenericClient.MainScene.timeLogStart("Create Model " + this.name);

    this.cubeSizeX = cubeSizeX;
    this.cubeSizeY = cubeSizeY;
    this.cubeSizeZ = cubeSizeZ;

    this.root = root;

    //Create Placeholder
    this.createPlaceHolder();

    //1: Check if mandatory values are set
    if( this.coverageImage === undefined || this.coverageDEM === undefined || this.imageURL === undefined || this.demURL === undefined
        || this.minx === undefined || this.miny === undefined || this.maxx === undefined || this.maxy === undefined || this.CRS === undefined )
    {
        alert("Not all mandatory values are set. WCPSDemWCPS: " + this.name );
        console.log(this);
        return;
    }

    //2: create wcps queries
    //If no query was defined use standard query.
    if( this.WCPSImageQuery === undefined)
    {
        this.WCPSImageQuery =  "for i in (" + this.coverageImage + ") return encode ( { ";
        this.WCPSImageQuery += 'red: scale(trim(i.red, {x:"' + this.CRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.CRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + this.XResolution + '), y:"CRS:1"(0:' + this.ZResolution + ")}, {}); ";
        this.WCPSImageQuery += 'green: scale(trim(i.green, {x:"' + this.CRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.CRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + this.XResolution + '), y:"CRS:1"(0:' + this.ZResolution + ")}, {}); ";
        this.WCPSImageQuery += 'blue: scale(trim(i.blue, {x:"' + this.CRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.CRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + this.XResolution + '), y:"CRS:1"(0:' + this.ZResolution + ")}, {})";
        this.WCPSImageQuery += '}, "' + this.imageFormat +'" )';
    }
    else //A custom query was defined so use it
    {
        //Replace $ symbols with the actual values
        this.WCPSImageQuery = this.replaceSymbolsInString(this.WCPSImageQuery);
    }

    if( this.WCPSDemQuery === undefined)
    {
        var currentXRes = this.XResolution;
        var currentZRes = this.ZResolution;
        this.WCPSDemQuery =  "for dtm in (" + this.coverageDEM + ") return encode (";
        this.WCPSDemQuery += 'scale(trim(dtm , {x:"' + this.CRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.CRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + currentXRes + '), y:"CRS:1"(0:' + currentZRes + ")}, {})";
        this.WCPSDemQuery += ', "csv" )';
    }
    else //A custom query was defined so use it
    {
        //Replace $ symbols with the actual values
        this.WCPSDemQuery = this.replaceSymbolsInString(this.WCPSDemQuery);
    }

    EarthServerGenericClient.requestWCPSImageWCPSDem(this,this.imageURL,this.WCPSImageQuery,this.demURL,this.WCPSDemQuery);
};

/**
 * This is a callback method as soon as the ServerRequest in createModel() has received it's data.
 * This is done automatically.
 * @param data - Received data from the ServerRequest.
 */
EarthServerGenericClient.Model_WCPSDemWCPS.prototype.receiveData= function( data)
{
    if( this.checkReceivedData(data))
    {
        //Remove the placeHolder
        this.removePlaceHolder();

        var YResolution = this.YResolution || (parseFloat(data.maxHMvalue) - parseFloat(data.minHMvalue) );
        var transform = this.createTransform(data.width,YResolution,data.height,parseFloat(data.minHMvalue),data.minXvalue,data.minZvalue);
        this.root.appendChild( transform);

        //Create Terrain out of the received data
        EarthServerGenericClient.MainScene.timeLogStart("Create Terrain " + this.name);
        this.terrain = new EarthServerGenericClient.LODTerrain(transform, data, this.index, this.noData, this.demNoData);
        this.terrain.createTerrain();
        EarthServerGenericClient.MainScene.timeLogEnd("Create Terrain " + this.name);
        this.elevationUpdateBinding(); // notify all bindings about the terrain elevation update

        if(this.sidePanels)
        {   this.terrain.createSidePanels(transform,1); }

        EarthServerGenericClient.MainScene.timeLogEnd("Create Model " + this.name);

        transform = null;
    }
};


/**
 * Every Scene Model creates it's own specific UI elements. This function is called automatically by the SceneManager.
 * @param element - The element where to append the specific UI elements for this model.
 */
EarthServerGenericClient.Model_WCPSDemWCPS.prototype.setSpecificElement= function(element)
{
    EarthServerGenericClient.appendElevationSlider(element,this.index);
};

//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Scene Model: WCPS Image with DEM in Alpha Channel
 * 1 URL for the service, 2 Coverage names for the image and dem.
 * @augments EarthServerGenericClient.AbstractSceneModel
 */
EarthServerGenericClient.Model_WCPSDemAlpha = function()
{
    this.setDefaults();
    this.name = "WCPS Image with DEM in alpha channel.";
    /**
     * Determines if progressive or complete loading of the model is used.
     * @default false
     * @type {Boolean}
     */
    this.progressiveLoading = false;

    /**
     * The custom or default WCPS Queries. The array contains either one element for complete loading
     * or multiple (3) queries for progressive loading of the model.
     * @type {Array}
     */
    this.WCPSQuery  = [];
};
EarthServerGenericClient.Model_WCPSDemAlpha.inheritsFrom( EarthServerGenericClient.AbstractSceneModel );
/**
 * Enables/Disables the progressive loading of the model.
 * @param value - True or False
 */
EarthServerGenericClient.Model_WCPSDemAlpha.prototype.setProgressiveLoading=function(value){
    this.progressiveLoading = value;

    //Progressive Loading creates 3 requests while normal loading 1
    if( this.progressiveLoading){ this.requests = 3; }
    else{   this.requests = 1;  }
};
/**
 * Sets the URL for the service.
 * @param url
 */
EarthServerGenericClient.Model_WCPSDemAlpha.prototype.setURL=function(url){
    /**
     * URL for the WCPS service.
     * @type {String}
     */
    this.URLWCPS = String(url);
};
/**
 * Sets both coverage names.
 * @param coverageImage - Coverage name for the image data set.
 * @param coverageDem   - Coverage name for the dem data set.
 */
EarthServerGenericClient.Model_WCPSDemAlpha.prototype.setCoverages = function (coverageImage, coverageDem) {
    /**
     * Name of the image coverage.
     * @type {String}
     */
    this.coverageImage = String(coverageImage);
    /**
     * name of the dem coverage.
     * @type {String}
     */
    this.coverageDEM = String(coverageDem);
};
/**
 * Sets a specific querystring for the RED channel of the WCPS query.
 * All red,blue,green and alpha has to be set, otherwise the standard query will be used.
 * @param querystring - the querystring. Use $CI (coverageImage), $CD (coverageDEM),
 * $MINX,$MINY,$MAXX,$MAXY(AoI) and $RESX,ResZ (Resolution) for automatic replacement.
 * Examples: $CI.red , x($MINX:$MINY)
 */
EarthServerGenericClient.Model_WCPSDemAlpha.prototype.setWCPSForChannelRED = function(querystring)
{
    this.WCPSQuery[0] = querystring;
};
/**
 * Sets a specific querystring for the GREEN channel of the WCPS query.
 * All red,blue,green and alpha has to be set, otherwise the standard query will be used.
 * @param querystring - the querystring. Use $CI (coverageImage), $CD (coverageDEM),
 * $MINX,$MINY,$MAXX,$MAXY(AoI) and $RESX,ResZ (Resolution) for automatic replacement.
 * Examples: $CI.red , x($MINX:$MINY)
 */
EarthServerGenericClient.Model_WCPSDemAlpha.prototype.setWCPSForChannelGREEN = function(querystring)
{
    this.WCPSQuery[1] = querystring;
};
/**
 * Sets a specific querystring for the BLUE channel of the WCPS query.
 * All red,blue,green and alpha has to be set, otherwise the standard query will be used.
 * @param querystring - the querystring. Use $CI (coverageImage), $CD (coverageDEM),
 * $MINX,$MINY,$MAXX,$MAXY(AoI) and $RESX,ResZ (Resolution) for automatic replacement.
 * Examples: $CI.red , x($MINX:$MINY)
 */
EarthServerGenericClient.Model_WCPSDemAlpha.prototype.setWCPSForChannelBLUE = function(querystring)
{
    this.WCPSQuery[2] = querystring;
};
/**
 * Sets a specific querystring for the ALPHA channel of the WCPS query.
 * All red,blue,green and alpha has to be set, otherwise the standard query will be used.
 * @param querystring - the querystring. Use $CI (coverageImage), $CD (coverageDEM),
 * $MINX,$MINY,$MAXX,$MAXY(AoI) and $RESX,ResZ (Resolution) for automatic replacement.
 * Examples: $CI.red , x($MINX:$MINY)
 */
EarthServerGenericClient.Model_WCPSDemAlpha.prototype.setWCPSForChannelALPHA = function(querystring)
{
    this.WCPSQuery[3] = querystring;
};

/**
 * Sets the Coordinate Reference System.
 * @param value - eg. "http://www.opengis.net/def/crs/EPSG/0/27700"
*/
EarthServerGenericClient.Model_WCPSDemAlpha.prototype.setCoordinateReferenceSystem = function(value)
{
    this.CRS = value;
};

/**
 * Creates the x3d geometry and appends it to the given root node. This is done automatically by the SceneManager.
 * @param root - X3D node to append the model.
 * @param cubeSizeX - Size of the fishtank/cube on the x-axis.
 * @param cubeSizeY - Size of the fishtank/cube on the y-axis.
 * @param cubeSizeZ - Size of the fishtank/cube on the z-axis.
 */
EarthServerGenericClient.Model_WCPSDemAlpha.prototype.createModel=function(root, cubeSizeX, cubeSizeY, cubeSizeZ){
    if( root === undefined)
        alert("root is not defined");

    EarthServerGenericClient.MainScene.timeLogStart("Create Model " + this.name);

    this.cubeSizeX = cubeSizeX;
    this.cubeSizeY = cubeSizeY;
    this.cubeSizeZ = cubeSizeZ;

    this.root = root;

    //Create Placeholder
    this.createPlaceHolder();

    //1: Check if mandatory values are set
    if( this.coverageImage === undefined || this.coverageDEM === undefined || this.URLWCPS === undefined || this.CRS === undefined
        || this.minx === undefined || this.miny === undefined || this.maxx === undefined || this.maxy === undefined )
    {
        alert("Not all mandatory values are set. WCPSDemAlpha: " + this.name );
        console.log(this);
        return;
    }

    //2: create wcps query/queries
    //Either the user query if all query strings are set. Or standard wcps query if wcps channels are not set.
    //Build one query for complete loading and multiple queries for progressive loading

    //IF something is not defined use standard query.
    if( this.WCPSQuery[0] === undefined || this.WCPSQuery[1] === undefined || this.WCPSQuery[2] === undefined || this.WCPSQuery[3] === undefined)
    {
        for(var i=0; i<this.requests; i++)
        {
            var currentXRes = parseInt(this.XResolution / Math.pow(2,i) );
            var currentZRes = parseInt(this.ZResolution / Math.pow(2,i) );
            this.WCPSQuery[i] =  "for i in (" + this.coverageImage + "), dtm in (" + this.coverageDEM + ") return encode ( { ";
            this.WCPSQuery[i] += 'red: scale(trim(i.red, {x:"' + this.CRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.CRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + currentXRes + '), y:"CRS:1"(0:' + currentZRes + ")}, {}); ";
            this.WCPSQuery[i] += 'green: scale(trim(i.green, {x:"' + this.CRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.CRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + currentXRes + '), y:"CRS:1"(0:' + currentZRes + ")}, {}); ";
            this.WCPSQuery[i] += 'blue: scale(trim(i.blue, {x:"' + this.CRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.CRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + currentXRes + '), y:"CRS:1"(0:' + currentZRes + ")}, {});";
            this.WCPSQuery[i] += 'alpha: (char) (((scale(trim(dtm , {x:"' + this.CRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.CRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + currentXRes + '), y:"CRS:1"(0:' + currentZRes + ")}, {})) / 1349) * 255)";
            this.WCPSQuery[i] += '}, "' + this.imageFormat +'" )';
        }
    }
    else //ALL set so use custom query
    {
        //Create multiple queries if progressive loading is set or one if not.
        for(var j=0; j<this.requests; j++)
        {
            //Replace $ symbols with the actual values
            var tmpString = [];
            for(i=0; i<4; i++)
            {
                tmpString[i] = EarthServerGenericClient.replaceAllFindsInString(this.WCPSQuery[i],"$CI","image");
                tmpString[i] = EarthServerGenericClient.replaceAllFindsInString(tmpString[i],"$CD","dtm");
                tmpString[i] = EarthServerGenericClient.replaceAllFindsInString(tmpString[i],"$MINX",this.minx);
                tmpString[i] = EarthServerGenericClient.replaceAllFindsInString(tmpString[i],"$MINY",this.miny);
                tmpString[i] = EarthServerGenericClient.replaceAllFindsInString(tmpString[i],"$MAXX",this.maxx);
                tmpString[i] = EarthServerGenericClient.replaceAllFindsInString(tmpString[i],"$MAXY",this.maxy);
                tmpString[i] = EarthServerGenericClient.replaceAllFindsInString(tmpString[i],"$CRS" ,'"' + this.CRS + '"');
                tmpString[i] = EarthServerGenericClient.replaceAllFindsInString(tmpString[i],"$RESX",parseInt(this.XResolution / Math.pow(2,j) ) );
                tmpString[i] = EarthServerGenericClient.replaceAllFindsInString(tmpString[i],"$RESZ",parseInt(this.ZResolution / Math.pow(2,j) ) );
            }
            this.WCPSQuery[j] =  "for image in (" + this.coverageImage + "), dtm in (" + this.coverageDEM + ") return encode ( { ";
            this.WCPSQuery[j] += "red: " + tmpString[0] + " ";
            this.WCPSQuery[j] += "green: " + tmpString[1]+ " ";
            this.WCPSQuery[j] += "blue: " + tmpString[2] + " ";
            this.WCPSQuery[j] += "alpha: " + tmpString[3];
            this.WCPSQuery[j] += '}, "' + this.imageFormat +'" )';
        }
    }

    //3: Make ServerRequest and receive data.
    if( !this.progressiveLoading)
    {   EarthServerGenericClient.requestWCPSImageAlphaDem(this,this.URLWCPS,this.WCPSQuery[0]);  }
    else
    {   EarthServerGenericClient.progressiveWCPSImageLoader(this,this.URLWCPS,this.WCPSQuery,true);   }
};
/**
 * This is a callback method as soon as the ServerRequest in createModel() has received it's data.
 * This is done automatically.
 * @param data - Received data from the ServerRequest.
 */
EarthServerGenericClient.Model_WCPSDemAlpha.prototype.receiveData = function( data)
{
    if( this.checkReceivedData(data))
    {
        //If progressive loading is enabled this function is called multiple times.
        //The lower resolution version shall be removed and replaced with the new one.
        //So the old transformNode will be removed and a new one created.
        if(this.transformNode !== undefined )
        {   this.root.removeChild(this.transformNode); }

        //In the first receiveData call remove the placeholder.
        this.removePlaceHolder();

        var YResolution = this.YResolution || (parseFloat(data.maxHMvalue) - parseFloat(data.minHMvalue) );
        this.transformNode = this.createTransform(data.width,YResolution,data.height,parseFloat(data.minHMvalue),data.minXvalue,data.minZvalue);
        this.root.appendChild(this.transformNode);

        //Create Terrain out of the received data
        if( !this.progressiveLoading)
        {
            EarthServerGenericClient.MainScene.timeLogStart("Create Terrain " + this.name);
            this.terrain = new EarthServerGenericClient.LODTerrain(this.transformNode, data, this.index, this.noData, this.demNoData);
            this.terrain.createTerrain();
            EarthServerGenericClient.MainScene.timeLogEnd("Create Terrain " + this.name);
            this.elevationUpdateBinding();
            if(this.sidePanels)
            {   this.terrain.createSidePanels(this.transformNode,1);    }
            EarthServerGenericClient.MainScene.timeLogEnd("Create Model " + this.name);
        }
        else
        {
            //Check if terrain is already created. Create it in the first function call.
            if( this.terrain === undefined )
            {   this.terrain = new EarthServerGenericClient.ProgressiveTerrain(this.index); }

            //Add new data (with higher resolution) to the terrain
            EarthServerGenericClient.MainScene.timeLogStart("Create Terrain " + this.name);
            this.terrain.insertLevel(this.transformNode,data,this.noData, this.demNoData);
            this.elevationUpdateBinding();
            if(this.sidePanels)
            {   this.terrain.createSidePanels(this.transformNode,1);    }
            EarthServerGenericClient.MainScene.timeLogEnd("Create Terrain " + this.name);

            if( this.receivedDataCount === this.requests)
            {   EarthServerGenericClient.MainScene.timeLogEnd("Create Model " + this.name);   }
        }

        //Delete transformNode when the last response call is done.
        //Until that the pointer is needed to delete the old terrain just before the new terrain is build.
        if( this.receivedDataCount === this.requests )
        {   this.transformNode = null;  }
    }
};

/**
 * Every Scene Model creates it's own specific UI elements. This function is called automatically by the SceneManager.
 * @param element - The element where to append the specific UI elements for this model.
 */
EarthServerGenericClient.Model_WCPSDemAlpha.prototype.setSpecificElement= function(element)
{
    EarthServerGenericClient.appendElevationSlider(element,this.index);
};
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Scene Model: WCPS Image with DEM from WCS Query
 * 2 URLs for the service, 2 Coverage names for the image and dem.
 * @augments EarthServerGenericClient.AbstractSceneModel
 */
EarthServerGenericClient.Model_WCPSDemWCS = function()
{
    this.setDefaults();
    this.name = "WCPS Image with DEM from WCS Query.";
    /**
     * WCS version for the query.
     * @default "2.0.0"
     * @type {String}
     */
    this.WCSVersion = "2.0.0";
};
EarthServerGenericClient.Model_WCPSDemWCS.inheritsFrom( EarthServerGenericClient.AbstractSceneModel );
/**
 * Sets the url for both the WCPS and WCS Queries.
 * @param wcpsurl - Service URL for the WCPS Request
 * @param demurl  - Service URL for the WCS Request
 */
EarthServerGenericClient.Model_WCPSDemWCS.prototype.setURLs=function(wcpsurl, demurl){
    /**
     * URL for the WCPS service.
     * @type {String}
     */
    this.URLWCPS = String(wcpsurl);
    /**
     * URL for the WCS service.
     * @type {String}
     */
    this.URLDEM  = String(demurl);
};
/**
 * Sets both coveragenames
 * @param coverageImage - Coverage name for the image dataset.
 * @param coverageDem   - Coverage name for the dem dataset.
 */
EarthServerGenericClient.Model_WCPSDemWCS.prototype.setCoverages = function (coverageImage, coverageDem) {
    /**
     * Name of the image coverage.
     * @type {String}
     */
    this.coverageImage = String(coverageImage);
    /**
     * Name if the dem coverage.
     * @type {String}
     */
    this.coverageDEM = String(coverageDem);
};
/**
 * Sets a complete custom querystring.
 * @param querystring - the querystring. Use $CI (coverageImage), $CD (coverageDEM),
 * $MINX,$MINY,$MAXX,$MAXY(AoI) and $RESX,ResZ (Resolution) for automatic replacement.
 * Examples: $CI.red , x($MINX:$MINY)
 */
EarthServerGenericClient.Model_WCPSDemWCS.prototype.setWCPSQuery = function(querystring)
{
    /**
     * The custom query.
     * @type {String}
     */
    this.WCPSQuery = String(querystring);
};

/**
 * Sets the WCS Version for the WCS Query String. Default: "2.0.0"
 * @param version - String with WCS version number.
 */
EarthServerGenericClient.Model_WCPSDemWCS.prototype.setWCSVersion = function(version)
{
    this.WCSVersion = String(version);
};

/**
 * Sets the Coordinate Reference System.
 * @param value - eg. "http://www.opengis.net/def/crs/EPSG/0/27700"
 */
EarthServerGenericClient.Model_WCPSDemWCS.prototype.setCoordinateReferenceSystem = function(value)
{
    this.CRS = value;
};

/**
 * Creates the x3d geometry and appends it to the given root node. This is done automatically by the SceneManager.
 * @param root - X3D node to append the model.
 * @param cubeSizeX - Size of the fishtank/cube on the x-axis.
 * @param cubeSizeY - Size of the fishtank/cube on the y-axis.
 * @param cubeSizeZ - Size of the fishtank/cube on the z-axis.
 */
EarthServerGenericClient.Model_WCPSDemWCS.prototype.createModel=function(root, cubeSizeX, cubeSizeY, cubeSizeZ){
    if( root === undefined)
        alert("root is not defined");

    EarthServerGenericClient.MainScene.timeLogStart("Create Model " + this.name);

    this.cubeSizeX = cubeSizeX;
    this.cubeSizeY = cubeSizeY;
    this.cubeSizeZ = cubeSizeZ;

    this.root = root;

    //Create Placeholder
    this.createPlaceHolder();

    //1: Check if mandatory values are set
    if( this.coverageImage === undefined || this.coverageDEM === undefined || this.URLWCPS === undefined || this.URLDEM === undefined
        || this.minx === undefined || this.miny === undefined || this.maxx === undefined || this.maxy === undefined || this.CRS === undefined )
    {
        alert("Not all mandatory values are set. WCPSDemWCS: " + this.name );
        console.log(this);
        return;
    }

    //2: create wcps query
    //If no query was defined use standard query.
    if( this.WCPSQuery === undefined)
    {
        this.WCPSQuery =  "for i in (" + this.coverageImage + ") return encode ( { ";
        this.WCPSQuery += 'red: scale(trim(i.red, {x:"' + this.CRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.CRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + this.XResolution + '), y:"CRS:1"(0:' + this.ZResolution + ")}, {}); ";
        this.WCPSQuery += 'green: scale(trim(i.green, {x:"' + this.CRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.CRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + this.XResolution + '), y:"CRS:1"(0:' + this.ZResolution + ")}, {}); ";
        this.WCPSQuery += 'blue: scale(trim(i.blue, {x:"' + this.CRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.CRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + this.XResolution + '), y:"CRS:1"(0:' + this.ZResolution + ")}, {})";
        this.WCPSQuery += '}, "' + this.imageFormat +'" )';
    }
    else //A custom query was defined so use it
    {
        //Replace $ symbols with the actual values
        this.WCPSQuery = this.replaceSymbolsInString(this.WCPSQuery);
        console.log(this.WCPSQuery);
    }
    //3: Make ServerRequest and receive data.
    var bb = {
        minLongitude: this.miny,
        maxLongitude: this.maxy,
        minLatitude:  this.minx,
        maxLatitude:  this.maxx
    };
    EarthServerGenericClient.requestWCPSImageWCSDem(this,this.URLWCPS,this.WCPSQuery,this.URLDEM,this.coverageDEM,bb,this.WCSVersion);
};

/**
 * This is a callback method as soon as the ServerRequest in createModel() has received it's data.
 * This is done automatically.
 * @param data - Received data from the ServerRequest.
 */
EarthServerGenericClient.Model_WCPSDemWCS.prototype.receiveData= function( data)
{
    if( this.checkReceivedData(data))
    {
        //Remove the placeHolder
        this.removePlaceHolder();

        var YResolution = this.YResolution || (parseFloat(data.maxHMvalue) - parseFloat(data.minHMvalue) );
        var transform = this.createTransform(data.width,YResolution,data.height,parseFloat(data.minHMvalue),data.minXvalue,data.minZvalue);
        this.root.appendChild( transform);

        //Create Terrain out of the received data
        EarthServerGenericClient.MainScene.timeLogStart("Create Terrain " + this.name);
        this.terrain = new EarthServerGenericClient.LODTerrain(transform, data, this.index, this.noData, this.demNoData);
        this.terrain.createTerrain();
        EarthServerGenericClient.MainScene.timeLogEnd("Create Terrain " + this.name);
        this.elevationUpdateBinding();

        if(this.sidePanels)
        {   this.terrain.createSidePanels(transform,1); }

        EarthServerGenericClient.MainScene.timeLogEnd("Create Model " + this.name);

        transform = null;
    }
};


/**
 * Every Scene Model creates it's own specific UI elements. This function is called automatically by the SceneManager.
 * @param element - The element where to append the specific UI elements for this model.
 */
EarthServerGenericClient.Model_WCPSDemWCS.prototype.setSpecificElement= function(element)
{
    EarthServerGenericClient.appendElevationSlider(element,this.index);
};
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Scene Model: WCS Point Cloud
 * 1 URL for the service, 1 Coverage name point cloud
 * @augments EarthServerGenericClient.AbstractSceneModel
 */
EarthServerGenericClient.Model_WCSPointCloud = function()
{
    this.setDefaults();
    this.name = "WCS Point Cloud";
    /**
     * WCS version for the query.
     * @default "2.0.0"
     * @type {String}
     */
    this.WCSVersion = "2.0.0";
    /**
     * Size of the drawn points.
     * @default 3.0
     * @type {number}
     */
    this.pointSize = 3.0;
};
EarthServerGenericClient.Model_WCSPointCloud.inheritsFrom( EarthServerGenericClient.AbstractSceneModel );

/**
 * Sets the URL for the service.
 * @param url
 */
EarthServerGenericClient.Model_WCSPointCloud.prototype.setURL=function(url){
    /**
     * URL for the WCS service.
     * @type {String}
     */
    this.URLWCS = String(url);
};
/**
 * Sets the WCS Version for the WCS Query String. Default: "2.0.0"
 * @param version - String with WCS version number.
 */
EarthServerGenericClient.Model_WCSPointCloud.prototype.setWCSVersion = function(version)
{
    this.WCSVersion = String(version);
};
/**
 * Sets the coverage name.
 * @param coveragePointCloud - Coverage name for the image data set.
 */
EarthServerGenericClient.Model_WCSPointCloud.prototype.setCoverage = function (coveragePointCloud)
{
    /**
     * Name of the point cloud coverage.
     * @type {String}
     */
    this.coveragePointCloud = String(coveragePointCloud);
};

/**
 * Sets the size of the points in the cloud.
 * @param pointSize - Size of the points in the cloud.
 */
EarthServerGenericClient.Model_WCSPointCloud.prototype.setPointSize = function (pointSize)
{
    /**
     * Size of the points in the cloud.
     * @type {String}
     */
    this.pointSize = pointSize;
};

/**
 * Creates the x3d geometry and appends it to the given root node. This is done automatically by the SceneManager.
 * @param root - X3D node to append the model.
 * @param cubeSizeX - Size of the fishtank/cube on the x-axis.
 * @param cubeSizeY - Size of the fishtank/cube on the y-axis.
 * @param cubeSizeZ - Size of the fishtank/cube on the z-axis.
 */
EarthServerGenericClient.Model_WCSPointCloud.prototype.createModel=function(root, cubeSizeX, cubeSizeY, cubeSizeZ){
    if( root === undefined)
        alert("root is not defined");

    EarthServerGenericClient.MainScene.timeLogStart("Create Model " + this.name);

    this.cubeSizeX = cubeSizeX;
    this.cubeSizeY = cubeSizeY;
    this.cubeSizeZ = cubeSizeZ;

    this.root = root;

    //Create Placeholder
    this.createPlaceHolder();

    // Check if mandatory values are set
    if( this.coveragePointCloud === undefined || this.URLWCS === undefined || this.minh === undefined || this.maxh === undefined
        || this.minx === undefined || this.miny === undefined || this.maxx === undefined || this.maxy === undefined )
    {
        alert("Not all mandatory values are set. WCSPointCloud: " + this.name );
        console.log(this);
        return;
    }
    // Make ServerRequest and receive data.
    EarthServerGenericClient.requestWCSPointCloud(this,this.URLWCS,this.WCSVersion,this.coveragePointCloud,
                    this.minx,this.maxx,this.miny,this.maxy,this.minh,this.maxh);
};

/**
 * Updates the size of points for this model.
 * @param value - Point size
 */
EarthServerGenericClient.Model_WCSPointCloud.prototype.updatePointSize = function(value)
{
    if( this.terrain )
        this.terrain.setPointSize(value);
};

/**
 * This is a callback method as soon as the ServerRequest in createModel() has received it's data.
 * This is done automatically.
 * @param data - Received data from the ServerRequest.
 */
EarthServerGenericClient.Model_WCSPointCloud.prototype.receiveData = function( data)
{
    if( this.checkReceivedData(data))
    {
        //If progressive loading is enabled this function is called multiple times.
        //The lower resolution version shall be removed and replaced with the new one.
        //So the old transformNode will be removed and a new one created.
        if(this.transformNode !== undefined )
        {   this.root.removeChild(this.transformNode); }

        //In the first receiveData call remove the placeholder.
        this.removePlaceHolder();

        var YResolution = this.YResolution || (parseFloat(data.maxHMvalue) - parseFloat(data.minHMvalue) );

        // build transform
        this.transformNode = this.createTransform(data.width,YResolution,data.height,data.minHMvalue,data.minXvalue,data.minZvalue);
        /*this.transformNode = document.createElement("transform");
        this.transformNode.setAttribute("id", "EarthServerGenericClient_modelTransform"+this.index);
        this.transformNode.setAttribute("onclick","EarthServerGenericClient.MainScene.OnClickFunction("+this.index+",event.hitPnt);");

        var scaleX = (this.cubeSizeX*this.xScale)/(data.width);
        var scaleY = (this.cubeSizeY*this.yScale)/ YResolution;
        var scaleZ = (this.cubeSizeZ*this.zScale)/(data.height);
        this.transformNode.setAttribute("scale", "" + scaleX + " " + scaleY + " " + scaleZ);

        var xoff = (this.cubeSizeX * this.xOffset) - (this.cubeSizeX/2.0) - (scaleX * data.minXvalue);
        var yoff = (this.cubeSizeY * this.yOffset) - (data.minHMvalue*scaleY) - (this.cubeSizeY/2.0);
        var zoff = (this.cubeSizeZ * this.zOffset) - (this.cubeSizeZ/2.0) - (scaleZ * data.minZvalue);
        this.transformNode.setAttribute("translation", "" + xoff+ " " + yoff  + " " + zoff);*/
        this.root.appendChild(this.transformNode);

        // create point cloud terrain
        this.terrain = new EarthServerGenericClient.PointCloudTerrain(this.transformNode,data,this.index,this.pointSize);
        this.terrain.createTerrain();
    }
};

/**
 * Every Scene Model creates it's own specific UI elements. This function is called automatically by the SceneManager.
 * @param element - The element where to append the specific UI elements for this model.
 */
EarthServerGenericClient.Model_WCSPointCloud.prototype.setSpecificElement= function(element)
{
    // change point size
    var id = "EarthServerGenericClient_SliderCell_ps_"+this.index;
    EarthServerGenericClient.appendGenericSlider(element,id,"Point Size",this.index,1,10,this.pointSize, EarthServerGenericClient.MainScene.updatePointSize);
};
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Scene Model: WMS Image with DEM from WCPS Query
 * 2 URLs for the service, 2 Coverage names for the image and dem.
 * @augments EarthServerGenericClient.AbstractSceneModel
 */
EarthServerGenericClient.Model_WMSDemWCPS = function()
{
    this.setDefaults();
    this.name = "WMS Image with DEM from WCPS Query.";

    /**
     * WMS version for the query.
     * @default "1.3"
     * @type {String}
     */
    this.WMSVersion = "1.3";
};
EarthServerGenericClient.Model_WMSDemWCPS.inheritsFrom( EarthServerGenericClient.AbstractSceneModel );
/**
 * Sets the urls for the WMS and WCPS Queries. If only one url is given it is used for both requests.
 * @param imageURL - Service URL for the WCPS Image Request
 * @param demURL - Service URL for the WCPS Dem Request
 */
EarthServerGenericClient.Model_WMSDemWCPS.prototype.setURLs=function(imageURL, demURL){
    /**
     * URL for the WCPS image service.
     * @type {String}
     */
    this.imageURL = String(imageURL);
    /**
     * URL for the WCPS Dem service.
     * @type {String}
     */
    this.demURL;
    if(demURL === undefined) // if demURL is not defined use imageURL
    {   this.demURL = String(imageURL); }
    else
    {   this.demURL  = String(demURL);  }
};
/**
 * Sets both coveragenames
 * @param coverageImage - Coverage name for the image dataset.
 * @param coverageDem   - Coverage name for the dem dataset.
 */
EarthServerGenericClient.Model_WMSDemWCPS.prototype.setCoverages = function (coverageImage, coverageDem) {
    /**
     * Name of the image coverage.
     * @type {String}
     */
    this.coverageImage = String(coverageImage);
    /**
     * Name if the dem coverage.
     * @type {String}
     */
    this.coverageDEM = String(coverageDem);
};

/**
 * Sets the WMS Version for the WMS Query String. Default: "1.3"
 * @param version - String with WMS version number.
 */
EarthServerGenericClient.Model_WMSDemWCPS.prototype.setWMSVersion = function(version)
{
    this.WMSVersion = String(version);
};

/**
 * Sets a custom query for the WCPS Dem request.
 * @param querystring - WCPS as a string.
 */
EarthServerGenericClient.Model_WMSDemWCPS.prototype.setWCPSDemQuery = function(querystring)
{
    /**
     * The custom WCPS Dem query.
     * @type {String}
     */
    this.WCPSDemQuery = String(querystring);
};


/**
 * Sets the Coordinate Reference System for the WCPS Query
 * @param value - eg. "http://www.opengis.net/def/crs/EPSG/0/27700"
 */
EarthServerGenericClient.Model_WMSDemWCPS.prototype.setWCPSCoordinateReferenceSystem = function(value)
{
    this.WCPSCRS = value;
};

/**
* Sets the Coordinate Reference System for the WMS Image.
* @param System - eg. CRS,SRS
* @param value - eg. EPSG:4326
*/
EarthServerGenericClient.Model_WMSDemWCPS.prototype.setWMSCoordinateReferenceSystem = function(System,value)
{
    this.WMSCRS = System + "=" + value;
};

/**
 * Creates the x3d geometry and appends it to the given root node. This is done automatically by the SceneManager.
 * @param root - X3D node to append the model.
 * @param cubeSizeX - Size of the fishtank/cube on the x-axis.
 * @param cubeSizeY - Size of the fishtank/cube on the y-axis.
 * @param cubeSizeZ - Size of the fishtank/cube on the z-axis.
 */
EarthServerGenericClient.Model_WMSDemWCPS.prototype.createModel=function(root, cubeSizeX, cubeSizeY, cubeSizeZ){
    if( root === undefined)
        alert("root is not defined");

    EarthServerGenericClient.MainScene.timeLogStart("Create Model " + this.name);

    this.cubeSizeX = cubeSizeX;
    this.cubeSizeY = cubeSizeY;
    this.cubeSizeZ = cubeSizeZ;

    this.root = root;

    //Create Placeholder
    this.createPlaceHolder();

    //1: Check if mandatory values are set
    if( this.coverageImage === undefined || this.coverageDEM === undefined || this.imageURL === undefined || this.demURL === undefined
        || this.minx === undefined || this.miny === undefined || this.maxx === undefined || this.maxy === undefined || this.WMSCRS === undefined || this.WCPSCRS === undefined )
    {
        alert("Not all mandatory values are set. WCPSDemWCPS: " + this.name );
        console.log(this);
        return;
    }


    if( this.WCPSDemQuery === undefined)
    {
        var currentXRes = this.XResolution;
        var currentZRes = this.ZResolution;
        this.WCPSDemQuery =  "for dtm in (" + this.coverageDEM + ") return encode (";
        this.WCPSDemQuery += 'scale(trim(dtm , {x:"' + this.WCPSCRS + '"(' + this.minx + ":" +  this.maxx + '), y:"' + this.WCPSCRS + '"(' + this.miny + ":" + this.maxy + ') }), {x:"CRS:1"(0:' + currentXRes + '), y:"CRS:1"(0:' + currentZRes + ")}, {})";
        this.WCPSDemQuery += ', "csv" )';
    }
    else //A custom query was defined so use it
    {
        //Replace $ symbols with the actual values
        this.WCPSDemQuery = this.replaceSymbolsInString(this.WCPSDemQuery);
    }

    var bb = {
        minLongitude: this.miny,
        maxLongitude: this.maxy,
        minLatitude:  this.minx,
        maxLatitude:  this.maxx
    };

    // Request
    EarthServerGenericClient.requestWMSImageWCPSDem(this,bb,this.XResolution,this.ZResolution,
        this.imageURL,this.coverageImage,this.WMSVersion,this.WMSCRS,this.imageFormat,this.demURL,this.WCPSDemQuery);
};

/**
 * This is a callback method as soon as the ServerRequest in createModel() has received it's data.
 * This is done automatically.
 * @param data - Received data from the ServerRequest.
 */
EarthServerGenericClient.Model_WMSDemWCPS.prototype.receiveData= function( data)
{
    if( this.checkReceivedData(data))
    {
        //Remove the placeHolder
        this.removePlaceHolder();

        var YResolution = this.YResolution || (parseFloat(data.maxHMvalue) - parseFloat(data.minHMvalue) );
        var transform = this.createTransform(data.width,YResolution,data.height,parseFloat(data.minHMvalue),data.minXvalue,data.minZvalue);
        this.root.appendChild( transform);

        //Create Terrain out of the received data
        EarthServerGenericClient.MainScene.timeLogStart("Create Terrain " + this.name);
        this.terrain = new EarthServerGenericClient.LODTerrain(transform, data, this.index, this.noData, this.demNoData);
        this.terrain.createTerrain();
        EarthServerGenericClient.MainScene.timeLogEnd("Create Terrain " + this.name);
        this.elevationUpdateBinding(); // notify all bindings about the terrain elevation update

        if(this.sidePanels)
        {   this.terrain.createSidePanels(transform,1); }

        EarthServerGenericClient.MainScene.timeLogEnd("Create Model " + this.name);

        transform = null;
    }
};


/**
 * Every Scene Model creates it's own specific UI elements. This function is called automatically by the SceneManager.
 * @param element - The element where to append the specific UI elements for this model.
 */
EarthServerGenericClient.Model_WMSDemWCPS.prototype.setSpecificElement= function(element)
{
    EarthServerGenericClient.appendElevationSlider(element,this.index);
};

//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Scene Model: WMS Image with DEM from WCS Query
 * 2 URLs for the service, 2 Coverage names for the image and dem.
 * @augments EarthServerGenericClient.AbstractSceneModel
 */
EarthServerGenericClient.Model_WMSDemWCS = function()
{
    this.setDefaults();
    this.name = "WMS Image with DEM from WCS Query.";
    /**
     * WCS version for the query.
     * @default "2.0.0"
     * @type {String}
     */
    this.WCSVersion = "2.0.0";
    /**
     * WMS version for the query.
     * @default "1.3"
     * @type {String}
     */
    this.WMSVersion = "1.3";
};
EarthServerGenericClient.Model_WMSDemWCS.inheritsFrom( EarthServerGenericClient.AbstractSceneModel );
/**
 * Sets the url for both the WMS and WCS Queries.
 * @param WMSurl - Service URL for the WMS Request
 * @param demurl  - Service URL for the WCS Request
 */
EarthServerGenericClient.Model_WMSDemWCS.prototype.setURLs=function(WMSurl, demurl){
    /**
     * URL for the WMS service.
     * @type {String}
     */
    this.URLWMS = String(WMSurl);
    /**
     * URL for the WCS service.
     * @type {String}
     */
    this.URLDEM  = String(demurl);
};
/**
 * Sets both coverage names
 * @param coverageImage - Coverage name for the image data set.
 * @param coverageDem   - Coverage name for the dem data set.
 */
EarthServerGenericClient.Model_WMSDemWCS.prototype.setCoverages = function (coverageImage, coverageDem) {
    /**
     * Name of the image coverage.
     * @type {String}
     */
    this.coverageImage = String(coverageImage);
    /**
     * Name if the dem coverage.
     * @type {String}
     */
    this.coverageDEM = String(coverageDem);
};
/**
 * Sets the WCS Version for the WCS Query String. Default: "2.0.0"
 * @param version - String with WCS version number.
 */
EarthServerGenericClient.Model_WMSDemWCS.prototype.setWCSVersion = function(version)
{
    this.WCSVersion = String(version);
};
/**
 * Sets the WMS Version for the WMS Query String. Default: "1.3"
 * @param version - String with WMS version number.
 */
EarthServerGenericClient.Model_WMSDemWCS.prototype.setWMSVersion = function(version)
{
    this.WMSVersion = String(version);
};
/**
 * Sets the response format for the WCS Queries.
 * @param format - Format string for the WCS Response
 */
EarthServerGenericClient.Model_WMSDemWCS.prototype.setFormat=function(WCSFormat){
    /**
     * URL for the WMS service.
     * @type {String}
     */
    this.WCSFormat = String(WCSFormat);
};
/**
 * Sets the Coordinate Reference System.
 * @param System - eg. CRS,SRS
 * @param value - eg. EPSG:4326
 */
EarthServerGenericClient.Model_WMSDemWCS.prototype.setCoordinateReferenceSystem = function(System, value)
{
    this.CRS = System + "=" + value;
};
/**
 * Sets the output CRS.
 @param outputCRS - The output CRS, e.g. 'http://www.opengis.net/def/crs/EPSG/0/4326'
 */
EarthServerGenericClient.Model_WMSDemWCS.prototype.setOutputCRS = function(value)
{
    this.outpuCRS = value;
};
/**
 * Creates the x3d geometry and appends it to the given root node. This is done automatically by the SceneManager.
 * @param root - X3D node to append the model.
 * @param cubeSizeX - Size of the fishtank/cube on the x-axis.
 * @param cubeSizeY - Size of the fishtank/cube on the y-axis.
 * @param cubeSizeZ - Size of the fishtank/cube on the z-axis.
 */
EarthServerGenericClient.Model_WMSDemWCS.prototype.createModel=function(root, cubeSizeX, cubeSizeY, cubeSizeZ){
    if( root === undefined)
        alert("root is not defined");

    EarthServerGenericClient.MainScene.timeLogStart("Create Model " + this.name);

    this.cubeSizeX = cubeSizeX;
    this.cubeSizeY = cubeSizeY;
    this.cubeSizeZ = cubeSizeZ;

    this.root = root;

    //Create Placeholder
    this.createPlaceHolder();

    //1: Check if mandatory values are set
    if( this.coverageImage === undefined || this.coverageDEM === undefined || this.URLWMS === undefined || this.URLDEM === undefined
        || this.minx === undefined || this.miny === undefined || this.maxx === undefined || this.maxy === undefined || this.CRS === undefined
        || this.WCSFormat === undefined)
    {
        alert("Not all mandatory values are set. WMSDemWCS: " + this.name );
        console.log(this);
        return;
    }

    //2: Make ServerRequest and receive data.
    var bb = {
        minLongitude: this.miny,
        maxLongitude: this.maxy,
        minLatitude:  this.minx,
        maxLatitude:  this.maxx
    };

    EarthServerGenericClient.requestWMSImageWCSDem(this,bb,this.XResolution,this.ZResolution,
                                                this.URLWMS,this.coverageImage,this.WMSVersion,this.CRS,this.imageFormat,
                                                this.URLDEM,this.coverageDEM,this.WCSVersion,this.WCSFormat);
};

/**
 * This is a callback method as soon as the ServerRequest in createModel() has received it's data.
 * This is done automatically.
 * @param data - Received data from the ServerRequest.
 */
EarthServerGenericClient.Model_WMSDemWCS.prototype.receiveData= function( data)
{
    if( this.checkReceivedData(data))
    {
        //Remove the placeHolder
        this.removePlaceHolder();

        var YResolution = this.YResolution || (parseFloat(data.maxHMvalue) - parseFloat(data.minHMvalue) );
        var transform = this.createTransform(data.width,YResolution,data.height,parseFloat(data.minHMvalue),data.minXvalue,data.minZvalue);
        this.root.appendChild( transform);

        //Create Terrain out of the received data
        EarthServerGenericClient.MainScene.timeLogStart("Create Terrain " + this.name);
        this.terrain = new EarthServerGenericClient.LODTerrain(transform, data, this.index, this.noData, this.demNoData);
        this.terrain.createTerrain();
        EarthServerGenericClient.MainScene.timeLogEnd("Create Terrain " + this.name);
        this.elevationUpdateBinding();
        if(this.sidePanels)
        {   this.terrain.createSidePanels(this.transformNode,1);    }
        EarthServerGenericClient.MainScene.timeLogEnd("Create Model " + this.name);

        transform = null;
    }
};


/**
 * Every Scene Model creates it's own specific UI elements. This function is called automatically by the SceneManager.
 * @param element - The element where to append the specific UI elements for this model.
 */
EarthServerGenericClient.Model_WMSDemWCS.prototype.setSpecificElement= function(element)
{
    EarthServerGenericClient.appendElevationSlider(element,this.index);
};
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Scene Model: WMS Image with DEM from WCS Query
 * 2 URLs for the service, 2 Coverage names for the image and dem.
 * @augments EarthServerGenericClient.AbstractSceneModel
 */
EarthServerGenericClient.Model_WMSDemWMS = function()
{
    this.setDefaults();
    this.name = "WMS Image with DEM from WMS Query.";
    /**
     * WMS version for the query.
     * @default "1.3"
     * @type {String}
     */
    this.WMSVersion = "1.3";
};
EarthServerGenericClient.Model_WMSDemWMS.inheritsFrom( EarthServerGenericClient.AbstractSceneModel );
/**
 * Sets the timespan for the request
 * @param timespan - eg. '2013-06-05T00:00:00Z/2013-06-08T00:00:00Z'
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.setBoundingBox = function(minx, miny, maxx, maxy) {
    this.bbox = {
        minLongitude: miny,
        maxLongitude: maxy,
        minLatitude: minx,
        maxLatitude: maxx
    };
};
/**
 * Sets the url for both the WMS and WCS Queries.
 * @param WMSurl - Service URL for the WMS Request
 * @param demurl  - Service URL for the WCS Request
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.setURLs=function(WMSurl, demurl){
    /**
     * URL for the WMS service.
     * @type {String}
     */
    this.URLWMS = String(WMSurl);
    /**
     * URL for the WCS service.
     * @type {String}
     */
    this.URLDEM  = String(demurl);
};
/**
 * Sets both coverage names
 * @param coverageImage - Coverage name for the image data set.
 * @param coverageDem   - Coverage name for the dem data set.
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.setCoverages = function (coverageImage, coverageDem) {
    /**
     * Name of the image coverage.
     * @type {String}
     */
    this.coverageImage = String(coverageImage);
    /**
     * Name if the dem coverage.
     * @type {String}
     */
    this.coverageDEM = String(coverageDem);
};
/**
 * Sets the WMS Version for the WMS Query String. Default: "1.3"
 * @param version - String with WMS version number.
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.setWCSVersion = function(version)
{
    this.WCSVersion = String(version);
};
/**
 * Sets the WMS Version for the WMS Query String. Default: "1.3"
 * @param version - String with WMS version number.
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.setWMSVersion = function(version)
{
    this.WMSVersion = String(version);
};
/**
 * Sets the data type for the ajax call executing the WCS query.
 * @param type - Datatype for the ajax call (default: 'XML')
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.setWCSDataType =function(type){
    this.WCSDataType = String(type);
};
/**
 * Sets the desired MIME type for the response of the WCS Queries.
 * @param type - MIME string for the WCS Response (i.e.: 'image/x-aaigrid')
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.setWCSMimeType =function(type){
    this.WCSMimeType = String(type);
};
/**
 * Sets the Coordinate Reference System.
 * @param System - eg. CRS,SRS
 * @param value - eg. EPSG:4326
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.setCoordinateReferenceSystem = function(System, value)
{
    this.CRS = System + "=" + value;
};
/**
 * Sets the output CRS.
 @param outputCRS - The output CRS, e.g. 'http://www.opengis.net/def/crs/EPSG/0/4326'
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.setOutputCRS = function(value)
{
    this.WCSOutputCRS = value;
};
/**
 * Sets the timespan for the request
 * @param timespan - eg. '2013-06-05T00:00:00Z/2013-06-08T00:00:00Z'
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.setTimespan = function(timespan)
{
    this.timespan = timespan;
};
/**
 * Creates the x3d geometry and appends it to the given root node. This is done automatically by the SceneManager.
 * @param root - X3D node to append the model.
 * @param cubeSizeX - Size of the fishtank/cube on the x-axis.
 * @param cubeSizeY - Size of the fishtank/cube on the y-axis.
 * @param cubeSizeZ - Size of the fishtank/cube on the z-axis.
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.createModel=function(root, cubeSizeX, cubeSizeY, cubeSizeZ){
    if( root === undefined) {
        console.log("root is not defined");
    }

    EarthServerGenericClient.MainScene.timeLogStart("Create Model " + this.name);

    this.cubeSizeX = cubeSizeX;
    this.cubeSizeY = cubeSizeY;
    this.cubeSizeZ = cubeSizeZ;

    this.root = root;

    // FIXXME: this is not the right place for eventually setting the default value:
    if (!this.WCSMimeType) {
        this.WCSMimeType = 'image/x-aaigrid';
    }

    //Create Placeholder
    this.createPlaceHolder();

    //1: Check if mandatory values are set
    if( this.coverageImage === undefined || this.coverageDEM === undefined || this.URLWMS === undefined || this.URLDEM === undefined
        || this.minx === undefined || this.miny === undefined || this.maxx === undefined || this.maxy === undefined || this.CRS === undefined)
    {
        console.log(this);
        return;
    }

    //2: Make ServerRequest and receive data.
    var bb = {
        minLongitude: this.miny,
        maxLongitude: this.maxy,
        minLatitude:  this.minx,
        maxLatitude:  this.maxx
    };

    EarthServerGenericClient.requestWMSImageWCSDem(this,bb,this.XResolution,this.ZResolution,
                                                this.URLWMS,this.coverageImage,this.WMSVersion,this.CRS,this.imageFormat,
                                                this.URLDEM,this.coverageDEM,this.WCSVersion,this.WCSMimeType,this.WCSDataType, 
                                                this.WCSOutputFormat,this.WCSOutputCRS,this.timespan);
};

/**
 * This is a callback method as soon as the ServerRequest in createModel() has received it's data.
 * This is done automatically.
 * @param data - Received data from the ServerRequest.
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.receiveData= function( data)
{
    if( this.checkReceivedData(data))
    {
        //Remove the placeHolder
        this.removePlaceHolder();

        var YResolution = this.YResolution || (parseFloat(data.maxHMvalue) - parseFloat(data.minHMvalue) );
        var transform = this.createTransform(data.width,YResolution,data.height,parseFloat(data.minHMvalue),data.minXvalue,data.minZvalue);
        this.root.appendChild( transform);

        //Create Terrain out of the received data
        EarthServerGenericClient.MainScene.timeLogStart("Create Terrain " + this.name);
        this.terrain = new EarthServerGenericClient.LODTerrain(transform, data, this.index, this.noData, this.demNoData);
        this.terrain.createTerrain();
        EarthServerGenericClient.MainScene.timeLogEnd("Create Terrain " + this.name);
        this.elevationUpdateBinding();
        if(this.sidePanels)
        {   this.terrain.createSidePanels(this.transformNode,1);    }
        EarthServerGenericClient.MainScene.timeLogEnd("Create Model " + this.name);

        transform = null;
    }
};


/**
 * Every Scene Model creates it's own specific UI elements. This function is called automatically by the SceneManager.
 * @param element - The element where to append the specific UI elements for this model.
 */
EarthServerGenericClient.Model_WMSDemWMS.prototype.setSpecificElement= function(element)
{
    EarthServerGenericClient.appendElevationSlider(element,this.index);
};
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Generic Server Response Data object. All requests store the response in an instance of this object.
 * One instance can be given as parameter for different requests if all requests writes different fields.
 * Example: One WMS request for the texture and one WCS request for the heightmap.
 */
EarthServerGenericClient.ServerResponseData = function () {
    this.heightmap = null;          // Heightmap
    this.pointCloudCoordinates = null; // Point cloud coordinates
    this.noDataValue = undefined;   // The value that should be considered as NODATA.
    this.heightmapUrl = "";         // If available, you can use the link as alternative.
    this.texture = new Image();     // Texture as image object
    this.texture.crossOrigin = '';  // Enable Texture to be edited (for alpha values for example)
    this.textureUrl = "";           // If available, you can use the link as alternative.
    this.width = 0;                 // Heightmap or pointcloud width
    this.height = 0;                // Heightmap or pointcloud height

    // The information about the heightmap are used to position a module correctly in the fishtank.
    // The minimum value as offset and the difference between minimum and maximum for scaling.
    this.minHMvalue =  Number.MAX_VALUE;// Lowest value in the heightmap or pointcloud
    this.maxHMvalue = -Number.MAX_VALUE;// Highest value in the heigtmap or pointcloud
    this.averageHMvalue = 0;        // Average value of the heightmap or pointcloud
    this.minXvalue =  Number.MAX_VALUE; // Lowest coordinate value on the X-axis of a pointcloud
    this.maxXvalue = -Number.MAX_VALUE; // Highest coordinate value on the X-axis of a pointcloud
    this.minZvalue =  Number.MAX_VALUE; // Lowest coordinate value on the Z-axis of a pointcloud
    this.maxZvalue = -Number.MAX_VALUE; // Highest coordinate value on the X-axis of a pointcloud

    // Flags to customize the server response
    this.heightmapAsString = false;  // Flag if heightmap is encoded as a array of arrays(default) or as a string with csv.
    this.validateHeightMap = true;   // Flag if heightmap should be checked in validate().
    this.validateTexture   = true;   // Flag if the texture should be checked in validate().
    this.validatePointCloud = false; // Flag if the point cloud should be in validate().
    this.removeAlphaChannel = false; // Flag if the alpha channel contains e.g. height data it should be removed for the texture

    /**
     * Validates if the response full successfully: Was an image and a height map received?
     * @returns {boolean} - True if both image and heightmap are present, false if not.
     */
    this.validate = function()
    {
        //Texture
        if( this.validateTexture )
        {
            if( this.texture === undefined){    return false;   }
            if( this.texture.width <= 0 || this.texture.height <=0){    return false;   }
        }

        //Heightmap
        if( this.validateHeightMap )
        {
            if( this.heightmap === null){    return false;   }
            if( this.width === null || this.height === null){    return false;   }
            if( this.minHMvalue === Number.MAX_VALUE || this.maxHMvalue === -Number.MAX_VALUE){    return false;   }
        }

        // point cloud
        if( this.validatePointCloud )
        {
            if( this.pointCloudCoordinates === null) return false;
            if( this.width === null || this.height === null){    return false;   }
            if( this.minHMvalue === Number.MAX_VALUE || this.maxHMvalue === -Number.MAX_VALUE){    return false;   }
        }

        //Everything OK
        return true;
    };
};

/**
 * Small helper to synchronise multiple request callbacks. After all callbacks to this helper
 * are received the ResponseData object with all response data is send to the module.
 * After each request is received a progress update is send to the module.
 * @param callback - Module which requests the data.
 * @param numberToCombine - Number of callbacks that shall be received.
 * @param saveDataInArray - In most cases one responseData is used. If set true the data is stored in an array.
 */
EarthServerGenericClient.combinedCallBack = function(callback,numberToCombine,saveDataInArray)
{
    var counter = 0;
    this.name = "Combined Callback: " + callback.name;
    this.dataArray = [];
    EarthServerGenericClient.MainScene.timeLogStart("Combine: " + callback.name);

    /**
     * @ignore
     * @param data - Server response data object
     */
    this.receiveData = function(data)
    {
        counter++;

        if(saveDataInArray)
            this.dataArray.push(data);

        if( counter ==  numberToCombine)
        {
            EarthServerGenericClient.MainScene.timeLogEnd("Combine: " + callback.name);

            if(saveDataInArray)// callback with the 1 responseData or the array
                callback.receiveData(this.dataArray);
            else
                callback.receiveData(data);
        }
    };

    /**
     * @ignore
     * @returns {undefined|float} - Returns the noData value of the dem from the module.
     */
    this.getDemNoDataValue = function()
    {
        return callback.getDemNoDataValue();
    };

    /**
     * @ignore
     * @returns {undefined|float} - Returns the noData value of the dem from the module.
     */
    this.getModel = function()
    {
        return callback;
    };
};

/**
 * Requests a WMS image, stores it in the responseData and make the callback once it is loaded.
 * @param callback - Object to do the callback.
 * @param responseData - Instance of the ServerResponseData.
 * @param WMSurl - URL of the WMS service.
 * @param WMScoverID - Coverage/Layer ID.
 * @param WMSCRS - The Coordinate Reference System. (Should be like: "crs=1")
 * @param WMSImageFormat - The image format that should be returned.
 * @param BoundingBox - The bounding box of the image.
 * @param WMSVersion - WMS Version that should be used.
 * @param width - Width of the response image.
 * @param height - Height of the response image.
 */
EarthServerGenericClient.getCoverageWMS = function(callback,responseData,WMSurl,WMScoverID,WMSCRS,WMSImageFormat,BoundingBox,WMSVersion,width,height,timespan)
{
    responseData.textureUrl = WMSurl + "?service=WMS&version=" + WMSVersion +"&request=Getmap&layers=" + WMScoverID;
    responseData.textureUrl += "&" + WMSCRS + "&format=image/" + WMSImageFormat;
    responseData.textureUrl += "&bbox=" + BoundingBox.minLatitude + "," + BoundingBox.minLongitude + ","+ BoundingBox.maxLatitude + "," + BoundingBox.maxLongitude;
    responseData.textureUrl += "&width="+width+"&height="+height;
    if (timespan) {
        responseData.textureUrl += "&time="+timespan;
    }

    responseData.texture.onload = function()
    {
        callback.receiveData(responseData);
    };
    responseData.texture.onerror = function()
    {
        x3dom.debug.logInfo("Could not load Image.");
        callback.receiveData(responseData);
    };
    responseData.texture.src = responseData.textureUrl;

};

/**
 * Starts a WCPS query and stores the received image in the responseData.
 * If a dem is encoded in the alpha channel it will be extracted and also stored. Set DemInAlpha Flag in this case.
 * @param callback - Object to do the callback.
 * @param responseData - Instance of the ServerResponseData.
 * @param url - URL of the WCPS service.
 * @param query - The WCPS query.
 * @param DemInAlpha - Flag if a dem is encoded in the alpha channel.
 */
EarthServerGenericClient.getWCPSImage = function(callback,responseData,url, query, DemInAlpha)
{
    try
    {
        responseData.texture.onload = function()
        {
            EarthServerGenericClient.MainScene.timeLogEnd("WCPS: " + callback.name);
            if(DemInAlpha)
            {
                responseData.heightmapUrl = responseData.texture.src;
                var demNoData = callback.getDemNoDataValue();

                var canvas = document.createElement('canvas');
                canvas.width = responseData.texture.width;
                canvas.height = responseData.texture.height;

                var context = canvas.getContext('2d');
                context.drawImage(responseData.texture, 0, 0);

                var hm = new Array(canvas.width);
                for(var k=0; k<canvas.width; k++)
                {
                    hm[k] = new Array(canvas.height);
                }

                responseData.width = hm.length;
                responseData.height = hm[0].length;
                responseData.minXvalue = 0;
                responseData.minZvalue = 0;
                responseData.maxXvalue = hm.length;
                responseData.maxZvalue = hm[0].length;

                var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                var total = 0;
                for(var i=3; i<imageData.data.length; i+=4)
                {
                    var index = i/4;
                    hm[parseInt(index%hm.length)][parseInt(index/hm.length)] = imageData.data[i];

                    if(imageData.data[i] !== demNoData)
                    {
                        if( responseData.minHMvalue > imageData.data[i] )
                        { responseData.minHMvalue = imageData.data[i]  }
                        if( responseData.maxHMvalue < imageData.data[i] )
                        { responseData.maxHMvalue = imageData.data[i]  }
                        total = total + parseFloat(imageData.data[i]);
                    }

                }
                responseData.averageHMvalue = parseFloat(total / imageData.data.length);
                responseData.heightmap = hm;

                context = null;
                canvas = null;
            }

            callback.receiveData(responseData);
        };
        responseData.texture.onerror = function()
        {
            responseData.texture = new Image();
            responseData.texture.onload = callback.receiveData(responseData);
            responseData.texture.src="defaultTexture.png";
            console.log("ServerRequest::wcpsRequest(): Could not load Image from url " + url);
        };

        responseData.textureUrl = url + "?query=" + encodeURIComponent(query);
        EarthServerGenericClient.MainScene.timeLogStart("WCPS: " + callback.name);
        responseData.texture.src = responseData.textureUrl;
    }
    catch(error)
    {
        x3dom.debug.logInfo('ServerRequest::getWCPSImage(): ' + error);
        callback.receiveData(responseData);
    }
};

/**
 * This function sends the WCPS query to the specified service and tries to interpret the received data as a DEM.
 * @param callback - Object to do the callback.
 * @param responseData - Instance of the ServerResponseData.
 * @param WCPSurl - URl of the WCPS service.
 * @param WCPSquery - The WCPS request query.
 */
EarthServerGenericClient.getWCPSDemCoverage = function(callback,responseData,WCPSurl,WCPSquery)
{
    EarthServerGenericClient.MainScene.timeLogStart("WCPS DEM Coverage: " + callback.name );
    var query = "query=" + encodeURIComponent(WCPSquery);

    $.ajax(
        {
            url: WCPSurl,
            type: 'GET',
            dataType: 'text',
            data: query,
            success: function(receivedData)
            {
                try{
                EarthServerGenericClient.MainScene.timeLogEnd("WCPS DEM Coverage: " + callback.name );
                var demNoData = callback.getDemNoDataValue();
                //The received data is a list of tuples: {value,value},{value,value},.....
                var tuples = receivedData.split('},');

                var sizeX = tuples.length;
                if( sizeX <=0 || isNaN(sizeX)  )
                {   throw "getWCPSDemCoverage: "+WCPSurl+": Invalid data size ("+sizeX+")"; }


                var hm = new Array(sizeX);
                for(var o=0; o<sizeX;o++)
                {   hm[o] = []; }

                for (var i = 0; i < tuples.length; i++)
                {
                    var tmp = tuples[i].substr(1);
                    var valuesList = tmp.split(",");

                    for (var k = 0; k < valuesList.length; k++)
                    {
                        tmp = parseFloat(valuesList[k]);
                        hm[i][k] = tmp;

                        if( tmp !== demNoData)
                        {
                            if (responseData.maxHMvalue < tmp)
                            {
                                responseData.maxHMvalue = parseFloat(tmp);
                            }
                            if (responseData.minHMvalue > tmp)
                            {
                                responseData.minHMvalue = parseFloat(tmp);
                            }
                        }
                    }
                }
                if(responseData.minHMvalue!=0 && responseData.maxHMvalue!=0)
                {
                    responseData.averageHMvalue = (responseData.minHMvalue+responseData.maxHMvalue)/2;
                }
                tuples = null;

                responseData.width = hm.length;
                responseData.height = hm[0].length;
                responseData.minXvalue = 0;
                responseData.minZvalue = 0;
                responseData.maxXvalue = hm.length;
                responseData.maxZvalue = hm[0].length;
                responseData.heightmap = hm;

                }
                catch(err)
                {   alert(err); }

                callback.receiveData(responseData);
            },
            error: function(xhr, ajaxOptions, thrownError)
            {
                EarthServerGenericClient.MainScene.timeLogEnd("WCPS DEM Coverage: " + callback.name );
                console.log('\t' + xhr.status +" " + ajaxOptions + " " + thrownError);
            }
        }
    );
};

/**
 * Requests a WCS point cloud and stores the coordinate string in the response data.
 * @param callback
 * @param responseData
 * @param WCSurl
 * @param WCSversion
 * @param WCScoverID
 * @param minx
 * @param maxx
 * @param miny
 * @param maxy
 * @param minh
 * @param maxh
 */
EarthServerGenericClient.getPointCloudWCS = function(callback,responseData,WCSurl,WCSversion,WCScoverID,minx,maxx,miny,maxy,minh,maxh)
{
    var request = 'service=WCS&Request=GetCoverage&version=' + WCSversion + '&CoverageId=' + WCScoverID;
    request += '&subset=Lat('+minx+','+maxx+')&subset=Long('+miny+','+maxy+')&subset=h('+minh+','+maxh+')';

    EarthServerGenericClient.MainScene.timeLogStart("WCS Coverage: " + callback.name );

    $.ajax(
        {
            url: WCSurl,
            type: 'GET',
            dataType: 'XML',
            data: request,
            success: function(receivedData)
            {

                //console.log(receivedData);

                try{
                    EarthServerGenericClient.MainScene.timeLogEnd("WCS PointCloud Coverage: " + callback.name );
                    var coords = $(receivedData).find(String("SimpleMultiPoint")).text();


                    if(coords && coords.length )
                    {
                        while( !EarthServerGenericClient.IsNumeric(coords.charAt(0) ))
                        {   coords = coords.substr(1);  }

                        var coordsArray = coords.split(" ");

                        // check all coords to set min,max,width&height values
                        for(var i=0; i+2< coordsArray.length; i+=3)
                        {
                            if( isNaN( parseFloat(coordsArray[i] ) )) continue;
                            if( isNaN( parseFloat(coordsArray[i+1] ))) continue;
                            if( isNaN( parseFloat(coordsArray[i+2] ))) continue;

                            // check min/max value on x axis
                            if( parseFloat(coordsArray[i]) < responseData.minXvalue) responseData.minXvalue = parseFloat(coordsArray[i]);
                            if( parseFloat(coordsArray[i]) > responseData.maxXvalue) responseData.maxXvalue = parseFloat(coordsArray[i]);
                            // check min/max hm value (y-axis)
                            if( parseFloat(coordsArray[i+2]) < responseData.minHMvalue) responseData.minHMvalue = parseFloat(coordsArray[i+2]);
                            if( parseFloat(coordsArray[i+2]) > responseData.maxHMvalue) responseData.maxHMvalue = parseFloat(coordsArray[i+2]);
                            // check min/max value on z axis
                            if( parseFloat(coordsArray[i+1]) < responseData.minZvalue) responseData.minZvalue = parseFloat(coordsArray[i+1]);
                            if( parseFloat(coordsArray[i+1]) > responseData.maxZvalue) responseData.maxZvalue = parseFloat(coordsArray[i+1]);
                        }

                        //switch y/z values and lower the values
                        var pointCloudCoordinatesArray = [];
                        for( i=0; i< coordsArray.length; i+=3)
                        {
                            if( isNaN( parseFloat(coordsArray[i]))  ) continue;
                            if( isNaN( parseFloat(coordsArray[i+1]) )) continue;
                            if( isNaN( parseFloat(coordsArray[i+2] ))) continue;

                            pointCloudCoordinatesArray.push( parseFloat(coordsArray[i  ]) - parseInt(responseData.minXvalue ) );
                            pointCloudCoordinatesArray.push( parseFloat(coordsArray[i+2]) - parseInt(responseData.minHMvalue) );
                            pointCloudCoordinatesArray.push( parseFloat(coordsArray[i+1]) - parseInt(responseData.minZvalue ) );
                        }

                        responseData.maxXvalue -= parseInt( responseData.minXvalue);
                        responseData.minXvalue -= parseInt( responseData.minXvalue);

                        responseData.maxZvalue -= parseInt( responseData.minZvalue);
                        responseData.minZvalue -= parseInt( responseData.minZvalue);

                        responseData.maxHMvalue -= parseInt( responseData.minHMvalue );
                        responseData.minHMvalue -= parseInt( responseData.minHMvalue );

                        responseData.width  = responseData.maxXvalue - responseData.minXvalue + 1;
                        responseData.height = responseData.maxZvalue - responseData.minZvalue + 1;
                    }
                    else
                        console.log("No coords");

                    responseData.pointCloudCoordinates = pointCloudCoordinatesArray.join(" ");
                }
                catch(err)
                {   alert(err); }

                callback.receiveData(responseData);
            },
            error: function(xhr, ajaxOptions, thrownError)
            {
                EarthServerGenericClient.MainScene.timeLogEnd("WCS PointCloud Coverage: " + callback.name );
                x3dom.debug.logInfo('\t' + xhr.status +" " + ajaxOptions + " " + thrownError);
            }
        }
    );
};

/**
 * Requests a WCS coverage and stores is the heightmap field of the responseData.
 * @param callback - Object to do the callback.
 * @param responseData - Instance of the ServerResponseData.
 * @param WCSurl - URl of the WCS service.
 * @param WCScoverID - ID of the coverage.
 * @param WCSBoundingBox - Bounding Box of the area.
 * @param WCSVersion - Version of used WCS service.
 * @param WCSMimeType - MIME type of the WCS response (i.e. 'image/x-aaigrid').
 * @param WCSDataType - The requested datatype for WCS response (equals to the 'dataType' field in a $.ajax call, i.e. 'XML', 'text', ...)
 */
EarthServerGenericClient.getCoverageWCS = function(callback,responseData,WCSurl,WCScoverID,WCSBoundingBox,WCSVersion,WCSMimeType,WCSDataType,WCSOutputFormat,ResX,ResY,WCSOutputCRS)
{
    var request = 'service=WCS&Request=GetCoverage&version=' + WCSVersion + '&CoverageId=' + WCScoverID;
    //var WCSOutputCRS = 'http://www.opengis.net/def/crs/EPSG/0/4326';
    if (typeof WCSOutputCRS !== 'undefined') {
        request += '&subsetx=x,' + WCSOutputCRS + '(' + WCSBoundingBox.minLatitude + ',' + WCSBoundingBox.maxLatitude + ')&subsety=y,' + WCSOutputCRS + '(' + WCSBoundingBox.minLongitude + ',' + WCSBoundingBox.maxLongitude + ')';
    } else {
        request += '&subsetx=x(' + WCSBoundingBox.minLatitude + ',' + WCSBoundingBox.maxLatitude + ')&subsety=y(' + WCSBoundingBox.minLongitude + ',' + WCSBoundingBox.maxLongitude + ')';
    }
    request += '&size=x(' + ResX + ')&size=y(' + ResY + ')';
    if (WCSMimeType) {
        request += '&format=' + WCSMimeType;
    }

    var datatype = 'XML'; // default value is 'XML' to not break code using previous versions of the EarthServerGenericClient
    if (WCSDataType) {
        datatype = WCSDataType;
    }

    EarthServerGenericClient.MainScene.timeLogStart("WCS Coverage: " + callback.name );

    // request = 'service=wcs&version=2.0.0&request=GetCoverage&outputCRS=http://www.opengis.net/def/crs/EPSG/0/4326&size=x(33)&size=y(33)&coverageid=ACE2&format=image/x-aaigrid&subset=x,http://www.opengis.net/def/crs/EPSG/0/4326(-22.5,-11.25)&subset=y,http://www.opengis.net/def/crs/EPSG/0/4326(33.75,45)';
    //request = 'service=wcs&version=2.0.0&request=GetCoverage&outputCRS=http://www.opengis.net/def/crs/EPSG/0/4326&size=x(500)&size=y(500)&coverageid=ACE2&format=image/x-aaigrid&subset=x,http://www.opengis.net/def/crs/EPSG/0/4326(-22.5,-11.25)&subset=y,http://www.opengis.net/def/crs/EPSG/0/4326(33.75,45)';

    $.ajax(
        {
            url: WCSurl,
            type: 'GET',
            dataType: datatype,
            data: request,
            success: function(receivedData)
            {
                try{
                EarthServerGenericClient.MainScene.timeLogEnd("WCS Coverage: " + callback.name );

                var didHandle = callback.getModel().preprocessReceivedData(receivedData, responseData, WCSMimeType);
                // Defaults to the following implementation to not break old code:
                if (!didHandle) {
                    var Grid = $(receivedData).find('GridEnvelope');
                    var low  = $(Grid).find('low').text().split(" ");
                    var high = $(Grid).find('high').text().split(" ");

                    var sizeX = high[0] - low[0] + 1;
                    var sizeY = high[1] - low[1] + 1;

                    if( sizeX <=0 || sizeY <=0 || isNaN(sizeX) || isNaN(sizeY) )
                    {   throw "getCoverageWCS: "+WCSurl+"/"+WCScoverID+": Invalid grid size ("+sizeX+","+sizeY+")"; }

                    responseData.height = sizeX;
                    responseData.width  = sizeY;

                    console.log(sizeX,sizeY);

                    var hm = new Array(sizeX);
                    for(var index=0; index<hm.length; index++)
                    {
                        hm[index] = new Array(sizeY);
                    }

                    var DataBlocks = $(receivedData).find('DataBlock');
                    DataBlocks.each(function () {
                        var tuples = $(this).find("tupleList").text().split('},');
                        for (var i = 0; i < tuples.length; i++) {
                            var tmp = tuples[i].substr(1);
                            var valuesList = tmp.split(",");

                            for (var k = 0; k < valuesList.length; k++) {
                                tmp = parseFloat(valuesList[k]);

                                hm[parseInt(k/(sizeX))][parseInt(k%(sizeX))] = tmp;

                                if (responseData.maxHMvalue < tmp)
                                {
                                    responseData.maxHMvalue = parseFloat(tmp);
                                }
                                if (responseData.minHMvalue > tmp)
                                {
                                    responseData.minHMvalue = parseFloat(tmp);
                                }
                            }
                        }
                        if(responseData.minHMvalue!=0 && responseData.maxHMvalue!=0)
                        {
                            responseData.averageHMvalue = (responseData.minHMvalue+responseData.maxHMvalue)/2;
                        }
                        tuples = null;
                    });
                    DataBlocks = null;

                    responseData.minXvalue = 0;
                    responseData.minZvalue = 0;
                    responseData.maxXvalue = sizeY;
                    responseData.maxZvalue = sizeX;
                    responseData.heightmap = hm;
                    }
                }
                catch(err)
                {   alert(err); }

                callback.receiveData(responseData);
            },
            error: function(xhr, ajaxOptions, thrownError)
            {
                EarthServerGenericClient.MainScene.timeLogEnd("WCS Coverage: " + callback.name );
                x3dom.debug.logInfo('\t' + xhr.status +" " + ajaxOptions + " " + thrownError);
            }
        }
    );
};

/**
 * Requests one image via WCSPS. It is assumed that the image has a dem encoded in the alpha channel.
 * If not the terrain is flat.
 * @param callback - Module that requests the image.
 * @param WCPSurl - URL of the WCPS service.
 * @param WCPSquery - The WCPS query.
 */
EarthServerGenericClient.requestWCPSImageAlphaDem = function(callback,WCPSurl,WCPSquery)
{
    var responseData = new EarthServerGenericClient.ServerResponseData();
    responseData.removeAlphaChannel = true; // Remove the alpha channel for the final texture
    EarthServerGenericClient.getWCPSImage(callback,responseData,WCPSurl,WCPSquery,true);
};

/**
 * Requests one image via WCSPS.
 * @param callback - Module that requests the image.
 * @param WCPSurl - URL of the WCPS service.
 * @param WCPSquery - The WCPS query.
 */
EarthServerGenericClient.requestWCPSImage = function(callback,WCPSurl,WCPSquery)
{
    var responseData = new EarthServerGenericClient.ServerResponseData();
    responseData.validateHeightMap = false; // No heightmap in this response intended so don't check it in validate()
    EarthServerGenericClient.getWCPSImage(callback,responseData,WCPSurl,WCPSquery,false);
};

/**
 * The progressive WCPS loader initiate multiple queries consecutively. As soon as one response is received the
 * next query is executed. Every response is given to the given callback.
 * Note: The WCPS loader starts with the last query in the array (LIFO).
 * @param callback - Module that requests the WCPS images.
 * @param WCPSurl - URL of the WCPS service.
 * @param WCPSqueries - Array of WCPS queries. (LIFO)
 * @param DemInAlpha - Flag if a dem is encoded in the alpha channel.
 */
EarthServerGenericClient.progressiveWCPSImageLoader = function(callback,WCPSurl,WCPSqueries,DemInAlpha)
{
    var which = WCPSqueries.length -1;
    //We need one responseData for every query in WCPSqueries
    var responseData = [];
    //For time logging.
    this.name = "Progressive WCPS Loader: " + callback.name;

    for(var i=0;i<WCPSqueries.length;i++)
    {
        responseData[i] = new EarthServerGenericClient.ServerResponseData();
        responseData[i].removeAlphaChannel = DemInAlpha; // Should the alpha channel be removed for the final texture?
    }

    /**
     * @ignore
     * @param which - index of the request to make.
     */
    this.makeRequest =  function(which)
    {
        if(which >= 0)
        {
            EarthServerGenericClient.MainScene.timeLogStart("Progressive WCPS: " + WCPSurl + "_Query_" +which);
            EarthServerGenericClient.getWCPSImage(this,responseData[which],WCPSurl,WCPSqueries[which],DemInAlpha);
        }
        else
        {   responseData = null;  }
    };
    /**
     * @ignore
     * @param data - Server response data object
     */
    this.receiveData = function(data)
    {
        EarthServerGenericClient.MainScene.timeLogEnd("Progressive WCPS: " + WCPSurl + "_Query_" +which);
        which--;
        this.makeRequest(which);
        callback.receiveData(data);
    };
    this.makeRequest(which);
};

/**
 * Requests an image via WCPS and a dem via WCS.
 * @param callback - Module requesting this data.
 * @param WCPSurl - URL of the WCPS service.
 * @param WCPSquery - WCPS Query for the image.
 * @param WCSurl - URL of the WCS service.
 * @param WCScoverID - Coverage ID for the WCS height data.
 * @param WCSBoundingBox - Bounding box of the area used in WCS.
 * @param WCSVersion - Version of the used WCS.
 */
EarthServerGenericClient.requestWCPSImageWCSDem = function(callback,WCPSurl,WCPSquery,WCSurl,WCScoverID,WCSBoundingBox,WCSVersion)
{
    var responseData = new EarthServerGenericClient.ServerResponseData();
    var combine = new EarthServerGenericClient.combinedCallBack(callback,2);

    EarthServerGenericClient.getWCPSImage(combine,responseData,WCPSurl,WCPSquery,false);
    EarthServerGenericClient.getCoverageWCS(combine,responseData,WCSurl,WCScoverID,WCSBoundingBox,WCSVersion);
};


EarthServerGenericClient.requestWCPSImageWCPSDem = function(callback,imageURL,imageQuery,demURL,demQuery)
{
    var responseData = new EarthServerGenericClient.ServerResponseData();
    var combine = new EarthServerGenericClient.combinedCallBack(callback,2);

    EarthServerGenericClient.getWCPSImage(combine,responseData,imageURL,imageQuery,false);
    EarthServerGenericClient.getWCPSDemCoverage(combine,responseData,demURL,demQuery);
};

/** 
 * Convenience function. Its only purpose is to provide a meaningful API for models. Technically
 * a Model could directly use 'startRequests'.
 */
EarthServerGenericClient.getDEMWithOverlays = function(calling_module, opts) {
    var requests = [];
    requests.push(opts.dem);
    for (var idx=0; idx<opts.imagery.length; ++idx) {
        requests.push(opts.imagery[idx]);
    }

    EarthServerGenericClient.startRequests(calling_module, requests, opts);
}

/**
 * Carries out the requests from all OGCProviders stored in the parameter array.
 * @param opts.timespan
 * @param opts.bbox
 * @param opts.resX
 * @param opts.resY
 */
EarthServerGenericClient.startRequests = function(calling_module, providers, opts) {
    var promise = new EarthServerGenericClient.combinedCallBack(calling_module, providers.length, true);

    for (var idx = 0; idx < providers.length; ++idx) {
        var provider = providers[idx];
        var responseData = new EarthServerGenericClient.ServerResponseData();
        // FIXXME: necessary for LODTerrainWithOverlays. This parameter is _not_ specified in ServerResponseData!
        responseData.layerName = provider.id;

        switch (provider.protocol) {
            case 'WMS':
                var WMSurl = provider.urls[0];
                var WMScoverID = provider.id;
                var WMSCRS = 'SRS=' + provider.crs;
                var WMSImageFormat = provider.format;
                var BoundingBox = opts.bbox;
                var WMSversion = provider.version;
                var ResX = opts.resX;
                var ResZ = opts.resZ;
                var timespan = opts.timespan;

                // FIXXME: get rid of the plethora of parameters and replace them with a single 'opts' object. It's Javascript, after all ;-)
                //   API-Suggestion:  ESGC.getCoverageWMS(promise, opts, true/false) -> true/false determines if one ServerResponseData
                //   object is created internally for all requests, or if each response gets its own ServerResponseData object.
                //   Future API-Suggestion: The functionality of generating and carrying out a request is the sole responsibility of the 
                //   'OGCProvider' class. 'startRequests' should simply iterate over the providers and let them do their jobs, e.g.:
                //   provider.startRequest(promise, opts, true/false).
                EarthServerGenericClient.getCoverageWMS(promise, responseData, WMSurl, WMScoverID, WMSCRS, WMSImageFormat, BoundingBox, WMSversion, ResX, ResZ, timespan);
                break;
            case 'WCS':
                var WCSurl = provider.urls[0];
                var WCScoverID = provider.id;
                var WCSCRS = provider.crs;
                var WCSMimeType = provider.format;
                var WCSDataType = provider.datatype;
                var WCSOutputFormat = provider.format;
                var WCSOutputCRS = provider.outputCRS;
                var BoundingBox = opts.bbox;
                var WCSVersion = provider.version;
                var ResX = opts.resX;
                var ResZ = opts.resZ;
                var timespan = opts.timespan;

                // FIXXME: get rid of the plethora of parameters and replace them with a single 'opts' object
                EarthServerGenericClient.getCoverageWCS(promise, responseData, WCSurl, WCScoverID, BoundingBox, WCSVersion, WCSMimeType, WCSDataType, WCSOutputFormat, ResX, ResZ, WCSOutputCRS);
                break;
            default:
                console.log('[EarthServerGenericClient.performRequests] protocol "' + provider.protocol + '"" not supported');
                break;
        }
    }
};

/**
 * Requests an image via WMS and a dem via WCS.
 * @param callback - Module requesting this data.
 * @param BoundingBox - Bounding box of the area, used in both WMS and WCS requests.
 * @param ResX - Width of the response image via WMS.
 * @param ResY - Height of the response image via WMS.
 * @param WMSurl - URL of the WMS service.
 * @param WMScoverID - Layer ID used in WMS.
 * @param WMSversion - Version of the WMS service.
 * @param WMSCRS - The Coordinate Reference System. (Should be like: "crs=1")
 * @param WMSImageFormat - Image format for the WMS response.
 * @param WCSurl - URL of the WCS service.
 * @param WCScoverID - Coverage ID used in WCS.
 * @param WCSVersion - Version of the WCS service.
 * @param WCSFormat - Format of the WCS response.
 */
EarthServerGenericClient.requestWMSImageWCSDem = function(callback,BoundingBox,ResX,ResY,WMSurl,WMScoverID,WMSversion,WMSCRS,WMSImageFormat,WCSurl,WCScoverID,WCSVersion,WCSMimeType,WCSDataType,WCSOutputFormat,WCSOutputCRS,timespan)
{
    var responseData = new EarthServerGenericClient.ServerResponseData();
    var combine = new EarthServerGenericClient.combinedCallBack(callback,2);

    EarthServerGenericClient.getCoverageWMS(combine,responseData,WMSurl,WMScoverID,WMSCRS,WMSImageFormat,BoundingBox,WMSversion,ResX,ResY,timespan);
    EarthServerGenericClient.getCoverageWCS(combine,responseData,WCSurl,WCScoverID,BoundingBox,WCSVersion,WCSMimeType,WCSDataType,WCSOutputFormat,ResX,ResY,WCSOutputCRS);
};

/**
 * Requests an image via WMS and a dem via WCPS.
 * @param callback - Module requesting this data.
 * @param BoundingBox - Bounding box of the area, used in both WMS and WCS requests.
 * @param ResX - Width of the response image via WMS.
 * @param ResY - Height of the response image via WMS.
 * @param WMSurl - URL of the WMS service.
 * @param WMScoverID - Layer ID used in WMS.
 * @param WMSversion - Version of the WMS service.
 * @param WMSCRS - The Coordinate Reference System. (Should be like: "crs=1")
 * @param WMSImageFormat - Image format for the WMS response.
 * @param WCPSurl - URL for the WCPS Query
 * @param WCPSquery - WCPS DEM Query
 */
EarthServerGenericClient.requestWMSImageWCPSDem = function( callback,BoundingBox,ResX,ResY,WMSurl,WMScoverID,WMSversion,WMSCRS,WMSImageFormat,WCPSurl,WCPSquery)
{
    var responseData = new EarthServerGenericClient.ServerResponseData();
    var combine = new EarthServerGenericClient.combinedCallBack(callback,2);

    EarthServerGenericClient.getCoverageWMS(combine,responseData,WMSurl,WMScoverID,WMSCRS,WMSImageFormat,BoundingBox,WMSversion,ResX,ResY);
    EarthServerGenericClient.getWCPSDemCoverage(combine,responseData,WCPSurl,WCPSquery);
};

EarthServerGenericClient.requestWCPSImages = function(callback, URLWCPS, WCPSQuery)
{
    var combine = new EarthServerGenericClient.combinedCallBack(callback,WCPSQuery.length,true);
    var responseDataArray = [];

    for(var o=0; o< WCPSQuery.length;o++)
    {
        responseDataArray.push( new EarthServerGenericClient.ServerResponseData() );
        responseDataArray[o].validateHeightMap = false; // no height map will be received
    }

    for(var i=0; i< WCPSQuery.length;i++)
    {
        EarthServerGenericClient.getWCPSImage(combine,responseDataArray[i],URLWCPS,WCPSQuery[i],false);
    }
};

/**
 * TODO:
 * @param callback
 * @param WCSurl
 * @param WCSversion
 * @param WCScoverID
 * @param minx
 * @param maxx
 * @param miny
 * @param maxy
 * @param minh
 * @param maxh
 */
EarthServerGenericClient.requestWCSPointCloud = function(callback,WCSurl,WCSversion,WCScoverID,minx,maxx,miny,maxy,minh,maxh)
{
    var data = new EarthServerGenericClient.ServerResponseData;
    data.validateHeightMap = false;
    data.validateTexture = false;
    data.validatePointCloud = true;

    EarthServerGenericClient.getPointCloudWCS(callback,data,WCSurl,WCSversion,WCScoverID,minx,maxx,miny,maxy,minh,maxh);

};
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Abstract base class for terrains.
 * @constructor
 */
EarthServerGenericClient.AbstractTerrain = function()
{
    /**
     * Stores the created appearances' names.
     * @type {Array}
     */
    var AppearanceDefined = [];

    /**
     * @ignore Empty default stub for nexFrame() function.
     */
    this.nextFrame = function()
    {};

    /**
     * Clears the list of already defined appearances.
     */
    this.clearDefinedAppearances = function()
    {
        AppearanceDefined = [];
    };

    /**
     * Stores the IDs of the materials to change the transparency.
     * @type {Array}
     */
    this.materialNodes = [];//Stores the IDs of the materials to change the transparency.

    /**
     * Deletes all saved material IDs. Use this function if you remove old material from the dom.
     * E.g. for ProgressiveTerrain.
     */
    this.clearMaterials = function()
    {
        this.materialNodes = [];
    };

    /**
     * Creates a html canvas element out of the texture and removes the alpha values.
     * @param texture - Texture to draw. Can be everything which can be rendered into a canvas.
     * @param index - Index of the model using this canvas. Used to give the canvas a unique ID.
     * @param noData - NoData sets all pixels with the RGB value that is the same NODATA to fully transparent.
     * @param removeAlphaChannel - Flag if the alpha channel of the image should be set to be fully opaque.
     *  texture No Data Value is found in the texture.
     * @returns {HTMLElement} The canvas element.
     */
    this.createCanvas = function(texture,index,noData,removeAlphaChannel)
    {
        var canvasTmp = document.createElement('canvas');
        var checkScaledData = false;

        if( texture !== undefined && texture.width > 0 && texture.height > 0)
        {
            canvasTmp.style.display = "none";
            canvasTmp.width  = texture.width;
            canvasTmp.height = texture.height;

            var context = canvasTmp.getContext('2d');
            context.drawImage(texture, 0,0, canvasTmp.width, canvasTmp.height);

            var imageData = context.getImageData(0, 0, canvasTmp.width, canvasTmp.height);

            if(noData !== undefined && noData.length >2) // nodata RGB values are set:
            {
                checkScaledData = true;
                for (var k=0;k<imageData.data.length;k+=4)
                {
                    if(imageData.data[k] === noData[0] && imageData.data[k+1] === noData[1] && imageData.data[k+2] === noData[2])
                    {   imageData.data[k+3]=0;    } // nodata value, so set transparent
                    else
                    {   imageData.data[k+3]=255;    }// other value, so set fully opaque
                }
                context.putImageData(imageData,0,0);
            }
            if( removeAlphaChannel) // nodata is not defined: set the alpha value of all pixels to fully opaque.
            {
                for (var i=0;i<imageData.data.length;i+=4)
                {
                    imageData.data[i+3]=255;
                }
                context.putImageData(imageData,0,0);
            }

            var canvasTexture = document.createElement('canvas');
            canvasTexture.style.display = "none";
            canvasTexture.setAttribute("id", "EarthServerGenericClient_Canvas"+index);
            canvasTexture.width  = Math.pow(2, Math.round(Math.log(texture.width)  / Math.log(2)));
            canvasTexture.height = Math.pow(2, Math.round(Math.log(texture.height) / Math.log(2)));

            // Check max texture size
            var maxTextureSize = x3dom.caps.MAX_TEXTURE_SIZE;
            if( canvasTexture.width  > maxTextureSize) canvasTexture.width  = maxTextureSize;
            if( canvasTexture.height > maxTextureSize) canvasTexture.height = maxTextureSize;

            var canvasContext = canvasTexture.getContext('2d');
            canvasContext.drawImage(canvasTmp,0,0,canvasTexture.width,canvasTexture.height);

            if( checkScaledData)
            {
                var scaledContext = canvasTexture.getContext('2d');
                var scaledData = scaledContext.getImageData(0, 0, canvasTexture.width, canvasTexture.height);
                for (var o=0;o<scaledData.data.length;o+=4)
                {
                    if(scaledData.data[o+3] != 0)
                        scaledData.data[o+3]=255;
                }
                scaledContext.putImageData(scaledData,0,0);
            }

        }

        return canvasTexture;
    };

    /**
     * Returns a string with the color values in RGBA of one side.
     * @param side - Which side.
     * @param width - Desired with.
     * @param height - Desired height.
     * @returns {string} - String with RGBA color values.
     */
    this.getColorSlide = function(side,width,height)
    {
        var slide = "";
        var xPos = 0;
        var yPos = 0;
        var xSize = 1;
        var ySize = 1;

        switch(side)
        {
            case 0: ySize = this.data.texture.height;
                    break;
            case 1: xSize = this.data.texture.width;
                    break;
            case 2: xSize = this.data.texture.width;
                    yPos = this.data.texture.height -1;
                    break;
            case 3: ySize = this.data.texture.height;
                    xPos = this.data.texture.width -1;
        }

        if(this.data.texture === undefined)
        {
            console.log("EarthServerGenericClient.AbstractTerrain: No texture.")
        }
        else
        {

            var newCanvas = document.createElement("canvas");
            newCanvas.style.display = "none";
            newCanvas.width  = this.data.texture.width;
            newCanvas.height = this.data.texture.height;
            var context = newCanvas.getContext('2d');
            context.drawImage(this.data.texture, 0,0, newCanvas.width, newCanvas.height);

            var data = context.getImageData(xPos,yPos,xSize,ySize);
            var length = data.data.length;

            for(var k=0; k< length; k=k+4)
            {
                slide = slide + (data.data[k]/255) + " ";
                slide = slide + (data.data[k+1]/255) + " ";
                slide = slide + (data.data[k+2]/255) + " ";
                slide = slide + (1) + " ";

                slide = slide + (data.data[k]/255) + " ";
                slide = slide + (data.data[k+1]/255) + " ";
                slide = slide + (data.data[k+2]/255) + " ";
                slide = slide + (1) + " ";
            }
        }

        return slide;
    };

    /**
     * Function to create one side panel. Normally called by the createSidePanels():
     * @param domElement - Transform node of the model.
     * @param side - Side of the panel.
     * @param width - Number of vertices of the side panel on the x axis.
     * @param height - Number of vertices of the side panel on the z axis.
     * @param xPos - Starting position of the side panel on the x axis.
     * @param yPos - Starting position of the side panel on the z axis.
     * @param spacing - Spacing of the model's shapes.
     * @param modelTrans - Model transformation on the y axis
     * @param modelScale - Models scale on the y axis
     */
    this.createOneSidePanel = function (domElement,side,width,height,xPos,yPos,spacing,modelTrans,modelScale)
    {
        var trans = document.createElement("transform");
        trans.setAttribute("scale","" + spacing + " 1 " + spacing);
        var shape = document.createElement('shape');
        var faceSet = document.createElement('IndexedFaceSet');
        faceSet.setAttribute("solid","false");

        //Color
        var color = document.createElement("colorRGBA");
        color.setAttribute("color", this.getColorSlide(side,width,height) );

        var info = {};
        info.chunkWidth = width;
        info.chunkHeight = height;
        info.xpos = xPos;
        info.ypos = yPos;

        var coords = document.createElement('Coordinate');
        var index = "0 1 3 2 -1 "; // vertex index for the first quad
        var points="";
        var bottom = ((-EarthServerGenericClient.MainScene.getCubeSizeY()/2.0) - parseFloat(modelTrans) ) / parseFloat(modelScale);
        var heightData = this.getHeightMap(info);

        // add vertices and indices for the quads
        for(var y=0; y<height;y++)
        {
            for(var x=0; x<width;x++)
            {
                points = points + (xPos+x) + " " + heightData[y][x] + " " + (yPos+y) +" ";
                points = points + (xPos+x) + " " + bottom + " " + (yPos+y) + " ";
                if(y+x!==0 && y+x< height+width -2)
                {
                    var mult = (x+y)*2;
                    index = index + (mult+1) + " " + mult + " " + (mult+2) + " " + (mult+3) + " -1 ";
                }
            }
        }

        faceSet.setAttribute("coordindex",index);
        coords.setAttribute("point", points);

        faceSet.appendChild(coords);
        faceSet.appendChild(color);
        shape.appendChild(faceSet);
        trans.appendChild(shape);
        domElement.appendChild(trans);

        trans = null;
        shape = null;
        faceSet = null;
        color = null;
        coords = null;
        index = null;
        points = null;
    };

    /**
     * Creates side panels for a models's terrain.
     * @param domElement - Transform node of the model.
     * @param spacing - The terrain's shapes spacing value.
     */
    this.createSidePanels = function(domElement,spacing)
    {
        if(this.data.texture === undefined) return;

        var modelScale = domElement.getAttribute("scale");
        modelScale = modelScale.split(" ");
        modelScale = modelScale[1];
        var modelTrans = domElement.getAttribute("translation");
        modelTrans = modelTrans.split(" ");
        modelTrans = modelTrans[1];

        this.createOneSidePanel(domElement,0,1,this.data.height,0,0,spacing,modelTrans,modelScale);
        this.createOneSidePanel(domElement,1,this.data.width,1,0,0,spacing,modelTrans,modelScale);
        this.createOneSidePanel(domElement,2,this.data.width,1,0,this.data.height-1,spacing,modelTrans,modelScale);
        this.createOneSidePanel(domElement,3,1,this.data.height,this.data.width-1,0,spacing,modelTrans,modelScale);

    };

    /**
     * Calculates the needed numbers of chunks for the terrain for a specific chunk size.
     * @param width - Width of the entire terrain.
     * @param height - Height of the entire terrain.
     * @param chunkSize - The size of one chunk.
     * @returns {} numChunksX: number, numChunksY: number, numChunks: number
     */
    this.calcNumberOfChunks = function(width,height,chunkSize)
    {
        var chunksInfo = {
            numChunksX: parseInt(width/chunkSize),
            numChunksY: parseInt(height/chunkSize),
            numChunks: 0
        };

        if(width%chunkSize!==0)
        {   chunksInfo.numChunksX++;  }


        if(height%chunkSize!==0)
        {   chunksInfo.numChunksY++;  }

        chunksInfo.numChunks = parseInt(chunksInfo.numChunksY*chunksInfo.numChunksX);
        return chunksInfo;
    };

    /**
     * This function calcs the needed information to build and place a chunk of a terrain.
     * @param index - Index of the model using the terrain. Used for creating IDs.
     * @param chunkSize - The desired size (count of values) of one chunk per axis.
     * @param chunkInfo - This parameter uses an object that will be returned by calcNumberOfChunks().
     *      It contains the information about a terrain and its chunks (e.g. number of chunks on each axis).
     * @param currentChunk - The index of the current chunk to be build.
     * @param terrainWidth - Width of the whole terrain. Used to calc texture coordinates.
     * @param terrainHeight - Height of the whole terrain. Used to calc texture coordinates.
     * @returns {}
     *      xpos: number, ypos: number, chunkWidth: number,
     *      chunkHeight: number, terrainWidth: number,
     *      terrainHeight: number, ID: number, modelIndex: number
     */
    this.createChunkInfo = function(index,chunkSize,chunkInfo,currentChunk,terrainWidth,terrainHeight)
    {
        var info = {
            xpos:parseInt(currentChunk%chunkInfo.numChunksX)*(chunkSize-1),
            ypos:parseInt(currentChunk/chunkInfo.numChunksX)*(chunkSize-1),
            chunkWidth:0,
            chunkHeight:0,
            terrainWidth: terrainWidth,
            terrainHeight: terrainHeight,
            ID: currentChunk,
            modelIndex: index
        };

        if( currentChunk%chunkInfo.numChunksX === (chunkInfo.numChunksX-1) )
        {   info.chunkWidth = terrainWidth - parseInt((chunkInfo.numChunksX-1)*(chunkSize-1));   }
        else
        {   info.chunkWidth = chunkSize;   }

        if( currentChunk >= chunkInfo.numChunks - chunkInfo.numChunksX)
        {   info.chunkHeight = terrainHeight - parseInt((chunkInfo.numChunksY-1)*(chunkSize-1)); }
        else
        {   info.chunkHeight = chunkSize  }

        return info;
    };

    /**
     * Returns a height map part from the given height map specified in the info parameter.
     * @param info - Which part of the heightmap should be returned.
     *      info.chunkHeight, info.chunkWidth, info.xpos & info.ypos
     * @returns {*}
     */
    this.getHeightMap = function(info)
    {
        try
        {
            var heightmapPart = new Array(info.chunkHeight);
            for(var i=0; i<info.chunkHeight; i++)
            {
                heightmapPart[i] = new Array(info.chunkWidth);
                for(var j=0; j<info.chunkWidth; j++)
                {
                    //If the requested position is out of bounce return the min value of the hm.
                    if(i > this.data.height || j > this.data.width || info.xpos+j < 0 || info.ypos+i <0)
                    {
                        heightmapPart[i][j] = this.data.minHMvalue;
                    }
                    else
                    {   heightmapPart[i][j] = this.data.heightmap[info.xpos+j][info.ypos+i];    }
                }
            }
            return heightmapPart;
        }
        catch(error)
        {
            console.log('AbstractTerrain::getHeightMap(): ' + error);
            return null;
        }
    };

    /**
     * Collects all material nodes of the terrain and changes each transparency attribute.
     * @param value - Transparency value between 0 (full visible) and 1 (invisible).
     */
    this.setTransparency = function(value)
    {
        for(var k=0;k<this.materialNodes.length;k++)
        {
            var mat =  document.getElementById(this.materialNodes[k]);
            if( mat !== null)
            {
                mat.setAttribute("transparency",value);
                // get parent appearance
                var app = mat.parentNode;
                if(app != null)
                {
                    if( value === 0)
                    {   app.setAttribute('sortType', 'opaque'); }
                    else
                    {   app.setAttribute('sortType', 'transparent'); }

                    // get parent shape
                    var shape = app.parentNode;
                    if( shape != null)
                    {
                        if( value == 1) // if shape is fully transparent, set rendering to false
                        {   shape.setAttribute("render","false");   }
                        else
                        {   shape.setAttribute("render","true");   }
                    }
                }
            }
            else
            {   console.log("Material with ID " +this.materialNodes[k] + " not found.");    }
        }
    };

    /**
     * Sets the number of drawn elements of the terrain.
     * The materials of the elements render flag are altered.
     * @param numberElements - Number of elements to be drawn.
     * @param focusElement - Element which has to be drawn, all other elements around this are next.
     */
    this.setDrawnElements = function(numberElements,focusElement)
    {
        var addOne =0;
        if( numberElements % 2 == 1)
        {   addOne =1; }

        var start = focusElement - parseInt(numberElements / 2)-addOne;
        var add = 0;
        if( start < 0)
        {
            add = 0 - start;
            start = 0;
        }
        var end = focusElement + parseInt(numberElements / 2) + add;
        if( end > this.materialNodes.length )
        {   end = this.materialNodes.length;  }

        for(var k=0;k<this.materialNodes.length;k++)
        {
            var mat =  document.getElementById(this.materialNodes[k]);
            if( mat !== null)
            {
                // get parent appearance
                var app = mat.parentNode;
                app = app.parentNode;
                if(k>=start && k < end)
                    app.setAttribute('render', 'true');
                else
                    app.setAttribute('render', 'false');
            }
            else
            {   console.log("Material with ID " +this.materialNodes[k] + " not found.");    }
        }
    };

    /**
     * This function handles the creation and usage of the appearances. It can be called for every shape or LOD that should use a canvasTexture.
     * It returns the amount of appearances specified. For every name only one appearance exits, every other uses it.
     * @param AppearanceName - Name of the appearance. If this name is not set in the array, it will be registered.
     *      In the case the name is already set, the existing one will be used.
     * @param AppearanceCount - Number of appearance to be created. E.g. the LODs use a bunch of three appearance nodes.
     * @param modelIndex - Index of the model using this appearance.
     * @param canvasTexture - Canvas element to be used in the appearance as texture.
     * @param transparency - Transparency of the appearance.
     * @param specular - Specular color of the appearance.
     * @param diffuse - Diffuse color of the appearance.
     * @param upright - Flag if the terrain is upright (underground data) and the texture stands upright in the cube.
     * @returns {Array} - Array of appearance nodes. If any error occurs, the function will return null.
     */
    this.getAppearances = function (AppearanceName, AppearanceCount, modelIndex, canvasTexture, transparency,specular,diffuse,upright) {
        try {
            var appearances = [AppearanceCount];
            for (var i = 0; i < AppearanceCount; i++) {
                var appearance = document.createElement('Appearance');

                if( transparency === 0)
                {   appearance.setAttribute('sortType', 'opaque'); }
                else
                {   appearance.setAttribute('sortType', 'transparent'); }

                if (AppearanceDefined[AppearanceName] != undefined)//use the already defined appearance
                {
                    appearance.setAttribute("use", AppearanceDefined[AppearanceName]);
                }
                else    //create a new appearance with the given parameter
                {
                    AppearanceDefined[AppearanceName] = AppearanceName;
                    appearance.setAttribute("id", AppearanceDefined[AppearanceName]);
                    appearance.setAttribute("def", AppearanceDefined[AppearanceName]);

                    // maybe only color
                    if( canvasTexture != undefined)
                    {
                        var texture = document.createElement('Texture');
                        texture.setAttribute('hideChildren', 'true');
                        texture.setAttribute("repeatS", 'true');
                        texture.setAttribute("repeatT", 'true');
                        texture.setAttribute("scale","false");
                        texture.appendChild(canvasTexture);

                        var imageTransform = document.createElement('TextureTransform');
                        imageTransform.setAttribute("scale", "1,-1");
                        if(upright)
                        {   imageTransform.setAttribute("rotation", "-1.57");   }
                    }

                    var material = document.createElement('material');
                    material.setAttribute("specularColor", specular);
                    material.setAttribute("diffuseColor", diffuse);
                    material.setAttribute('transparency', transparency);
                    material.setAttribute('ID',AppearanceName+"_mat");
                    //Save this material ID to change transparency during runtime
                    this.materialNodes.push( AppearanceName+"_mat");

                    appearance.appendChild(material);
                    // only add if created
                    if( canvasTexture !== undefined)
                    {
                        appearance.appendChild(imageTransform);
                        appearance.appendChild(texture);
                    }

                    texture = null;
                    imageTransform = null;
                    material = null;
                }
                appearances[i] = appearance;
            }
            return appearances;
        }
        catch (error) {
            console.log('EarthServerGenericClient::AbstractTerrain::getAppearances(): ' + error);
            return null;
        }
    };

    /**
     * Returns the Width of the Heightmap of the terrain.
     * @returns {number}
     */
    this.getHeightmapWidth = function()
    {   return this.data.width; };

    /**
     * Returns the Height of the Heightmap of the terrain.
     * @returns {number}
     */
    this.getHeightmapHeight = function()
    {   return this.data.height; };

    /**
     * Returns the elevation value of the height map at a specific point in the 3D scene.
     * All transformations and scales are considered.
     * @param xPos - Position on the x-axis.
     * @param zPos - Position on the z-axis.
     * @returns {number} - The height on the y-axis.
     */
    this.getHeightAt3DPosition = function(xPos,zPos)
    {
        var value = 0;
        var transform = document.getElementById("EarthServerGenericClient_modelTransform"+this.index);
        if(transform && this.data.heightmap)
        {
            var translations = transform.getAttribute("translation");
            translations = translations.split(" ");
            var scales = transform.getAttribute("scale");
            scales = scales.split(" ");

            var xValue = (xPos - translations[0]) / scales[0];
            var zValue = (zPos - translations[2]) / scales[2];

            value = parseFloat( this.data.heightmap[ parseInt(xValue) ][ parseInt(zValue) ] * scales[1] ) + parseFloat(translations[1]);
        }
        else
        {   console.log("AbstractTerrain::getHeightAt3DPosition: Can't find model transform for index " + this.index); }

        return value;
    };

    /**
     * Returns the dem value of the height map at a specific point in the 3D scene.
     * @param xPos - Position on the x-axis.
     * @param zPos - Position on the z-axis.
     * @returns {number} - The height of the dem.
     */
    this.getDemValueAt3DPosition = function(xPos,zPos)
    {
        var value = 0;
        var transform = document.getElementById("EarthServerGenericClient_modelTransform"+this.index);
        if(transform && this.data.heightmap)
        {
            var translations = transform.getAttribute("translation");
            translations = translations.split(" ");
            var scales = transform.getAttribute("scale");
            scales = scales.split(" ");

            var xValue = (xPos - translations[0]) / scales[0];
            var zValue = (zPos - translations[2]) / scales[2];

            value = parseFloat( this.data.heightmap[ parseInt(xValue) ][ parseInt(zValue) ] );
        }
        else
        {   console.log("AbstractTerrain::getDemValueAt3DPosition: Can't find model transform for index " + this.index); }

        return value;
    };
};





/**
 * @class This terrain should receive multiple insertLevel calls. It removes the old version
 * and replace it with the new data. It can be used for progressive loading.
 * Example: WCPSDemAlpha with progressive loading using the progressiveWCPSImageLoader.
 * @augments EarthServerGenericClient.AbstractTerrain
 * @param index - Index of the model using this terrain.
 * @constructor
 */
EarthServerGenericClient.ProgressiveTerrain = function(index)
{
    this.index = index;

    /**
     * General information about the amount of chunks needed to build the terrain.
     * @type {Object}
     */
    var chunkInfo;
    /**
     * Size of one chunk. Chunks at the borders can be smaller.
     * 256*256 (2^16) is the max size because of only 16 bit indices.
     * @type {number}
     */
    var chunkSize = 121;
    /**
     * The canvas that holds the received image.
     * @type {HTMLElement}
     */
    this.canvasTexture;
    /**
     * Counter of the inserted levels.
     * @type {number}
     */
    var currentData = 0;

    /**
     * Counter for the insertion of chunks.
     * @type {number}
     */
    var currentChunk =0;

    /**
     * Insert one data level into the scene. The old elevation grid will be removed and one new build.
     * @param root - Dom Element to append the terrain to.
     * @param data - Received Data of the Server request.
     * @param noDataValue - Array with the RGB values to be considered as no data available and shall be drawn transparent.
     * @param noDemValue - The single value in the DEM that should be considered as NODATA
     */
    this.insertLevel = function(root,data,noDataValue,noDemValue)
    {
        this.data = data;
        this.root = root;
        this.noData = noDataValue;
        this.noDemValue = noDemValue;
        this.canvasTexture = this.createCanvas(data.texture,index,noDataValue,data.removeAlphaChannel);
        chunkInfo     = this.calcNumberOfChunks(data.width,data.height,chunkSize);

        //Remove old Materials of the deleted children
        this.clearMaterials();

        for(currentChunk=0; currentChunk< chunkInfo.numChunks; currentChunk++)
        {
            EarthServerGenericClient.MainScene.enterCallbackForNextFrame( this.index );
        }
        currentChunk =0;
        currentData++;
        //chunkInfo = null;

        EarthServerGenericClient.MainScene.reportProgress(index);
    };

    /**
     * The Scene Manager calls this function after a few frames since the last insertion of a chunk.
     */
    this.nextFrame = function()
    {
        try
        {
            //Build all necessary information and values to create a chunk
            var info = this.createChunkInfo(this.index,chunkSize,chunkInfo,currentChunk,this.data.width,this.data.height);
            var hm = this.getHeightMap(info);
            var appearance = this.getAppearances("TerrainApp_"+this.index+"_"+currentData,1,
                this.index,this.canvasTexture,this.data.transparency,this.data.specularColor,this.data.diffuseColor);

            var transform = document.createElement('Transform');
            transform.setAttribute("translation", info.xpos + " 0 " + info.ypos);
            transform.setAttribute("scale", "1.0 1.0 1.0");

            if( this.noData !== undefined || this.noDemValue != undefined)
            {   new GapGrid(transform,info, hm, appearance,this.noDemValue); }
            else
            {   new ElevationGrid(transform,info, hm, appearance); }

            this.root.appendChild(transform);

            currentChunk++;
            //Delete vars avoid circular references
            info = null;
            hm = null;
            appearance = null;
            transform = null;
        }
        catch(error)
        {
            alert('Terrain::CreateNewChunk(): ' + error);
        }
    };
};
EarthServerGenericClient.ProgressiveTerrain.inheritsFrom( EarthServerGenericClient.AbstractTerrain);


/**
 * @class This terrain builds up a LOD with 3 levels of the received data.
 * @param root - Dom Element to append the terrain to.
 * @param data - Received Data of the Server request.
 * @param index - Index of the model that uses this terrain.
 * @param noDataValue - Array with the RGB values to be considered as no data available and shall be drawn transparent.
 * @param noDemValue - The single value in the DEM that should be considered as NODATA
 * @augments EarthServerGenericClient.AbstractTerrain
 * @constructor
 */
EarthServerGenericClient.LODTerrain = function(root, data,index,noDataValue,noDemValue)
{
    this.materialNodes = [];//Stores the IDs of the materials to change the transparency.
    this.data = data;
    this.index = index;
    this.noData = noDataValue;
    this.noDemValue = noDemValue;

    /**
     * Distance to change between full and 1/2 resolution.
     * @type {number}
     */
    var lodRange1       = 5000;
    /**
     * Distance to change between 1/2 and 1/4 resolution.
     * @type {number}
     */
    var lodRange2       = 17000;

    /**
     * The canvas that holds the received image.
     * @type {HTMLElement}
     */
    this.canvasTexture   = this.createCanvas( data.texture,index,noDataValue,data.removeAlphaChannel);

    /**
     * Size of one chunk. Chunks at the borders can be smaller.
     * We want to build 3 chunks for the LOD with different resolution but the same size on the screen.
     * With 121 values the length of the most detailed chunk is 120.
     * The second chunk has 61 values and the length of 60. With a scale of 2 it's back to the size of 120.
     * The third chunk has 31 values and the length if 30. With a scale of 4 it's also back to the size 120.
     * @type {number}
     */
    var chunkSize = 121;
    /**
     * General information about the number of chunks needed to build the terrain.
     * @type {number}
     */
    var chunkInfo       = this.calcNumberOfChunks(data.width,data.height,chunkSize);

    /**
     * Counter for the insertion of chunks.
     * @type {number}
     */
    var currentChunk    = 0;

    /**
     * Builds the terrain and appends it into the scene.
     */
    this.createTerrain= function()
    {
        for(currentChunk=0; currentChunk< chunkInfo.numChunks;currentChunk++)
        {
            EarthServerGenericClient.MainScene.enterCallbackForNextFrame( this.index );
        }
        currentChunk=0;
        //chunkInfo = null;

        EarthServerGenericClient.MainScene.reportProgress(index);
    };

    /**
     * The Scene Manager calls this function after a few frames since the last insertion of a chunk.
     */
    this.nextFrame = function()
    {
        try
        {
            //Build all necessary information and values to create a chunk
            var info = this.createChunkInfo(this.index,chunkSize,chunkInfo,currentChunk,data.width,data.height);
            var hm = this.getHeightMap(info);
            var appearance = this.getAppearances("TerrainApp_"+index,3,index,this.canvasTexture,
                data.transparency,this.data.specularColor,this.data.diffuseColor);

            var transform = document.createElement('Transform');
            transform.setAttribute("translation", info.xpos + " 0 " + info.ypos);
            transform.setAttribute("scale", "1.0 1.0 1.0");

            var lodNode = document.createElement('LOD');
            lodNode.setAttribute("Range", lodRange1 + ',' + lodRange2);
            lodNode.setAttribute("id", 'lod' + info.ID);

            if( this.noData !== undefined || this.noDemValue != undefined)
            {   new GapGrid(lodNode,info, hm, appearance,this.noDemValue); }
            else
            {   new ElevationGrid(lodNode,info, hm, appearance);  }

            transform.appendChild(lodNode);
            root.appendChild(transform);

            currentChunk++;
            //Delete vars avoid circular references
            info = null;
            hm = null;
            appearance = null;
            transform = null;
            lodNode = null;
        }
        catch(error)
        {
            alert('Terrain::CreateNewChunk(): ' + error);
        }
    };
};
EarthServerGenericClient.LODTerrain.inheritsFrom( EarthServerGenericClient.AbstractTerrain);

/**
 * @class This terrain builds a plane with sharad data.
 * @param root - Dom Element to append the terrain to.
 * @param data - Received Data of the Server request.
 * @param index - Index of the model that uses this terrain.
 * @param noData - Array with RGB value to be considered NODATA and shall be transparent.
 * @param coordinates - Coordinates of the single data points.
 * @param area - Area of interest in which the sharad data points are inserted.
 * @augments EarthServerGenericClient.AbstractTerrain
 * @constructor
 */
EarthServerGenericClient.SharadTerrain = function(root,data,index,noData,coordinates,area)
{
    this.materialNodes = [];//Stores the IDs of the materials to change the transparency.
    this.data = data;
    this.index = index;

    /**
     * The canvas that holds the received image.
     * @type {HTMLElement}
     */
   this.canvasTexture   = this.createCanvas( data.texture,index,noData,data.removeAlphaChannel);

    /**
     * Builds the terrain and appends it into the scene.
     */
    this.createTerrain = function()
    {
        var appearance = this.getAppearances("TerrainApp_"+this.index,1,this.index,this.canvasTexture,
            data.transparency,this.data.specularColor,this.data.diffuseColor,true);
        var shape = document.createElement("shape");

        var indexedFaceSet = document.createElement('IndexedFaceSet');
        indexedFaceSet.setAttribute("colorPerVertex", "false");

        indexedFaceSet.setAttribute("solid","false");
        var coords = document.createElement('Coordinate');
        var points= "";
        var index = "";

        // No coordinates specified. Create simple plane
        if(coordinates === undefined || area.minx === undefined || area.miny === undefined || area.maxx === undefined || area.maxy === undefined)
        {
            var sizeX = this.canvasTexture.width;
            var sizeZ = this.canvasTexture.height;

            index = "0 1 2 3 -1";
            var p = {};
            p[0] = "0 0 0 ";
            p[1] = "0 0 "+ sizeZ + " ";
            p[2] = ""+ sizeX    + " 0 " + sizeZ + " ";
            p[3] = ""+ sizeX    + " 0 0";

            for(var i=0; i<4;i++)
            {   points = points+p[i];   }
        }
        else // Coordinates are specified. Build one face for every data point
        {
            // Set first quad index
            index = "0 1 3 2 -1 ";
            var height = Math.pow(2, Math.round(Math.log(data.texture.height)/Math.log(2)));
            if( height > x3dom.caps.MAX_TEXTURE_SIZE) height = x3dom.caps.MAX_TEXTURE_SIZE;

            // add vertices and indices for the quads
            for(var k=0; k<coordinates.length;k++)
            {
                // Get geo position of the data point
                var x = coordinates[k][0];
                var y = coordinates[k][1];
                // Transform them into cube coordinates
                var pos   = EarthServerGenericClient.MainScene.getCubePositionForPoint(this.index,x,y,area);


                if(pos.valid)
                {
                    // Add position to points
                    points = points + (pos.x) + " " + (pos.y+height) + " " + (pos.z) +" ";
                    points = points + (pos.x) + " " + (pos.y) + " " + (pos.z) + " ";
                    if(k!==0 && k<coordinates.length-1)
                    {
                        var mult = k*2;
                        index = index + (mult+1) + " " + mult + " " + (mult+2) + " " + (mult+3) + " -1 ";
                    }
                }
            }
        }

        coords.setAttribute("point", points);
        indexedFaceSet.setAttribute("coordindex",index);
        indexedFaceSet.appendChild(coords);
        shape.appendChild(appearance[0]);
        shape.appendChild(indexedFaceSet);

        root.appendChild(shape);

        shape = null;
        indexedFaceSet = null;
        appearance = null;
        coords = null;

        EarthServerGenericClient.MainScene.reportProgress(this.index);
    };


};
EarthServerGenericClient.SharadTerrain.inheritsFrom( EarthServerGenericClient.AbstractTerrain);

/**
 * Terrain to display multiple layers.
 * @param root - Dom Element to append the terrain to.
 * @param dataArray - Received Data array of the Server requests.
 * @param index - Index of the model that uses this terrain.
 * @param noDataValue - No Data Value
 * @constructor
 */
EarthServerGenericClient.VolumeTerrain = function(root,dataArray,index,noDataValue)
{
    this.materialNodes = [];//Stores the IDs of the materials to change the transparency.
    this.data = dataArray;
    this.index = index;
    this.noData = noDataValue;
    this.appearances = [];  // appearances of the layers
    this.canvasTextures = []; // canvas textures of the layers
    this.focus = 0;//parseInt( dataArray.length / 2 ) +1;

    //create canvas textures and appearances
    for(var i=0; i<dataArray.length;i++)
    {
        this.canvasTextures.push( this.createCanvas( dataArray[i].texture,index,noDataValue,dataArray[i].removeAlphaChannel) );
        this.appearances.push( this.getAppearances("TerrainApp_"+this.index+i,1,this.index,this.canvasTextures[i],
            dataArray[i].transparency,dataArray[i].specularColor,dataArray[i].diffuseColor) );
    }

    // create planes with textures
    for(i=0; i<dataArray.length;i++)
    {
        var shape,transform,grid, coordsNode;

        transform = document.createElement("transform");
        transform.setAttribute("translation","0 "+ i +" 0");

        shape = document.createElement('Shape');
        shape.setAttribute("id",this.index+"_shape_"+i+"_"+0);

        coordsNode = document.createElement('Coordinate');
        coordsNode.setAttribute("point", "0 0 0 1 0 0 1 0 1 0 0 1");

        grid = document.createElement('IndexedFaceSet');
        grid.setAttribute("solid", "false");
        grid.setAttribute("colorPerVertex", "false");

        grid.setAttribute("coordIndex", "0 1 2 3 -1");
        grid.appendChild( coordsNode );

        shape.appendChild(this.appearances[i][0]);
        shape.appendChild(grid);
        transform.appendChild(shape);

        root.appendChild(transform);

        // set vars null
        shape = null;
        grid = null;
        transform = null;
        coordsNode = null;

        EarthServerGenericClient.MainScene.reportProgress(this.index);
    }

    this.updateMaxShownElements = function(value)
    {
        this.setDrawnElements(value,this.focus);
    };
};
EarthServerGenericClient.VolumeTerrain.inheritsFrom( EarthServerGenericClient.AbstractTerrain);

/**
 * Terrain to display multiple layers.
 * @param root - Dom Element to append the terrain to.
 * @param data - Received Data of the Server request.
 * @param index - Index of the model that uses this terrain.
 * @param pointSize - Size of the points.
 * @constructor
 */
EarthServerGenericClient.PointCloudTerrain = function(root,data,index,pointSize)
{
    this.materialNodes = [];//Stores the IDs of the materials to change the transparency.
    this.appearance = null;  // appearance
    this.data = data;
    this.index = index;
    this.pointSize = parseFloat(pointSize);
    this.transparencyFieldID = "EarthServerGenericClient_model_"+index+"_transparencyField";
    this.pointSizeFieldID    = "EarthServerGenericClient_model_"+index+"_pointSizeField";

    this.createTerrain = function()
    {
        // create material
        this.appearance = document.createElement("Appearance");

        // create shape,PointSet, etc.
        var shape = document.createElement("Shape");
        var pointSet = document.createElement("PointSet");
        pointSet.setAttribute("solid","false");
        var coords = document.createElement("coordinate");
        coords.setAttribute("point", data.pointCloudCoordinates);

        pointSet.appendChild(coords);
        this.appendShader( this.appearance);
        shape.appendChild(this.appearance);
        shape.appendChild(pointSet);
        root.appendChild(shape);

        coords = null;
        pointSet = null;
        shape = null;
        this.appearance = null;

        EarthServerGenericClient.MainScene.reportProgress(index);
    };

    this.appendShader = function(domElement)
    {
        var cShader = document.createElement("composedShader");
        var field1  = document.createElement("field");
        field1.setAttribute("name","matCol");
        field1.setAttribute("type","SFVec3f");
        field1.setAttribute("value",data.diffuseColor);
        cShader.appendChild(field1);
        var field2  = document.createElement("field");
        field2.setAttribute("id", this.transparencyFieldID);
        field2.setAttribute("name","transparency");
        field2.setAttribute("type","SFFloat");
        field2.setAttribute("value",String(1.0 - data.transparency) );
        cShader.appendChild(field2);
        var field3  = document.createElement("field");
        field3.setAttribute("id", this.pointSizeFieldID);
        field3.setAttribute("name","pointSize");
        field3.setAttribute("type","SFFloat");
        field3.setAttribute("value",String(this.pointSize.toFixed(2)) );
        cShader.appendChild(field3);

        var vertexCode = "attribute vec3 position; \n";
        vertexCode += "uniform mat4 modelViewProjectionMatrix; \n";
        vertexCode += "uniform mat4 projectionMatrix; \n";
        vertexCode += "varying vec3 fPosition; \n";
        vertexCode += "varying vec3 fNormal; \n";
        vertexCode += "uniform float pointSize; \n";
        vertexCode += "void main() { \n";
        vertexCode += "fPosition = position; \n";
        vertexCode += "gl_Position = modelViewProjectionMatrix * vec4(position, 1.0); \n";
        vertexCode += "gl_PointSize = pointSize; } \n";

        /*var vertexCode = "precision highp float; \n";
        vertexCode += "attribute vec3 position; \n";
        vertexCode += "attribute vec3 normal; \n";
        vertexCode += "uniform mat4 modelViewMatrix; \n";
        vertexCode += "uniform mat4 projectionMatrix; \n";
        vertexCode += "varying vec3 fPosition; \n";
        vertexCode += "void main() \n";
        vertexCode += "{ \n";
        vertexCode += "vec4 pos = modelViewMatrix * vec4(position, 1.0); \n";
        vertexCode += "gl_PointSize = " + pointSize.toFixed(2) +"; \n";
        vertexCode += "fPosition = pos; \n";
        vertexCode += "gl_Position = projectionMatrix * pos;} \n";*/

        var shaderPartVertex = document.createElement("shaderPart");
        shaderPartVertex.setAttribute("type","VERTEX");
        shaderPartVertex.innerHTML = vertexCode;
        cShader.appendChild(shaderPartVertex);

        var fragmentCode = "#ifdef GL_FRAGMENT_PRECISION_HIGH \n";
        fragmentCode += "precision highp float; \n";
        fragmentCode += "#else \n";
        fragmentCode += "precision mediump float; \n";
        fragmentCode += "#endif \n";
        fragmentCode += "uniform vec3 matCol; \n";
        fragmentCode += "uniform float transparency; \n";
        fragmentCode += "void main() { \n";
        fragmentCode += "gl_FragColor = vec4(matCol, transparency); } \n";

        /*var fragmentCode = "#ifdef GL_FRAGMENT_PRECISION_HIGH \n";
        fragmentCode += "precision highp float; \n";
        fragmentCode += "#else \n";
        fragmentCode += "precision mediump float; \n";
        fragmentCode += "#endif \n";
        fragmentCode += "uniform vec2 resolution; \n";
        fragmentCode += "varying vec3 fPosition; \n";
        fragmentCode += "void main() { \n";
        fragmentCode += "float k = (fPosition.z) / (5.0); \n";
        fragmentCode += "vec2 ss = vec2(gl_FragCoord.x / resolution.x, gl_FragCoord.y/resolution.y); \n";
        fragmentCode += "gl_FragColor = vec4(ss, k, 1.0); \n";
        //fragmentCode += "if (length(ss - vec2(0.5)) > 10.55) \n";
        //agmentCode += "discard; \n";
        fragmentCode += "} \n";*/


        var shaderPartFragment = document.createElement("shaderPart");
        shaderPartFragment.setAttribute("type","FRAGMENT");
        shaderPartFragment.innerHTML = fragmentCode;
        cShader.appendChild(shaderPartFragment);

        domElement.appendChild( cShader );

        cShader = null;
        field1 = null;
        shaderPartVertex = null;
        shaderPartFragment = null;
    };

    /**
     * Overwrites function from base terrain class. Sets the transparency in the shader.
     * @param value - Transparency value between 0 (full visible) and 1 (invisible).
     */
    this.setTransparency = function(value)
    {
        var transparencyField = document.getElementById( this.transparencyFieldID);

        if( transparencyField )
            transparencyField.setAttribute("value", String(1.0-value) );
        else
            console.log("EarthServerGenericClient.PointCloudTerrain: Can't find transparency field.")
    };

    /**
     * Sets the size of the drawn points.
     * @param value - Size if the points.
     */
    this.setPointSize = function(value)
    {
        var pointSizeField = document.getElementById( this.pointSizeFieldID );

        if( pointSizeField)
            pointSizeField.setAttribute("value", String(value));
        else
            console.log("EarthServerGenericClient.PointCloudTerrain: Can't find point size field.")
    }
};
EarthServerGenericClient.PointCloudTerrain.inheritsFrom( EarthServerGenericClient.AbstractTerrain);
//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * Creates the basic UI
 * @param domElementID - Dom element to append the UI to.
 */
EarthServerGenericClient.createBasicUI = function(domElementID)
{
    var UI_DIV = document.getElementById(domElementID);
    if( !UI_DIV )
    {
        alert("Can't find DomElement for UI with ID " +domElementID);
        return;
    }

    //Create Divs for all scene models
    for(var i=0; i<EarthServerGenericClient.MainScene.getModelCount();i++)
    {
        var name = document.createElement("h3");
        name.innerHTML = EarthServerGenericClient.MainScene.getModelName(i);
        var div = document.createElement("div");
        //Set IDs
        name.setAttribute("id","EarthServerGenericClient_ModelHeader_"+i);
        div.setAttribute("id","EarthServerGenericClient_ModelDiv_"+i);

        UI_DIV.appendChild(name);
        UI_DIV.appendChild(div);

        EarthServerGenericClient.appendXYZSlider(div,"Model"+i+"X","X Translation",i,0,
            -EarthServerGenericClient.MainScene.getCubeSizeX(),EarthServerGenericClient.MainScene.getCubeSizeX(),
            EarthServerGenericClient.MainScene.getModelOffsetX(i) * EarthServerGenericClient.MainScene.getCubeSizeX(),
            EarthServerGenericClient.MainScene.updateOffset);

        /*
        Note about the sliders: The cube is using X and Z axis is base and Y as height.
        While this is standard in computer graphics it can confuse users.
        Because of this the labels on Y and Z are switched.
         */

        EarthServerGenericClient.appendXYZSlider(div,"Model"+i+"Z","Y Translation",i,2,
            -EarthServerGenericClient.MainScene.getCubeSizeZ(),EarthServerGenericClient.MainScene.getCubeSizeZ(),
            EarthServerGenericClient.MainScene.getModelOffsetZ(i) * EarthServerGenericClient.MainScene.getCubeSizeZ(),
            EarthServerGenericClient.MainScene.updateOffset);

        EarthServerGenericClient.appendXYZSlider(div,"Model"+i+"Y","Z Translation",i,1,
            -EarthServerGenericClient.MainScene.getCubeSizeY(),EarthServerGenericClient.MainScene.getCubeSizeY(),
            EarthServerGenericClient.MainScene.getModelOffsetY(i) * EarthServerGenericClient.MainScene.getCubeSizeY(),
            EarthServerGenericClient.MainScene.updateOffset);

        EarthServerGenericClient.appendAlphaSlider(div,i);
        EarthServerGenericClient.MainScene.setSpecificElement(i,div);

        div=null;
    }

    //Create Div for the Cameras
    var Cam = document.createElement("h3");
    Cam.innerHTML = "Cameras";
    var cdiv = document.createElement("div");
    var cp   = document.createElement("p");

    for(i=0; i< EarthServerGenericClient.MainScene.getCameraDefCount();i++)
    {
        var button = document.createElement('button');
        var cameraDef = EarthServerGenericClient.MainScene.getCameraDef(i);
        cameraDef = cameraDef.split(":");
        button.setAttribute("onclick", "EarthServerGenericClient.MainScene.setView('"+cameraDef[1]+"');return false;");
        button.innerHTML = cameraDef[0];

        cp.appendChild(button);
        button = null;
    }
    cdiv.appendChild(cp);
    UI_DIV.appendChild(Cam);
    UI_DIV.appendChild(cdiv);

    cdiv=null;
    cp=null;

    //Create Div Reset
    var reset = document.createElement("h3");
    reset.innerHTML = "Reset";
    var rdiv = document.createElement("div");
    var rp   = document.createElement("p");

    var rbutton = document.createElement('button');
    rbutton.setAttribute("onclick", "EarthServerGenericClient.MainScene.resetScene();return false;");
    rbutton.innerHTML = "RESET";

   rp.appendChild(rbutton);
   rbutton = null;

    rdiv.appendChild(rp);
    UI_DIV.appendChild(reset);
    UI_DIV.appendChild(rdiv);

    rdiv=null;
    rp=null;

    //Create Divs for a Light sources
    for(i=0; i<EarthServerGenericClient.MainScene.getLightCount();i++)
    {
        var lightHeader = document.createElement("h3");
        lightHeader.innerHTML = "Light " + i;
        var lightDiv = document.createElement("div");

        UI_DIV.appendChild(lightHeader);
        UI_DIV.appendChild(lightDiv);

        /*
         Note about the sliders: The cube is using X and Z axis is base and Y as height.
         While this is standard in computer graphics it can confuse users.
         Because of this the labels on Y and Z are switched.
         */

        EarthServerGenericClient.appendXYZSlider(lightDiv,"Light"+i+"X","X Translation",i,0,
            -EarthServerGenericClient.MainScene.getCubeSizeX(),EarthServerGenericClient.MainScene.getCubeSizeX(),0,
            EarthServerGenericClient.MainScene.updateLightPosition);

        EarthServerGenericClient.appendXYZSlider(lightDiv,"Light"+i+"Z","Y Translation",i,2,
            -EarthServerGenericClient.MainScene.getCubeSizeZ(),EarthServerGenericClient.MainScene.getCubeSizeZ(),0,
            EarthServerGenericClient.MainScene.updateLightPosition);

        EarthServerGenericClient.appendXYZSlider(lightDiv,"Light"+i+"Y","Z Translation",i,1,
            -EarthServerGenericClient.MainScene.getCubeSizeY(),EarthServerGenericClient.MainScene.getCubeSizeY(),0,
            EarthServerGenericClient.MainScene.updateLightPosition);

        EarthServerGenericClient.appendGenericSlider(lightDiv,"Light"+i+"R","Radius",i,0,5000,500,
            EarthServerGenericClient.MainScene.updateLightRadius);

        EarthServerGenericClient.appendGenericSlider(lightDiv,"Light"+i+"I","Intensity",i,0,5,1,
            EarthServerGenericClient.MainScene.updateLightIntensity);

        lightDiv=null;
        lightHeader=null;
    }

    // Create Div for the Annotations
    if( EarthServerGenericClient.MainScene.getAnnotationLayerCount() )
    {
        var Anno = document.createElement("h3");
        Anno.innerHTML = "Annotations";
        var adiv = document.createElement("div");

        for(i=0; i< EarthServerGenericClient.MainScene.getAnnotationLayerCount();i++)
        {
            var ap   = document.createElement("p");

            var ALname = EarthServerGenericClient.MainScene.getAnnotationLayerName(i);
            ap.innerHTML= ALname + ": ";
            var checkbox = document.createElement("input");
            checkbox.setAttribute("type","checkbox");
            checkbox.setAttribute("checked","checked");
            checkbox.setAttribute("onchange","EarthServerGenericClient.MainScene.drawAnnotationLayer('"+ALname+"',this.checked)");
            ap.appendChild(checkbox);
            //Build list with annotations in this layer
            var list = document.createElement("ul");
            var annotationTexts = EarthServerGenericClient.MainScene.getAnnotationLayerTexts(ALname);
            for(var k=0; k<annotationTexts.length;k++)
            {
                var entry = document.createElement("li");
                entry.innerHTML = annotationTexts[k];
                list.appendChild(entry);
                entry = null;
            }

            ap.appendChild(list);
            adiv.appendChild(ap);
            ap = null;
            checkbox = null;
            list = null;
        }

        UI_DIV.appendChild(Anno);
        UI_DIV.appendChild(adiv);

        adiv=null;
        ap=null;
    }
    $( "#"+domElementID ).accordion({
        heightStyle: "content",
        collapsible: true
    });

    UI_DIV = null;
};

/**
 * Destroys the basic UI.
 */
EarthServerGenericClient.destroyBasicUI = function(domElementID)
{
    $( "#"+domElementID ).accordion( "destroy" );
};

/**
 * Appends a axis slider to a UI element. Axis sliders call the callback function with an ID,axis and their value.
 * @param domElement - Append the slider to this dom element.
 * @param sliderID - Dom ID for this slider.
 * @param label - Label (displayed in the UI) for this slider
 * @param elementID - First parameter for the callback function. Change the element with this ID.
 * @param axis - Axis this slider should effect. 0:x 1:y 2:z
 * @param min - Minimum value of this slider.
 * @param max - Maximum value of this slider.
 * @param startValue - Start value of this slider.
 * @param callback - Callback function, every time the slider is moved this function will be called.
 */
EarthServerGenericClient.appendXYZSlider = function(domElement,sliderID,label,elementID,axis,min,max,startValue,callback)
{
    var p = document.createElement("p");
    p.innerHTML = label;
    domElement.appendChild(p);

    var slider = document.createElement("div");
    slider.setAttribute("id",sliderID);
    domElement.appendChild(slider);

    $( "#"+sliderID ).slider({
        range: "max",
        min: min,
        max: max,
        value: startValue,
        slide: function( event, ui ) {
            callback(elementID,axis,ui.value);
        }
    });
};

/**
 * Generic sliders are calling their callback function with an element ID and their value.
 * @param domElement - Append the slider to this dom element.
 * @param sliderID - Dom ID for this slider.
 * @param label - Label (displayed in the UI) for this slider
 * @param elementID - First parameter for the callback function. Change the module with this ID.
 * @param min - Minimum value of this slider.
 * @param max - Maximum value of this slider.
 * @param startValue - Start value of this slider.
 * @param callback - Callback function, every time the slider is moved this function will be called.
 */
EarthServerGenericClient.appendGenericSlider = function(domElement,sliderID,label,elementID,min,max,startValue,callback)
{
    var p = document.createElement("p");
    p.innerHTML = label;
    domElement.appendChild(p);

    var slider = document.createElement("div");
    slider.setAttribute("id",sliderID);
    domElement.appendChild(slider);

    $( "#"+sliderID ).slider({
        range: "max",
        min: min,
        max: max,
        value: startValue,
        slide: function( event, ui ) {
            callback(elementID,ui.value);
        }
    });

};

/**
 * Special slider for setting the transparency of scene models.
 * @param domElement - Append the slider to this dom element.
 * @param moduleNumber - Index of the scene model.
 */
EarthServerGenericClient.appendAlphaSlider = function(domElement, moduleNumber){
    //AlphaChannel
    var ap = document.createElement("p");
    ap.setAttribute("id","EarthServerGenericClient_SliderCell_a_" + moduleNumber );
    ap.innerHTML = "Transparency: ";
    domElement.appendChild(ap);

    //jQueryUI Slider
    var Aslider = document.createElement("div");
    Aslider.setAttribute("id","aSlider_"+moduleNumber);
    domElement.appendChild(Aslider);

    $( "#aSlider_"+moduleNumber ).slider({
        range: "max",
        min: 0,
        max: 100,
        value: EarthServerGenericClient.MainScene.getModelTransparency(moduleNumber)*100,
        slide: function( event, ui ) {
            EarthServerGenericClient.MainScene.updateTransparency(moduleNumber,parseFloat(ui.value/100));
        }
    });

};

/**
 * Special slider for setting the elevation of scene models.
 * @param domElement - Append the slider to this dom element.
 * @param moduleNumber - Index of the scene model.
 */
EarthServerGenericClient.appendElevationSlider = function(domElement,moduleNumber){

    var ep = document.createElement("p");
    ep.setAttribute("id","EarthServerGenericClient_SliderCell_e_" + moduleNumber );
    ep.innerHTML = "Elevation: ";
    domElement.appendChild(ep);

    //jQueryUI Slider
    var Eslider = document.createElement("div");
    Eslider.setAttribute("id","eSlider_"+moduleNumber);
    domElement.appendChild(Eslider);

    $( "#eSlider_"+moduleNumber ).slider({
        range: "max",
        min: 0,
        max: 100,
        value: 10,
        slide: function( event, ui ) {
            EarthServerGenericClient.MainScene.updateElevation(moduleNumber,ui.value);
        }
    });

};

EarthServerGenericClient.appendMaxShownElementsSlider = function(domElement,moduleNumber,maxElements)
{
    var ep = document.createElement("p");
    ep.setAttribute("id","EarthServerGenericClient_SliderCell_me_" + moduleNumber );
    ep.innerHTML = "DrawnElements: ";
    domElement.appendChild(ep);

    //jQueryUI Slider
    var Eslider = document.createElement("div");
    Eslider.setAttribute("id","meSlider_"+moduleNumber);
    domElement.appendChild(Eslider);

    $( "#meSlider_"+moduleNumber ).slider({
        range: "max",
        min: 1,
        max: maxElements,
        value: parseInt(maxElements/2),
        slide: function( event, ui ) {
            EarthServerGenericClient.MainScene.updateMaxShownElements(moduleNumber,ui.value);
        }
    });
};

/**
 * @class The default progress bar to display the progress in loading and creating the scene models.
 * @param DivID
 */
EarthServerGenericClient.createProgressBar =  function(DivID)
{
    $( "#"+DivID ).progressbar({ value: 0, max: 100 });
    $( "#"+DivID ).on( "progressbarcomplete", function( event, ui ) {
        $( "#"+DivID ).toggle( "blind" );
    } );

    /**
     * Updates the value in the progress bar.
     * @param value - New value
     */
    this.updateValue = function(value)
    {
        $( "#"+DivID ).progressbar( "option", "value", value );
    };
};


//Namespace
var EarthServerGenericClient = EarthServerGenericClient || {};

/**
 * @class Abstract base class for visualisation tools.
 * @constructor
 */
EarthServerGenericClient.AbstractVisualisation = function()
{
    var posX = 0;
    var posY = 0;
    var maxX = 0;
    var maxY = 0;
    var minX = 0;
    var minY = 0;
    var axis = "x";
    var size = 50;

    this.setSize = function(newSize)
    {
        if( newSize > 0)
        {   size = newSize; }
        else
        {   console.log("EarthServerGenericClient.AbstractVisualisation::setSize: A value smaller than 0 not allowed.");    }
    };
    this.getSize = function()
    {   return size;    };

    this.setBoundaries = function(minx,maxx,miny,maxy)
    {
        minX = minx;
        minY = miny;
        maxX = maxx;
        maxY = maxy;
    };

    this.move = function(deltaX,deltaY)
    {
        if( posX+deltaX >= minX && posX+deltaX <maxX)
        {   posX = posX+deltaX; }

        if( posY+deltaY >= minY && posY+deltaY <maxY)
        {   posY = posY+deltaY; }

        this.updateVisualisation(posX,posY);
    };

    this.moveTo = function(xVal,yVal)
    {
        if( xVal > minX && xVal < maxX)
        {   posX  = xVal;   }

        if( yVal > minY && yVal < maxY)
        {   posY = yVal;    }

        this.updateVisualisation(posX,posY);
    };

    this.getPosX = function()
    {   return posX;    };
    this.getPosY = function()
    {   return posY;    };

    this.setAxis = function(newAxis)
    {
        if(newAxis !== "x" && newAxis !== "y" && newAxis !== "z")
        {   console.log("EarthServerGenericClient.AbstractVisualisation::setAxis: Can't set Axis. Has to be 'x','y' or 'z'.");}
        else
        {   axis = newAxis; }
    };
    this.getAxis = function()
    {   return axis;    };

    this.createImageTexture = function(width,height,imageData,canvasID)
    {
        this.canvasTexture = null;

        if( imageData !== undefined || width <= 0 || height <= 0)
        {
            this.canvasTexture = document.createElement('canvas');
            this.canvasTexture.style.display = "none";
            this.canvasTexture.setAttribute("id",canvasID);
            this.canvasTexture.width = width;
            this.canvasTexture.height = height;

            var context = this.canvasTexture.getContext('2d');
            context.putImageData(imageData,0,0);
        }
        else
        {   console.log("EarthServerGenericClient.AbstractVisualisation: Could not create Canvas."); }

        return this.canvasTexture;
    };

    this.updateCanvas = function(newImageData)
    {
        if( this.canvas)
        {
            var context = canvas.getContext('2d');
            context.putImageData(newImageData,0,0);
        }
        else
        {   console.log("EarthServerGenericClient.AbstractVisualisation: Could not find Canvas.");    }
    };

    this.rawDataToPixelData = function(rawData,hmMin,hmMax)
    {
        var pixels = this.canvas.width*this.canvasTexture.height*4;
        var pixelData = [pixels];

        //Draw complete white first
        for(var i=0; i<pixels;i++)
        {
            pixelData[i]=255;
        }
        //Draw heightmap into the white canvas
        for(i=0; i<rawData.length;i++)
        {
            var height = 0;
        }
    }
};

/**
 * @class
 * @constructor
 * @augments EarthServerGenericClient.AbstractVisualisation
 */
EarthServerGenericClient.HeightProfileVisualisation = function(index,getHeightmapFunction,size,hmWidth,hmHeight,axis,hmMin,hmMax)
{
    this.setSize(size);
    this.setBoundaries(0,hmWidth,0,hmHeight);
    this.move(hmWidth/2,hmHeight/2);
    this.setAxis(axis);

    this.updateVisualisation = function(posX,posY)
    {
        var info = {};
        info.xpos = posX;
        info.ypos = posY;
        if( this.getAxis() === "x")
        {
            info.chunkHeight = 1;
            info.chunkWidth  = this.getSize();
        }
        else
        {
            info.chunkHeight = this.getSize();
            info.chunkWidth  = 1;
        }

        var rawData   = getHeightmapFunction(info);
        var pixelData = rawDataToPixelData(rawData,hmMin,hmMax);
    }
};
EarthServerGenericClient.HeightProfileVisualisation.inheritsFrom( EarthServerGenericClient.AbstractVisualisation);
/** X3DOM Runtime, http://www.x3dom.org/ 1.6.0-dev - fa599b611f4a3dc0d32ecf6dd20fad6bf3390fee - Tue Dec 10 16:10:30 2013 +0100 *//*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

// Add some JS1.6 Array functions:
// (This only includes the non-prototype versions, because otherwise it messes up 'for in' loops)

if (!Array.forEach) {
	/*
	 *	Function: Array.forEach
	 *
	 *	Javascript array forEach() method calls a function for each element in the array.
	 * 
	 *  Parameters:
	 *
	 *   	array - The array
	 *		fun   - Function to test each element of the array
	 *      thisp - Object to use as __this__ when executing callback
	 *
	 *	Returns:
	 *
	 * 		The created array
	 */
	Array.forEach = function (array, fun, thisp) {
        var len = array.length;
        for (var i = 0; i < len; i++) {
            if (i in array) {
                fun.call(thisp, array[i], i, array);
            }
        }
    };
}

if (!Array.map) {
    Array.map = function(array, fun, thisp) {
        var len = array.length;
        var res = [];
        for (var i = 0; i < len; i++) {
            if (i in array) {
                res[i] = fun.call(thisp, array[i], i, array);
            }
        }
        return res;
    };
}

if (!Array.filter) {
    Array.filter = function(array, fun, thisp) {
        var len = array.length;
        var res = [];
        for (var i = 0; i < len; i++) {
            if (i in array) {
                var val = array[i];
                if (fun.call(thisp, val, i, array)) {
                    res.push(val);
                }
            }
        }
        return res;
    };
}

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/*
 * @namespace Namespace container for x3dom objects.
 */
var x3dom = {
    canvases: []
};

x3dom.x3dNS = 'http://www.web3d.org/specifications/x3d-namespace'; // non-standard, but sort of supported by Xj3D
x3dom.x3dextNS = 'http://philip.html5.org/x3d/ext';
x3dom.xsltNS = 'http://www.w3.org/1999/XSL/x3dom.Transform';
x3dom.xhtmlNS = 'http://www.w3.org/1999/xhtml';
// <<<<<<<<<<<<<

/** @namespace the x3dom.nodeTypes namespace. */
x3dom.nodeTypes = {};

/** @namespace the x3dom.nodeTypesLC namespace. Stores nodetypes in lowercase */
x3dom.nodeTypesLC = {};

/** @namespace the x3dom.components namespace. */
x3dom.components = {};

/** Cache for primitive nodes (Box, Sphere, etc.) */
x3dom.geoCache = [];

/** Stores information about Browser and hardware capabilities */
x3dom.caps = { PLATFORM: navigator.platform, AGENT: navigator.userAgent };

/** Registers the node defined by @p nodeDef.

    The node is registered with the given @p nodeTypeName and @p componentName.

    @param nodeTypeName the name of the node type (e.g. Material, Shape, ...)
    @param componentName the name of the component the node type belongs to
    @param nodeDef the definition of the node type
 */
x3dom.registerNodeType = function(nodeTypeName, componentName, nodeDef) {
    //console.log("Registering nodetype [" + nodeTypeName + "] in component [" + componentName + "]");
    if (x3dom.components[componentName] === undefined) {
        x3dom.components[componentName] = {};
    }
    nodeDef._typeName = nodeTypeName;
    nodeDef._compName = componentName;
    x3dom.components[componentName][nodeTypeName] = nodeDef;
    x3dom.nodeTypes[nodeTypeName] = nodeDef;
    x3dom.nodeTypesLC[nodeTypeName.toLowerCase()] = nodeDef;
};

/** Test if node is registered X3D element */
x3dom.isX3DElement = function(node) {
    // x3dom.debug.logInfo("node=" + node + "node.nodeType=" + node.nodeType + ", node.localName=" + node.localName + ", ");
    return (node.nodeType === Node.ELEMENT_NODE && node.localName &&
        (x3dom.nodeTypes[node.localName] || x3dom.nodeTypesLC[node.localName.toLowerCase()] ||
         node.localName.toLowerCase() === "x3d" || node.localName.toLowerCase() === "websg" ||
         node.localName.toLowerCase() === "scene" || node.localName.toLowerCase() === "route" ));
};

/*
 *	Function: x3dom.extend
 *
 *	Returns a prototype object suitable for extending the given class
 *	_f_. Rather than constructing a new instance of _f_ to serve as
 *	the prototype (which unnecessarily runs the constructor on the created
 *	prototype object, potentially polluting it), an anonymous function is
 *	generated internally that shares the same prototype:
 *
 *	Parameters:
 *
 *   	f - Method f a constructor
 *
 *	Returns:
 *
 * 		A suitable prototype object
 *
 *	See Also:
 *
 *		Douglas Crockford's essay on <prototypical inheritance at http://javascript.crockford.com/prototypal.html>.
 */
x3dom.extend = function(f) {
  function g() {}
  g.prototype = f.prototype || f;
  return new g();
};

/**
 * Function x3dom.getStyle
 * 
 * Computes the value of the specified CSS property <tt>p</tt> on the
 * specified element <tt>e</tt>.
 *
 * Parameters:
 *     oElm       - The element on which to compute the CSS property
 *     strCssRule - The name of the CSS property
 *
 *	Returns:
 *
 * 		The computed value of the CSS property
 */
x3dom.getStyle = function(oElm, strCssRule) {
    var strValue = "";
    if (document.defaultView.getComputedStyle && document.defaultView.getComputedStyle(oElm, null)) {
        //strValue = window.getComputedStyle(oElm).webkitTransform;
        strValue = document.defaultView.getComputedStyle(oElm, null).getPropertyValue(strCssRule);
        //strValue = window.getComputedStyle(oElm, "")[strCssRule];
    }
    else if(oElm.currentStyle){
        strCssRule = strCssRule.replace(/\-(\w)/g, function (strMatch, p1){ return p1.toUpperCase(); });
        strValue = oElm.currentStyle[strCssRule];
    }
    return strValue;
};


/** Utility function for defining a new class.

    @param parent the parent class of the new class
    @param ctor the constructor of the new class
    @param methods an object literal containing the methods of the new class
    @return the constructor function of the new class
  */
function defineClass(parent, ctor, methods) {
    function inheritance() {}

    if (parent) {
        inheritance.prototype = parent.prototype;
        ctor.prototype = new inheritance();
        ctor.prototype.constructor = ctor;
        ctor.superClass = parent;
    }
    if (methods) {
        for (var m in methods) {
            ctor.prototype[m] = methods[m];
        }
    }
    return ctor;
}

/** Utility function for testing a node type.

    @param object the object to test
    @param clazz the type of the class
    @return true or false
  */
x3dom.isa = function(object, clazz) {
	if (!object) {
		return false;
	}
    if (object.constructor === clazz) {
        return true;
    }
    if (object.constructor.superClass === undefined) {
        return false;
    }

    function f(c) {
        if (c === clazz) {
            return true;
        }
        if (c.prototype && c.prototype.constructor && c.prototype.constructor.superClass) {
            return f(c.prototype.constructor.superClass);
        }
        return false;
    }
    return f(object.constructor.superClass);
};


/// helper
x3dom.getGlobal = function() { return (function(){ return this;}).call(null); };


/**
 * Load javascript file either by performing an synchronous jax request
 * an eval'ing the response or by dynamically creating a <script> tag.
 *
 * CAUTION: This function is a possible source for Cross-Site
 *          Scripting Attacks.
 *
 * @param  src  The location of the source file relative to
 *              path_prefix. If path_prefix is omitted, the
 *              current directory (relative to the HTML document)
 *              is used instead.
 * @param  path_prefix A prefix URI to add to the resource to be loaded.
 *                     The URI must be given in normalized path form ending in a
 *                     path seperator (i.e. src/nodes/). It can be in absolute
 *                     URI form (http://somedomain.tld/src/nodes/)
 * @param  blocking    By default the lookup is done via blocking jax request.
 *                     set to false to use the script i
 */
x3dom.loadJS = function(src, path_prefix, blocking) {
    var blocking = (blocking === false) ? blocking : true;   // default to true

    if (blocking) {
        var url = (path_prefix) ? path_prefix.trim() + src : src;

        var req = new XMLHttpRequest();

        if (req) {
            // third parameter false = synchronous/blocking call
            // need this to load the JS before onload completes
            req.open("GET", url, false);
            req.send(null); // blocking

            // maybe consider global eval
            // http://perfectionkills.com/global-eval-what-are-the-options/#indirect_eval_call_examples
            eval(req.responseText);
        }

    } else {
        var head = document.getElementsByTagName('HEAD').item(0);
        var script = document.createElement("script");
        var loadpath = (path_prefix) ? path_prefix.trim() + src : src;
        if (head) {
            x3dom.debug.logError("Trying to load external JS file: " + loadpath);
            //alert("Trying to load external JS file: " + loadpath);
            script.type = "text/javascript";
            script.src = loadpath;
//        head.appendChild(script);
            head.appendChild(script, head.firstChild);
        } else {
            alert("No document object found. Can't load components!");
            //x3dom.debug.logError("No document object found. Can't load components");
        }
    }
};

// helper
function array_to_object(a) {
  var o = {};
  for(var i=0;i<a.length;i++) {
    o[a[i]]='';
  }
  return o;
}

/**
 * Provides requestAnimationFrame in a cross browser way.
 * https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/sdk/demos/common/webgl-utils.js
 */
window.requestAnimFrame = (function() {
	return window.requestAnimationFrame ||
    	   window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame ||
           window.oRequestAnimationFrame ||
           window.msRequestAnimationFrame ||
           function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
             window.setTimeout(callback, 16);
           };
})();

/**
 * Toggle full-screen mode
 */
x3dom.toggleFullScreen = function() {
    if (document.fullScreen || document.mozFullScreen || document.webkitIsFullScreen) {
        if (document.cancelFullScreen) {
            document.cancelFullScreen();
        }
        else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        }
        else if (document.webkitCancelFullScreen) {
            document.webkitCancelFullScreen();
        }
    }
    else {
        var docElem = document.documentElement;
        if (docElem.requestFullScreen) {
            docElem.requestFullScreen();
        }
        else if (docElem.mozRequestFullScreen) {
            docElem.mozRequestFullScreen();
        }
        else if (docElem.webkitRequestFullScreen) {
            docElem.webkitRequestFullScreen();
        }
    }
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

x3dom.debug = {

    INFO:       "INFO",
    WARNING:    "WARNING",
    ERROR:      "ERROR",
    EXCEPTION:  "EXCEPTION",
    
	// determines whether debugging/logging is active. If set to "false"
	// no debugging messages will be logged.
	isActive: false,

    // stores if firebug is available
    isFirebugAvailable: false,
    
    // stores if the x3dom.debug object is initialized already
    isSetup: false,
	
	// stores if x3dom.debug object is append already (Need for IE integration)
	isAppend: false,

    // stores the number of lines logged
    numLinesLogged: 0,
    
    // the maximum number of lines to log in order to prevent
    // the browser to slow down
    maxLinesToLog: 10000,

	// the container div for the logging messages
	logContainer: null,
    
    /** @brief Setup the x3dom.debug object.

        Checks for firebug and creates the container div for the logging 
		messages.
      */
    setup: function() {
		// If debugging is already setup simply return
        if (x3dom.debug.isSetup) { return; }

		// Check for firebug console
        try {
            if (window.console.firebug !== undefined) {
                x3dom.debug.isFirebugAvailable = true;           
            }
        }
        catch (err) {
            x3dom.debug.isFirebugAvailable = false;
        }
        
		// 
		x3dom.debug.setupLogContainer();

        // setup should be setup only once, thus store if we done that already
        x3dom.debug.isSetup = true;
    },
	
	/** @brief Activates the log
      */
	activate: function(visible) {
		x3dom.debug.isActive = true;
		
        //var aDiv = document.createElement("div");
        //aDiv.style.clear = "both";
        //aDiv.appendChild(document.createTextNode("\r\n"));
        //aDiv.style.display = (visible) ? "block" : "none";
        x3dom.debug.logContainer.style.display = (visible) ? "block" : "none";
		
		//Need this HACK for IE/Flash integration. IE don't have a document.body at this time when starting Flash-Backend
		if(!x3dom.debug.isAppend) {
			if(navigator.appName == "Microsoft Internet Explorer") {
				//document.documentElement.appendChild(aDiv);
				x3dom.debug.logContainer.style.marginLeft = "8px";
				document.documentElement.appendChild(x3dom.debug.logContainer);
			}else{
				//document.body.appendChild(aDiv);
				document.body.appendChild(x3dom.debug.logContainer);
			}
			x3dom.debug.isAppend = true;
		}
	},

	/** @brief Inserts a container div for the logging messages into the HTML page
      */
	setupLogContainer: function() {
		x3dom.debug.logContainer = document.createElement("div");
		x3dom.debug.logContainer.id = "x3dom_logdiv";
		x3dom.debug.logContainer.setAttribute("class", "x3dom-logContainer");
		x3dom.debug.logContainer.style.clear = "both";
		//document.body.appendChild(x3dom.debug.logContainer);
	},

	/** @brief Generic logging function which does all the work.

		@param msg the log message
		@param logType the type of the log message. One of INFO, WARNING, ERROR 
					   or EXCEPTION.
      */
    doLog: function(msg, logType) {

		// If logging is deactivated do nothing and simply return
		if (!x3dom.debug.isActive) { return; }

		// If we have reached the maximum number of logged lines output
		// a warning message
		if (x3dom.debug.numLinesLogged === x3dom.debug.maxLinesToLog) {
			msg = "Maximum number of log lines (=" + x3dom.debug.maxLinesToLog + 
				  ") reached. Deactivating logging...";
		}

		// If the maximum number of log lines is exceeded do not log anything
		// but simply return 
		if (x3dom.debug.numLinesLogged > x3dom.debug.maxLinesToLog) { return; }

		// Output a log line to the HTML page
		var node = document.createElement("p");
		node.style.margin = 0;
        switch (logType) {
            case x3dom.debug.INFO:
                node.style.color = "#00ff00";
                break;
            case x3dom.debug.WARNING:
                node.style.color = "#cd853f";
                break;
            case x3dom.debug.ERROR:
                node.style.color = "#ff4500";
                break;
            case x3dom.debug.EXCEPTION:
                node.style.color = "#ffff00";
                break;
            default: 
                node.style.color = "#00ff00";
                break;
        }
		
		// not sure if try/catch solves problem http://sourceforge.net/apps/trac/x3dom/ticket/52
		// but due to no avail of ATI gfxcard can't test
        try {
			node.innerHTML = logType + ": " + msg;
			x3dom.debug.logContainer.insertBefore(node, x3dom.debug.logContainer.firstChild);
        } catch (err) {
			if (window.console.firebug !== undefined) {
				window.console.warn(msg);
			}
        }
        
		// Use firebug's console if available
        if (x3dom.debug.isFirebugAvailable) {
            switch (logType) {
                case x3dom.debug.INFO:
                    window.console.info(msg);
                    break;
                case x3dom.debug.WARNING:
                    window.console.warn(msg);
                    break;
                case x3dom.debug.ERROR:
                    window.console.error(msg);
                    break;
                case x3dom.debug.EXCEPTION:
                    window.console.debug(msg);
                    break;
                default: 
                    break;
            }
        }
        
		x3dom.debug.numLinesLogged++;
    },
    
    /** Log an info message. */
    logInfo: function(msg) {
        x3dom.debug.doLog(msg, x3dom.debug.INFO);
    },
    
    /** Log a warning message. */
    logWarning: function(msg) {
        x3dom.debug.doLog(msg, x3dom.debug.WARNING);
    },
    
    /** Log an error message. */
    logError: function(msg) {
        x3dom.debug.doLog(msg, x3dom.debug.ERROR);
    },
    
    /** Log an exception message. */
    logException: function(msg) {
        x3dom.debug.doLog(msg, x3dom.debug.EXCEPTION);
    },

    /** Log an assertion. */
	assert: function(c, msg) {
		if (!c) {
			x3dom.debug.doLog("Assertion failed in " + 
                    x3dom.debug.assert.caller.name + ': ' + 
                    msg, x3dom.debug.ERROR);
		}
	},
	
	/**
	 Checks the type of a given object.
	 
	 @param obj the object to check.
	 @returns one of; "boolean", "number", "string", "object",
	  "function", or "null".
	*/
	typeOf: function (obj) {
		var type = typeof obj;
		return type === "object" && !obj ? "null" : type;
	},

	/**
	 Checks if a property of a specified object has the given type.
	 
	 @param obj the object to check.
	 @param name the property name.
	 @param type the property type (optional, default is "function").
	 @returns true if the property exists and has the specified type,
	  otherwise false.
	*/
	exists: function (obj, name, type) {
		type = type || "function";
		return (obj ? this.typeOf(obj[name]) : "null") === type;
	},
	
	/**
	 Dumps all members of the given object.
	*/
	dumpFields: function (node) {
		var str = "";
		for (var fName in node) {
			str += (fName + ", ");
		}
		str += '\n';
		x3dom.debug.logInfo(str);
		return str;
	}
};

// Call the setup function to... umm, well, setup x3dom.debug
x3dom.debug.setup();

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

//---------------------------------------------------------------------------------------------------------------------

x3dom.arc = {};
x3dom.arc.instance = null;

x3dom.arc.Limits = function(min, max, initial)
{
    this._min = min;
    this._max = max;

    this.getValue = function(value)
    {
        value = this._min + (this._max - this._min) * value;
        return this._max >= value ? (this._min <= value ? value : this._min ) : this._max;
    };
};

//---------------------------------------------------------------------------------------------------------------------

x3dom.arc.ARF = function(name, min, max, dirFac, factorGetterFunc, factorSetterFunc, getterFunc, setterFunc)
{
    this._name = name;
    //start with average
    this._stateValue = [ 0.5, 0.5 ];

    this._limits = new x3dom.arc.Limits(min, max);
    this._factorGetterFunc = factorGetterFunc;
    this._factorSetterFunc = factorSetterFunc;
    this._setterFunc = setterFunc;
    this._getterFunc = getterFunc;
    this._dirFac = dirFac;

    this.getFactor = function()
    {
        return this._factorGetterFunc();
    };

    this.update = function(state, step)
    {
        var stateVal = this._stateValue[state] + step * this._dirFac;
        this._stateValue[state] =  0 <= stateVal ? ( 1 >= stateVal ? stateVal : 1 ) : 0;
        this._setterFunc(this._limits.getValue(this._stateValue[state]));

        //console.log(this.name +" "+this._factorGetterFunc() +" *  " + step +" "+ this._stateValue[state] +" "+ state);
    };

    this.reset = function()
    {
        this._stateValue[0] = 0.5;
        this._stateValue[1] = 0.5;
    };
};

//---------------------------------------------------------------------------------------------------------------------

x3dom.arc.AdaptiveRenderControl = defineClass(
    null,
    function(scene)
    {
        x3dom.arc.instance = this;

        this._scene = scene;
        this._targetFrameRate = [];
        this._targetFrameRate[0] = this._scene._vf.minFrameRate;
        this._targetFrameRate[1] = this._scene._vf.maxFrameRate;

        this._currentState = 0;

        var that = this;
        var environment = that._scene.getEnvironment();

        this._arfs = [];

        this._arfs.push(
            new x3dom.arc.ARF("smallFeatureCulling",
                0, 10, -1,
                function()
                {
                    return environment._vf.smallFeatureFactor;
                },
                function(value)
                {
                    environment._vf.smallFeatureFactor = value;
                },
                function()
                {
                    return  environment._vf.smallFeatureThreshold;
                },
                function(value)
                {
                    environment._vf.smallFeatureThreshold = value;
                }
            )
        );

        this._arfs.push(
            new x3dom.arc.ARF("lowPriorityCulling",
                0,100,1,
                function()
                {
                    return environment._vf.lowPriorityFactor;
                },
                function(value)
                {
                    environment._vf.lowPriorityFactor = value;
                },
                function()
                {
                    return environment._vf.lowPriorityThreshold * 100;
                },
                function(value)
                {
                    environment._vf.lowPriorityThreshold = value / 100;
                }
            )
        );

        this._arfs.push(
            new x3dom.arc.ARF("tessellationDetailCulling",
                1,12,-1,
                function()
                {
                    return environment._vf.tessellationErrorFactor;
                },
                function(value)
                {
                    environment._vf.tessellationErrorFactor = value;
                },
                //@todo: this factor is a static member of PopGeo... should it belong to scene instead?
                function()
                {
                    return environment.tessellationErrorThreshold;
                },
                function(value)
                {
                    environment.tessellationErrorThreshold = value;
                }
            )
        );

        this._stepWidth = 0.1;
    },
    {
        update : function(state, fps) // state: 0 = static, 1 : moving
        {
            this._currentState = state;
            var delta =  fps - this._targetFrameRate[state];

            //to prevent flickering
            this._stepWidth = Math.abs(delta) > 10 ? 0.1 : 0.01;

            /*if( (delta > 0 && state == 1) || (delta < 0 && state == 0))
                return;
            */

            var factorSum = 0;
            var normFactors = [];

            //normalize factors
            var i, n = this._arfs.length;

            for(i = 0; i < n; ++i)
            {
                normFactors[i] = this._arfs[i].getFactor();
                if(normFactors[i] > 0)
                    factorSum += normFactors[i];
            }

            var dirFac = delta < 0 ? -1 : 1;
            for(i = 0; i < n; ++i)
            {
                if(normFactors[i] > 0)
                {
                    normFactors[i] /= factorSum;
                    this._arfs[i].update(state, this._stepWidth * normFactors[i] * dirFac);
                }
            }
        },

        reset: function()
        {
            for( var i = 0, n = this._arfs.length; i < n; ++i)
            {
                this._arfs[i].reset();
            }
        }
    }
);

//---------------------------------------------------------------------------------------------------------------------


/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */
 
 
 /**
 * Class: x3dom.DownloadManager
 *
 * Simple priority-based download manager.
 * Before objects of priority n+1 are available,
 * all objects of priority n must have been already delivered.
 * The highest priority key is 0.
 * 
 */

/// a small Request class
var Request = function(url, onloadCallback, priority){
	this.url 	  		     = url;	
	this.priority 		   = priority;
	this.xhr 	  		     = new XMLHttpRequest();
	this.onloadCallbacks = [onloadCallback];
	
	var self = this;

	this.xhr.onload = function() {		
		if (x3dom.DownloadManager.debugOutput) {
			x3dom.debug.logInfo('Download manager received data for URL \'' + self.url + '\'.');
		}
		
		--x3dom.DownloadManager.activeDownloads;
	
    if ((x3dom.DownloadManager.stallToKeepOrder === false ) || (x3dom.DownloadManager.resultGetsStalled(self.priority) === false)) {
      var i;
      for (i = 0; i < self.onloadCallbacks.length; ++i) {			
        self.onloadCallbacks[i](self.xhr.response);
      }
      
      x3dom.DownloadManager.removeDownload(self);
      
      x3dom.DownloadManager.updateStalledResults();
    }
    else if (x3dom.DownloadManager.debugOutput) {
			x3dom.debug.logInfo('Download manager stalled downloaded result for URL \'' + self.url + '\'.');
		}
    
		x3dom.DownloadManager.tryNextDownload();
	};
};


Request.prototype.send = function() {
	this.xhr.open('GET', encodeURI(this.url), true); //asynchronous	
	
	//at the moment, ArrayBuffer is the only possible return type
	this.xhr.responseType = 'arraybuffer';
	
	this.xhr.send(null);
	
	if (x3dom.DownloadManager.debugOutput) {
		x3dom.debug.logInfo('Download manager posted XHR for URL \'' + this.url + '\'.');
	}
};


x3dom.DownloadManager = {

requests 		     : [], //map priority->[requests]

maxDownloads 	   : 6,  //number of max. concurrent downloads

activeDownloads  : 0,  //number of active downloads

debugOutput		   : false,

stallToKeepOrder : false,


toggleDebugOutput : function(flag) {
	this.debugOutput = flag;	
},


toggleStrictReturnOrder : function(flag) {
  //@todo: this is not working properly yet!
  this.stallToKeepOrder = false;
  //this.stallToKeepOrder = flag;
},


removeDownload : function(req) {
	var i, j;
	var done = false;

	for (i = 0; i < this.requests.length && !done; ++i) {	
		if (this.requests[i]){			
			for (j = 0; j < this.requests[i].length; ++j) {
				if (this.requests[i][j] === req) {
					this.requests[i].splice(j, 1);
					done = true;
					break;
				}
			}
		}
	}
},


tryNextDownload : function() {
	var firstRequest;
	var i, j;
		
	//if there are less then maxDownloads running, start a new one,
	//otherwise do nothing
	if (this.activeDownloads < this.maxDownloads) {	
		//remove first queue element, if any
		for (i = 0; i < this.requests.length && !firstRequest; ++i) {
			//find the request queue with the highest priority
			if (this.requests[i]) {
				//remove first unsent request from the queue, if any
				for (j = 0; j < this.requests[i].length; ++j) {					
					if (this.requests[i][j].xhr.readyState === XMLHttpRequest.UNSENT) {
						firstRequest = this.requests[i][j];
						break;						
					}
				}
			}
		}
		
		if (firstRequest) {		
			firstRequest.send();			
			
			++this.activeDownloads;
		}
	}
},


resultGetsStalled : function(priority) {
  var i;
  
  for (i = 0; i < priority; ++i) {
    if (this.requests[i] && this.requests[i].length) {
      return true;
    }
  }
  
  return false;
},


updateStalledResults : function() {
  if (x3dom.DownloadManager.stallToKeepOrder) {  
    var i, j, k;
    var req, pendingRequestFound = false;
    
    for (i = 0; i < this.requests.length && !pendingRequestFound; ++i) {
    
      if (this.requests[i]) {
        for (j = 0; j < this.requests[i].length; ++j) {
          //check if there is a stalled result and relase it, if so
          req = this.requests[i][j];
          
          if (req.xhr.readyState === XMLHttpRequest.DONE) {
          
            if (x3dom.DownloadManager.debugOutput) {
              x3dom.debug.logInfo('Download manager releases stalled result for URL \'' + req.url + '\'.');
            }
            
            for (k = 0; k < req.onloadCallbacks.length; ++k) {
              req.onloadCallbacks[k](req.xhr.response);
            }
            
            //remove request from the list
            this.requests[i].splice(j, 1);          
          }
          //if there is an unfinished result, stop releasing results of lower priorities
          else {
            pendingRequestFound = true;	
          }
        }
      }
      
    }
  }
},


/**
 * Requests a download from the given URL, with the given onloadCallback and priority.
 * The callback function will be invoked with a JSON object as parameter, where the
 * 'arrayBuffer' member contains a reference to the requested data and the 'url' member
 * contains the original user-given URL of the object.
 * 
 * If there is no data from the given url available, but there is already a registered request
 * for it, the new callback is just appended to the old registered request object. Note that,
 * in this special case, the priority of the old request is not changed, i.e. the priority
 * of the new request to the same url is ignored.
 */
get : function(urls, onloadCallbacks, priorities) {
  var i, j, k, r;
  var found = false;
  var url, onloadCallback, priority;
  
  if (urls.length !== onloadCallbacks.length || urls.length !== priorities.length)
  {
    x3dom.debug.logError('DownloadManager: The number of given urls, onload callbacks and priorities is not equal. Ignoring requests.');
    return;
  }
  
  //insert requests
  for (k = 0; k < urls.length; ++k) {
    if (!onloadCallbacks[k] === undefined || !priorities[k] === undefined) {
      x3dom.debug.logError('DownloadManager: No onload callback and / or priority specified. Ignoring request for \"' + url + '\"');
      continue;
    }
    else {
      url            = urls[k];
      onloadCallback = onloadCallbacks[k];
      priority       = priorities[k];
      
      //enqueue request priority-based or append callback to a matching active request		
      
      //check if there is already an enqueued or sent request for the given url
      for (i = 0; i < this.requests.length && !found; ++i) {
        if (this.requests[i]) {			
          for (j = 0; j < this.requests[i].length; ++j) {
            if (this.requests[i][j].url === url) {
              this.requests[i][j].onloadCallbacks.push(onloadCallback);
              
              if (x3dom.DownloadManager.debugOutput) {
                x3dom.debug.logInfo('Download manager appended onload callback for URL \'' + url + '\' to a registered request using the same URL.');
              }
              
              found = true;
              break;
            }
          }
        }
      }
    
      if (!found) {
        r = new Request(url, onloadCallback, priority);
        
        if (this.requests[priority]) {
          this.requests[priority].push(r);
        }
        else {
          this.requests[priority] = [r];
        }
      }
    }
  }
  
  //try to download data
  for (i = 0; i < urls.length && this.activeDownloads < this.maxDownloads; ++i) {
    this.tryNextDownload();    
  }
}
	
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

var JOB_WAITING_FOR_DATA  = 0;
var JOB_DATA_AVAILABLE    = 1;
var JOB_GETTING_PROCESSED = 2;
var JOB_FINISHED          = 3;


x3dom.RefinementJobManager = function() {
  var self = this;
  
  if (typeof Worker !== 'undefined') {
    this.worker = new Worker(new x3dom.RefinementJobWorker().toBlob());
    //console.log(this.worker);
    this.worker.postMessage = this.worker.webkitPostMessage || this.worker.postMessage;  
    this.worker.addEventListener('message', function(event){return self.messageFromWorker(event);}, false);
  }
  else if (!x3dom.RefinementJobManager.suppressOnWorkersNotSupported) {
    x3dom.RefinementJobManager.suppressOnWorkersNotSupported = true;
    x3dom.RefinementJobManager.onWorkersNotSupported();    
  } 
  
  this.attributes = [];
};
 

//global flags to avoid multiple popups with the same warning
x3dom.RefinementJobManager.suppressOnTransferablesNotSupported = true;
x3dom.RefinementJobManager.suppressOnWorkersNotSupported       = false;
 
 
x3dom.RefinementJobManager.onTransferablesNotSupported = function() {
  alert('Your browser does not support transferables.\n' +
        'This application might run slower than expected due to data cloning operations.');
};
               
               
x3dom.RefinementJobManager.onWorkersNotSupported = function() {
  alert('WebWorkers are not supported by your browser. Unable to use RefinementJobManager.');
};

 
x3dom.RefinementJobManager.prototype.addResultBuffer = function(attributeId, bufferView) {
  //at the moment, we assume that only unsigned integer types are used
  this.attributes[attributeId] = {resultBuffer                : bufferView.buffer,
                                  resultBufferBytesPerElement : bufferView.BYTES_PER_ELEMENT,
                                  jobs                        : []                };
};


x3dom.RefinementJobManager.prototype.addRefinementJob = function(attributeId, priority, url, level, finishedCallback, stride,
                                                                 numComponentsList, bitsPerLevelList, readOffsetList, writeOffsetList) {  
  var self = this;  
  
  var job = {priority          : priority,        
             url               : url,
             level             : level,
             finishedCallback  : finishedCallback,
             stride            : stride,
             numComponentsList : numComponentsList,
             bitsPerLevelList  : bitsPerLevelList,
             readOffsetList    : readOffsetList,
             writeOffsetList   : writeOffsetList,
             state             : JOB_WAITING_FOR_DATA,
             dataBuffer        : {}                   };
  
  this.attributes[attributeId].jobs.push(job);
  
  var downloadCallback;
  
  (function(attId, url) {
    downloadCallback = function(arrayBuffer) {
      self.jobInputDataLoaded(attId, url, arrayBuffer);
    };
  })(attributeId, url);
  
  
  //CODE FOR DOWNLOAD MANAGER USE:
  //this is just an option:
  //it tells the download manager to return data only if there are no pending requests of higher priority left
  //this way, we ensure can guarantee to get all levels in the correct order, which is visually more satisfying
  //however, one may decide to leave this option out to allow for a random refinement processing order
  //x3dom.DownloadManager.toggleStrictReturnOrder(true);
  
  x3dom.DownloadManager.get([url], [downloadCallback], [priority]);
  //(END CODE FOR DOWNLOAD MANAGER USE)
  
  
  //ALTERNATIVE CODE WITHOUT DOWNLOAD MANAGER USE:
  // var xhr = new XMLHttpRequest();
	// xhr.open("GET", url, true);
	// xhr.responseType = "arraybuffer";	
  // xhr.onload = function() {          
	  // downloadCallback(xhr.response);    
	// };  
  // xhr.send(null);
  //(ALTERNATIVE CODE WITHOUT DOWNLOAD MANAGER USE:)
};


x3dom.RefinementJobManager.prototype.jobInputDataLoaded = function(attributeId, url, dataBuffer) {  
  var i;
  var jobs = this.attributes[attributeId].jobs;
  
  for (i = 0; i < jobs.length; ++i) {
    if (jobs[i].url === url) {      
      jobs[i].state      = JOB_DATA_AVAILABLE;  
      jobs[i].dataBuffer = dataBuffer;
      
      this.tryNextJob(attributeId);
    }
  }
}


x3dom.RefinementJobManager.prototype.tryNextJob = function(attributeId) {  
  var i, job;
  var jobs           = this.attributes[attributeId].jobs;  
  var owningBuffer   = true;
  var availableIndex = -1;
  var bufferView;  
  
  for (i = 0; i < jobs.length; ++i) {
      if (jobs[i].state === JOB_GETTING_PROCESSED) {        
        owningBuffer = false;
        break;
      }
      if (availableIndex === -1 && jobs[i].state === JOB_DATA_AVAILABLE) {
        availableIndex = i;
      }
  }
  
  if (owningBuffer && availableIndex !== -1) {
    job = jobs[availableIndex];
    
    job.state = JOB_GETTING_PROCESSED;
    
    this.worker.postMessage({msg                         : 'processJob',
                             attributeId                 : attributeId,
                             level                       : job.level,
                             stride                      : job.stride,
                             numComponentsList           : job.numComponentsList,
                             bitsPerLevelList            : job.bitsPerLevelList,
                             readOffsetList              : job.readOffsetList,
                             writeOffsetList             : job.writeOffsetList,                             
                             resultBufferBytesPerElement : this.attributes[attributeId].resultBufferBytesPerElement,
                             dataBuffer                  : job.dataBuffer,
                             resultBuffer                : this.attributes[attributeId].resultBuffer                },
                            [job.dataBuffer, this.attributes[attributeId].resultBuffer]);
                             
    //after postMessage, the buffers should have been transfered and neutered
		if ((job.dataBuffer.byteLength > 0 || this.attributes[attributeId].resultBuffer.byteLength > 0) &&
        !x3dom.RefinementJobManager.suppressOnTransferablesNotSupported                               ) {
		  x3dom.RefinementJobManager.suppressOnTransferablesNotSupported = true;
      x3dom.RefinementJobManager.onTransferablesNotSupported();		  
		}
  }
};


x3dom.RefinementJobManager.prototype.processedDataAvailable = function(attributeId, resultBuffer) {
  var i;
  var jobs = this.attributes[attributeId].jobs;
  
  this.attributes[attributeId].resultBuffer = resultBuffer;
  
  for (i = 0; i < jobs.length; ++i) {
    if (jobs[i].state === JOB_GETTING_PROCESSED) {
      jobs[i].state = JOB_FINISHED;      
      jobs[i].finishedCallback(attributeId, this.getBufferView(attributeId));
      break;
    }
  }
};


x3dom.RefinementJobManager.prototype.continueProcessing = function(attributeId) {
  this.tryNextJob(attributeId);
};


x3dom.RefinementJobManager.prototype.messageFromWorker = function(message) {
  if (message.data.msg) {
    switch (message.data.msg) {
      
      case 'jobFinished':        
        this.processedDataAvailable(message.data.attributeId,
                                    message.data.resultBuffer);
        break;
                                    
      case 'log':
        x3dom.debug.logInfo('Message from Worker Context: ' + message.data.txt);
        break;
    }
  }
};


x3dom.RefinementJobManager.prototype.getBufferView = function(attributeId) {
  var att = this.attributes[attributeId];
  
  switch (att.resultBufferBytesPerElement) {
    case 1:
      return new Uint8Array(att.resultBuffer);
    case 2:
      return new Uint16Array(att.resultBuffer);
    case 4:
      return new Uint32Array(att.resultBuffer);
    default:
      x3dom.debug.logError('Unable to create BufferView: the given number of ' + att.resultBufferBytesPerElement +
                           ' bytes per element does not match any Uint buffer type.');
  }
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


URL = (typeof URL       !== 'undefined') ? URL :
      (typeof webkitURL !== 'undefined') ? webkitURL : undefined;
        
         
x3dom.RefinementJobWorker = function() {
};


x3dom.RefinementJobWorker.prototype.subtract = function(v0, v1) {
  return [v0[0] - v1[0],
          v0[1] - v1[1],
          v0[2] - v1[2]];
};

x3dom.RefinementJobWorker.prototype.normalize = function(v) {
  var l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
  l = 1.0 / l;
  return [v[0]*l, v[1]*l, v[2]*l];
};

x3dom.RefinementJobWorker.prototype.cross = function(v0, v1) {
  return [v0[1]*v1[2] - v0[2]*v1[1],
          v0[2]*v1[0] - v0[0]*v1[2],
          v0[0]*v1[1] - v0[1]*v1[0]];
};


x3dom.RefinementJobWorker.prototype.log = function(logMessage) {
  postMessage({msg : 'log', txt : logMessage});
};


x3dom.RefinementJobWorker.prototype.processJob = function(attributeId, level, stride,
                                                          numComponentsList, bitsPerLevelList, readOffsetList, writeOffsetList,
                                                          dataBufferView, resultBufferView)
{ 
  var aPrecOff, bPrecOff;

  //optimized cases for decoding:
  //---------------------------------------------------------------------------------------------
  //Attrib. A (e.g. positions)        : 3 x 2 bit
  //Attrib. B (e.g. normals)          : 2 x 1 bit
  //Result Buffer Alignment / Padding : a1 a2 a3 0 b1 b2
  if (numComponentsList.length === 2 &&
      numComponentsList[0]     === 3 &&
      numComponentsList[1]     === 2 &&
      bitsPerLevelList[0]      === 6 &&
      bitsPerLevelList[1]      === 2   ) {      
    aPrecOff = resultBufferView.BYTES_PER_ELEMENT * 8 - 2 - (level * 2);  //2 bits per component per level
    bPrecOff = resultBufferView.BYTES_PER_ELEMENT * 8 - 1 - (level * 1);  //2 bit per component per level
    
    addBits_3x2_2x1(dataBufferView, resultBufferView, aPrecOff, bPrecOff);
  }  
  //---------------------------------------------------------------------------------------------
  //Attrib. A (e.g. positions)        : 3 x 2  bit
  //Attrib. B (e.g. normals)          : 3 x 16 bit -> COMPUTED ON-THE-FLY PER FACE
  //Result Buffer Alignment / Padding : a1 a2 a3 0 b1 b2 b3 0
  else if (numComponentsList.length === 2 &&
           numComponentsList[0]     === 3 &&
           numComponentsList[1]     === 3 &&
           bitsPerLevelList[0]      === 6 &&
           bitsPerLevelList[1]      === 0   ) {      
    aPrecOff = resultBufferView.BYTES_PER_ELEMENT * 8 - 2 - (level * 2);  //2 bits per component per level
    
    addBits_3x2_3x2_computeNormals(dataBufferView, resultBufferView, aPrecOff);
  } 
  //---------------------------------------------------------------------------------------------
  // else if (...) {
  //  ...
  //}
  //---------------------------------------------------------------------------------------------
  //default non-optimized decoding:
  //(assuming interleaved output)
  else {
    addBits(level, stride, numComponentsList, bitsPerLevelList, readOffsetList, writeOffsetList, dataBufferView, resultBufferView);
  }
	
  postMessage({msg          : 'jobFinished',
               attributeId  : attributeId,
               resultBuffer : resultBufferView.buffer},
              [resultBufferView.buffer]);
};


x3dom.RefinementJobWorker.prototype.onmessage = function(message) {  
  var i, dataBufferBytesPerElement;
  
  if (message.data.msg) {
    switch (message.data.msg) {
    
      case 'processJob':
        dataBufferBytesPerElement = 0;
        
        for (i = 0; i < message.data.bitsPerLevelList.length; ++i) {
          dataBufferBytesPerElement += message.data.bitsPerLevelList[i];
        }
        
        //here, we assume that dataBufferBytesPerElement will be 1, 2 or 4 afterwards
        dataBufferBytesPerElement = Math.ceil(dataBufferBytesPerElement / 8.0);
        
        processJob(message.data.attributeId, message.data.level, message.data.stride,
                   message.data.numComponentsList, message.data.bitsPerLevelList, message.data.readOffsetList, message.data.writeOffsetList,
                   getBufferView(dataBufferBytesPerElement,                message.data.dataBuffer),
                   getBufferView(message.data.resultBufferBytesPerElement, message.data.resultBuffer));
        break;        
    }
  }
};


x3dom.RefinementJobWorker.prototype.getBufferView = function(bytesPerElement, buffer) {
  switch (bytesPerElement) {
    case 1:
      return new Uint8Array(buffer);
    case 2:
      return new Uint16Array(buffer);
    case 4:
      return new Uint32Array(buffer);
    default:
      log('ERROR: The estimated element length of ' + bytesPerElement + ' bytes does not match any known Uint buffer type.');
      break;
  }
};


x3dom.RefinementJobWorker.prototype.addBits_3x2_2x1 = function(dataBufferView, resultBufferView, aPrecOff, bPrecOff) {  
  //Optimized Decoding

  //Attrib. A (e.g. positions)        : 3 x 2 bit
  //Attrib. B (e.g. normals)          : 2 x 1 bit  
  //Result Buffer Alignment / Padding : a1 a2 a3 0 b1 b2
  
	//{
    var idx   	     = 0;
    var n            = dataBufferView.length;
    
		var i, dataChunk, a1, a2, a3, b1, b2;
		
		for (i = 0; i < n; ++i) {		
			dataChunk = dataBufferView[i];
			
			a1   = (dataChunk & 0xC0) >>> 6;
			a1 <<= aPrecOff; 
			
			a2   = (dataChunk & 0x30) >>> 4;
			a2 <<= aPrecOff;
			
			a3 	 = (dataChunk & 0x0C) >>> 2;
			a3 <<= aPrecOff;
			
			resultBufferView[idx++] |= a1;
			resultBufferView[idx++] |= a2
			resultBufferView[idx++] |= a3;
      
      ++idx;
      
      b1   = (dataChunk & 0x02) >>> 1;
			b1 <<= bPrecOff;
			
			b2   = (dataChunk & 0x01);
			b2 <<= bPrecOff;
			
			resultBufferView[idx++] |= b1;
			resultBufferView[idx++] |= b2;
		}
	//}
};


x3dom.RefinementJobWorker.prototype.addBits_3x2_3x2_computeNormals = function(dataBufferView, resultBufferView, aPrecOff) {  
  //Optimized Decoding

  //Attrib. A (positions)             : 3 x 2 bit  
  //Attrib. B (normals)               : 16 bit, computed per triangle via dot product
  //Result Buffer Alignment / Padding : a1 a2 a3 0  b1 b2 b3 0
  
	//{
    var idx   	     = 0;
    var n            = dataBufferView.length;
    
		var i, dataChunk, a1, a2, a3, b1, b2, b3,
        points = 0, p = [], e1, e2, nor;
		
		for (i = 0; i < n; ++i) {		
			dataChunk = dataBufferView[i];
			
			a1   = (dataChunk & 0xC0) >>> 6;
			a1 <<= aPrecOff; 
			
			a2   = (dataChunk & 0x30) >>> 4;
			a2 <<= aPrecOff;
			
			a3 	 = (dataChunk & 0x0C) >>> 2;
			a3 <<= aPrecOff;
			
			resultBufferView[idx++] |= a1;
			resultBufferView[idx++] |= a2
			resultBufferView[idx++] |= a3;
      
      p[points] = [resultBufferView[idx-3],
                   resultBufferView[idx-2],
                   resultBufferView[idx-1]];
      
      ++idx;
      
      if (++points === 3) {
        points = 0;
        
        e1  = this.normalize(this.subtract(p[1], p[0]));
        e2  = this.normalize(this.subtract(p[2], p[0]));        
        nor = this.normalize(this.cross(e1, e2));
          
        b1 = nor[0] * 32767 + 32767;
        b2 = nor[1] * 32767 + 32767;
        b3 = nor[2] * 32767 + 32767;
        
        resultBufferView[idx        ] = b1;
        resultBufferView[idx+1      ] = b2;
        resultBufferView[idx+2      ] = b3;
                                 
        resultBufferView[idx   - 8  ] = b1;
        resultBufferView[idx+1 - 8  ] = b2;
        resultBufferView[idx+2 - 8  ] = b3;
                                 
        resultBufferView[idx   - 8*2] = b1;
        resultBufferView[idx+1 - 8*2] = b2;
        resultBufferView[idx+2 - 8*2] = b3;
      }
      
      idx+=4;
		}
	//}
};


x3dom.RefinementJobWorker.prototype.addBits = function(level, stride,
                                                       numComponentsList, bitsPerLevelList, readOffsetList, writeOffsetList,
                                                       dataBufferView, resultBufferView) {
  var i, j, c, nc, attributeLeftShift;
	var dataChunk;
	
	var componentMasksList  = [], componentMasks;
  var componentShiftsList = [], componentShifts;
  var precisionOffsetList = [], precisionOffset;
  
  var m = numComponentsList.length;
  
  var strideInElements = stride / (resultBufferView.BYTES_PER_ELEMENT * 8);
  
  var bitsPerComponentPerLevel;

	for (i = 0; i < m; ++i) {
		nc = numComponentsList[i];
	
    bitsPerComponentPerLevel = (bitsPerLevelList[i]/numComponentsList[i]);
    
    //@todo: check this for non-interleaved output
		attributeLeftShift 	    = (dataBufferView.BYTES_PER_ELEMENT * 8) - readOffsetList[i] - bitsPerComponentPerLevel * nc;    
		precisionOffsetList[i] = (resultBufferView.BYTES_PER_ELEMENT * 8) - bitsPerComponentPerLevel - (level * bitsPerComponentPerLevel);

    componentMasks  = [];
    componentShifts = [];
    
		for (c = 0; c < nc; ++c) {
			componentShifts[c] = attributeLeftShift + (nc - c - 1) * bitsPerComponentPerLevel;
			
			componentMasks[c]    = 0 | (Math.pow(2, bitsPerComponentPerLevel) - 1);
			componentMasks[c]  <<= componentShifts[c];
		}
    
    componentMasksList.push(componentMasks);
    componentShiftsList.push(componentShifts);
	}	
	
	var n = dataBufferView.length;	
		
	var baseIdx, idx;
		
	var component;
	
	for (j = 0; j < m; ++j) {
		nc		           = numComponentsList[j];
    //@todo: check this for non-interleaved output
		baseIdx		       = writeOffsetList[j] / (resultBufferView.BYTES_PER_ELEMENT * 8);
    componentMasks   = componentMasksList[j];
    componentShifts  = componentShiftsList[j];
    precisionOffset  = precisionOffsetList[j];
		
		for (i = 0; i < n; ++i) {
			dataChunk = dataBufferView[i];
			
			for (c = 0; c < nc; ++c) {
				component = dataChunk & componentMasks[c];			
				
				component >>>= componentShifts[c];
				component  <<= precisionOffset;
				
				idx = baseIdx + c;
        //@todo: check this for non-interleaved output
				resultBufferView[idx] |= component;
			}
			
      //@todo: check this for non-interleaved output
			baseIdx += strideInElements;
		}
  }
}


x3dom.RefinementJobWorker.prototype.toBlob = function () {
  var str = '';
  
  str += 'postMessage = (typeof webkitPostMessage !== "undefined") ? webkitPostMessage : postMessage;\n';

  for (var p in this) {
		if(this[p] != x3dom.RefinementJobWorker.prototype.toBlob) {
			str += p + ' = ';
			
			if (this[p] instanceof String) {
			  str += '"' + this[p] + '"';
			}
			else if (this[p] instanceof Array) {
				str += "[];\n";
			}
			else {
			  str += this[p] + ';\n';
			}
		}
  }
  
  var blob = new Blob([str]);
  return URL.createObjectURL(blob);
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


x3dom.Properties = function() {
    this.properties = {};
};

x3dom.Properties.prototype.setProperty = function(name, value) {
    x3dom.debug.logInfo("Properties: Setting property '"+ name + "' to value '" + value + "'");
    this.properties[name] = value;
};

x3dom.Properties.prototype.getProperty = function(name, def) {
    if (this.properties[name]) {
        return this.properties[name]
    } else {
        return def;
    }
};

x3dom.Properties.prototype.merge = function(other) {
    for (var attrname in other.properties) {
        this.properties[attrname] = other.properties[attrname];
    }
};

x3dom.Properties.prototype.toString = function() {
    var str = "";
    for (var name in this.properties) {
        str += "Name: " + name + " Value: " + this.properties[name] + "\n";
    }
    return str;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

x3dom.DoublyLinkedList = function() {
	this.length = 0;
	this.first = null;
	this.last = null;
};

x3dom.DoublyLinkedList.ListNode = function(point, point_index, normals, colors, texCoords) {
	this.point = point;
	this.point_index = point_index;
	this.normals = normals;
	this.colors = colors;
	this.texCoords = texCoords;
	this.next = null;
	this.prev = null;
};

x3dom.DoublyLinkedList.prototype.appendNode = function(node) {
  	if (this.first === null) {
    	node.prev = node;
    	node.next = node;
    	this.first = node;
    	this.last = node;
  	} else {
   	 	node.prev = this.last;
   	 	node.next = this.first;
   	 	this.first.prev = node;
    	this.last.next = node;
    	this.last = node;
  	}
  	this.length++;
};

x3dom.DoublyLinkedList.prototype.insertAfterNode = function(node, newNode) {
  	newNode.prev = node;
 	newNode.next = node.next;
  	node.next.prev = newNode;
  	node.next = newNode;
  	if (newNode.prev == this.last) { 
		this.last = newNode;
	}
  	this.length++;
};

x3dom.DoublyLinkedList.prototype.deleteNode = function(node) {
 	if (this.length > 1) {
		node.prev.next = node.next;
		node.next.prev = node.prev;
		if (node == this.first) {
			this.first = node.next;
		}
		if (node == this.last) {
			this.last = node.prev;
		}
	} else {
		this.first = null;
		this.last = null;
	}
	node.prev = null;
	node.next = null;
	this.length--;
};

x3dom.DoublyLinkedList.prototype.getNode = function(index) {
	var node = null;
	if(index > this.length) {
		return node;
	}
	for(var i = 0; i < this.length; i++) {
		if(i == 0) {
			node = this.first;
		} else {
			node = node.next;
		}
		if(i == index) {
			return node;
		}
	}
    return null;
};

x3dom.DoublyLinkedList.prototype.invert = function() {
	var tmp = null;
	var node = this.first;
	
	for(var i = 0; i < this.length; i++) {
		tmp = node.prev;
		node.prev =	node.next;
		node.next = tmp;
		node = node.prev;
	}
	tmp = this.first;
	this.first = this.last;
	this.last = tmp;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


x3dom.EarClipping = {
	
	reversePointDirection: function (linklist, plane) {
			var l, k;
			var count = 0;
			var z = 0;
			var nodei, nodel, nodek;
			
			if (linklist.length < 3) {
				return false;
			}
			
			for (var i = 0; i < linklist.length; i++) {
				l = (i + 1) % linklist.length;
				k = (i + 2) % linklist.length;
				
				nodei = linklist.getNode(i);
				nodel = linklist.getNode(l);
				nodek = linklist.getNode(k); 
							
				if(plane == 'YZ') {
					z  = (nodel.point.y - nodei.point.y) * (nodek.point.z - nodel.point.z);
					z -= (nodel.point.z - nodei.point.z) * (nodek.point.y - nodel.point.y);
				} else if(plane == 'XZ') {
					z  = (nodel.point.z - nodei.point.z) * (nodek.point.x - nodel.point.x);
					z -= (nodel.point.x - nodei.point.x) * (nodek.point.z - nodel.point.z);
				} else {
					z  = (nodel.point.x - nodei.point.x) * (nodek.point.y - nodel.point.y);
					z -= (nodel.point.y - nodei.point.y) * (nodek.point.x - nodel.point.x);
				}
				
				if (z < 0) {
					count--;
				} else {
					count++;
				}
			}
			
			if (count < 0) {
				linklist.invert();
				return true;
			}	
			return false;
	}, 

	getIndexes: function (linklist) {
		var node = linklist.first.next;
		var plane = this.identifyPlane(node.prev.point, node.point, node.next.point);
		
		var invers = this.reversePointDirection(linklist, plane);
		var indexes = [];
		node = linklist.first.next;
		var next = null;
		var count = 0;	
			
		var isEar = true;
		
		while(linklist.length >= 3 && count < 15) {
			next = node.next;
			for(var i = 0; i < linklist.length; i++) {
				if(this.isNotEar(linklist.getNode(i).point, node.prev.point, node.point, node.next.point, plane)) {
					isEar = false;
				}
			}
			
			if(isEar) {
				if(this.isKonvex(node.prev.point, node.point, node.next.point, plane)) {
					indexes.push(node.prev.point_index, node.point_index, node.next.point_index);
					linklist.deleteNode(node);
				} else {
					count++;
				}
			}

			node = next;
			isEar = true;
		}
		if(invers){
			return indexes.reverse();
		} else {
			return indexes;
		}
	},

	getMultiIndexes: function (linklist) {
		var node = linklist.first.next;
		var plane = this.identifyPlane(node.prev.point, node.point, node.next.point);
		var invers = this.reversePointDirection(linklist, plane);
		
		var data = {};
		data.indices = [];
		data.point = [];
		data.normals = [];
		data.colors = [];
		data.texCoords = [];
		node = linklist.first.next;
		var next = null;
		var count = 0;
			
		var isEar = true;
		while(linklist.length >= 3  && count < 15) {
			
			next = node.next;
			for(var i = 0; i < linklist.length; i++) {
				
			if(this.isNotEar(linklist.getNode(i).point, node.prev.point, node.point, node.next.point, plane)) {
					isEar = false;
				}
			}
			if(isEar) {
				
				if(this.isKonvex(node.prev.point, node.point, node.next.point, plane)) {				
					data.indices.push(node.prev.point_index, node.point_index, node.next.point_index);
					data.point.push(node.prev.point,
									node.point,
									node.next.point);
					if(node.normals) {					
						data.normals.push(node.prev.normals,
										  node.normals,
										  node.next.normals);
					
					}
					if(node.colors){
						data.colors.push(node.prev.colors,
										node.colors,
										node.next.colors);
					}
					if(node.texCoords){
						data.texCoords.push(node.prev.texCoords,
											node.texCoords,
											node.next.texCoords); 
					}
					linklist.deleteNode(node);
				}  else {
					count++;
				}
			}

			node = next;
			isEar = true;
		}
		
		if(invers){	
			data.indices = data.indices.reverse();
			data.point = data.point.reverse();
			data.normals = data.normals.reverse();
			data.colors = data.colors.reverse();
			data.texCoords = data.texCoords.reverse();
		}

		return data;
	}, 
	
	isNotEar: function (ap1, tp1, tp2, tp3, plane) {
		var b0, b1, b2, b3;
		var ap1a, ap1b, tp1a, tp1b, tp2a, tp2b, tp3a, tp3b;
		
		if(plane == 'YZ') {
			ap1a = ap1.y; ap1b = ap1.z;
			tp1a = tp1.y; tp1b = tp1.z;
			tp2a = tp2.y; tp2b = tp2.z;
			tp3a = tp3.y; tp3b = tp3.z;
		} else if(plane == 'XZ') {
			ap1a = ap1.z; ap1b = ap1.x;
			tp1a = tp1.z; tp1b = tp1.x;
			tp2a = tp2.z; tp2b = tp2.x;
			tp3a = tp3.z; tp3b = tp3.x;
		} else {
			ap1a = ap1.x; ap1b = ap1.y;
			tp1a = tp1.x; tp1b = tp1.y;
			tp2a = tp2.x; tp2b = tp2.y;
			tp3a = tp3.x; tp3b = tp3.y;
		}

        b0 = ((tp2a - tp1a) * (tp3b - tp1b) - (tp3a - tp1a) * (tp2b - tp1b));
        if (b0 != 0) {
            b1 = (((tp2a - ap1a) * (tp3b - ap1b) - (tp3a - ap1a) * (tp2b - ap1b)) / b0);
            b2 = (((tp3a - ap1a) * (tp1b - ap1b) - (tp1a - ap1a) * (tp3b - ap1b)) / b0);
            b3 = 1 - b1 - b2;

            return ((b1 > 0) && (b2 > 0) && (b3 > 0));
        }
        else {
            return false;
        }
    },

	isKonvex: function (p, p1, p2, plane) {
		var pa, pb, p1a, p1b, p2a, p2b;
		if(plane == 'YZ') {
			pa = p.y; pb = p.z;
			p1a = p1.y; p1b = p1.z;
			p2a = p2.y; p2b = p2.z;
		} else if(plane == 'XZ') {
			pa = p.z; pb = p.x;
			p1a = p1.z; p1b = p1.x;
			p2a = p2.z; p2b = p2.x;
		} else {
			pa = p.x; pb = p.y;
			p1a = p1.x; p1b = p1.y;
			p2a = p2.x; p2b = p2.y;
		}
		
		var l = ((p1a - pa) * (p2b - pb) - (p1b - pb) * (p2a - pa));
        return (l >= 0);
	},
	
	identifyPlane: function(p1, p2, p3) {
		var v1x, v1y, v1z;
		var v2x, v2y, v2z;
		var v3x, v3y, v3z;
	
		v1x = p2.x - p1.x; v1y = p2.y - p1.y; v1z = p2.z - p1.z;
		v2x = p3.x - p1.x; v2y = p3.y - p1.y; v2z = p3.z - p1.z;
		
		v3x = Math.abs(v1y*v2z - v1z*v2y);
		v3y = Math.abs(v1z*v2x - v1x*v2z);
		v3z = Math.abs(v1x*v2y - v1y*v2x);
		
		var angle = Math.max(v3x, v3y, v3z);
		
		if(angle == v3x) {
			return 'YZ';
		} else if(angle == v3y) {
			return 'XZ';
		} else if(angle == v3z) {
			return 'XY';
		} else {
			return 'XZ';    // error
		}
	}
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/*****************************************************************************
* Utils class holds utility functions for renderer
*****************************************************************************/
x3dom.Utils = {};

x3dom.Utils.maxIndexableCoords = 65535;
x3dom.Utils.measurements = [];


// http://gent.ilcore.com/2012/06/better-timer-for-javascript.html
window.performance = window.performance || {};
performance.now = (function () {
    return performance.now ||
           performance.mozNow ||
           performance.msNow ||
           performance.oNow ||
           performance.webkitNow ||
           function () {
               return new Date().getTime();
           };
})();

x3dom.Utils.startMeasure = function (name) {
    var uname = name.toUpperCase();
    if (!x3dom.Utils.measurements[uname]) {
        if (performance && performance.now) {
            x3dom.Utils.measurements[uname] = performance.now();
        } else {
            x3dom.Utils.measurements[uname] = new Date().getTime();
        }
    }
};

x3dom.Utils.stopMeasure = function (name) {
    var uname = name.toUpperCase();
    if (x3dom.Utils.measurements[uname]) {
        var startTime = x3dom.Utils.measurements[uname];
        delete x3dom.Utils.measurements[uname];
        if (performance && performance.now) {
            return performance.now() - startTime;
        } else {
            return new Date().getTime() - startTime;
        }
    }
    return 0;
};

/*****************************************************************************
 *
 *****************************************************************************/
x3dom.Utils.isNumber = function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
};

/*****************************************************************************
* 
*****************************************************************************/
x3dom.Utils.createTexture2D = function(gl, doc, src, bgnd, withCredentials, scale)
{
	var texture = gl.createTexture();

    //Create a black 4 pixel texture to prevent 'texture not complete' warning
    var data = new Uint8Array([0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255]);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
    gl.bindTexture(gl.TEXTURE_2D, null);

    texture.ready = false;
	
	if (src == null || src == '')
	    return texture;
	
	var image = new Image();
	image.crossOrigin = withCredentials ? 'use-credentials' : '';
	image.src = src;
	
	doc.downloadCount++;	
	
	image.onload = function() {
        if (scale)
		    image = x3dom.Utils.scaleImage( image );
		
		if(bgnd == true) {
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		}
		gl.bindTexture(gl.TEXTURE_2D, texture);
		//gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
		gl.bindTexture(gl.TEXTURE_2D, null);
		if(bgnd == true) {
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
		}
		
		//Save image size
		texture.width  = image.width;
		texture.height = image.height;
		texture.ready = true;
		
		doc.downloadCount--;
		doc.needRender = true;
	};
	
	image.onerror = function() {
		x3dom.debug.logError("[Utils|createTexture2D] Can't load Image: " + src);
		doc.downloadCount--;
	};
	
	return texture;
};

/*****************************************************************************
* 
*****************************************************************************/
x3dom.Utils.createTextureCube = function(gl, doc, url, bgnd, withCredentials, scale)
{
	var texture = gl.createTexture();

	var faces;
	if (bgnd) {
		faces = [gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 
				 gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 
				 gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X];
	}
	else
	{
		//       back, front, bottom, top, left, right
		faces = [gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
				 gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
				 gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_X];
	}

    texture.ready = false;
    texture.pendingTextureLoads = -1;
    texture.textureCubeReady = false;

    var width = 0, height = 0;

	for (var i=0; i<faces.length; i++) {
		var face = faces[i];

		var image = new Image();
		image.crossOrigin = withCredentials ? 'use-credentials' : '';
		texture.pendingTextureLoads++;
		doc.downloadCount++;
		
		image.onload = (function(texture, face, image, swap) {
			return function() {
				if (width == 0 && height == 0) {
					width = image.width;
					height = image.height;
				}
				else if (scale && (width != image.width || height != image.height)) {
					x3dom.debug.logWarning("[Utils|createTextureCube] Rescaling CubeMap images, which are of different size!");
					image = x3dom.Utils.rescaleImage(image, width, height);
				}
				
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, swap);
				gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
				gl.texImage2D(face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
				gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
				
				texture.pendingTextureLoads--;
				doc.downloadCount--;

				if (texture.pendingTextureLoads < 0) {
                    //Save image size also for cube tex
                    texture.width  = width;
                    texture.height = height;
					texture.textureCubeReady = true;
					x3dom.debug.logInfo("[Utils|createTextureCube] Loading CubeMap finished...");
					doc.needRender = true;
				}
			};
		})( texture, face, image, bgnd );

		image.onerror = function()
		{
			doc.downloadCount--;

			x3dom.debug.logError("[Utils|createTextureCube] Can't load CubeMap!");
		};
		
		// backUrl, frontUrl, bottomUrl, topUrl, leftUrl, rightUrl (for bgnd)
		image.src = url[i];
	}
	
	return texture;
};

/*****************************************************************************
* 
*****************************************************************************/
x3dom.Utils.getFileName = function(url)
{
	var filename;
	
	if( url.lastIndexOf("/") > -1 ) {
		filename = url.substr( url.lastIndexOf("/") + 1 );
	}
	else if( url.lastIndexOf("\\") > -1 ) {
		filename = url.substr( url.lastIndexOf("\\") + 1 );
	}
	else {
		filename = url;
	}

	return filename;
};

/*****************************************************************************
* 
*****************************************************************************/
x3dom.Utils.findTextureByName = function(texture, name)
{
	for ( var i=0; i<texture.length; ++i )
	{
		if ( name == texture[i].samplerName )
			return texture[i];
	}
	return false;
};

/*****************************************************************************
* Rescale image to given size
*****************************************************************************/
x3dom.Utils.rescaleImage = function(image, width, height)
{
	var canvas = document.createElement("canvas");
	canvas.width = width; canvas.height = height;
	canvas.getContext("2d").drawImage(image,
				0, 0, image.width, image.height,
				0, 0, canvas.width, canvas.height);
	return canvas;
};

/*****************************************************************************
* Scale image to next best power of two
*****************************************************************************/
x3dom.Utils.scaleImage = function(image)
{
	if (!x3dom.Utils.isPowerOfTwo(image.width) || !x3dom.Utils.isPowerOfTwo(image.height)) {
		var canvas = document.createElement("canvas");
		canvas.width = x3dom.Utils.nextHighestPowerOfTwo(image.width);
		canvas.height = x3dom.Utils.nextHighestPowerOfTwo(image.height);
		var ctx = canvas.getContext("2d");
		ctx.drawImage(image,
					  0, 0, image.width, image.height,
					  0, 0, canvas.width, canvas.height);
		image = canvas;
	}
	return image;
};


/*****************************************************************************
* Check if value is power of two
*****************************************************************************/
x3dom.Utils.isPowerOfTwo = function(x) 
{
	return ((x & (x - 1)) === 0);
};


/*****************************************************************************
* Return next highest power of two
*****************************************************************************/
x3dom.Utils.nextHighestPowerOfTwo = function(x) 
{
	--x;
	for (var i = 1; i < 32; i <<= 1) {
		x = x | x >> i;
	}
	return (x + 1);
};


/*****************************************************************************
* Return next best power of two
*****************************************************************************/
x3dom.Utils.nextBestPowerOfTwo = function(x)
{
    // use precomputed log(2.0) = 0.693147180559945
	var log2x = Math.log(x) / 0.693147180559945;
	return Math.pow(2, Math.round(log2x));
};

/*****************************************************************************
* Return data type size in byte
*****************************************************************************/
x3dom.Utils.getDataTypeSize = function(type) 
{
	switch(type)
	{
		case "Int8":
		case "Uint8":
			return 1;
		case "Int16":
		case "Uint16":
			return 2;
		case "Int32":
		case "Uint32":
		case "Float32":
			return 4;
		case "Float64":
		default:
			return 8;
	}
};

/*****************************************************************************
 * Return offset multiplier (Uint32 is twice as big as Uint16)
 *****************************************************************************/
x3dom.Utils.getOffsetMultiplier = function(indexType, gl)
{
    switch(indexType)
    {
        case gl.UNSIGNED_SHORT:
            return 1;
        case gl.UNSIGNED_INT:
            return 2;
        case gl.UNSIGNED_BYTE:
            return 0.5;
        default:
            return 1;
    }
};

/*****************************************************************************
 * Return byte aware offset
 *****************************************************************************/
x3dom.Utils.getByteAwareOffset = function(offset, indexType, gl)
{
    switch(indexType)
    {
        case gl.UNSIGNED_SHORT:
            return 2 * offset;
        case gl.UNSIGNED_INT:
            return 4 * offset;
        case gl.UNSIGNED_BYTE:
            return offset;
        default:
            return 2 * offset;
    }
};

/*****************************************************************************
* Return this.gl-Type
*****************************************************************************/
x3dom.Utils.getVertexAttribType = function(type, gl)
{
	var dataType = gl.NONE;

	switch(type)
	{
		case "Int8":
			dataType = gl.BYTE;
			break;
		case "Uint8":
			dataType = gl.UNSIGNED_BYTE;
			break;
		case "Int16":
			dataType = gl.SHORT;
			break;
		case "Uint16":
			dataType = gl.UNSIGNED_SHORT;
			break;
		case "Int32":
			dataType = gl.INT;
			break;
		case "Uint32":
			dataType = gl.UNSIGNED_INT;
			break;
		case "Float32":
			dataType = gl.FLOAT;
			break;
		case "Float64":
		default:
			x3dom.debug.logError("Can't find this.gl data type for " + type + ", getting FLOAT...");
			dataType = gl.FLOAT;
			break;
	}

	return dataType;
};

/*****************************************************************************
* Return TypedArray View
*****************************************************************************/
x3dom.Utils.getArrayBufferView = function(type, buffer)
{
	var array = null;
	
	switch(type)
	{
		case "Int8":
			array = new Int8Array(buffer);
			break;
		case "Uint8":
			array = new Uint8Array(buffer);
			break;
		case "Int16":
			array = new Int16Array(buffer);
			break;
		case "Uint16":
			array = new Uint16Array(buffer);
			break;
		case "Int32":
			array = new Int32Array(buffer);
			break;
		case "Uint32":
			array = new Uint32Array(buffer);
			break;
		case "Float32":
			array = new Float32Array(buffer);
			break;
		case "Float64":
			array = new Float64Array(buffer);
			break;
		default:
			x3dom.debug.logError("Can't create typed array view of type " + type + ", trying Float32...");
			array = new Float32Array(buffer);
			break;
	}

	return array;
};

/*****************************************************************************
* Checks whether a TypedArray View Type with the given name string is unsigned
*****************************************************************************/
x3dom.Utils.isUnsignedType = function (str)
{
  return (str == "Uint8" || str == "Uint16" || str == "Uint16" || str == "Uint32");
};


/*****************************************************************************
* Checks for lighting
*****************************************************************************/
x3dom.Utils.checkDirtyLighting = function (viewarea)
{
	return (viewarea.getLights().length + viewarea._scene.getNavigationInfo()._vf.headlight);
};

/*****************************************************************************
* Get GL min filter
*****************************************************************************/
x3dom.Utils.minFilterDic = function(gl, minFilter)
{
	switch(minFilter.toUpperCase())
	{
		case "NEAREST":                      return gl.NEAREST;
		case "LINEAR":                       return gl.LINEAR;
		case "NEAREST_MIPMAP_NEAREST":       return gl.NEAREST_MIPMAP_NEAREST;
		case "NEAREST_MIPMAP_LINEAR":        return gl.NEAREST_MIPMAP_LINEAR;
		case "LINEAR_MIPMAP_NEAREST":        return gl.LINEAR_MIPMAP_NEAREST;
		case "LINEAR_MIPMAP_LINEAR":         return gl.LINEAR_MIPMAP_LINEAR;
		case "AVG_PIXEL":                    return gl.LINEAR;
		case "AVG_PIXEL_AVG_MIPMAP":         return gl.LINEAR_MIPMAP_LINEAR;
		case "AVG_PIXEL_NEAREST_MIPMAP":     return gl.LINEAR_MIPMAP_NEAREST;
		case "DEFAULT":                      return gl.LINEAR_MIPMAP_LINEAR;
		case "FASTEST":                      return gl.NEAREST;
		case "NEAREST_PIXEL":                return gl.NEAREST;
		case "NEAREST_PIXEL_AVG_MIPMAP":     return gl.NEAREST_MIPMAP_LINEAR;
		case "NEAREST_PIXEL_NEAREST_MIPMAP": return gl.NEAREST_MIPMAP_NEAREST;
		case "NICEST":                       return gl.LINEAR_MIPMAP_LINEAR;
		default:							 return gl.LINEAR;
	}
};

/*****************************************************************************
* Get GL mag filter
*****************************************************************************/
x3dom.Utils.magFilterDic = function(gl, magFilter)
{
	switch(magFilter.toUpperCase())
	{
		case "NEAREST": 		return gl.NEAREST;
		case "LINEAR":			return gl.LINEAR;
		case "AVG_PIXEL":		return gl.LINEAR;
		case "DEFAULT":			return gl.LINEAR;
		case "FASTEST":			return gl.NEAREST;
		case "NEAREST_PIXEL":	return gl.NEAREST;
		case "NICEST":			return gl.LINEAR;
		default:				return gl.LINEAR;
	}
};

/*****************************************************************************
* Get GL boundary mode
*****************************************************************************/
x3dom.Utils.boundaryModesDic = function(gl, mode) 
{
	switch(mode.toUpperCase())
	{
		case "CLAMP":             return gl.CLAMP_TO_EDGE;
		case "CLAMP_TO_EDGE":     return gl.CLAMP_TO_EDGE;
		case "CLAMP_TO_BOUNDARY": return gl.CLAMP_TO_EDGE;       
		case "MIRRORED_REPEAT":   return gl.MIRRORED_REPEAT;
		case "REPEAT":            return gl.REPEAT;
		default:				  return gl.REPEAT;
	}
};

/*****************************************************************************
 * Get GL primitive type
 *****************************************************************************/
x3dom.Utils.primTypeDic = function(gl, type)
{
    switch(type.toUpperCase())
    {
        case "POINTS":        return gl.POINTS;
        case "LINES":         return gl.LINES;
        case "LINELOOP":      return gl.LINE_LOOP;
        case "LINESTRIP":     return gl.LINE_STRIP;
        case "TRIANGLES":     return gl.TRIANGLES;
        case "TRIANGLESTRIP": return gl.TRIANGLE_STRIP;
        case "TRIANGLEFAN":   return gl.TRIANGLE_FAN;
        default:              return gl.TRIANGLES;
    }
};

/*****************************************************************************
* Get GL depth function
*****************************************************************************/
x3dom.Utils.depthFunc = function(gl, func) 
{
	switch(func.toUpperCase())
	{ 
		case "NEVER":             return gl.NEVER;
		case "ALWAYS":            return gl.ALWAYS;
		case "LESS":              return gl.LESS;       
		case "EQUAL":             return gl.EQUAL;
		case "LEQUAL":            return gl.LEQUAL;
        case "GREATER":           return gl.GREATER;
        case "GEQUAL":            return gl.GEQUAL;
        case "NOTEQUAL":          return gl.NOTEQUAL;
		default:				  return gl.LEQUAL;
	}
};

/*****************************************************************************
 * Get GL blend function
 *****************************************************************************/
x3dom.Utils.blendFunc = function(gl, func)
{
    switch(func.toLowerCase())
    {
        case "zero":                        return gl.ZERO;
        case "one":                         return gl.ONE;
        case "dst_color":                   return gl.DST_COLOR;
        case "dst_alpha":                   return gl.DST_ALPHA;
        case "src_color":                   return gl.SRC_COLOR;
        case "src_alpha":                   return gl.SRC_ALPHA;
        case "one_minus_dst_color":         return gl.ONE_MINUS_DST_COLOR;
        case "one_minus_dst_alpha":         return gl.ONE_MINUS_DST_ALPHA;
        case "one_minus_src_color":         return gl.ONE_MINUS_SRC_COLOR;
        case "one_minus_src_alpha":         return gl.ONE_MINUS_SRC_ALPHA;
        case "src_alpha_saturate":          return gl.SRC_ALPHA_SATURATE;
        case "constant_color":              return gl.CONSTANT_COLOR;
        case "constant_alpha":              return gl.CONSTANT_ALPHA;
        case "one_minus_constant_color":    return gl.ONE_MINUS_CONSTANT_COLOR;
        case "one_minus_constant_alpha":    return gl.ONE_MINUS_CONSTANT_ALPHA;
        default:				            return 0;
    }
};

/*****************************************************************************
 * Get GL blend equations
 *****************************************************************************/
x3dom.Utils.blendEquation = function(gl, func)
{
    switch(func.toLowerCase())
    {
        case "func_add":                return gl.FUNC_ADD;
        case "func_subtract":           return gl.FUNC_SUBTRACT;
        case "func_reverse_subtract":   return gl.FUNC_REVERSE_SUBTRACT;
        case "min":                     return 0;  //Not supported yet
        case "max":                     return 0;  //Not supported yet
        case "logic_op":                return 0;  //Not supported yet
        default:				        return 0;
    }
};

/*****************************************************************************
* 
*****************************************************************************/
x3dom.Utils.generateProperties = function (viewarea, shape) 
{
	var property = {};

	var geometry 	= shape._cf.geometry.node;
	var appearance 	= shape._cf.appearance.node;
	var texture 	= appearance ? appearance._cf.texture.node : null;
	var material    = appearance ? appearance._cf.material.node : null;
    var environment = viewarea._scene.getEnvironment();

	//Check if it's a composed shader
	if (appearance && appearance._shader &&
        x3dom.isa(appearance._shader, x3dom.nodeTypes.ComposedShader)) {

		property.CSHADER          = shape._objectID;
	}
    else if (geometry) {

        property.CSHADER          = -1;
        property.SOLID            = (shape.isSolid()) ? 1 : 0;
        property.TEXT             = (x3dom.isa(geometry, x3dom.nodeTypes.Text)) ? 1 : 0;
        property.POPGEOMETRY      = (x3dom.isa(geometry, x3dom.nodeTypes.PopGeometry)) ? 1 : 0;
        property.BITLODGEOMETRY   = (x3dom.isa(geometry, x3dom.nodeTypes.BitLODGeometry)) ? 1 : 0;
        property.IMAGEGEOMETRY    = (x3dom.isa(geometry, x3dom.nodeTypes.ImageGeometry))  ? 1 : 0;
        property.IG_PRECISION     = (property.IMAGEGEOMETRY) ? geometry.numCoordinateTextures() : 0;
        property.IG_INDEXED       = (property.IMAGEGEOMETRY && geometry.getIndexTexture() != null) ? 1 : 0;
        property.POINTLINE2D      = x3dom.isa(geometry, x3dom.nodeTypes.PointSet) ||
                                    x3dom.isa(geometry, x3dom.nodeTypes.IndexedLineSet) ||
                                    x3dom.isa(geometry, x3dom.nodeTypes.Polypoint2D) ||
                                    x3dom.isa(geometry, x3dom.nodeTypes.Polyline2D) ||
                                    x3dom.isa(geometry, x3dom.nodeTypes.Arc2D) ||
                                    x3dom.isa(geometry, x3dom.nodeTypes.Circle2D) ? 1 : 0;
        
        property.APPMAT           = (appearance && (material || property.CSSHADER) ) ? 1 : 0;
        property.SHADOW           = (viewarea.getLightsShadow()) ? 1 : 0;
        property.FOG              = (viewarea._scene.getFog()._vf.visibilityRange > 0) ? 1 : 0;
        property.CSSHADER         = (appearance && appearance._shader &&
                                     x3dom.isa(appearance._shader, x3dom.nodeTypes.CommonSurfaceShader)) ? 1 : 0;
        property.LIGHTS           = (!property.POINTLINE2D && appearance && (material || property.CSSHADER)) ?
                                     viewarea.getLights().length + (viewarea._scene.getNavigationInfo()._vf.headlight) : 0;
        property.TEXTURED         = (texture || property.TEXT) ? 1 : 0;
        property.TEXTRAFO         = (appearance && appearance._cf.textureTransform.node) ? 1 : 0;
        property.DIFFUSEMAP       = (property.CSSHADER && appearance._shader.getDiffuseMap()) ? 1 : 0;
        property.NORMALMAP        = (property.CSSHADER && appearance._shader.getNormalMap()) ? 1 : 0;
        property.SPECMAP          = (property.CSSHADER && appearance._shader.getSpecularMap()) ? 1 : 0;
        property.DISPLACEMENTMAP  = (property.CSSHADER && appearance._shader.getDisplacementMap()) ? 1 : 0;
        property.DIFFPLACEMENTMAP = (property.CSSHADER && appearance._shader.getDiffuseDisplacementMap()) ? 1 : 0;
        property.CUBEMAP          = (texture && x3dom.isa(texture, x3dom.nodeTypes.X3DEnvironmentTextureNode)) ? 1 : 0;
        property.BLENDING         = (property.TEXT || property.CUBEMAP || (texture && texture._blending)) ? 1 : 0;
        property.REQUIREBBOX      = (geometry._vf.coordType !== undefined && geometry._vf.coordType != "Float32") ? 1 : 0;
        property.REQUIREBBOXNOR   = (geometry._vf.normalType !== undefined && geometry._vf.normalType != "Float32") ? 1 : 0;
        property.REQUIREBBOXCOL   = (geometry._vf.colorType !== undefined && geometry._vf.colorType != "Float32") ? 1 : 0;
        property.REQUIREBBOXTEX   = (geometry._vf.texCoordType !== undefined && geometry._vf.texCoordType != "Float32") ? 1 : 0;    
        property.COLCOMPONENTS    = geometry._mesh._numColComponents;
        property.NORCOMPONENTS    = geometry._mesh._numNormComponents;
        property.POSCOMPONENTS    = geometry._mesh._numPosComponents;
        property.SPHEREMAPPING    = (geometry._cf.texCoord !== undefined && geometry._cf.texCoord.node !== null &&
                                     geometry._cf.texCoord.node._vf.mode &&
                                     geometry._cf.texCoord.node._vf.mode.toLowerCase() == "sphere") ? 1 : 0;
        property.VERTEXCOLOR      = (geometry._mesh._colors[0].length > 0 ||
                                     (property.IMAGEGEOMETRY && geometry.getColorTexture()) ||
                                     (property.BITLODGEOMETRY && geometry.hasColor()) ||
                                     (property.POPGEOMETRY    && geometry.hasColor()) ||
                                     (geometry._vf.color !== undefined && geometry._vf.color.length > 0)) ? 1 : 0;
        property.GAMMACORRECTION  = environment._vf.gammaCorrectionDefault;
	}
	
	property.toIdentifier = function() { 
		var id = "";
		for(var p in this) { 
			if(this[p] != this.toIdentifier && this[p] != this.toString) {
				id += this[p];
			}
		}
        this.id = id;
		return id;
	};
	
	property.toString = function() { 
		var str = "";
		for(var p in this) { 
			if(this[p] != this.toIdentifier && this[p] != this.toString) {
				str += p + ": " + this[p] + ", ";
			}
		}
		return str;
	};

    property.toIdentifier();

	return property;
};

/*****************************************************************************
* Returns "shader" such that "shader.foo = [1,2,3]" magically sets the 
* appropriate uniform
*****************************************************************************/
x3dom.Utils.wrapProgram = function (gl, program, shaderID)
{
	var shader = {
        shaderID: shaderID,
        program: program
    };
        
	shader.bind = function () { 
		gl.useProgram(program); 
	};

	var loc = null;
	var obj = null;
	var i, glErr;

    // get uniforms
	var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
	
	for (i=0; i < numUniforms; ++i) {
		try {
			obj = gl.getActiveUniform(program, i);
		}
		catch (eu) {
            if (!obj) continue;
        }

        glErr = gl.getError();
        if (glErr) {
            x3dom.debug.logError("GL-Error (on searching uniforms): " + glErr);
        }

		loc = gl.getUniformLocation(program, obj.name);	
		
		switch (obj.type) {
			case gl.SAMPLER_2D:
				shader.__defineSetter__(obj.name, 
					(function (loc) { return function (val) { gl.uniform1i(loc, val); }; })(loc));
				break;
			case gl.SAMPLER_CUBE:
				shader.__defineSetter__(obj.name, 
					(function (loc) { return function (val) { gl.uniform1i(loc, val); }; })(loc));
				break;
			case gl.BOOL:
				shader.__defineSetter__(obj.name, 
					(function (loc) { return function (val) { gl.uniform1i(loc, val); }; })(loc));
				break;
			case gl.FLOAT:
                /*
                 * Passing a MFFloat type into uniform.
                 * by Sofiane Benchaa, 2012.
                 * 
                 * Based on OpenGL specification.
                 * url: http://www.opengl.org/sdk/docs/man/xhtml/glGetUniformLocation.xml 
                 *
                 * excerpt : Except if the last part of name indicates a uniform variable array, 
                 * the location of the first element of an array can be retrieved by using the name of the array, 
                 * or by using the name appended by "[0]".
                 * 
                 * Detecting the float array and extracting its uniform name without the brackets.
                 */
				if (obj.name.indexOf("[0]") != -1)
					shader.__defineSetter__(obj.name.substring(0, obj.name.length-3), 
						(function (loc) { return function (val) { gl.uniform1fv(loc, new Float32Array(val)); }; })(loc));
				else
					shader.__defineSetter__(obj.name, 
						(function (loc) { return function (val) { gl.uniform1f(loc, val); }; })(loc));
                break;
			case gl.FLOAT_VEC2:
				shader.__defineSetter__(obj.name, 
					(function (loc) { return function (val) { gl.uniform2f(loc, val[0], val[1]); }; })(loc));           
				break;
			case gl.FLOAT_VEC3:
				shader.__defineSetter__(obj.name, 
					(function (loc) { return function (val) { gl.uniform3f(loc, val[0], val[1], val[2]); }; })(loc));
				break;
			case gl.FLOAT_VEC4:
				shader.__defineSetter__(obj.name, 
					(function (loc) { return function (val) { gl.uniform4f(loc, val[0], val[1], val[2], val[3]); }; })(loc));
				break;
			case gl.FLOAT_MAT2:
				shader.__defineSetter__(obj.name, 
					(function (loc) { return function (val) { gl.uniformMatrix2fv(loc, false, new Float32Array(val)); }; })(loc));
				break;
			case gl.FLOAT_MAT3:
				shader.__defineSetter__(obj.name, 
					(function (loc) { return function (val) { gl.uniformMatrix3fv(loc, false, new Float32Array(val)); }; })(loc));
				break;
			case gl.FLOAT_MAT4:
				shader.__defineSetter__(obj.name, 
					(function (loc) { return function (val) { gl.uniformMatrix4fv(loc, false, new Float32Array(val)); }; })(loc));
				break;
			case gl.INT:
				shader.__defineSetter__(obj.name,
					(function (loc) { return function (val) { gl.uniform1i(loc, val); }; }) (loc));
				break;
			default:
				x3dom.debug.logWarning('GLSL program variable '+obj.name+' has unknown type '+obj.type);
		}
	}

    // get attributes
	var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
	
	for (i=0; i < numAttribs; ++i) {
		try {
			obj = gl.getActiveAttrib(program, i);
		}
		catch (ea) {
            if (!obj) continue;
        }

        glErr = gl.getError();
        if (glErr) {
            x3dom.debug.logError("GL-Error (on searching attributes): " + glErr);
        }

		loc = gl.getAttribLocation(program, obj.name);
		shader[obj.name] = loc;
	}

	return shader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * States namespace
 */
x3dom.States = function (x3dElem) {
    var that = this;
    this.active = false;

    this.viewer = document.createElement('div');
    this.viewer.id = 'x3dom-state-viewer';

    var title = document.createElement('div');
    title.className = 'x3dom-states-head';
    //title.appendChild(document.createTextNode('x3dom'));

    var subTitle = document.createElement('span');
    subTitle.className = 'x3dom-states-head2';
    //subTitle.appendChild(document.createTextNode('stats'));
    title.appendChild(subTitle);

    this.measureList = document.createElement('ul');
    this.measureList.className = 'x3dom-states-list';

    this.infoList = document.createElement('ul');
    this.infoList.className = 'x3dom-states-list';

    this.viewer.appendChild(title);
    this.viewer.appendChild(this.measureList);
    this.viewer.appendChild(this.infoList);

    /**
     *
     */
    this.disableContextMenu = function (e) {
        e.preventDefault();
        e.stopPropagation();
        e.returnValue = false;
        return false;
    };

    /**
     *
     */
    this.thousandSeperator = function (value) {
        return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    };

    /**
     *
     */
    this.toFixed = function (value) {
        var fixed = (value < 1) ? 2 : (value < 10) ? 2 : 2;
        return value.toFixed(fixed);
    };

    /**
     *
     */
    this.update = function () {
        var infos = x3dElem.runtime.states.infos;
        var measurements = x3dElem.runtime.states.measurements;

        //Clear measure list
        this.measureList.innerHTML = "";

        //Create list items
        for (var m in measurements) {
            if (!measurements.hasOwnProperty(m)) {
                continue;
            }

            infoItem = document.createElement('li');
            infoItem.className = 'x3dom-states-item';

            infoTitle = document.createElement('div');
            infoTitle.className = 'x3dom-states-item-title';
            infoTitle.appendChild(document.createTextNode(m));

            infoValue = document.createElement('div');
            infoValue.className = 'x3dom-states-item-value';
            infoValue.appendChild(document.createTextNode(this.toFixed(measurements[m])));

            infoItem.appendChild(infoTitle);
            infoItem.appendChild(infoValue);

            this.measureList.appendChild(infoItem);
        }

        //Clear info list
        this.infoList.innerHTML = "";

        //Create list items
        for (var i in infos) {
            var infoItem = document.createElement('li');
            infoItem.className = 'x3dom-states-item';

            var infoTitle = document.createElement('div');
            infoTitle.className = 'x3dom-states-item-title';
            infoTitle.appendChild(document.createTextNode(i));

            var infoValue = document.createElement('div');
            infoValue.className = 'x3dom-states-item-value';
            infoValue.appendChild(document.createTextNode(this.thousandSeperator(infos[i])));

            infoItem.appendChild(infoTitle);
            infoItem.appendChild(infoValue);

            this.infoList.appendChild(infoItem);
        }
    };

    window.setInterval(function () {
        that.update();
    }, 1000);

    this.viewer.addEventListener("contextmenu", that.disableContextMenu);
};

/**
 *
 */
x3dom.States.prototype.display = function (value) {
    this.active = (value !== undefined) ? value : !this.active;
    this.viewer.style.display = (this.active) ? "block" : "none";
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Manage all the GL-States and try to reduce the state changes
 */
x3dom.StateManager = function (ctx3d)
{
    //Our GL-Context
    this.gl = ctx3d;

    //Hold all the active states
    this.states = [];

    //Initialize States
    this.initStates();
};

/*
 * Initialize States
 */
x3dom.StateManager.prototype.initStates = function ()
{
    //Initialize Shader states
    this.states['shaderID'] = null;

    //Initialize Framebuffer-Operation states
    this.states['colorMask'] = {red: null, green: null, blue: null, alpha: null};
    this.states['depthMask'] = null;
    this.states['stencilMask'] = null;

    //Initialize Rasterization states
    this.states['cullFace'] = null;
    this.states['frontFace'] = null;
    this.states['lineWidth'] = null;

    //Initialize Per-Fragment-Operation states
    this.states['blendColor'] = {red: null, green: null, blue: null, alpha: null};
    this.states['blendEquation'] = null;
    this.states['blendEquationSeparate'] = {modeRGB: null, modeAlpha: null};
    this.states['blendFunc'] = {sfactor: null, dfactor: null};
    this.states['blendFuncSeparate'] = {srcRGB: null, dstRGB: null, srcAlpha: null, dstAlpha: null};
    this.states['depthFunc'] = null;

    //Initialize View and Clip states
    this.states['viewport'] = {x: null, y: null, width: null, height: null};
    this.states['depthRange'] = {zNear: null, zFar: null};

    //TODO more states (e.g. stencil, texture, ...)
};

/*
 * Only bind program if different (returns true if changed)
 */
x3dom.StateManager.prototype.useProgram = function (shader)
{
    if (this.states['shaderID'] != shader.shaderID)
    {
        this.gl.useProgram(shader.program);
        this.states['shaderID'] = shader.shaderID;
        return true;
    }
    return false;
};

/*
 * Unset active program for clean init state
 */
x3dom.StateManager.prototype.unsetProgram = function ()
{
    this.states['shaderID'] = null;
};

/*
 * Enable GL capabilities
 */
x3dom.StateManager.prototype.enable = function (cap)
{
    if (this.states[cap] !== true)
    {
        this.gl.enable(cap);
        this.states[cap] = true;
    }
};

/*
 * Disable GL capabilities
 */
x3dom.StateManager.prototype.disable = function (cap)
{
    if (this.states[cap] !== false)
    {
        this.gl.disable(cap);
        this.states[cap] = false;
    }
};

/*
 * Enable and disable writing of frame buffer color components
 */
x3dom.StateManager.prototype.colorMask = function (red, green, blue, alpha)
{
    if (this.states['colorMask'].red != red ||
        this.states['colorMask'].green != green ||
        this.states['colorMask'].blue != blue ||
        this.states['colorMask'].alpha != alpha)
    {
        this.gl.colorMask(red, green, blue, alpha);
        this.states['colorMask'].red = red;
        this.states['colorMask'].green = green;
        this.states['colorMask'].blue = blue;
        this.states['colorMask'].alpha = alpha;
    }
};

/*
 * Sets whether or not you can write to the depth buffer.
 */
x3dom.StateManager.prototype.depthMask = function (flag)
{
    if (this.states['depthMask'] != flag)
    {
        this.gl.depthMask(flag);
        this.states['depthMask'] = flag;
    }
};

/*
 * Control the front and back writing of individual bits in the stencil planes
 */
x3dom.StateManager.prototype.stencilMask = function (mask)
{
    if (this.states['stencilMask'] != mask)
    {
        this.gl.stencilMask(mask);
        this.states['stencilMask'] = mask;
    }
};

/*
 * Specify whether front- or back-facing facets can be culled
 */
x3dom.StateManager.prototype.cullFace = function (mode)
{
    if (this.states['cullFace'] != mode)
    {
        this.gl.cullFace(mode);
        this.states['cullFace'] = mode;
    }
};

/*
 * Define front- and back-facing polygons
 */
x3dom.StateManager.prototype.frontFace = function (mode)
{
    if (this.states['frontFace'] != mode)
    {
        this.gl.frontFace(mode);
        this.states['frontFace'] = mode;
    }
};

/*
 * Specify the width of rasterized lines
 */
x3dom.StateManager.prototype.lineWidth = function (width)
{
    width = (width <= 1) ? 1 : width;

    if (this.states['lineWidth'] != width)
    {
        this.gl.lineWidth(width);
        this.states['lineWidth'] = width;
    }
};

/*
 * Set the blend color
 */
x3dom.StateManager.prototype.blendColor = function (red, green, blue, alpha)
{
    if (this.states['blendColor'].red != red ||
        this.states['blendColor'].green != green ||
        this.states['blendColor'].blue != blue ||
        this.states['blendColor'].alpha != alpha)
    {
        this.gl.blendColor(red, green, blue, alpha);
        this.states['blendColor'].red = red;
        this.states['blendColor'].green = green;
        this.states['blendColor'].blue = blue;
        this.states['blendColor'].alpha = alpha;
    }
};

/*
 * Specify the equation used for both the RGB blend equation and the Alpha blend equation
 */
x3dom.StateManager.prototype.blendEquation = function (mode)
{
    if (mode && this.states['blendEquation'] != mode)
    {
        this.gl.blendEquation(mode);
        this.states['blendEquation'] = mode;
    }
};

/*
 * set the RGB blend equation and the alpha blend equation separately
 */
x3dom.StateManager.prototype.blendEquationSeparate = function (modeRGB, modeAlpha)
{
    if (this.states['blendEquationSeparate'].modeRGB != modeRGB ||
        this.states['blendEquationSeparate'].modeAlpha != modeAlpha)
    {
        this.gl.blendEquationSeparate(modeRGB, modeAlpha);
        this.states['blendEquationSeparate'].modeRGB = modeRGB;
        this.states['blendEquationSeparate'].modeAlpha = modeAlpha;
    }
};

/*
 * Specify pixel arithmetic
 */
x3dom.StateManager.prototype.blendFunc = function (sfactor, dfactor)
{
    if (this.states['blendFunc'].sfactor != sfactor ||
        this.states['blendFunc'].dfactor != dfactor)
    {
        this.gl.blendFunc(sfactor, dfactor);
        this.states['blendFunc'].sfactor = sfactor;
        this.states['blendFunc'].dfactor = dfactor;
    }
};

/*
 * Specify pixel arithmetic for RGB and alpha components separately
 */
x3dom.StateManager.prototype.blendFuncSeparate = function (srcRGB, dstRGB, srcAlpha, dstAlpha)
{
    if (this.states['blendFuncSeparate'].srcRGB != srcRGB ||
        this.states['blendFuncSeparate'].dstRGB != dstRGB ||
        this.states['blendFuncSeparate'].srcAlpha != srcAlpha ||
        this.states['blendFuncSeparate'].dstAlpha != dstAlpha)
    {
        this.gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
        this.states['blendFuncSeparate'].srcRGB = srcRGB;
        this.states['blendFuncSeparate'].dstRGB = dstRGB;
        this.states['blendFuncSeparate'].srcAlpha = srcAlpha;
        this.states['blendFuncSeparate'].dstAlpha = dstAlpha;
    }
};

/*
 * Specify the value used for depth buffer comparisons
 */
x3dom.StateManager.prototype.depthFunc = function (func)
{
    if (this.states['depthFunc'] != func)
    {
        this.gl.depthFunc(func);
        this.states['depthFunc'] = func;
    }
};

/*
 * Specify the value used for depth buffer comparisons
 */
x3dom.StateManager.prototype.depthRange = function (zNear, zFar)
{
    if (zNear < 0 || zFar < 0 || zNear > zFar)
    {
        return;   // do noting and leave default values
    }

    zNear = (zNear > 1) ? 1 : zNear;
    zFar  = (zFar  > 1) ? 1 : zFar;

    if (this.states['depthRange'].zNear != zNear || this.states['depthRange'].zFar != zFar)
    {
        this.gl.depthRange(zNear, zFar);
        this.states['depthRange'].zNear = zNear;
        this.states['depthRange'].zFar = zFar;
    }
};

/*
 * Set the viewport
 */
x3dom.StateManager.prototype.viewport = function (x, y, width, height)
{
    if (this.states['viewport'].x != x ||
        this.states['viewport'].y != y ||
        this.states['viewport'].width != width ||
        this.states['viewport'].height != height)
    {
        this.gl.viewport(x, y, width, height);
        this.states['viewport'].x = x;
        this.states['viewport'].y = y;
        this.states['viewport'].width = width;
        this.states['viewport'].height = height;
    }
};

/*
 * Bind a framebuffer to a framebuffer target
 */
x3dom.StateManager.prototype.bindFramebuffer = function (target, framebuffer)
{
    this.gl.bindFramebuffer(target, framebuffer);
    this.initStates();
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/** used from within gfx_webgl.js */
x3dom.BinaryContainerLoader = {
    outOfMemory: false,     // try to prevent browser crashes

    checkError: function(gl) {
        var glErr = gl.getError();
        if (glErr) {
            if (glErr == gl.OUT_OF_MEMORY) {
                this.outOfMemory = true;
                x3dom.debug.logError("GL-Error " + glErr + " on loading binary geometry (out of memory).");
                console.error("WebGL: OUT_OF_MEMORY");
            }
            else {
                x3dom.debug.logError("GL-Error " + glErr + " on loading binary geometry.");
            }
        }
    }
};


/** setup/download binary geometry */
x3dom.BinaryContainerLoader.setupBinGeo = function(shape, sp, gl, viewarea, currContext)
{
    if (this.outOfMemory) {
        return;
    }

    var t00 = new Date().getTime();
    var that = this;

    var binGeo = shape._cf.geometry.node;

    // 0 := no BG, 1 := indexed BG, -1 := non-indexed BG
    shape._webgl.binaryGeometry = -1;

    shape._webgl.internalDownloadCount = ((binGeo._vf.index.length > 0) ? 1 : 0) +
        ((binGeo._hasStrideOffset && binGeo._vf.coord.length > 0) ? 1 : 0) +
        ((!binGeo._hasStrideOffset && binGeo._vf.coord.length > 0) ? 1 : 0) +
        ((!binGeo._hasStrideOffset && binGeo._vf.normal.length > 0) ? 1 : 0) +
        ((!binGeo._hasStrideOffset && binGeo._vf.texCoord.length > 0) ? 1 : 0) +
        ((!binGeo._hasStrideOffset && binGeo._vf.color.length > 0) ? 1 : 0);

    var createTriangleSoup = (binGeo._vf.normalPerVertex == false) ||
                              ((binGeo._vf.index.length > 0) && (binGeo._vf.indexType == "Int32" ||
                                (binGeo._vf.indexType == "Uint32" && !x3dom.caps.INDEX_UINT)));

    shape._webgl.makeSeparateTris = {
        index: null,
        coord: null,
        normal: null,
        texCoord: null,
        color: null,

        pushBuffer: function(name, buf) {
            this[name] = buf;

            if (--shape._webgl.internalDownloadCount == 0) {
                if (this.coord)
                    this.createMesh();
                shape._nameSpace.doc.needRender = true;
            }
            if (--shape._nameSpace.doc.downloadCount == 0)
                shape._nameSpace.doc.needRender = true;
        },

        createMesh: function() {
            var geoNode = binGeo;

            if (geoNode._hasStrideOffset) {
                x3dom.debug.logError(geoNode._vf.indexType +
                    " index type and per-face normals not supported for interleaved arrays.");
                return;
            }

            for (var k=0; k<shape._webgl.primType.length; k++) {
                if (shape._webgl.primType[k] == gl.TRIANGLE_STRIP) {
                    x3dom.debug.logError("makeSeparateTris: triangle strips not yet supported for per-face normals.");
                    return;
                }
            }

            var attribTypeStr = geoNode._vf.coordType;
            shape._webgl.coordType = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);

            // remap vertex data
            var bgCenter, bgSize, bgPrecisionMax;

            if (shape._webgl.coordType != gl.FLOAT)
            {
                if (geoNode._mesh._numPosComponents == 4 &&
                    x3dom.Utils.isUnsignedType(geoNode._vf.coordType))
                    bgCenter = x3dom.fields.SFVec3f.copy(geoNode.getMin());
                else
                    bgCenter = x3dom.fields.SFVec3f.copy(geoNode._vf.position);

                bgSize = x3dom.fields.SFVec3f.copy(geoNode._vf.size);
                bgPrecisionMax = geoNode.getPrecisionMax('coordType');
            }
            else
            {
                bgCenter = new x3dom.fields.SFVec3f(0, 0, 0);
                bgSize = new x3dom.fields.SFVec3f(1, 1, 1);
                bgPrecisionMax = 1.0;
            }

            // check types
            var dataLen = shape._coordStrideOffset[0] / x3dom.Utils.getDataTypeSize(geoNode._vf.coordType);
            dataLen = (dataLen == 0) ? 3 : dataLen;

            x3dom.debug.logWarning("makeSeparateTris.createMesh called with coord length " + dataLen);

            if (this.color && dataLen != shape._colorStrideOffset[0] / x3dom.Utils.getDataTypeSize(geoNode._vf.colorType))
            {
                this.color = null;
                x3dom.debug.logWarning("Color format not supported.");
            }

            var texDataLen = this.texCoord ? (shape._texCoordStrideOffset[0] /
                                              x3dom.Utils.getDataTypeSize(geoNode._vf.texCoordType)) : 0;

            // set data types
            //geoNode._vf.coordType = "Float32";
            geoNode._vf.normalType = "Float32";

            //shape._webgl.coordType = gl.FLOAT;
            shape._webgl.normalType = gl.FLOAT;

            //geoNode._mesh._numPosComponents = 3;
            geoNode._mesh._numNormComponents = 3;

            //shape._coordStrideOffset = [0, 0];
            shape._normalStrideOffset = [0, 0];

            // create non-indexed mesh
            var posBuf = [], normBuf = [], texcBuf = [], colBuf = [];
            var i, j, l, n = this.index ? (this.index.length - 2) : (this.coord.length / 3 - 2);

            for (i=0; i<n; i+=3)
            {
                j = dataLen * (this.index ? this.index[i] : i);
                var p0 = new x3dom.fields.SFVec3f(bgSize.x * this.coord[j  ] / bgPrecisionMax,
                                                  bgSize.y * this.coord[j+1] / bgPrecisionMax,
                                                  bgSize.z * this.coord[j+2] / bgPrecisionMax);
                // offset irrelevant for normal calculation
                //p0 = bgCenter.add(p0);

                posBuf.push(this.coord[j  ]);
                posBuf.push(this.coord[j+1]);
                posBuf.push(this.coord[j+2]);
                if (dataLen > 3) posBuf.push(this.coord[j+3]);

                if (this.color) {
                    colBuf.push(this.color[j  ]);
                    colBuf.push(this.color[j+1]);
                    colBuf.push(this.color[j+2]);
                    if (dataLen > 3) colBuf.push(this.color[j+3]);
                }

                if (this.texCoord) {
                    l = texDataLen * (this.index ? this.index[i] : i);

                    texcBuf.push(this.texCoord[l  ]);
                    texcBuf.push(this.texCoord[l+1]);
                    if (texDataLen > 3) {
                        texcBuf.push(this.texCoord[l+2]);
                        texcBuf.push(this.texCoord[l+3]);
                    }
                }

                j = dataLen * (this.index ? this.index[i+1] : i+1);
                var p1 = new x3dom.fields.SFVec3f(bgSize.x * this.coord[j  ] / bgPrecisionMax,
                                                  bgSize.y * this.coord[j+1] / bgPrecisionMax,
                                                  bgSize.z * this.coord[j+2] / bgPrecisionMax);
                //p1 = bgCenter.add(p1);

                posBuf.push(this.coord[j  ]);
                posBuf.push(this.coord[j+1]);
                posBuf.push(this.coord[j+2]);
                if (dataLen > 3) posBuf.push(this.coord[j+3]);

                if (this.color) {
                    colBuf.push(this.color[j  ]);
                    colBuf.push(this.color[j+1]);
                    colBuf.push(this.color[j+2]);
                    if (dataLen > 3) colBuf.push(this.color[j+3]);
                }

                if (this.texCoord) {
                    l = texDataLen * (this.index ? this.index[i+1] : i+1);

                    texcBuf.push(this.texCoord[l  ]);
                    texcBuf.push(this.texCoord[l+1]);
                    if (texDataLen > 3) {
                        texcBuf.push(this.texCoord[l+2]);
                        texcBuf.push(this.texCoord[l+3]);
                    }
                }

                j = dataLen * (this.index ? this.index[i+2] : i+2);
                var p2 = new x3dom.fields.SFVec3f(bgSize.x * this.coord[j  ] / bgPrecisionMax,
                                                  bgSize.y * this.coord[j+1] / bgPrecisionMax,
                                                  bgSize.z * this.coord[j+2] / bgPrecisionMax);
                //p2 = bgCenter.add(p2);

                posBuf.push(this.coord[j  ]);
                posBuf.push(this.coord[j+1]);
                posBuf.push(this.coord[j+2]);
                if (dataLen > 3) posBuf.push(this.coord[j+3]);

                if (this.color) {
                    colBuf.push(this.color[j  ]);
                    colBuf.push(this.color[j+1]);
                    colBuf.push(this.color[j+2]);
                    if (dataLen > 3) colBuf.push(this.color[j+3]);
                }

                if (this.texCoord) {
                    l = texDataLen * (this.index ? this.index[i+2] : i+2);

                    texcBuf.push(this.texCoord[l  ]);
                    texcBuf.push(this.texCoord[l+1]);
                    if (texDataLen > 3) {
                        texcBuf.push(this.texCoord[l+2]);
                        texcBuf.push(this.texCoord[l+3]);
                    }
                }

                var a = p0.subtract(p1);
                var b = p1.subtract(p2);
                var norm = a.cross(b).normalize();

                for (j=0; j<3; j++) {
                    normBuf.push(norm.x);
                    normBuf.push(norm.y);
                    normBuf.push(norm.z);
                }
            }

            // coordinates
            var buffer = gl.createBuffer();
            shape._webgl.buffers[1] = buffer;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER,
                x3dom.Utils.getArrayBufferView(geoNode._vf.coordType, posBuf), gl.STATIC_DRAW);

            gl.vertexAttribPointer(sp.position, geoNode._mesh._numPosComponents,
                shape._webgl.coordType, false,
                shape._coordStrideOffset[0], shape._coordStrideOffset[1]);
            gl.enableVertexAttribArray(sp.position);

            // normals
            buffer = gl.createBuffer();
            shape._webgl.buffers[2] = buffer;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normBuf), gl.STATIC_DRAW);

            gl.vertexAttribPointer(sp.normal, geoNode._mesh._numNormComponents,
                shape._webgl.normalType, false,
                shape._normalStrideOffset[0], shape._normalStrideOffset[1]);
            gl.enableVertexAttribArray(sp.normal);

            // tex coords
            if (this.texCoord)
            {
                buffer = gl.createBuffer();
                shape._webgl.buffers[3] = buffer;

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER,
                    x3dom.Utils.getArrayBufferView(geoNode._vf.texCoordType, texcBuf),
                    gl.STATIC_DRAW);

                gl.vertexAttribPointer(sp.texcoord, geoNode._mesh._numTexComponents,
                    shape._webgl.texCoordType, false,
                    shape._texCoordStrideOffset[0], shape._texCoordStrideOffset[1]);
                gl.enableVertexAttribArray(sp.texcoord);
            }

            // colors
            if (this.color)
            {
                buffer = gl.createBuffer();
                shape._webgl.buffers[4] = buffer;

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER,
                    x3dom.Utils.getArrayBufferView(geoNode._vf.colorType, colBuf),
                    gl.STATIC_DRAW);

                gl.vertexAttribPointer(sp.color, geoNode._mesh._numColComponents,
                    shape._webgl.colorType, false,
                    shape._colorStrideOffset[0], shape._colorStrideOffset[1]);
                gl.enableVertexAttribArray(sp.color);
            }

            // adjust sizes
            geoNode._vf.vertexCount = [];
            geoNode._vf.vertexCount[0] = posBuf.length / dataLen;

            geoNode._mesh._numCoords = geoNode._vf.vertexCount[0];
            geoNode._mesh._numFaces = geoNode._vf.vertexCount[0] / 3;

            shape._webgl.primType = [];
            shape._webgl.primType[0] = gl.TRIANGLES;

            // cleanup
            posBuf = null;
            normBuf = null;
            texcBuf = null;
            colBuf = null;

            this.index = null;
            this.coord = null;
            this.normal = null;
            this.texCoord = null;
            this.color = null;

            that.checkError(gl);

            // recreate shader
            delete shape._webgl.shader;
            shape._webgl.shader = currContext.cache.getDynamicShader(gl, viewarea, shape);
        }
    };

    // index
    if (binGeo._vf.index.length > 0)
    {
        var xmlhttp0 = new XMLHttpRequest();
        xmlhttp0.open("GET", encodeURI(shape._nameSpace.getURL(binGeo._vf.index)), true);
        xmlhttp0.responseType = "arraybuffer";

        shape._nameSpace.doc.downloadCount += 1;

        xmlhttp0.send(null);

        xmlhttp0.onload = function()
        {
            if (!shape._webgl)
                return;

            var XHR_buffer = xmlhttp0.response;

            var geoNode = binGeo;
            var attribTypeStr = geoNode._vf.indexType;  //"Uint16"

            var indexArray = x3dom.Utils.getArrayBufferView(attribTypeStr, XHR_buffer);

            if (createTriangleSoup) {
                shape._webgl.makeSeparateTris.pushBuffer("index", indexArray);
                return;
            }

            var indicesBuffer = gl.createBuffer();
            shape._webgl.buffers[0] = indicesBuffer;

            if (x3dom.caps.INDEX_UINT && attribTypeStr == "Uint32") {
                //indexArray is Uint32Array
                shape._webgl.indexType = gl.UNSIGNED_INT;
            }
            else {
                //indexArray is Uint16Array
                shape._webgl.indexType = gl.UNSIGNED_SHORT;
            }

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);

            // Test reading Data
            //x3dom.debug.logWarning("arraybuffer[0]="+indexArray[0]+"; n="+indexArray.length);

            shape._webgl.binaryGeometry = 1;    // indexed BG

            if (geoNode._vf.vertexCount[0] == 0)
                geoNode._vf.vertexCount[0] = indexArray.length;

            geoNode._mesh._numFaces = 0;

            for (var i=0; i<geoNode._vf.vertexCount.length; i++) {
                if (shape._webgl.primType[i] == gl.TRIANGLE_STRIP)
                    geoNode._mesh._numFaces += geoNode._vf.vertexCount[i] - 2;
                else
                    geoNode._mesh._numFaces += geoNode._vf.vertexCount[i] / 3;
            }

            indexArray = null;

            shape._nameSpace.doc.downloadCount -= 1;
            shape._webgl.internalDownloadCount -= 1;
            if (shape._webgl.internalDownloadCount == 0)
                shape._nameSpace.doc.needRender = true;

            that.checkError(gl);

            var t11 = new Date().getTime() - t00;
            x3dom.debug.logInfo("XHR0/ index load time: " + t11 + " ms");
        };
    }

    // interleaved array -- assume all attributes are given in one single array buffer
    if (binGeo._hasStrideOffset && binGeo._vf.coord.length > 0)
    {
        var xmlhttp = new XMLHttpRequest();
        xmlhttp.open("GET", encodeURI(shape._nameSpace.getURL(binGeo._vf.coord)), true);
        xmlhttp.responseType = "arraybuffer";

        shape._nameSpace.doc.downloadCount += 1;

        xmlhttp.send(null);

        xmlhttp.onload = function()
        {
            if (!shape._webgl)
                return;

            var XHR_buffer = xmlhttp.response;

            var geoNode = binGeo;
            var attribTypeStr = geoNode._vf.coordType;

            // assume same data type for all attributes (but might be wrong)
            shape._webgl.coordType    = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);
            shape._webgl.normalType   = shape._webgl.coordType;
            shape._webgl.texCoordType = shape._webgl.coordType;
            shape._webgl.colorType    = shape._webgl.coordType;

            var attributes = x3dom.Utils.getArrayBufferView(attribTypeStr, XHR_buffer);

            // calculate number of single data packages by including stride and type size
            var dataLen = shape._coordStrideOffset[0] / x3dom.Utils.getDataTypeSize(attribTypeStr);
            if (dataLen)
                geoNode._mesh._numCoords = attributes.length / dataLen;

            if (geoNode._vf.index.length == 0) {
                for (var i=0; i<geoNode._vf.vertexCount.length; i++) {
                    if (shape._webgl.primType[i] == gl.TRIANGLE_STRIP)
                        geoNode._mesh._numFaces += geoNode._vf.vertexCount[i] - 2;
                    else
                        geoNode._mesh._numFaces += geoNode._vf.vertexCount[i] / 3;
                }
            }

            var buffer = gl.createBuffer();

            shape._webgl.buffers[1] = buffer;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, attributes, gl.STATIC_DRAW);

            gl.vertexAttribPointer(sp.position, geoNode._mesh._numPosComponents,
                shape._webgl.coordType, false,
                shape._coordStrideOffset[0], shape._coordStrideOffset[1]);
            gl.enableVertexAttribArray(sp.position);

            if (geoNode._vf.normal.length > 0)
            {
                shape._webgl.buffers[2] = buffer;

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, attributes, gl.STATIC_DRAW);

                gl.vertexAttribPointer(sp.normal, geoNode._mesh._numNormComponents,
                    shape._webgl.normalType, false,
                    shape._normalStrideOffset[0], shape._normalStrideOffset[1]);
                gl.enableVertexAttribArray(sp.normal);
            }

            if (geoNode._vf.texCoord.length > 0)
            {
                shape._webgl.buffers[3] = buffer;

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, attributes, gl.STATIC_DRAW);

                gl.vertexAttribPointer(sp.texcoord, geoNode._mesh._numTexComponents,
                    shape._webgl.texCoordType, false,
                    shape._texCoordStrideOffset[0], shape._texCoordStrideOffset[1]);
                gl.enableVertexAttribArray(sp.texcoord);
            }

            if (geoNode._vf.color.length > 0)
            {
                shape._webgl.buffers[4] = buffer;

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, attributes, gl.STATIC_DRAW);

                gl.vertexAttribPointer(sp.color, geoNode._mesh._numColComponents,
                    shape._webgl.colorType, false,
                    shape._colorStrideOffset[0], shape._colorStrideOffset[1]);
                gl.enableVertexAttribArray(sp.color);
            }

            attributes = null;  // delete data block in CPU memory

            shape._nameSpace.doc.downloadCount -= 1;
            shape._webgl.internalDownloadCount -= 1;
            if (shape._webgl.internalDownloadCount == 0)
                shape._nameSpace.doc.needRender = true;

            that.checkError(gl);

            var t11 = new Date().getTime() - t00;
            x3dom.debug.logInfo("XHR/ interleaved array load time: " + t11 + " ms");
        };
    }

    // coord
    if (!binGeo._hasStrideOffset && binGeo._vf.coord.length > 0)
    {
        var xmlhttp1 = new XMLHttpRequest();
        xmlhttp1.open("GET", encodeURI(shape._nameSpace.getURL(binGeo._vf.coord)), true);
        xmlhttp1.responseType = "arraybuffer";

        shape._nameSpace.doc.downloadCount += 1;

        xmlhttp1.send(null);

        xmlhttp1.onload = function()
        {
            if (!shape._webgl)
                return;

            var XHR_buffer = xmlhttp1.response;

            var geoNode = binGeo;
            var i = 0;

            var attribTypeStr = geoNode._vf.coordType;
            shape._webgl.coordType = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);

            var vertices = x3dom.Utils.getArrayBufferView(attribTypeStr, XHR_buffer);

            if (createTriangleSoup) {
                shape._webgl.makeSeparateTris.pushBuffer("coord", vertices);
                return;
            }

            gl.bindAttribLocation(sp.program, 0, "position");

            var positionBuffer = gl.createBuffer();
            shape._webgl.buffers[1] = positionBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            gl.vertexAttribPointer(sp.position,
                geoNode._mesh._numPosComponents,
                shape._webgl.coordType, false,
                shape._coordStrideOffset[0], shape._coordStrideOffset[1]);
            gl.enableVertexAttribArray(sp.position);

            geoNode._mesh._numCoords = vertices.length / geoNode._mesh._numPosComponents;

            if (geoNode._vf.index.length == 0) {
                for (i=0; i<geoNode._vf.vertexCount.length; i++) {
                    if (shape._webgl.primType[i] == gl.TRIANGLE_STRIP)
                        geoNode._mesh._numFaces += geoNode._vf.vertexCount[i] - 2;
                    else
                        geoNode._mesh._numFaces += geoNode._vf.vertexCount[i] / 3;
                }
            }

            // Test reading Data
            //x3dom.debug.logWarning("arraybuffer[0].vx="+vertices[0]);

            if ((attribTypeStr == "Float32") &&
                (shape._vf.bboxSize.x < 0 || shape._vf.bboxSize.y < 0 || shape._vf.bboxSize.z < 0))
            {
                var min = new x3dom.fields.SFVec3f(vertices[0],vertices[1],vertices[2]);
                var max = new x3dom.fields.SFVec3f(vertices[0],vertices[1],vertices[2]);

                for (i=3; i<vertices.length; i+=3)
                {
                    if (min.x > vertices[i+0]) { min.x = vertices[i+0]; }
                    if (min.y > vertices[i+1]) { min.y = vertices[i+1]; }
                    if (min.z > vertices[i+2]) { min.z = vertices[i+2]; }

                    if (max.x < vertices[i+0]) { max.x = vertices[i+0]; }
                    if (max.y < vertices[i+1]) { max.y = vertices[i+1]; }
                    if (max.z < vertices[i+2]) { max.z = vertices[i+2]; }
                }

                // TODO; move to mesh for all cases?
                shape._vf.bboxCenter.setValues(min.add(max).multiply(0.5));
                shape._vf.bboxSize.setValues(max.subtract(min));
            }

            vertices = null;

            shape._nameSpace.doc.downloadCount -= 1;
            shape._webgl.internalDownloadCount -= 1;
            if (shape._webgl.internalDownloadCount == 0)
                shape._nameSpace.doc.needRender = true;

            that.checkError(gl);

            var t11 = new Date().getTime() - t00;
            x3dom.debug.logInfo("XHR1/ coord load time: " + t11 + " ms");
        };
    }

    // normal
    if (!binGeo._hasStrideOffset && binGeo._vf.normal.length > 0)
    {
        var xmlhttp2 = new XMLHttpRequest();
        xmlhttp2.open("GET", encodeURI(shape._nameSpace.getURL(binGeo._vf.normal)), true);
        xmlhttp2.responseType = "arraybuffer";

        shape._nameSpace.doc.downloadCount += 1;

        xmlhttp2.send(null);

        xmlhttp2.onload = function()
        {
            if (!shape._webgl)
                return;

            var XHR_buffer = xmlhttp2.response;

            var attribTypeStr = binGeo._vf.normalType;
            shape._webgl.normalType = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);

            var normals = x3dom.Utils.getArrayBufferView(attribTypeStr, XHR_buffer);

            if (createTriangleSoup) {
                shape._webgl.makeSeparateTris.pushBuffer("normal", normals);
                return;
            }

            var normalBuffer = gl.createBuffer();
            shape._webgl.buffers[2] = normalBuffer;

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

            gl.vertexAttribPointer(sp.normal,
                binGeo._mesh._numNormComponents,
                shape._webgl.normalType, false,
                shape._normalStrideOffset[0], shape._normalStrideOffset[1]);
            gl.enableVertexAttribArray(sp.normal);

            // Test reading Data
            //x3dom.debug.logWarning("arraybuffer[0].nx="+normals[0]);

            normals = null;

            shape._nameSpace.doc.downloadCount -= 1;
            shape._webgl.internalDownloadCount -= 1;
            if (shape._webgl.internalDownloadCount == 0)
                shape._nameSpace.doc.needRender = true;

            that.checkError(gl);

            var t11 = new Date().getTime() - t00;
            x3dom.debug.logInfo("XHR2/ normal load time: " + t11 + " ms");
        };
    }

    // texCoord
    if (!binGeo._hasStrideOffset && binGeo._vf.texCoord.length > 0)
    {
        var xmlhttp3 = new XMLHttpRequest();
        xmlhttp3.open("GET", encodeURI(shape._nameSpace.getURL(binGeo._vf.texCoord)), true);
        xmlhttp3.responseType = "arraybuffer";

        shape._nameSpace.doc.downloadCount += 1;

        xmlhttp3.send(null);

        xmlhttp3.onload = function()
        {
            if (!shape._webgl)
                return;

            var XHR_buffer = xmlhttp3.response;

            var attribTypeStr = binGeo._vf.texCoordType;
            shape._webgl.texCoordType = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);

            var texCoords = x3dom.Utils.getArrayBufferView(attribTypeStr, XHR_buffer);

            if (createTriangleSoup) {
                shape._webgl.makeSeparateTris.pushBuffer("texCoord", texCoords);
                return;
            }

            var texcBuffer = gl.createBuffer();
            shape._webgl.buffers[3] = texcBuffer;

            gl.bindBuffer(gl.ARRAY_BUFFER, texcBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

            gl.vertexAttribPointer(sp.texcoord,
                binGeo._mesh._numTexComponents,
                shape._webgl.texCoordType, false,
                shape._texCoordStrideOffset[0], shape._texCoordStrideOffset[1]);
            gl.enableVertexAttribArray(sp.texcoord);

            // Test reading Data
            //x3dom.debug.logWarning("arraybuffer[0].tx="+texCoords[0]);

            texCoords = null;

            shape._nameSpace.doc.downloadCount -= 1;
            shape._webgl.internalDownloadCount -= 1;
            if (shape._webgl.internalDownloadCount == 0)
                shape._nameSpace.doc.needRender = true;

            that.checkError(gl);

            var t11 = new Date().getTime() - t00;
            x3dom.debug.logInfo("XHR3/ texCoord load time: " + t11 + " ms");
        };
    }

    // color
    if (!binGeo._hasStrideOffset && binGeo._vf.color.length > 0)
    {
        var xmlhttp4 = new XMLHttpRequest();
        xmlhttp4.open("GET", encodeURI(shape._nameSpace.getURL(binGeo._vf.color)), true);
        xmlhttp4.responseType = "arraybuffer";

        shape._nameSpace.doc.downloadCount += 1;

        xmlhttp4.send(null);

        xmlhttp4.onload = function()
        {
            if (!shape._webgl)
                return;

            var XHR_buffer = xmlhttp4.response;

            var attribTypeStr = binGeo._vf.colorType;
            shape._webgl.colorType = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);

            var colors = x3dom.Utils.getArrayBufferView(attribTypeStr, XHR_buffer);

            if (createTriangleSoup) {
                shape._webgl.makeSeparateTris.pushBuffer("color", colors);
                return;
            }

            var colorBuffer = gl.createBuffer();
            shape._webgl.buffers[4] = colorBuffer;

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

            gl.vertexAttribPointer(sp.color,
                binGeo._mesh._numColComponents,
                shape._webgl.colorType, false,
                shape._colorStrideOffset[0], shape._colorStrideOffset[1]);
            gl.enableVertexAttribArray(sp.color);

            // Test reading Data
            //x3dom.debug.logWarning("arraybuffer[0].cx="+colors[0]);

            colors = null;

            shape._nameSpace.doc.downloadCount -= 1;
            shape._webgl.internalDownloadCount -= 1;
            if (shape._webgl.internalDownloadCount == 0)
                shape._nameSpace.doc.needRender = true;

            that.checkError(gl);

            var t11 = new Date().getTime() - t00;
            x3dom.debug.logInfo("XHR4/ color load time: " + t11 + " ms");
        };
    }
    // TODO: tangent AND binormal
};


/** setup/download pop geometry */
x3dom.BinaryContainerLoader.setupPopGeo = function(shape, sp, gl, viewarea, currContext)
{
    if (this.outOfMemory) {
        return;
    }

    var popGeo = shape._cf.geometry.node;

    //reserve space for vertex buffer (and index buffer if any) on the gpu
    if (popGeo.hasIndex()) {
        shape._webgl.popGeometry = 1;

        shape._webgl.buffers[0] = gl.createBuffer();

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shape._webgl.buffers[0]);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, popGeo.getTotalNumberOfIndices()*2, gl.STATIC_DRAW);

        //this is a workaround to mimic gl_VertexID
        shape._webgl.buffers[5] = gl.createBuffer();

        var idBuffer = new Float32Array(popGeo._vf.vertexBufferSize);

        (function(){ for (var i = 0; i < idBuffer.length; ++i) idBuffer[i] = i; })();

        gl.bindBuffer(gl.ARRAY_BUFFER, shape._webgl.buffers[5]);
        gl.bufferData(gl.ARRAY_BUFFER, idBuffer, gl.STATIC_DRAW);
    }
    else {
        shape._webgl.popGeometry = -1;
    }

    shape._webgl.buffers[1] = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, shape._webgl.buffers[1]);
    gl.bufferData(gl.ARRAY_BUFFER, (popGeo._vf.attributeStride * popGeo._vf.vertexBufferSize), gl.STATIC_DRAW);


    //setup general render settings
    var attribTypeStr      = popGeo._vf.coordType;
    shape._webgl.coordType = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);

    shape._coordStrideOffset[0] = popGeo.getAttributeStride();
    shape._coordStrideOffset[1] = popGeo.getPositionOffset();

    gl.vertexAttribPointer(sp.position, shape._cf.geometry.node._mesh._numPosComponents, shape._webgl.coordType,
                           false, shape._coordStrideOffset[0], shape._coordStrideOffset[1]);
    gl.enableVertexAttribArray(sp.position);

    if (popGeo.hasNormal()) {
        attribTypeStr           = popGeo._vf.normalType;
        shape._webgl.normalType = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);

        shape._normalStrideOffset[0] = popGeo.getAttributeStride();
        shape._normalStrideOffset[1] = popGeo.getNormalOffset();

        shape._webgl.buffers[2] = shape._webgl.buffers[1]; //use interleaved vertex data buffer

        gl.vertexAttribPointer(sp.normal, shape._cf.geometry.node._mesh._numNormComponents, shape._webgl.normalType,
                               false, shape._normalStrideOffset[0], shape._normalStrideOffset[1]);
        gl.enableVertexAttribArray(sp.normal);
    }
    if (popGeo.hasTexCoord()) {
        attribTypeStr             = popGeo._vf.texCoordType;
        shape._webgl.texCoordType = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);

        shape._webgl.buffers[3] = shape._webgl.buffers[1]; //use interleaved vertex data buffer

        shape._texCoordStrideOffset[0] = popGeo.getAttributeStride();
        shape._texCoordStrideOffset[1] = popGeo.getTexCoordOffset();

        gl.vertexAttribPointer(sp.texcoord, shape._cf.geometry.node._mesh._numTexComponents, shape._webgl.texCoordType,
                               false, shape._texCoordStrideOffset[0], shape._texCoordStrideOffset[1]);
        gl.enableVertexAttribArray(sp.texcoord);
    }
    if (popGeo.hasColor()) {
        attribTypeStr          = popGeo._vf.colorType;
        shape._webgl.colorType = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);

        shape._webgl.buffers[4] = shape._webgl.buffers[1]; //use interleaved vertex data buffer

        shape._colorStrideOffset[0] = popGeo.getAttributeStride();
        shape._colorStrideOffset[1] = popGeo.getColorOffset();

        gl.vertexAttribPointer(sp.color, shape._cf.geometry.node._mesh._numColComponents, shape._webgl.colorType,
                               false, shape._colorStrideOffset[0], shape._colorStrideOffset[1]);
        gl.enableVertexAttribArray(sp.color);
    }

    shape._webgl.currentNumIndices  = 0;
    shape._webgl.currentNumVertices = 0;
    shape._webgl.numVerticesAtLevel = [];
    shape._webgl.levelsAvailable    = 0;

    this.checkError(gl);

    shape._webgl.levelLoaded = [];
    (function() {
        for (var i = 0; i < popGeo.getNumLevels(); ++i)
            shape._webgl.levelLoaded.push(false);
    })();

    //download callback, used to simply upload received vertex data to the GPU
    var uploadDataToGPU = function(data, lvl) {
        //x3dom.debug.logInfo("PopGeometry: Received data for level " + lvl + " !\n");

        shape._webgl.levelLoaded[lvl] = true;
        shape._webgl.numVerticesAtLevel[lvl] = 0;

        if (data) {
            //perform gpu data upload
            var indexDataLengthInBytes = 0;
            var redrawNeeded = false;

            if (popGeo.hasIndex()) {
                indexDataLengthInBytes = popGeo.getNumIndicesByLevel(lvl)*2;

                if (indexDataLengthInBytes > 0) {
                    redrawNeeded = true;

                    var indexDataView = new Uint8Array(data, 0, indexDataLengthInBytes);

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shape._webgl.buffers[0]);
                    //index data is always placed where it belongs, as we have to keep the order of rendering
                    (function() {
                        var indexDataOffset = 0;

                        for (var i = 0; i < lvl; ++i) { indexDataOffset += popGeo.getNumIndicesByLevel(i); }

                        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, indexDataOffset*2, indexDataView);
                    })();
                }
            }

            var vertexDataLengthInBytes = data.byteLength - indexDataLengthInBytes;

            if (vertexDataLengthInBytes > 0) {
                redrawNeeded = true;

                var attributeDataView = new Uint8Array(data, indexDataLengthInBytes, vertexDataLengthInBytes);

                gl.bindBuffer(gl.ARRAY_BUFFER, shape._webgl.buffers[1]);
                if (!popGeo.hasIndex()) {
                    //on non-indexed rendering, vertex data is just appended, the order of vertex data packages doesn't matter
                    gl.bufferSubData(gl.ARRAY_BUFFER, shape._webgl.currentNumVertices       * popGeo.getAttributeStride(),
                                     attributeDataView);
                }
                else {
                    //on indexed rendering, vertex data is always placed where it belongs, as we have to keep the indexed order
                    gl.bufferSubData(gl.ARRAY_BUFFER,popGeo.getVertexDataBufferOffset(lvl) * popGeo.getAttributeStride(),
                                     attributeDataView);
                }

                //adjust render settings: vertex data
                shape._webgl.numVerticesAtLevel[lvl] = vertexDataLengthInBytes / popGeo.getAttributeStride();
                shape._webgl.currentNumVertices += shape._webgl.numVerticesAtLevel[lvl];
            }

            //compute number of valid indices
            (function() {
                var numValidIndices = 0;

                for (var i = shape._webgl.levelsAvailable; i < popGeo.getNumLevels(); ++i) {
                    if (shape._webgl.levelLoaded[i] === false) {
                        break;
                    }
                    else {
                        numValidIndices += popGeo.getNumIndicesByLevel(i);
                        ++shape._webgl.levelsAvailable;
                    }
                }

                //adjust render settings: index data
                shape._webgl.currentNumIndices = numValidIndices;
            })();

            //here, we tell X3DOM how many faces / vertices get displayed in the stats
            popGeo._mesh._numCoords = shape._webgl.currentNumVertices;
            //@todo: this assumes pure TRIANGLES data
            popGeo._mesh._numFaces  = (popGeo.hasIndex() ? shape._webgl.currentNumIndices : shape._webgl.currentNumVertices) / 3;

            //here, we tell X3DOM how many vertices get rendered
            //@todo: this assumes pure TRIANGLES data
            popGeo.adaptVertexCount(popGeo.hasIndex() ? popGeo._mesh._numFaces * 3 : popGeo._mesh._numCoords);
            //x3dom.debug.logInfo("PopGeometry: Loaded level " + lvl + " data to gpu, model has now " +
            //    popGeo._mesh._numCoords + " vertices and " + popGeo._mesh._numFaces + " triangles, " +
            //    (new Date().getTime() - shape._webgl.downloadStartTimer) + " ms after posting download requests");

            //request redraw, if necessary
            if (redrawNeeded) {
                shape._nameSpace.doc.needRender = true;
            }
        }
    };

    //post XHRs
    var dataURLs = popGeo.getDataURLs();

    var downloadCallbacks = [];
    var priorities        = [];

    shape._webgl.downloadStartTimer = new Date().getTime();

    //CODE WITH DL MANAGER
    //use the DownloadManager to prioritize loading

    for (var i = 0; i < dataURLs.length; ++i) {
        shape._nameSpace.doc.downloadCount += 1;

        (function(idx) {
            downloadCallbacks.push(function(data) {
                shape._nameSpace.doc.downloadCount -= 1;
                return uploadDataToGPU(data, idx);
            });
        })(i);

        priorities.push(i);
    }

    x3dom.DownloadManager.get(dataURLs, downloadCallbacks, priorities);
    //END CODE WITH DL MANAGER
};

/** setup/download bit-lod geometry */
x3dom.BinaryContainerLoader.setupBitLODGeo = function(shape, sp, gl, viewarea, currContext)
{
    if (this.outOfMemory) {
        return;
    }

    shape._webgl.bitLODGeometry = -1;

    var bitLODGeometry = shape._cf.geometry.node;

    if (!bitLODGeometry._vf.normalPerVertex)
    {
        shape._webgl.bitLODtotalVertexCount = 0;    // otherwise undefined

        for (i = 0; i < bitLODGeometry._vf.vertexCount.length; i++) {
            if (shape._webgl.primType[i] == gl.TRIANGLES) {
                shape._webgl.bitLODtotalVertexCount += bitLODGeometry._vf.vertexCount[i];
            }
            else if (shape._webgl.primType[i] == gl.TRIANGLE_STRIP) {
                shape._webgl.bitLODtotalVertexCount += (bitLODGeometry._vf.vertexCount[i] - 2) * 3;
            }
        }
    }

    //Get number of components
    var numComponents = bitLODGeometry.getNumComponents();

    //Check if components available
    if(numComponents)
    {
        //Check if there are indices available
        if(bitLODGeometry.hasIndex())
        {
            //this function generates a single, large triangle buffer out of
            //  - an index buffer containing indices of TRIANGLES / TRIANGLE STRIPS
            //  - a set of data buffers containing the triangle data
            shape._webgl.generateTriangleBuffer = function() {
                if ( typeof shape._webgl.dataBuffers[0] != 'undefined' &&
                    (typeof shape._webgl.dataBuffers[1] != 'undefined' || //positions & normals
                     typeof shape._webgl.dataBuffers[3] != 'undefined' || //texcoords
                     typeof shape._webgl.dataBuffers[4] != 'undefined'    //colors
                    ))
                {
                    var indexArray = shape._webgl.dataBuffers[0];

                    var read_idx_pos_nor;
                    var read_idx_tc;
                    var read_idx_col;
                    var write_idx;
                    var i;

                    var n_theta   = 0;
                    var n_phi     = 0;
                    var accum_cnt = 0;
                    var points    = [new x3dom.fields.SFVec3f(0, 0, 0),
                        new x3dom.fields.SFVec3f(0, 0, 0),
                        new x3dom.fields.SFVec3f(0, 0, 0)];
                    var nor = new x3dom.fields.SFVec3f(0, 0, 0);
                    var v1  = new x3dom.fields.SFVec3f(0, 0, 0);
                    var v2  = new x3dom.fields.SFVec3f(0, 0, 0);

                    var coordsNormalsAvailable = (typeof shape._webgl.dataBuffers[1] != 'undefined' &&
                                                         shape._webgl.dataBuffers[1].length > 0);
                    var texCoordsAvailable     = (typeof shape._webgl.dataBuffers[3] != 'undefined' &&
                                                         shape._webgl.dataBuffers[3].length > 0);
                    var colorsAvailable        = (typeof shape._webgl.dataBuffers[4] != 'undefined' &&
                                                         shape._webgl.dataBuffers[4].length > 0);

                    var posNorEntriesPerElement = (shape._cf.geometry.node._mesh._numNormComponents == 2 ? 6 : 8);
                    var stride = posNorEntriesPerElement + (bitLODGeometry.hasTexCoord() ? 2 : 0) +
                                                           (bitLODGeometry.hasColor() ? 4 : 0);

                    if (typeof shape._webgl.triangleBuffer == 'undefined') {
                        //6 to 12 entries per element:
                        //px py pz + 0 + nt np [+ s t] [+ r g b + 0]
                        //px py pz + 0 + nx ny nz + 0 + [+ s t] [+ r g b + 0]
                        shape._webgl.triangleBuffer = new Uint16Array(indexArray.length * stride);
                    }

                    for (i = 0; i < indexArray.length; ++i) {
                        write_idx = i * stride;

                        if (coordsNormalsAvailable) {
                            read_idx_pos_nor = indexArray[i] * 6;

                            //write coords
                            shape._webgl.triangleBuffer[write_idx    ] = shape._webgl.dataBuffers[1][read_idx_pos_nor    ];
                            shape._webgl.triangleBuffer[write_idx + 1] = shape._webgl.dataBuffers[1][read_idx_pos_nor + 1];
                            shape._webgl.triangleBuffer[write_idx + 2] = shape._webgl.dataBuffers[1][read_idx_pos_nor + 2];
                            shape._webgl.triangleBuffer[write_idx + 3] = 0;

                            //write normals
                            //A: use transmitted per-vertex-normals
                            if (bitLODGeometry._vf.normalPerVertex) {
                                shape._webgl.triangleBuffer[write_idx + 4] = shape._webgl.dataBuffers[1][read_idx_pos_nor + 4];
                                shape._webgl.triangleBuffer[write_idx + 5] = shape._webgl.dataBuffers[1][read_idx_pos_nor + 5];
                            }
                            else if (shape._webgl.loadedLevels === 8) {
                                //B: on-the-fly normal computation for per-face normals (by cross product)
                                points[accum_cnt].x = shape._webgl.dataBuffers[1][read_idx_pos_nor    ];
                                points[accum_cnt].y = shape._webgl.dataBuffers[1][read_idx_pos_nor + 1];
                                points[accum_cnt].z = shape._webgl.dataBuffers[1][read_idx_pos_nor + 2];

                                if (++accum_cnt === 3) {
                                    v1 = points[1].subtract(points[0]);
                                    v2 = points[2].subtract(points[0]);

                                    nor = v1.cross(v2);
                                    nor = nor.normalize();

                                    //map to positive integers
                                    nor = nor.add(new x3dom.fields.SFVec3f(1.0, 1.0, 1.0));
                                    nor = nor.multiply(0.5);
                                    nor = nor.multiply(shape._cf.geometry.node.getPrecisionMax('normalType'));

                                    shape._webgl.triangleBuffer[write_idx + 4 - stride*2] = nor.x.toFixed(0);
                                    shape._webgl.triangleBuffer[write_idx + 5 - stride*2] = nor.y.toFixed(0);
                                    shape._webgl.triangleBuffer[write_idx + 6 - stride*2] = nor.z.toFixed(0);

                                    shape._webgl.triangleBuffer[write_idx + 4 - stride  ] = nor.x.toFixed(0);
                                    shape._webgl.triangleBuffer[write_idx + 5 - stride  ] = nor.y.toFixed(0);
                                    shape._webgl.triangleBuffer[write_idx + 6 - stride  ] = nor.z.toFixed(0);

                                    shape._webgl.triangleBuffer[write_idx + 4           ] = nor.x.toFixed(0);
                                    shape._webgl.triangleBuffer[write_idx + 5           ] = nor.y.toFixed(0);
                                    shape._webgl.triangleBuffer[write_idx + 6           ] = nor.z.toFixed(0);

                                    accum_cnt = 0;
                                }
                            }
                        }

                        write_idx += posNorEntriesPerElement;

                        if (texCoordsAvailable) {
                            read_idx_tc = indexArray[i] * 2;

                            //write texcoords
                            shape._webgl.triangleBuffer[write_idx    ] = shape._webgl.dataBuffers[3][read_idx_tc    ];
                            shape._webgl.triangleBuffer[write_idx + 1] = shape._webgl.dataBuffers[3][read_idx_tc + 1];

                            write_idx += 2;
                        }

                        if (colorsAvailable) {
                            read_idx_col = indexArray[i] * 4;

                            //write colors
                            shape._webgl.triangleBuffer[write_idx    ] = shape._webgl.dataBuffers[4][read_idx_col    ];
                            shape._webgl.triangleBuffer[write_idx + 1] = shape._webgl.dataBuffers[4][read_idx_col + 1];
                            shape._webgl.triangleBuffer[write_idx + 2] = shape._webgl.dataBuffers[4][read_idx_col + 2];
                            shape._webgl.triangleBuffer[write_idx + 3] = 0;

                            write_idx += 4;
                        }
                    }

                    //upload triangle buffer to the gpu and configure attributes
                    var glBuf = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, glBuf);
                    gl.bufferData(gl.ARRAY_BUFFER, shape._webgl.triangleBuffer, gl.STATIC_DRAW);

                    var attribTypeStr 		= bitLODGeometry._vf.coordType;
                    shape._webgl.coordType  = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);
                    shape._webgl.normalType = shape._webgl.coordType;

                    shape._coordStrideOffset[0]  = shape._normalStrideOffset[0] = stride*2;
                    shape._coordStrideOffset[1]  = 0;
                    shape._normalStrideOffset[1] = 8; //4*2

                    shape._webgl.buffers[1] = glBuf;
                    shape._webgl.buffers[2] = glBuf;
                                      
                    gl.vertexAttribPointer(sp.position, shape._cf.geometry.node._mesh._numPosComponents,
                        shape._webgl.coordType, false, shape._coordStrideOffset[0],
                        shape._coordStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.position);

                    gl.vertexAttribPointer(sp.normal, shape._cf.geometry.node._mesh._numNormComponents,
                        shape._webgl.normalType, false, shape._coordStrideOffset[0],
                        shape._coordStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.normal);

                    if (bitLODGeometry.hasTexCoord()) {
                        shape._webgl.texCoordType = shape._webgl.coordType;
                        shape._webgl.buffers[3] = glBuf;

                        shape._texCoordStrideOffset[0] = stride*2;
                        shape._texCoordStrideOffset[1] = posNorEntriesPerElement*2;

                        gl.vertexAttribPointer(sp.texcoord, shape._cf.geometry.node._mesh._numTexComponents,
                            shape._webgl.texCoordType, false, shape._texCoordStrideOffset[0],
                            shape._texCoordStrideOffset[1]);
                        gl.enableVertexAttribArray(sp.texcoord);
                    }

                    if (bitLODGeometry.hasColor()) {
                        shape._webgl.colorType  = shape._webgl.coordType;
                        shape._webgl.buffers[4] = glBuf;

                        shape._colorStrideOffset[0] = stride*2;
                        shape._colorStrideOffset[1] = bitLODGeometry.hasTexCoord() ? (posNorEntriesPerElement + 2) * 2 :
                                                                                      posNorEntriesPerElement * 2;

                        gl.vertexAttribPointer(sp.color, shape._cf.geometry.node._mesh._numColComponents,
                            shape._webgl.colorType, false, shape._colorStrideOffset[0],
                            shape._colorStrideOffset[1]);
                        gl.enableVertexAttribArray(sp.color);
                    }
                }
            };

            shape._webgl.bitLODGeometry = 1;    // indexed BLG
            var xmlhttpLOD = new XMLHttpRequest();
            xmlhttpLOD.open("GET", encodeURI(shape._nameSpace.getURL(bitLODGeometry._vf.index)), true);
            xmlhttpLOD.responseType = "arraybuffer";

            shape._nameSpace.doc.downloadCount += 1;

            xmlhttpLOD.send(null);

            xmlhttpLOD.onload = function()
            {
                var XHR_buffer = xmlhttpLOD.response;

                var indexArray;

                if (bitLODGeometry.usesClientSideNormals() && bitLODGeometry.usesVLCIndices()) {
                    
                    //variable-length decoding, indexed triangle strips are converted to indexed triangles
                    (function(){
                        if (typeof shape._webgl.dataBuffers == 'undefined')
                            shape._webgl.dataBuffers = [];

                        shape._webgl.dataBuffers[0] = [];

                        var codes = x3dom.Utils.getArrayBufferView("Uint8", XHR_buffer);
                        var i = 0;
                        var b;
                        var delta;
                        var magic_number;
                        var value = 0;

                        var vertexIdx = 0;
                        var primIdx   = 0;
                        var lastVal   = -1, preLastVal = -1;

                        while (i < codes.length) {
                            if (vertexIdx >= shape._cf.geometry.node._vf.vertexCount[primIdx]) {
                                ++primIdx;
                                vertexIdx = 0;
                            }

                            b = codes[i++];

                            delta        = 0;
                            magic_number = 128;

                            //read bytes while the marker bit (first one) is set
                            while (b >= 128) {
                                delta |= b - 128;
                                delta <<= 7;

                                magic_number <<= 7;

                                b = codes[i++];
                            }

                            delta |= b;

                            magic_number /= 2;
                            delta -= magic_number;

                            value = value + delta;

                            if (shape._webgl.primType[primIdx] == gl.TRIANGLE_STRIP) {
                                if (vertexIdx < 3) {
                                    shape._webgl.dataBuffers[0].push(value);
                                }
                                else if ((vertexIdx % 2) == 0) {
                                    shape._webgl.dataBuffers[0].push(preLastVal);
                                    shape._webgl.dataBuffers[0].push(lastVal);
                                    shape._webgl.dataBuffers[0].push(value);
                                }
                                else {
                                    shape._webgl.dataBuffers[0].push(lastVal);
                                    shape._webgl.dataBuffers[0].push(preLastVal);
                                    shape._webgl.dataBuffers[0].push(value);
                                }

                                preLastVal = lastVal;
                                lastVal    = value;
                            }
                            else {
                                shape._webgl.dataBuffers[0].push(value);
                            }

                            ++vertexIdx;
                        }
                    }());

                    //switch to non-indexed rendering
                    shape._webgl.bitLODGeometry = -1;

                    //create triangle render buffer with normals computed on-the-fly
                    //(if data is already available ...)
                    shape._webgl.generateTriangleBuffer();

                    bitLODGeometry._mesh._numFaces  = shape._webgl.dataBuffers[0].length / 3;
                    bitLODGeometry._mesh._numCoords = shape._webgl.dataBuffers[0].length;
                }
                else
                {   
                    var indicesBuffer = gl.createBuffer();
                    shape._webgl.buffers[0] = indicesBuffer;
                    
                    if (bitLODGeometry.usesVLCIndices())
                    {
                        var decodedIndices = [];

                        (function(){
                            var codes = x3dom.Utils.getArrayBufferView("Uint8", XHR_buffer);
                            var i = 0;
                            var b;
                            var delta;
                            var magic_number;
                            var value = 0;

                            var vertexIdx = 0;
                            var primIdx   = 0;
                            var lastVal   = -1, preLastVal = -1;

                            while (i < codes.length) {
                                if (vertexIdx >= shape._cf.geometry.node._vf.vertexCount[primIdx]) {
                                    ++primIdx;
                                    vertexIdx = 0;
                                }

                                b = codes[i++];

                                delta        = 0;
                                magic_number = 128;

                                //read bytes while the marker bit (first one) is set
                                while (b >= 128) {
                                    delta |= b - 128;
                                    delta <<= 7;

                                    magic_number <<= 7;

                                    b = codes[i++];
                                }

                                delta |= b;

                                magic_number /= 2;
                                delta -= magic_number;

                                value = value + delta;

                                decodedIndices.push(value);

                                ++vertexIdx;
                            }
                        }());

                        indexArray = new Uint16Array(decodedIndices);
                    }
                    else
                    {
                        indexArray = x3dom.Utils.getArrayBufferView("Uint16", XHR_buffer);
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);

                    if (bitLODGeometry.getVertexCount(0) == 0)
                        bitLODGeometry.setVertexCount(0, indexArray.length);

                    bitLODGeometry._mesh._numFaces = 0;

                    for (var p=0; p<bitLODGeometry.getNumPrimTypes(); p++) {
                        if (shape._webgl.primType[p] == gl.TRIANGLE_STRIP)
                            bitLODGeometry._mesh._numFaces += bitLODGeometry.getVertexCount(p) - 2;
                        else
                            bitLODGeometry._mesh._numFaces += bitLODGeometry.getVertexCount(p) / 3;
                    }
                }

                indexArray = null;

                shape._nameSpace.doc.downloadCount -= 1;
                shape._nameSpace.doc.needRender = true;
            };
        }

        function callBack(attributeId, bufferView)
        {
            if (typeof shape._webgl.loadedLevels == 'undefined') {
                shape._webgl.loadedLevels   = 0;
                bitLODGeometry.loadedLevels = 0;
            }

            shape._webgl.loadedLevels++;
            bitLODGeometry.loadedLevels++;

            if (bitLODGeometry.hasIndex() && bitLODGeometry.usesClientSideNormals()) {
                if (typeof shape._webgl.dataBuffers == 'undefined')
                    shape._webgl.dataBuffers = [];

                if (attributeId === 0) {
                    shape._webgl.dataBuffers[1] = bufferView;
                }
                else if (attributeId === 1) {
                    shape._webgl.dataBuffers[3] = bufferView;
                }
                else if (attributeId === 2) {
                    shape._webgl.dataBuffers[4] = bufferView;
                }

                shape._webgl.generateTriangleBuffer();
            }
            else
            {
                var buffer = gl.createBuffer();

                if (attributeId === 0) {
                    var attribTypeStr 		= bitLODGeometry._vf.coordType;

                    shape._webgl.coordType  = x3dom.Utils.getVertexAttribType(attribTypeStr, gl);
                    shape._webgl.normalType = shape._webgl.coordType;

                    // calculate number of single data packages by including stride and type size
                    var dataLen = shape._coordStrideOffset[0] / x3dom.Utils.getDataTypeSize(attribTypeStr);
                    //@todo: we need numCoords before this callback is invoked
                    if (dataLen && bitLODGeometry._vf.normalPerVertex)
                        bitLODGeometry._mesh._numCoords = bufferView.length / dataLen;

                    //Positions
                    shape._webgl.buffers[1] = buffer;

                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, bufferView, gl.STATIC_DRAW);

                    gl.vertexAttribPointer(sp.position, shape._cf.geometry.node._mesh._numPosComponents,
                        shape._webgl.coordType, false,
                        shape._coordStrideOffset[0], shape._coordStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.position);

                    //Normals
                    shape._webgl.buffers[2] = buffer;

                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, bufferView, gl.STATIC_DRAW);

                    gl.vertexAttribPointer(sp.normal, shape._cf.geometry.node._mesh._numNormComponents,
                        shape._webgl.normalType, false,
                        shape._normalStrideOffset[0], shape._normalStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.normal);
                }
                else if (attributeId === 1)
                {
                    shape._webgl.texCoordType = shape._webgl.coordType;
                    shape._webgl.buffers[3] = buffer;

                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, bufferView, gl.STATIC_DRAW);

                    gl.vertexAttribPointer(sp.texcoord, shape._cf.geometry.node._mesh._numTexComponents,
                        shape._webgl.texCoordType, false,
                        shape._texCoordStrideOffset[0], shape._texCoordStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.texcoord);
                }
                else if (attributeId === 2)
                {
                    shape._webgl.colorType = shape._webgl.coordType;
                    shape._webgl.buffers[4] = buffer;

                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, bufferView, gl.STATIC_DRAW);

                    gl.vertexAttribPointer(sp.color, shape._cf.geometry.node._mesh._numColComponents,
                        shape._webgl.colorType, false,
                        shape._colorStrideOffset[0], shape._colorStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.color);
                }

                bufferView = null;
            }

            //shape._nameSpace.doc.downloadCount -= 1;
            shape._nameSpace.doc.needRender = true;

            shape._webgl.refinementJobManager.continueProcessing(attributeId);
        }

        //If there is still no BitComposer create a new one
        //shape._webgl.bitLODComposer = new x3dom.BitLODComposer();
        shape._webgl.refinementJobManager = new x3dom.RefinementJobManager();

        //allocate buffers, pass them to the refinement manager
        //@todo: method returns number of index entries - at the moment, we have no mechanism to get the
        //       real number of vertices here, so we usually allocate too much memory
        var numVerts = bitLODGeometry.getNumVertices();

        var buf = new ArrayBuffer(12 * numVerts);
        var interleavedCoordNormalBuffer = new Uint16Array(buf);

        shape._webgl.refinementJobManager.addResultBuffer(0, interleavedCoordNormalBuffer);

        for (var i = 0; i < bitLODGeometry.getCoordNormalURLs().length; ++i) {
            shape._webgl.refinementJobManager.addRefinementJob(
                0,                                     //attributeId / resultBufferId
                i,                                     //download priority
                bitLODGeometry.getCoordNormalURLs()[i],//data file url
                i,                                     //refinement level (-> important for bit shift)
                callBack,                              //'job finished'-callback
                96,                                    //stride in bits (size of a single result element)
                [3, 2],                                //number of components information array
                [6, 2],                                //bits per refinement level information array
                [0, 6],                                //read offset (bits) information array
                [0, 64]);                              //write offset (bits) information array
        }

        if(bitLODGeometry.hasTexCoord()) {
            var tBuf = new ArrayBuffer(4 * numVerts);
            var texCoordBuffer = new Uint16Array(tBuf);

            shape._webgl.refinementJobManager.addResultBuffer(1, texCoordBuffer);

            for (i = 0; i < bitLODGeometry.getTexCoordURLs().length; ++i) {
                shape._webgl.refinementJobManager.addRefinementJob(
                    1,                           		//attributeId / resultBufferId
                    i,                           		//download priority
                    bitLODGeometry.getTexCoordURLs()[i], //data file url
                    i,                           		//refinement level (-> important for bit shift)
                    callBack,  							//'job finished'-callback
                    32,                          		//stride in bits (size of a single result element)
                    [2],                         		//number of components information array
                    [8],                         		//bits per refinement level information array
                    [0],                         		//read offset (bits) information array
                    [0]);                        		//write offset (bits) information array
            }
        }

        if(bitLODGeometry.hasColor()) {
            var cBuf = new ArrayBuffer(6 * numVerts);
            var colorBuffer = new Uint16Array(cBuf);

            shape._webgl.refinementJobManager.addResultBuffer(2, colorBuffer);

            for (i = 0; i < bitLODGeometry.getColorURLs().length; ++i) {
                shape._webgl.refinementJobManager.addRefinementJob(
                    2,                           		//attributeId / resultBufferId
                    i,                           		//download priority
                    bitLODGeometry.getColorURLs()[i],	//data file url
                    i,                           		//refinement level (-> important for bit shift)
                    callBack,  							//'job finished'-callback
                    48,                          		//stride in bits (size of a single result element)
                    [3],                         		//number of components information array
                    [6],                         		//bits per refinement level information array
                    [0],                         		//read offset (bits) information array
                    [0]);                        		//write offset (bits) information array
            }
        }
    }
};

/** setup/download image geometry */
x3dom.BinaryContainerLoader.setupImgGeo = function(shape, sp, gl, viewarea, currContext)
{
    if (this.outOfMemory) {
        return;
    }

    var imageGeometry = shape._cf.geometry.node;

    if ( imageGeometry.getIndexTexture() ) {
        shape._webgl.imageGeometry = 1;
    } else {
        shape._webgl.imageGeometry = -1;
    }

    imageGeometry.unsetGeoDirty();

    if (currContext.IG_PositionBuffer == null) {
        currContext.IG_PositionBuffer = gl.createBuffer();
    }

    shape._webgl.buffers[1] = currContext.IG_PositionBuffer;
    gl.bindBuffer(gl.ARRAY_BUFFER, currContext.IG_PositionBuffer);

    var vertices = new Float32Array(shape._webgl.positions[0]);

    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, currContext.IG_PositionBuffer);

    gl.vertexAttribPointer(sp.position, imageGeometry._mesh._numPosComponents,
        shape._webgl.coordType, false,
        shape._coordStrideOffset[0], shape._coordStrideOffset[1]);
    gl.enableVertexAttribArray(sp.position);

    vertices = null;

    this.checkError(gl);
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/**
 * c'tor
 */
x3dom.DrawableCollection = function (drawableCollectionConfig) {
    this.collection = [];

    this.viewMatrix = drawableCollectionConfig.viewMatrix;
    this.projMatrix = drawableCollectionConfig.projMatrix;
    this.sceneMatrix = drawableCollectionConfig.sceneMatrix;

    this.viewarea = drawableCollectionConfig.viewArea;

    var scene = this.viewarea._scene;
    var env = scene.getEnvironment();
    var viewpoint = scene.getViewpoint();

    this.near = viewpoint.getNear();
    this.pixelHeightAtDistOne = viewpoint.getImgPlaneHeightAtDistOne() / this.viewarea._height;

    this.context = drawableCollectionConfig.context;
    this.gl = drawableCollectionConfig.gl;

    this.viewFrustum = this.viewarea.getViewfrustum(this.sceneMatrix);
    this.worldVol = new x3dom.fields.BoxVolume();     // helper

    this.frustumCulling = drawableCollectionConfig.frustumCulling && (this.viewFrustum != null);
    this.smallFeatureThreshold = drawableCollectionConfig.smallFeatureThreshold;

    // if (lowPriorityThreshold < 1) sort all potentially visible objects according to priority
    this.sortOpaque = (this.smallFeatureThreshold > 0 && env._lowPriorityThreshold < 1);
    this.sortTrans = drawableCollectionConfig.sortTrans;

    this.prioLevels = 10;
    this.maxTreshold = 100;

    this.sortBySortKey = false;
    this.sortByPriority = false;

    this.numberOfNodes = 0;

    this.length = 0;
};

/**
 *  graphState = {
 *     boundedNode:  backref to bounded node object
 *     localMatrix:  mostly identity
 *     globalMatrix: current transform
 *     volume:       local bbox
 *     worldVolume:  global bbox
 *     center:       center in eye coords
 *     coverage:     currently approx. number of pixels on screen
 *  };
 */
x3dom.DrawableCollection.prototype.cull = function (transform, graphState, singlePath, planeMask) {
    var node = graphState.boundedNode;  // get ref to SG node

    if (!node || !node._vf.render) {
        return 0;   // <0 outside, >0 inside, but can't tell in this case
    }

    var volume = node.getVolume();      // create on request
    var MASK_SET = 63;  // 2^6-1, i.e. all sides of the volume

    if (this.frustumCulling) {
        var wvol;

        if (singlePath && !graphState.worldVolume.isValid()) {
            graphState.worldVolume.transformFrom(transform, volume);
            wvol = graphState.worldVolume;  // use opportunity to update if necessary
        }
        else if (planeMask < MASK_SET) {
            this.worldVol.transformFrom(transform, volume);
            wvol = this.worldVol;
        }

        if (planeMask < MASK_SET)
            planeMask = this.viewFrustum.intersect(wvol, planeMask);
        if (planeMask <= 0) {
            return -1;      // if culled return -1; 0 should never happen
        }
    }
    else {
        planeMask = MASK_SET;
    }

    graphState.coverage = -1;    // if -1 then ignore value later on

    // TODO: save the coverage only for drawables, which are unique (shapes can be shared!)
    if (this.smallFeatureThreshold > 0 || node.forceUpdateCoverage()) {
        var modelViewMat = this.viewMatrix.mult(transform);

        graphState.center = modelViewMat.multMatrixPnt(volume.getCenter());

        var rVec = modelViewMat.multMatrixVec(volume.getRadialVec());
        var r    = rVec.length();

        var dist = Math.max(-graphState.center.z - r, this.near);
        var projPixelLength = dist * this.pixelHeightAtDistOne;

        graphState.coverage = (r * 2.0) / projPixelLength;

        if (this.smallFeatureThreshold > 0 && graphState.coverage < this.smallFeatureThreshold) {
            return 0;   // differentiate between outside and this case
        }
    }

    // not culled, incr node cnt
    this.numberOfNodes++;

    return planeMask;   // >0, inside
};

/**
 * A drawable is basically a unique pair of a shape node and a global transformation.
 */
x3dom.DrawableCollection.prototype.addShape = function (shape, transform, graphState) {
    //Create a new drawable object
    var drawable = {};

    //Set the shape
    drawable.shape = shape;

    //Set the transform
    drawable.transform = transform;

    drawable.localTransform = graphState.localMatrix;

    //Set the local bounding box (reference, can be shared amongst shapes)
    drawable.localVolume = graphState.volume;

    //Set the global bbox (needs to be cloned since shape can be shared)
    drawable.worldVolume = x3dom.fields.BoxVolume.copy(graphState.worldVolume);

    //Calculate the magical object priority (though currently not very magic)
    drawable.priority = Math.max(0, graphState.coverage);
    //drawable.priority = this.calculatePriority(graphState);

    //Get shaderID from shape
    drawable.shaderID = shape.getShaderProperties(this.viewarea).id;

    var appearance = shape._cf.appearance.node;

    drawable.sortType = appearance ? appearance._vf.sortType.toLowerCase() : "opaque";
    drawable.sortKey = appearance ? appearance._vf.sortKey : 0;

    if (drawable.sortType == 'transparent') {
        if (this.smallFeatureThreshold > 0) {
            // TODO: center was previously set in cull, which is called first, but this
            // might be problematic if scene is traversed in parallel and node is shared
            // (though currently traversal is sequential, so everything is fine)
            drawable.zPos = graphState.center.z;
        }
        else {
            //Calculate the z-Pos for transparent object sorting
            //if the center of the box is not available
            var center = transform.multMatrixPnt(shape.getCenter());
            center = this.viewMatrix.multMatrixPnt(center);
            drawable.zPos = center.z;
        }
    }

    //Look for sorting by sortKey
    if (!this.sortBySortKey && drawable.sortKey != 0) {
        this.sortBySortKey = true;
    }

    //Generate separate array for sortType if not exists
    if (this.collection[drawable.sortType] === undefined) {
        this.collection[drawable.sortType] = [];
    }

    //Push drawable to the collection
    this.collection[drawable.sortType].push(drawable);
    //this.collection[drawable.sortType][drawable.sortKey][drawable.priority][drawable.shaderID].push(drawable);

    //Increment collection length
    this.length++;

    //Finally setup shape directly here to avoid another loop of O(n)
    if (this.context && this.gl) {
        this.context.setupShape(this.gl, drawable, this.viewarea);
    }
    //TODO: what about Flash? Shall we also setup structures here?
};

/**
 * A drawable is basically a unique pair of a shape node and a global transformation.
 */
x3dom.DrawableCollection.prototype.addDrawable = function (drawable) {
    //Calculate the magical object priority (though currently not very magic)
    //drawable.priority = this.calculatePriority(graphState);

    //Get shaderID from shape
    drawable.shaderID = drawable.shape.getShaderProperties(this.viewarea).id;

    var appearance = drawable.shape._cf.appearance.node;

    drawable.sortType = appearance ? appearance._vf.sortType.toLowerCase() : "opaque";
    drawable.sortKey = appearance ? appearance._vf.sortKey : 0;

    if (drawable.sortType == 'transparent') {
        //TODO set zPos for drawable for z-sorting
        //Calculate the z-Pos for transparent object sorting
        //if the center of the box is not available
        var center = drawable.transform.multMatrixPnt(drawable.shape.getCenter());
        center = this.viewMatrix.multMatrixPnt(center);
        drawable.zPos = center.z;
    }

    //Look for sorting by sortKey
    if (!this.sortBySortKey && drawable.sortKey != 0) {
        this.sortBySortKey = true;
    }

    //Generate separate array for sortType if not exists
    if (this.collection[drawable.sortType] === undefined) {
        this.collection[drawable.sortType] = [];
    }

    //Push drawable to the collection
    this.collection[drawable.sortType].push(drawable);
    //this.collection[drawable.sortType][drawable.sortKey][drawable.priority][drawable.shaderID].push(drawable);

    //Increment collection length
    this.length++;

    //Finally setup shape directly here to avoid another loop of O(n)
    if (this.context && this.gl) {
        this.context.setupShape(this.gl, drawable, this.viewarea);
    }
};


/**
 * Calculate the magical object priority (though currently not very magic).
 */
x3dom.DrawableCollection.prototype.calculatePriority = function (graphState) {
    //Use coverage as priority
    var priority = Math.max(0, graphState.coverage);

    //Classify the priority level
    var pl = this.prioLevels - 1;   // Can this be <= 0? Then FIXME!
    priority = Math.min( Math.round(priority / (this.maxTreshold / pl)), pl );

    return priority;
};

/**
 *
 */
x3dom.DrawableCollection.prototype.concat = function () {
    var opaque = (this.collection['opaque'] !== undefined) ? this.collection['opaque'] : [];
    var transparent = (this.collection['transparent'] !== undefined) ? this.collection['transparent'] : [];

    //Merge opaque and transparent drawables to a single array
    this.collection = opaque.concat(transparent);
};

/**
 *
 */
x3dom.DrawableCollection.prototype.get = function (idx) {
    return this.collection[idx];
};

/**
 *
 */
x3dom.DrawableCollection.prototype.sort = function () {
    var opaque = [];
    var transparent = [];

    //Sort opaque drawables
    if (this.collection['opaque'] !== undefined) {
        // never call this for very big scenes, getting very slow; try binning approach
        if (this.sortOpaque) {
            this.collection['opaque'].sort(function (a, b) {
                if (a.sortKey == b.sortKey || !this.sortBySortKey) {
                    //Second sort criteria (priority)
                    return b.priority - a.priority;
                }
                //First sort criteria (sortKey)
                return a.sortKey - b.sortKey;
            });
        }
        opaque = this.collection['opaque'];
    }

    //Sort transparent drawables
    if (this.collection['transparent'] !== undefined) {
        if (this.sortTrans) {
            this.collection['transparent'].sort(function (a, b) {
                if (a.sortKey == b.sortKey || !this.sortBySortKey) {
                    if (a.priority == b.priority || !this.sortByPriority) {
                        //Third sort criteria (zPos)
                        return a.zPos - b.zPos;
                    }
                    //Second sort criteria (priority)
                    return b.priority - a.priority;
                }
                //First sort criteria (sortKey)
                return a.sortKey - b.sortKey;
            });
        }
        transparent = this.collection['transparent'];
    }

    //Merge opaque and transparent drawables to a single array (slow operation)
    this.collection = opaque.concat(transparent);
};

x3dom.DrawableCollection.prototype.forEach = function (fnc, maxPriority) {
    //Set maximal priority
    maxPriority = typeof maxPriority !== 'undefined' ? Math.min(maxPriority, this.prioLevels) : this.prioLevels;

    //Define run variables
    var sortKey, priority, shaderID, drawable;

    //First traverse Opaque drawables
    for (sortKey=0; sortKey<this.collection['opaque'].length; ++sortKey)
    {
        if (this.collection['opaque'][sortkey] !== undefined)
        {
            for (priority=this.collection['opaque'][sortKey].length; priority>0; --priority)
            {
                if (this.collection['opaque'][sortKey][priority] !== undefined)
                {
                    for (shaderID in this.collection['opaque'][sortKey][priority])
                    {
                        for (drawable=0; drawable<this.collection['opaque'][sortKey][priority][shaderID].lenght; ++drawable)
                        {
                            fnc( this.collection['opaque'][sortKey][priority][shaderID][drawable] );
                        }
                    }
                }
            }
        }
    }

    //Next traverse transparent drawables
    for (sortKey=0; sortKey<this.collection['transparent'].length; ++sortKey)
    {
        if (this.collection['transparent'][sortkey] !== undefined)
        {
            for (priority=this.collection['transparent'][sortKey].length; priority>0; --priority)
            {
                if (this.collection['transparent'][sortKey][priority] !== undefined)
                {
                    for (var shaderId in this.collection['transparent'][sortKey][priority])
                    {
                        //Sort transparent drawables by z-Pos
                        this.collection['transparent'][sortKey][priority][shaderId].sort(function(a, b) {
                            return a.zPos - b.zPos
                        });

                        for (drawable=0; drawable<this.collection['transparent'][sortKey][priority][shaderId].lenght; ++drawable)
                        {
                            fnc( this.collection['transparent'][sortKey][priority][shaderId][drawable] );
                        }
                    }
                }
            }
        }
    }
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

//---------------------------------------------------------------------------------------------------------------------

//namespace
x3dom.bvh = {};

//---------------------------------------------------------------------------------------------------------------------

/**
 * BVH Settings class
 */
x3dom.bvh.Settings = defineClass(
    null,
    function(debug, showDebugBoxVolumes,bvhType, maxObjectsPerNode, maxDepth, minRelBBoxSize)
    {
        this.debug = debug;
        this.showDebugBoxVolumes = showDebugBoxVolumes;
        this.bvhType = bvhType;
        this.maxObjectsPerNode = maxObjectsPerNode;
        this.maxDepth = maxDepth;
        this.minRelativeBBoxSize = minRelBBoxSize !== 'undefined' ? minRelBBoxSize : 0.01;
        this.MASK_SET = 63;
    }
);

//---------------------------------------------------------------------------------------------------------------------

/**
 * Node containing AABB and drawable shape
 */
x3dom.bvh.DataNode = defineClass(
    null,
    function(drawable)
    {
        this.drawable = drawable;
        this.bbox = new x3dom.fields.BoxVolume();
        this.bbox.transformFrom(drawable.transform, drawable.shape.getVolume());
        drawable.worldVolume = x3dom.fields.BoxVolume.copy(this.bbox);
    }
);

//---------------------------------------------------------------------------------------------------------------------

/**
 * Base class for jsBVHs
 */
x3dom.bvh.Base = defineClass(
    null,
    function(settings)
    {
        /*Data Members*/
        this.dataNodes = [];
        this.drawableCollection = null;
        this.coveredBoxVolume = null;
        this.settings = settings;
    },
    {
        /*add Drawable as DataNode to BVH */
        addDrawable : function(drawable)
        {
            this.dataNodes.push(new x3dom.bvh.DataNode(drawable));
        },
        /*get Node BoxVolume - to be overwritten for actual hierarchies*/
        getHierarchyNodeBoxVolume : function(id)
        {
            if(this.dataNodes.length  > id)
            {
                return this.dataNodes[id].bbox;
            }
            return null;
        },

        /*
         * interface functions
         */
        build : function(){},
        collectDrawables : function(drawableCollection){},
        /*
         * return longest axis of box : 0=x, 1=y, 2=z
         */
        getLongestAxisForBox : function(box)
        {
            var min = new x3dom.fields.SFVec3f,
                max = new x3dom.fields.SFVec3f;
            box.getBounds(min,max);

            var length =  Math.abs(max.x-min.x),
                y = Math.abs(max.y - min.y),
                z = Math.abs(max.z - min.z),
                ret = "x";

            if( y > length)
            {
                length = y;
                ret = "y";
            }
            if( z > length)
            {
                return "z";
            }
            return ret;
        },
        /* calculate boundingBox for all data nodes */
        calculateBBoxForDataNodes : function()
        {
            var box = x3dom.fields.BoxVolume.copy(this.dataNodes[0].bbox),
                min = new x3dom.fields.SFVec3f(),
                max = new x3dom.fields.SFVec3f(),
                nMin = new x3dom.fields.SFVec3f(),
                nMax = new x3dom.fields.SFVec3f();

            box.getBounds(min,max);

            for(var i = 1, n = this.dataNodes.length; i < n; ++i)
            {
                this.dataNodes[i].bbox.getBounds(nMin,nMax);

                if(nMin.x < min.x) min.x = nMin.x;
                if(nMax.x > max.x) max.x = nMax.x;
                if(nMin.y < min.y) min.y = nMin.y;
                if(nMax.y > max.y) max.y = nMax.y;
                if(nMin.z < min.z) min.z = nMin.z;
                if(nMax.z > max.z) max.z = nMax.z;
            }
            box.setBounds(min,max);
            return box;
        },
        splitBoxVolume : function(bbox, axis, leftSplit, rightSplit)
        {
            var min = new x3dom.fields.SFVec3f,
                max = new x3dom.fields.SFVec3f;

            bbox.getBounds(min,max);

            var leftMin = x3dom.fields.SFVec3f.copy(min),
                leftMax = x3dom.fields.SFVec3f.copy(max),
                rightMin = x3dom.fields.SFVec3f.copy(min),
                rightMax = x3dom.fields.SFVec3f.copy(max);

            leftMax[axis] = leftSplit;
            rightMin[axis] = rightSplit;

            return [new x3dom.fields.BoxVolume(leftMin,leftMax),new x3dom.fields.BoxVolume(rightMin,rightMax)];
        },
        calculateCoverage : function(bbox)
        {
            //small feature culling
            var modelViewMat = this.drawableCollection.viewMatrix;
            var center = modelViewMat.multMatrixPnt(bbox.getCenter());
            var rVec = modelViewMat.multMatrixVec(bbox.getRadialVec());
            var r    = rVec.length();
            var dist = Math.max(-center.z - r, this.drawableCollection.near);
            var projPixelLength = dist * this.drawableCollection.pixelHeightAtDistOne;
            return (r * 2.0) / projPixelLength;
        }
    }
);

//---------------------------------------------------------------------------------------------------------------------

/**
 * Decorator for BVH- Debugging
 */
x3dom.bvh.DebugDecorator = defineClass(
    null,
    function(bvh,scene,settings)
    {
        this.bvh = bvh;
        this.scene = scene;
        this.debugShape = null;
        this.renderedDrawablesCount = 0;
    },
    {
        /*add Drawable as DataNode to BVH */
        addDrawable : function(drawable)
        {
            this.bvh.addDrawable(drawable);
        },
        /*
         * measure build time and create debugging elements
         */
        compile : function()
        {
            if(this.bvh.settings.showDebugBoxVolumes && this.scene != null)
            {
                this.createDebugShape();
            }
            if(this.bvh.settings.bvhType == 'jsBIH')
                x3dom.Utils.startMeasure("buildBVH");
            //compile
            this.bvh.compile();

            if(this.bvh.settings.debug && this.bvh.settings.bvhType == 'jsBIH')
            {
                console.log("Compile time: "+x3dom.Utils.stopMeasure("buildBVH"));
                console.log("BVH : %o",this.bvh);
            }
            if(this.bvh.settings.showDebugBoxVolumes)
            {
                if(this.bvh.settings.bvhType == 'jsBIH')
                    this.addHierarchyBoxVolumes();
                this.createLineRenderersFromBoxVolumes();
            }
        },
        showCompileStats : function()
        {
            this.bvh.showCompileStats();
        },
        collectDrawables : function(drawableCollection)
        {
            /*var getDCSize = function(drawableCollection)
            {
                var count = 0;
                for(var i = 0, n = drawableCollection.collection.length; i < n; ++i)
                {
                    count +=  drawableCollection.collection[i].length;
                }
                return count;
            };*/

            this.renderedDrawablesCount = drawableCollection.length;//getDCSize(drawableCollection);
            this.bvh.collectDrawables(drawableCollection);
            this.renderedDrawablesCount = drawableCollection.length - this.renderedDrawablesCount;
            //console.log("added drawables: "+this.renderedDrawablesCount);
        },
        //create shape for debugging
        createDebugShape : function()
        {
            this.debugShape = new x3dom.nodeTypes.Shape();
            this.debugShape._nameSpace = this.scene._nameSpace;

            this.bvh.geo = null,
            this.bvh.coords = null;

            if(!this.debugShape._cf.appearance.node)
            {
                var appearance = x3dom.nodeTypes.Appearance.defaultNode();
                var material = x3dom.nodeTypes.Material.defaultNode();
                material._vf.diffuseColor = new x3dom.fields.SFColor(1,0,0);
                material._vf.specularColor = new x3dom.fields.SFColor(1,0,0);
                material._vf.emissiveColor = new x3dom.fields.SFColor(1,0,0);

                appearance.addChild(material);
                this.debugShape.addChild(appearance);
            }
            if(!this.debugShape._cf.geometry.node)
            {
                this.bvh.geo = new x3dom.nodeTypes.IndexedLineSet();
                this.bvh.coords = new x3dom.nodeTypes.Coordinate();
            }
        },
        addHierarchyBoxVolumes : function()
        {
            //add data from real bvh
            var id = 0;
            var boxVolume;
            while( (boxVolume = this.bvh.getHierarchyNodeBoxVolume(id)) != null)
            {

                this.addBoxVolumeToGeometry(boxVolume,this.bvh.geo);
                id++;
            }
        },
        createLineRenderersFromBoxVolumes : function()
        {
            //add data to frontend elements
            for(var i = 0, n = this.bvh.geo._mesh._positions[0].length; i < n; ++i)
            {
                this.bvh.coords._vf.point.push(this.bvh.geo._mesh._positions[0][i]);
            }

            for(var i = 0, n = this.bvh.geo._mesh._indices[0].length; i < n; ++i)
            {
                this.bvh.geo._vf.coordIndex.push(this.bvh.geo._mesh._indices[0][i]);
                this.bvh.geo._vf.colorIndex.push(0);
            }
            this.bvh.geo.addChild(this.bvh.coords);
            this.debugShape.addChild(this.bvh.geo);
            this.bvh.geo.nodeChanged();
            this.scene.addChild(this.debugShape);
            this.debugShape.nodeChanged();
            this.scene.nodeChanged();
        },

        //adds a boxvolume to a geometry
        addBoxVolumeToGeometry : function(boxVolume, geo)
        {

            var min = new x3dom.fields.SFVec3f(),
                max = new x3dom.fields.SFVec3f();

            boxVolume.getBounds(min,max);

            var startId = geo._mesh._positions[0].length;
            geo._mesh._positions[0].push(
                new x3dom.fields.SFVec3f(min.x, min.y, min.z), // 0 links unten hinten
                new x3dom.fields.SFVec3f(min.x, min.y, max.z), // 1 links unten vorne
                new x3dom.fields.SFVec3f(min.x, max.y, min.z), // 2 links oben hinten
                new x3dom.fields.SFVec3f(min.x, max.y, max.z), // 3 links oben vorne
                new x3dom.fields.SFVec3f(max.x, min.y, min.z), // 4 rechts unten hinten
                new x3dom.fields.SFVec3f(max.x, min.y, max.z), // 5 rechts unten vorne
                new x3dom.fields.SFVec3f(max.x, max.y, min.z), // 6 rechts oben hinten
                new x3dom.fields.SFVec3f(max.x, max.y, max.z)  // 7 rechts oben vorne
            );

            //set indices
            geo._mesh._indices[0].push(
                startId, startId+1, -1,
                startId, startId+2, -1,
                startId, startId+4, -1,
                startId+1, startId+3, -1,
                startId+1, startId+5, -1,
                startId+2, startId+3, -1,
                startId+2, startId+6, -1,
                startId+4, startId+5, -1,
                startId+4, startId+6, -1,
                startId+7, startId+3, -1,
                startId+7, startId+5, -1,
                startId+7, startId+6, -1
            );
        },
        showTraverseStats : function(runtime)
        {
            this.bvh.showTraverseStats(runtime);
        }
    }
);

//---------------------------------------------------------------------------------------------------------------------

/*******************************************
 * Bounding Interval Hierarchy -
 ******************************************/


x3dom.bvh.BihNode = defineClass(
    null,
    function()
    {
        this.rightChild = null;
        this.leftChild = null;

        /* is split axis or leaf node : 0=x,1=y,2=z,-1=leaf */
        this.split_axis = -1;

        /* clipping planes */
        this.clip = [0,0];

        this.bbox = null;

        /* only set in leafs */
        this.dataIndex = [0,0];

    }
);

/**
 * Bounding Interval Hierarchy -
 */
x3dom.bvh.BIH = defineClass(
    x3dom.bvh.Base,
    function(scene, settings)
    {
        x3dom.bvh.BIH.superClass.call(this, settings);
        this.bihNodes = [];
        this.index = [];

        this.env = scene.getEnvironment();
    },
    {
        /*gets BIHNode for id or creates if not present */
        getNodeForIndex : function(index)
        {
            while(this.bihNodes.length <= index)
            {
                this.bihNodes.push(new x3dom.bvh.BihNode());
            }
            return this.bihNodes[index];
        },
        /* sorts given number of objects from start inplace and returns number in "left" space */
        bucketSort : function(startIndex, number, pivot, axis)
        {
            var numLeft = 0,
                center,
                swap;

            //sort into subspaces
            for(var i = 0; i < number; ++i)
            {
                //get center of bounding box
                center = this.dataNodes[this.index[startIndex+i]].bbox.getCenter();

                swap = -1;
                if( center[axis] < pivot )
                {   //swap
                    swap = this.index[startIndex+i];
                    this.index[startIndex+i] = this.index[startIndex+numLeft];
                    this.index[startIndex+numLeft] = swap;
                    numLeft += 1;
                }
            }
            return numLeft;
        },
        /*
         * recursively divides set of geometry into subnodes
         */
        processNode : function(nodeIndex, startObjIndex, numObjs, bbox, depth)
        {
            var node = this.getNodeForIndex(nodeIndex);
            node.bbox = bbox;

            //calculate split axis and split at center of AABB
            node.split_axis = this.getLongestAxisForBox(bbox);
            var splitCenter = bbox.getCenter()[node.split_axis];

            //bucket sort objects into subspaces
            var numLeft = this.bucketSort(startObjIndex,numObjs,splitCenter,node.split_axis);
            var numRight = numObjs - numLeft;

            //adjust splitting planes to really fit both subspaces
            node.clip[0] = bbox.min[node.split_axis];
            node.clip[1] = bbox.max[node.split_axis];

            var centerIndex = startObjIndex + numLeft;
            var i= 0, val= 0;
            for(i = startObjIndex; i < centerIndex; ++i)
            {
                val = this.dataNodes[this.index[i]].bbox.max[node.split_axis];
                if(val > node.clip[0])
                    node.clip[0] = val;
            }

            for(i = centerIndex; i < startObjIndex + numObjs; ++i)
            {
                val = this.dataNodes[this.index[i]].bbox.min[node.split_axis];
                if(val < node.clip[1])
                    node.clip[1] = val;
            }

            //enlarge sub-spaces by X%
            /*var delta = (bbox.max[node.split_axis] - bbox.min[node.split_axis]) * this.settings.bboxEnlargement;
            node.clip[0] += delta;
            node.clip[1] -= delta;
            */

            var relativeBBoxToSmall = (bbox.getDiameter()/ this.coveredBoxVolume.getDiameter()) <= this.settings.minRelativeBBoxSize;

            //get box volumes from split
            var voxel = this.splitBoxVolume(bbox, node.split_axis, node.clip[0], node.clip[1]); //splitCenter could be faster

            //subdivide or store leaves
            if((numLeft > this.settings.maxObjectsPerNode) && (depth < this.settings.maxDepth) && !relativeBBoxToSmall )
            {
                node.leftChild = this.processNode(this.bihNodes.length,startObjIndex,numLeft,voxel[0],depth+1);
            }
            else
            {
                //store in new Node
                node.leftChild = this.getNodeForIndex(this.bihNodes.length);
                node.leftChild.bbox = (numLeft == 1)? this.dataNodes[this.index[startObjIndex]].bbox : voxel[0];

                node.leftChild.dataIndex[0] = startObjIndex;
                node.leftChild.dataIndex[1] = numLeft;
            }

            if((numRight > this.settings.maxObjectsPerNode) && (depth < this.settings.maxDepth) && !relativeBBoxToSmall)
            {
               node.rightChild = this.processNode(this.bihNodes.length,startObjIndex +numLeft,numRight,voxel[1],depth+1);
            }
            else
            {
                //store in new Node
                node.rightChild = this.getNodeForIndex(this.bihNodes.length);
                node.rightChild.bbox = (numRight == 1)? this.dataNodes[this.index[startObjIndex+numLeft]].bbox : voxel[1];

                node.rightChild .dataIndex[0] = startObjIndex + numLeft;
                node.rightChild .dataIndex[1] = numRight;
            }

            return node;
        },
        /*get Node BoxVolume*/
        getHierarchyNodeBoxVolume : function(id)
        {
            if(this.bihNodes.length  > id)
            {
                return this.bihNodes[id].bbox;
            }
            return null;
        },

        /* compiles nodes into bih tree */
        compile : function()
        {
            if(this.dataNodes.length == 0)
                return;

            //calculate covered area boundingbox
            this.coveredBoxVolume = this.calculateBBoxForDataNodes();

            //add to index for bucket sorting
            for(var i = 0, n = this.dataNodes.length; i < n; ++i)
            {
                this.index.push(i);
            }
            this.processNode(0,0,this.dataNodes.length,this.coveredBoxVolume,0);
        },
        showCompileStats : function()
        {

        },
        /* return drawables to webgl for rendering */
        collectDrawables : function(drawableCollection)
        {
            this.drawableCollection = drawableCollection;

            if(this.bihNodes.length > 0)
            {
                var planeMask = 0;
                this.intersect(this.bihNodes[0], planeMask);
            }
        },
        calculateCoverage : function(bbox)
        {
            var modelViewMatrix = this.drawableCollection.viewMatrix;//.mult(transform);
            var center = modelViewMatrix.multMatrixPnt(bbox.getCenter());
            var rVec = modelViewMatrix.multMatrixVec(bbox.getRadialVec());
            var r    = rVec.length();
            var dist = Math.max(-center.z - r, this.drawableCollection.near);
            var projPixelLength = dist * this.drawableCollection.pixelHeightAtDistOne;
            return (r * 2.0) / projPixelLength;
        },
        intersect : function(node, planeMask)
        {
            //viewfrustum intersection test
            if(planeMask < this.settings.MASK_SET)
                planeMask = this.drawableCollection.viewFrustum.intersect(node.bbox,planeMask);
            if(planeMask >= 0)
            {
                //leaf node - add drawables
                if(node.split_axis == -1)
                {
                    //add all drawables of datanodes between indices of node (dataIndex[0] - dataIndex[1])
                    //if they cover enough pixels
                    for(var i = 0, n = node.dataIndex[1]; i < n; ++i)
                    {
                        var dataNode = this.dataNodes[this.index[node.dataIndex[0]+i]];
                        var coverage = this.calculateCoverage(dataNode.bbox);

                        if( coverage >= this.env._vf.smallFeatureThreshold )
                        {
                            dataNode.drawable.priority = coverage;
                            this.drawableCollection.addDrawable(dataNode.drawable);
                        }
                    }
                }
                else
                {
                    var coverage = this.calculateCoverage(node.bbox);
                    if (coverage >= this.env._vf.smallFeatureThreshold )
                    {
                        //traverse children
                        this.intersect(node.leftChild, planeMask);
                        this.intersect(node.rightChild, planeMask);
                    }
                }
            }
        },
        showTraverseStats : function(runtime)
        {

        }
    }
);

//---------------------------------------------------------------------------------------------------------------------

/**
 * Wrapper for cross-compiled Culler
 */
x3dom.bvh.Culler = defineClass(
    null,
    function(drawableCollection, scene, settings)
    {
        this.drawableCollection = drawableCollection;
        this.scene = scene;
        this.settings = settings;
        this.frameId = 0;

        this.compileSetup = new Module.CompileSetup();
        this.compileSetup.poolSize = this.drawableCollection.length;
        this.compileSetup.debug = this.settings.debug;
        this.compileSetup.showDebugBoxVolumes = this.settings.showDebugBoxVolumes;
        this.compileSetup.dataStructureType = this.settings.bvhType == "OCTREE" ? Module.DataStructureType.OCTREE : Module.DataStructureType.BIH;
        this.compileSetup.maxObjectsPerNode = this.settings.maxObjectsPerNode;
        this.compileSetup.maxDepth = this.settings.maxDepth;

        var that = this;

        var jsFuncs =
        {
            addStructureBoxVolume : function(depth, volume)
            {
                var volMin = volume.min, volMax = volume.max;

                var min = new x3dom.fields.SFVec3f(volMin.x, volMin.y, volMin.z),
                    max = new x3dom.fields.SFVec3f(volMax.x, volMax.y, volMax.z);


                var startId = that.geo._mesh._positions[0].length;
                that.geo._mesh._positions[0].push(
                    new x3dom.fields.SFVec3f(min.x, min.y, min.z), // 0 links unten hinten
                    new x3dom.fields.SFVec3f(min.x, min.y, max.z), // 1 links unten vorne
                    new x3dom.fields.SFVec3f(min.x, max.y, min.z), // 2 links oben hinten
                    new x3dom.fields.SFVec3f(min.x, max.y, max.z), // 3 links oben vorne
                    new x3dom.fields.SFVec3f(max.x, min.y, min.z), // 4 rechts unten hinten
                    new x3dom.fields.SFVec3f(max.x, min.y, max.z), // 5 rechts unten vorne
                    new x3dom.fields.SFVec3f(max.x, max.y, min.z), // 6 rechts oben hinten
                    new x3dom.fields.SFVec3f(max.x, max.y, max.z)  // 7 rechts oben vorne
                );

                //set indices
                that.geo._mesh._indices[0].push(
                    startId, startId+1, -1,
                    startId, startId+2, -1,
                    startId, startId+4, -1,
                    startId+1, startId+3, -1,
                    startId+1, startId+5, -1,
                    startId+2, startId+3, -1,
                    startId+2, startId+6, -1,
                    startId+4, startId+5, -1,
                    startId+4, startId+6, -1,
                    startId+7, startId+3, -1,
                    startId+7, startId+5, -1,
                    startId+7, startId+6, -1
                );
            },

            timeNow: function()
            {
                return performance.now();
            }
        };

        this.compileSetup.setJsCallbacks(Module.JsCallbacks.implement(jsFuncs));
        this.culler = new Module.Culler(this.compileSetup);

        this.traverseSetup = new Module.TraverseSetup();
    },
    {
        addDrawable : function(drawable)
        {
            var that = this;

            var funcs =
            {
                drawable: drawable,

                addDrawableToCollection : function(coverage)
                {
                    this.drawable.priority = coverage;
                    that.drawableCollection.addDrawable(this.drawable);
                },

                createBoxVolume : function()
                {
                    var bbox = new x3dom.fields.BoxVolume();
                    bbox.transformFrom(this.drawable.transform, this.drawable.shape.getVolume());
                    this.drawable.worldVolume = x3dom.fields.BoxVolume.copy(bbox);

                    var min = new x3dom.fields.SFVec3f(),max = new x3dom.fields.SFVec3f();
                    bbox.getBounds(min,max);

                    var boxVol = new Module.BoxVolume(new Module.SFVec3f(min.x,min.y,min.z),new Module.SFVec3f(max.x,max.y,max.z));
                    return boxVol;
                }
            };
            var dc = new Module.DrawableContainer.implement(funcs);
            this.culler.addDrawable(dc);
        },

        compile : function()
        {
            this.culler.compile();
        },
        showCompileStats : function()
        {
            console.log(this.culler.stats());
        },
        /* return drawables to webgl for rendering */
        collectDrawables : function(drawableCollection)
        {
            this.drawableCollection = drawableCollection;
            var viewFrustum = this.drawableCollection.viewFrustum;
            var modelViewMatrix = this.drawableCollection.viewMatrix;

            var mvm = new Module.SFMatrix4f(
                modelViewMatrix._00,modelViewMatrix._01,modelViewMatrix._02,modelViewMatrix._03,
                modelViewMatrix._10,modelViewMatrix._11,modelViewMatrix._12,modelViewMatrix._13,
                modelViewMatrix._20,modelViewMatrix._21,modelViewMatrix._22,modelViewMatrix._23,
                modelViewMatrix._30,modelViewMatrix._31,modelViewMatrix._32,modelViewMatrix._33);
            this.traverseSetup.setModelViewMatrix(mvm);


            var vf = new Module.FrustumVolume(
                viewFrustum.planeNormals[0].x,viewFrustum.planeNormals[0].y,viewFrustum.planeNormals[0].z, viewFrustum.planeDistances[0],
                viewFrustum.planeNormals[1].x,viewFrustum.planeNormals[1].y,viewFrustum.planeNormals[1].z, viewFrustum.planeDistances[1],
                viewFrustum.planeNormals[2].x,viewFrustum.planeNormals[2].y,viewFrustum.planeNormals[2].z, viewFrustum.planeDistances[2],
                viewFrustum.planeNormals[3].x,viewFrustum.planeNormals[3].y,viewFrustum.planeNormals[3].z, viewFrustum.planeDistances[3],
                viewFrustum.planeNormals[4].x,viewFrustum.planeNormals[4].y,viewFrustum.planeNormals[4].z, viewFrustum.planeDistances[4],
                viewFrustum.planeNormals[5].x,viewFrustum.planeNormals[5].y,viewFrustum.planeNormals[5].z, viewFrustum.planeDistances[5]
            );
            this.traverseSetup.setViewFrustum(vf);

            //set calculation parameters
            this.traverseSetup.pixelHeightAtDistOne = this.drawableCollection.pixelHeightAtDistOne;
            this.traverseSetup.nearClippingPlane = this.drawableCollection.near;

            var env = this.scene.getEnvironment();

            //setup culling methods
            this.traverseSetup.viewFrustumCulling = env._vf.frustumCulling;
            this.traverseSetup.smallFeatureCulling = env._vf.smallFeatureCulling;
            this.traverseSetup.occlusionCulling = env._vf.occlusionCulling;

            //set up parameters
            this.traverseSetup.smallFeatureThreshold = env._vf.smallFeatureThreshold;
            //this.traverseSetup.occlusionCoveredThreshold = env.occlusionVisibilityThreshold;

            //set up traverser
            this.traverseSetup.useRenderQueue = false;
            this.traverseSetup.frameId = this.frameId++;
            this.traverseSetup.traverserType = Module.TraverserType.DistanceQueue;

            this.culler.cull(this.traverseSetup);

            mvm.delete();
            vf.delete();
        },
        showTraverseStats : function( runtime)
        {
            var cullingStats = this.culler.stats().culling;
            runtime.addInfo('#CNodes Visited', cullingStats.nodesVisited);
            runtime.addInfo('#Cull Frustum', cullingStats.nodesViewFrustumCulled);
            runtime.addInfo('#Cull SFeature', cullingStats.nodesSmallFeatureCulled);
            runtime.addInfo('#Cull OCC', cullingStats.nodesOcclusionCulled);
            runtime.addInfo('#Drawables SF', cullingStats.drawablesSmallFeatureCulled);
        }
    }
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * @class x3dom.X3DCanvas
 */
x3dom.X3DCanvas = function(x3dElem, canvasIdx) {

    var that = this;
	this.canvasIdx = canvasIdx;

    this.initContext = function(canvas, forbidMobileShaders, forceMobileShaders, tryWebGL2, tryIE11)
    {
        x3dom.debug.logInfo("Initializing X3DCanvas for [" + canvas.id + "]");
        var gl = x3dom.gfx_webgl(canvas, forbidMobileShaders, forceMobileShaders, tryWebGL2, x3dElem);
        
        if (!gl) {
            x3dom.debug.logError("No 3D context found...");
            this.x3dElem.removeChild(canvas);
            return null;
        } else {
            var webglVersion = parseFloat(x3dom.caps.VERSION.match(/\d+\.\d+/)[0]);
            if (webglVersion < 1.0 && !tryIE11) {
                x3dom.debug.logError("No valid 3D context found...");
                this.x3dElem.removeChild(canvas);
                return null;
            }
        }
        
        return gl;
    };

	this.initFlashContext = function(object, renderType) {
        x3dom.debug.logInfo("Initializing X3DObject for [" + object.id + "]");
        return x3dom.gfx_flash(object, renderType);
    };

	this.appendParam = function(node, name, value) {
		var param = document.createElement('param');
		param.setAttribute('name', name);
		param.setAttribute('value', value);
		node.appendChild( param );
	};
	
	this.fileExists = function(url) {
		var xhr = new XMLHttpRequest();
		try {
			xhr.open("HEAD", url, false);
			xhr.send(null);
			return (xhr.status != 404);
		} catch(e) { return true; }
	};		
	
	this.detectFlash = function(required, max)
	{
		var required_version = required;
		var max_version = max;
		var available_version = 0;

		/* this section is for NS, Mozilla, Firefox and similar Browsers */
		if(typeof(navigator.plugins["Shockwave Flash"]) == "object")
		{
			var description = navigator.plugins["Shockwave Flash"].description;
			available_version = description.substr(16, (description.indexOf(".", 16) - 16));
		}
		else if(typeof(ActiveXObject) == "function") {
			for(var i = 10; i < (max_version + 1); i ++) {
				try {
					if(typeof(new ActiveXObject("ShockwaveFlash.ShockwaveFlash." + i)) == "object") {
						available_version = i+1;
					}
			   }
			   catch(error){}
			}
		}
	
		return [available_version, required_version];
	};
	
	this.createInitFailedDiv = function(x3dElem) {
		var div = document.createElement('div');
        div.setAttribute("id", "x3dom-create-init-failed");
		div.style.width = x3dElem.getAttribute("width");
		div.style.height = x3dElem.getAttribute("height");
		div.style.backgroundColor = "#C00";
		div.style.color = "#FFF";
		div.style.fontSize = "20px";
		div.style.fontWidth = "bold";
		div.style.padding = "10px 10px 10px 10px";
		div.style.display = "inline-block";
		div.style.fontFamily = "Helvetica";
		div.style.textAlign = "center";
		
		div.appendChild(document.createTextNode('Your Browser does not support X3DOM'));
		div.appendChild(document.createElement('br'));
		div.appendChild(document.createTextNode('Read more about Browser support on:'));
		div.appendChild(document.createElement('br'));
		
		var link = document.createElement('a');
		link.setAttribute('href', 'http://www.x3dom.org/?page_id=9');
		link.appendChild( document.createTextNode('X3DOM | Browser Support'));
		div.appendChild(link);

        // check if "altImg" is specified on x3d element and if so use it as background
        var altImg = x3dElem.getAttribute("altImg") || null;
        if (altImg) {
            var altImgObj = new Image();
            altImgObj.src = altImg;
            div.style.backgroundImage = "url("+altImg+")";
            div.style.backgroundRepeat = "no-repeat";
            div.style.backgroundPosition = "50% 50%";
        }

        x3dElem.appendChild(div);

        x3dom.debug.logError("Your Browser does not support X3DOM!");
	};

    this.createFlashObject = function (x3dElem) {

        var result = this.detectFlash(11, 11);

        if (!result[0] || result[0] < result[1]) {
            return null;
        } else {

            x3dom.debug.logInfo("Creating FlashObject for (X)3D element...");

            //Get X3D-Element ID
            var id = x3dElem.getAttribute("id");
            if (id !== null) {
                id = "x3dom-" + id + "-object";
            } else {
                var index = new Date().getTime();
                id = "x3dom-" + index + "-object";
            }

            //Get SWFPath
            var swf_path = x3dElem.getAttribute("swfpath");
            if (swf_path === null) {
                swf_path = "x3dom.swf";
            }

            if (!this.fileExists(swf_path)) {
                var version;
                if (x3dom.versionInfo === undefined ||
                    x3dom.versionInfo.version.indexOf('dev') != -1) //use dev version
                {
                    version = "dev";
                }
                else {
                    version = x3dom.versionInfo.version.substr(3);
                }

                swf_path = "http://www.x3dom.org/download/" + version + "/x3dom.swf";

                x3dom.debug.logWarning("Can't find local x3dom.swf (" + version + "). X3DOM now using the online version from x3dom.org." +
                    "The online version needs a <a href='http://examples.x3dom.org/crossdomain.xml'>crossdomain.xml</a> " +
                    "file in the root directory of your domain to access textures");
            }

            //Get width from x3d-Element or set default
            var width = x3dElem.getAttribute("width");
            var idx = -1;
            if (width == null) {
                width = 550;
            } else {
                idx = width.indexOf("px");
                if (idx != -1) {
                    width = width.substr(0, idx);
                }
            }
            //Get height from x3d-Element or set default
            var height = x3dElem.getAttribute("height");
            if (height == null) {
                height = 400;
            } else {
                idx = height.indexOf("px");
                if (idx != -1) {
                    height = height.substr(0, idx);
                }
            }

            //Get flash render type
            var renderType = x3dElem.getAttribute("flashrenderer");
            if (renderType == null) {
                this.flash_renderType = "forward";
            } else {
                this.flash_renderType = "deferred";
            }

            var obj = document.createElement('object');
            obj.setAttribute('width', '100%');
            obj.setAttribute('height', '100%');
            obj.setAttribute('id', id);

            //Check for xhtml
            if (!document.doctype || document.doctype && document.doctype.publicId.search(/DTD XHTML/i) != -1) {
                x3dom.debug.logWarning("Flash backend doesn't like XHTML, please use HTML5!");
                obj.setAttribute('style', 'width:' + width + 'px; height:' + height + 'px;');
            } else {
                if (x3dElem.getAttribute('style') == null) {
                    x3dElem.setAttribute('style', 'width:' + width + 'px; height:' + height + 'px;');
                }
            }

            this.appendParam(obj, 'menu', 'false');
            this.appendParam(obj, 'quality', 'high');
            this.appendParam(obj, 'wmode', 'direct');
            this.appendParam(obj, 'allowScriptAccess', 'always');
            this.appendParam(obj, 'flashvars', 'canvasIdx=' + this.canvasIdx + '&renderType=' + this.flash_renderType);
            this.appendParam(obj, 'movie', swf_path);

            if (navigator.appName == "Microsoft Internet Explorer") {
                x3dElem.appendChild(obj);
                obj.setAttribute('classid', 'clsid:d27cdb6e-ae6d-11cf-96b8-444553540000');
            } else {
                obj.setAttribute('type', 'application/x-shockwave-flash');
                obj.setAttribute('data', swf_path);
                x3dElem.appendChild(obj);
            }

            return obj;
        }
    };

    this.createHTMLCanvas = function(x3dElem)
    {
        x3dom.debug.logInfo("Creating canvas for (X)3D element...");
        var canvas = document.createElement('canvas');
        canvas.setAttribute("class", "x3dom-canvas");

        // check if user wants to style the X3D element
        var userStyle = x3dElem.getAttribute("style");
        if (userStyle) {
            x3dom.debug.logInfo("Inline X3D styles detected");
        }

        // check if user wants to attach events to the X3D element
        var evtArr = [
            "onmousedown",
            "onmousemove",
            "onmouseout",
            "onmouseover",
            "onmouseup",
            "onclick",
            "ondblclick",
            "onkeydown",
            "onkeypress",
            "onkeyup",

            // w3c touch: http://www.w3.org/TR/2011/WD-touch-events-20110505/
            "ontouchstart",
            "ontouchmove",
            "ontouchend",
            "ontouchcancel",
            "ontouchleave",
			"ontouchenter",
            
            // apple gestures
            //"ongesturestart",
            //"ongesturechange",
            //"ongestureend",

            // mozilla touch
            "onMozTouchDown",
            "onMozTouchMove",
            "onMozTouchUp",

            // drag and drop, requires 'draggable' source property set true (usually of an img)
            "ondragstart",
            "ondrop",
            "ondragover"
        ];

        // TODO; handle attribute event handlers dynamically during runtime
        //this step is necessary because of some weird behavior in some browsers:
        //we need a canvas element on startup to make every callback (e.g., 'onmousemove') work,
        //which was previously set for the canvas' outer elements
        for (var i=0; i < evtArr.length; i++)
        {
            var evtName = evtArr[i];
            var userEvt = x3dElem.getAttribute(evtName);
            if (userEvt) {
                x3dom.debug.logInfo(evtName +", "+ userEvt);

                canvas.setAttribute(evtName, userEvt);

                //remove the event attribute from the X3D element to prevent duplicate callback invocation
                x3dElem.removeAttribute(evtName);
            }
        }

        var userProp = x3dElem.getAttribute("draggable");
        if (userProp) {
            x3dom.debug.logInfo("draggable=" + userProp);
            canvas.setAttribute("draggable", userProp);
        }

        // workaround since one cannot find out which handlers are registered
        if (!x3dElem.__addEventListener && !x3dElem.__removeEventListener)
        {
            x3dElem.__addEventListener = x3dElem.addEventListener;
            x3dElem.__removeEventListener = x3dElem.removeEventListener;

            // helpers to propagate the element's listeners
            x3dElem.addEventListener = function(type, func, phase) {
                var j, found = false;
                for (j=0; j < evtArr.length && !found; j++) {
                    if (evtArr[j] === type) {
                        found = true;
                    }
                }

                if (found) {
                    x3dom.debug.logInfo('addEventListener for div.on' + type);
                    that.canvas.addEventListener(type, func, phase);
                } else {
                    x3dom.debug.logInfo('addEventListener for X3D.on' + type);
                    this.__addEventListener(type, func, phase);
                }
            };

            x3dElem.removeEventListener = function(type, func, phase) {
                var j, found = false;
                for (j=0; j<evtArr.length && !found; j++) {
                    if (evtArr[j] === type) {
                        found = true;
                    }
                }

                if (found) {
                    x3dom.debug.logInfo('removeEventListener for div.on' + type);
                    that.canvas.removeEventListener(type, func, phase);
                } else {
                    x3dom.debug.logInfo('removeEventListener for X3D.on' + type);
                    this.__removeEventListener(type, func, phase);
                }
            };
        }

        x3dElem.appendChild(canvas);

        // If the X3D element has an id attribute, append "_canvas"
        // to it and and use that as the id for the canvas
        var id = x3dElem.getAttribute("id");
        if (id !== null) {
            canvas.id = "x3dom-" + id + "-canvas";
        } else {
            // If the X3D element does not have an id... do what?
            // For now check the date for creating a (hopefully) unique id
            var index = new Date().getTime();
            canvas.id = "x3dom-" + index + "-canvas";
        }

        // Apply the width and height of the X3D element to the canvas
        var w, h;

        if ((w = x3dElem.getAttribute("width")) !== null) {
            //Attention: pbuffer dim is _not_ derived from style attribs!
            if (w.indexOf("%") >= 0) {
				x3dom.debug.logWarning("The width attribute is to be specified in pixels not in percent.");
			}
            canvas.style.width = w;
            canvas.setAttribute("width", w);
        }

        if ((h = x3dElem.getAttribute("height")) !== null) {
            //Attention: pbuffer dim is _not_ derived from style attribs!
            if (h.indexOf("%") >= 0) {
				x3dom.debug.logWarning("The height attribute is to be specified in pixels not in percent.");
			}
            canvas.style.height = h;
            canvas.setAttribute("height", h);
        }

        // http://snook.ca/archives/accessibility_and_usability/elements_focusable_with_tabindex
        canvas.setAttribute("tabindex", "0");
       // canvas.focus(); ???why - it is necessary - makes touch events break???
        
        return canvas;
    };

    var _old_dim = [0, 0];
    this.watchForResize = function() {

        var new_dim = [
            parseInt(x3dom.getStyle(that.canvas, "width")),
            parseInt(x3dom.getStyle(that.canvas, "height"))
        ];
        
        if ((_old_dim[0] != new_dim[0]) || (_old_dim[1] != new_dim[1])) {
            _old_dim = new_dim;
            that.x3dElem.setAttribute("width", new_dim[0]+"px");
            that.x3dElem.setAttribute("height", new_dim[1]+"px");
        }
    };

    this.createProgressDiv = function() {
        var progressDiv = document.createElement('div');
        progressDiv.setAttribute("class", "x3dom-progress");

        var _text = document.createElement('strong');
        _text.appendChild(document.createTextNode('Loading...'));
        progressDiv.appendChild(_text);

        var _inner = document.createElement('span');
        _inner.setAttribute('style', "width: 25%;");
        _inner.appendChild(document.createTextNode(' '));  // this needs to be a protected whitespace
        progressDiv.appendChild(_inner);

        progressDiv.oncontextmenu = progressDiv.onmousedown = function(evt) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.returnValue = false;
            return false;
        };
        return progressDiv;
    };


	//Need for WebKit Browser
	this.isFlashReady = false;

    this.x3dElem = x3dElem;

    x3dom.caps.MOBILE = (navigator.appVersion.indexOf("Mobile") > -1);
	
	this.backend = this.x3dElem.getAttribute('backend');
	if (this.backend)
	    this.backend = this.backend.toLowerCase();
	else
	    this.backend = 'none';

    if (this.backend == 'flash') {
		this.backend = 'flash';
		this.canvas = this.createFlashObject(x3dElem);
		if (this.canvas != null) {
			this.canvas.parent = this;
			this.gl = this.initFlashContext(this.canvas, this.flash_renderType);
		} else {
			this.createInitFailedDiv(x3dElem);
			return;
		}
	} else {
		this.canvas = this.createHTMLCanvas(x3dElem);
		this.canvas.parent = this;
		this.gl = this.initContext( this.canvas, 
		            (this.backend.search("desktop") >= 0), 
		            (this.backend.search("mobile") >= 0),
                    (this.backend.search("webgl2") >= 0),
                    (this.backend.search("ie11") >= 0));
		this.backend = 'webgl';
		if (this.gl == null)
		{
			x3dom.debug.logInfo("Fallback to Flash Renderer");
			this.backend = 'flash';
			this.canvas = this.createFlashObject(x3dElem);
			if (this.canvas != null) {
				this.canvas.parent = this;
				this.gl = this.initFlashContext(this.canvas, this.flash_renderType);
			} else {
				this.createInitFailedDiv(x3dElem);
				return;
			}
		}
	}
	
	x3dom.caps.BACKEND = this.backend;

    // for FPS measurements
    this.fps_t0 = new Date().getTime();

    this.lastTimeFPSWasTaken = 0;
    this.framesSinceLastTime = 0;

    this.doc = null;

    // allow listening for (size) changes
    x3dElem.__setAttribute = x3dElem.setAttribute;
    x3dElem.setAttribute = function(attrName, newVal) {
        this.__setAttribute(attrName, newVal);

        switch(attrName) {

            case "width":
                that.canvas.setAttribute("width", newVal);
                if (that.doc._viewarea) {
                    that.doc._viewarea._width = parseInt(that.canvas.getAttribute("width"), 0);
                }
                break;

            case "height":
                that.canvas.setAttribute("height", newVal);
                if (that.doc._viewarea) {
                    that.doc._viewarea._height = parseInt(that.canvas.getAttribute("height"), 0);
                }
                break;

            default:
        }

        that.doc.needRender = true;
    };

    var runtimeEnabled = x3dElem.getAttribute("runtimeEnabled");

    if (runtimeEnabled !== null) {
        this.hasRuntime = (runtimeEnabled.toLowerCase() == "true");
    } else {
        this.hasRuntime = x3dElem.hasRuntime;
    }

    if (this.gl === null) {
        this.hasRuntime = false;
    }

	//States only needed for the webgl backend. flash has his own.
    if (this.backend != "flash") {
        this.showStat = x3dElem.getAttribute("showStat");

        this.stateViewer = new x3dom.States(x3dElem);
        if (this.showStat !== null && this.showStat == "true") {
            this.stateViewer.display(true);
        }

        this.x3dElem.appendChild(this.stateViewer.viewer);
    }

    // progress bar
    this.showProgress = x3dElem.getAttribute("showProgress");
    this.progressDiv = this.createProgressDiv();
    this.progressDiv.style.display = (this.showProgress !== null && this.showProgress == "true") ? "inline" : "none";
    this.x3dElem.appendChild(this.progressDiv);

    // touch visualization
    this.showTouchpoints = x3dElem.getAttribute("showTouchpoints");
    this.showTouchpoints = this.showTouchpoints ? !(this.showTouchpoints.toLowerCase() == "false") : true;
    //this.showTouchpoints = this.showTouchpoints ? (this.showTouchpoints.toLowerCase() == "true") : false;

    // disable touch events
    this.disableTouch = x3dElem.getAttribute("disableTouch");
    this.disableTouch = this.disableTouch ? (this.disableTouch.toLowerCase() == "true") : false;
    
    
    if (this.canvas !== null && this.gl !== null && this.hasRuntime && this.backend !== "flash") {
        // event handler for mouse interaction
        this.canvas.mouse_dragging = false;
        this.canvas.mouse_button = 0;
        this.canvas.mouse_drag_x = 0;
        this.canvas.mouse_drag_y = 0;

        this.canvas.isMulti = false;    // don't interfere with multi-touch

        this.canvas.oncontextmenu = function(evt) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.returnValue = false;
            return false;
        };
        
        // TODO: handle context lost events properly
        this.canvas.addEventListener("webglcontextlost", function(event) {
            x3dom.debug.logError("WebGL context lost");
            event.preventDefault();
        }, false);
        
        this.canvas.addEventListener("webglcontextrestored", function(event) {
            x3dom.debug.logError("recover WebGL state and resources on context lost NYI");
            event.preventDefault();
        }, false);
        
        
        // Mouse Events
        this.canvas.addEventListener('mousedown', function (evt) {
			if(!this.isMulti) {
				this.focus();
				
				switch(evt.button) {
					case 0:  this.mouse_button = 1; break;  //left
					case 1:  this.mouse_button = 4; break;  //middle
					case 2:  this.mouse_button = 2; break;  //right
					default: this.mouse_button = 0; break;
				}
				
				if (evt.shiftKey) { this.mouse_button = 1; }
				if (evt.ctrlKey)  { this.mouse_button = 4; }
				if (evt.altKey)   { this.mouse_button = 2; }
				
				var pos = this.parent.mousePosition(evt);
				this.mouse_drag_x = pos.x;
				this.mouse_drag_y = pos.y;
				
				this.mouse_dragging = true;
				
				this.parent.doc.onMousePress(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
				this.parent.doc.needRender = true;
				
				evt.returnValue = true;
			}
        }, false);

        this.canvas.addEventListener('mouseup', function (evt) {
			if(!this.isMulti) {
			    var prev_mouse_button = this.mouse_button;
				this.mouse_button = 0;
				this.mouse_dragging = false;

				this.parent.doc.onMouseRelease(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button, prev_mouse_button);
				this.parent.doc.needRender = true;
				
				evt.returnValue = true;
			}
        }, false);

        this.canvas.addEventListener('mouseover', function (evt) {
			if(!this.isMulti) {
				this.mouse_button = 0;
				this.mouse_dragging = false;

				this.parent.doc.onMouseOver(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
				this.parent.doc.needRender = true;
				
				evt.returnValue = true;
			}
        }, false);

        this.canvas.addEventListener('mouseout', function (evt) {
			if(!this.isMulti) {
				this.mouse_button = 0;
				this.mouse_dragging = false;

				this.parent.doc.onMouseOut(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
				this.parent.doc.needRender = true;
				
				evt.returnValue = true;
			}
        }, false);

        this.canvas.addEventListener('dblclick', function (evt) {
			if(!this.isMulti) {
				this.mouse_button = 0;
				
				var pos = this.parent.mousePosition(evt);
				this.mouse_drag_x = pos.x;
				this.mouse_drag_y = pos.y;
				
				this.mouse_dragging = false;

				this.parent.doc.onDoubleClick(that.gl, this.mouse_drag_x, this.mouse_drag_y);
				this.parent.doc.needRender = true;
				
				evt.returnValue = true;
			}
        }, false);

        this.canvas.addEventListener('mousemove', function (evt) {
			if(!this.isMulti) {

				if (evt.shiftKey) { this.mouse_button = 1; }
				if (evt.ctrlKey)  { this.mouse_button = 4; }
				if (evt.altKey)   { this.mouse_button = 2; }
           
				var pos = this.parent.mousePosition(evt);
				this.mouse_drag_x = pos.x;
              	this.mouse_drag_y = pos.y; 
				
				if (this.mouse_dragging) {
					this.parent.doc.onDrag(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
				}
				else {
					this.parent.doc.onMove(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
				}
			    
				this.parent.doc.needRender = true;
				
				// deliberately different for performance reasons
				evt.preventDefault();
				evt.stopPropagation();
				evt.returnValue = false;
			}
        }, false);

        this.canvas.addEventListener('DOMMouseScroll', function (evt) {
			if(!this.isMulti) {
                this.focus();

				this.mouse_drag_y += 2 * evt.detail;

				this.parent.doc.onDrag(that.gl, this.mouse_drag_x, this.mouse_drag_y, 2);
				this.parent.doc.needRender = true;

                evt.preventDefault();
                evt.stopPropagation();
                evt.returnValue = false;
			}
        }, false);

        this.canvas.addEventListener('mousewheel', function (evt) {
			if(!this.isMulti) {
                this.focus();

				this.mouse_drag_y -= 0.1 * evt.wheelDeltaY;

				this.parent.doc.onDrag(that.gl, this.mouse_drag_x, this.mouse_drag_y, 2);
				this.parent.doc.needRender = true;

                evt.preventDefault();
                evt.stopPropagation();
                evt.returnValue = false;
			}
        }, false);


        // Key Events
        this.canvas.addEventListener('keypress', function (evt) {
            var keysEnabled = this.parent.x3dElem.getAttribute("keysEnabled");
            if (!keysEnabled || keysEnabled.toLowerCase() == "true") {
                this.parent.doc.onKeyPress(evt.charCode);
            }
            this.parent.doc.needRender = true;
            evt.returnValue = true;
        }, true);

        // in webkit special keys are only handled on key-up
        this.canvas.addEventListener('keyup', function (evt) {
            var keysEnabled = this.parent.x3dElem.getAttribute("keysEnabled");
            if (!keysEnabled || keysEnabled.toLowerCase() == "true") {
                this.parent.doc.onKeyUp(evt.keyCode);
            }
            this.parent.doc.needRender = true;
            evt.returnValue = true;
        }, true);

        this.canvas.addEventListener('keydown', function (evt) {
            var keysEnabled = this.parent.x3dElem.getAttribute("keysEnabled");
            if (!keysEnabled || keysEnabled.toLowerCase() == "true") {
                this.parent.doc.onKeyDown(evt.keyCode);
            }
            this.parent.doc.needRender = true;
            evt.returnValue = true;
        }, true);


        // Multitouch Events
        var touches =
        {
          numTouches : 0,
          
          firstTouchTime: new Date().getTime(),
          firstTouchPoint: new x3dom.fields.SFVec2f(0,0),
          
          lastDrag : new x3dom.fields.SFVec2f(),
          
          lastMiddle : new x3dom.fields.SFVec2f(),
          lastDistance : new x3dom.fields.SFVec2f(),
          lastSquareDistance : 0,
          lastAngle : 0,
		  lastLayer : [],

          examineNavType: true,
          
          calcAngle : function(vector)
          {
            var rotation = vector.normalize().dot(new x3dom.fields.SFVec2f(1,0));
            rotation = Math.acos(rotation);
            
            if(vector.y < 0)
              rotation = Math.PI + (Math.PI - rotation);
              
            return rotation;
          },

          disableTouch: this.disableTouch,
          // set a marker in HTML so we can track the position of the finger visually
          visMarker: this.showTouchpoints,
          visMarkerBag: [],
          
          visualizeTouches: function(evt)
          {
              if (!this.visMarker)
                  return;

              var touchBag = [];
              var marker = null;
              
              for (var i=0; i<evt.touches.length; i++) {
                  var id = evt.touches[i].identifier || evt.touches[i].streamId;
                  if (!id) id = 0;
                  
                  var index = this.visMarkerBag.indexOf(id);
                  
                  if (index >= 0) {
                      marker = document.getElementById("visMarker" + id);

                      marker.style.left = (evt.touches[i].pageX) + "px";
                      marker.style.top  = (evt.touches[i].pageY) + "px";
                  }
                  else {
                      marker = document.createElement("div");
                      
        			  marker.appendChild(document.createTextNode("#" + id));
        			  marker.id = "visMarker" + id;
        			  marker.className = "x3dom-touch-marker";
        			  document.body.appendChild(marker);
        			  
        			  index = this.visMarkerBag.length;
        			  this.visMarkerBag[index] = id;
                  }
                  
                  touchBag.push(id);
              }
              
              for (var j=this.visMarkerBag.length-1; j>=0; j--) {
                  var oldId = this.visMarkerBag[j];
                  
                  if (touchBag.indexOf(oldId) < 0) {
                      this.visMarkerBag.splice(j, 1);
                      marker = document.getElementById("visMarker" + oldId);
                      document.body.removeChild(marker);
                  }
              }
          }
        };
        
        // Mozilla Touches
        var mozilla_ids = [];
		
        var mozilla_touches = 
        {
          touches : [],
          preventDefault : function() {}
        };
        
        // === Touch Start ===
        var touchStartHandler = function(evt, doc)
        {
            this.isMulti = true;
			evt.preventDefault();
			touches.visualizeTouches(evt);

            this.focus();
			
			if (doc == null)
				doc = this.parent.doc;

            var navi = doc._scene.getNavigationInfo();
            touches.examineNavType = (navi.getType() == "examine");

			touches.lastLayer = [];

            var i, pos;
			for(i = 0; i < evt.touches.length; i++) {
				pos = this.parent.mousePosition(evt.touches[i]);
				touches.lastLayer.push(new Array(evt.touches[i].identifier, new x3dom.fields.SFVec2f(pos.x,pos.y)));
			}
           
			if(touches.numTouches < 1 && evt.touches.length == 1) {
			
				touches.numTouches = 1;
				touches.lastDrag = new x3dom.fields.SFVec2f(evt.touches[0].screenX, evt.touches[0].screenY);
			}
			else if(touches.numTouches < 2 && evt.touches.length >= 2) {
			
				touches.numTouches = 2;
            
				var touch0 = new x3dom.fields.SFVec2f(evt.touches[0].screenX, evt.touches[0].screenY);
				var touch1 = new x3dom.fields.SFVec2f(evt.touches[1].screenX, evt.touches[1].screenY);
            
				var distance = touch1.subtract(touch0);
				var middle = distance.multiply(0.5).add(touch0);
				var squareDistance = distance.dot(distance);
            
				touches.lastDistance = distance;
				touches.lastMiddle = middle;
				touches.lastSquareDistance = squareDistance;
				touches.lastAngle = touches.calcAngle(distance);
			}
			
			// update scene bbox
			doc._scene.updateVolume();

            if (touches.examineNavType) {
                for(i = 0; i < evt.touches.length; i++) {
                    pos = this.parent.mousePosition(evt.touches[i]);
                    doc.onPick(that.gl, pos.x, pos.y);
                    doc._viewarea.prepareEvents(pos.x, pos.y, 1, "onmousedown");
                    doc._viewarea._pickingInfo.lastClickObj = doc._viewarea._pickingInfo.pickObj;
                }
            }
            else if (evt.touches.length) {
                pos = this.parent.mousePosition(evt.touches[0]);
                doc.onMousePress(that.gl, pos.x, pos.y, 1);     // 1 means left mouse button
            }

            doc.needRender = true;
        };
        
        var touchStartHandlerMoz = function(evt)
        {
			this.isMulti = true;
			evt.preventDefault();
          
			var new_id = true;
			for(var i=0; i<mozilla_ids.length; ++i)
				if(mozilla_ids[i] == evt.streamId)
					new_id = false;
              
			if(new_id == true) {		
				evt.identifier = evt.streamId;
				mozilla_ids.push(evt.streamId);
				mozilla_touches.touches.push(evt);
			}
			touchStartHandler(mozilla_touches, this.parent.doc);
        };
        
        // === Touch Move ===
        var touchMoveHandler = function(evt, doc)
        {
			evt.preventDefault();
			touches.visualizeTouches(evt);
			
			if (doc == null)
				doc = this.parent.doc;

            var pos = null;
            var rotMatrix = null;

            if (touches.examineNavType) {
                /*
                if (doc._scene._vf.doPickPass && doc._scene._vf.pickMode.toLowerCase() !== "box") {
                    for(var i = 0; i < evt.touches.length; i++) {
                        pos = this.parent.mousePosition(evt.touches[i]);
                        doc.onPick(that.gl, pos.x, pos.y);

                        doc._viewarea.handleMoveEvt(pos.x, pos.y, 1);
                    }
                }
                */

                // one finger: x/y rotation
                if(evt.touches.length == 1) {
                    var currentDrag = new x3dom.fields.SFVec2f(evt.touches[0].screenX, evt.touches[0].screenY);

                    var deltaDrag = currentDrag.subtract(touches.lastDrag);
                    touches.lastDrag = currentDrag;

                    var mx = x3dom.fields.SFMatrix4f.rotationY(deltaDrag.x / 100);
                    var my = x3dom.fields.SFMatrix4f.rotationX(deltaDrag.y / 100);
                    rotMatrix = mx.mult(my);

                    doc.onMoveView(that.gl, null, rotMatrix);
                }
                // two fingers: scale, translation, rotation around view (z) axis
                else if(evt.touches.length >= 2) {
                    var touch0 = new x3dom.fields.SFVec2f(evt.touches[0].screenX, evt.touches[0].screenY);
                    var touch1 = new x3dom.fields.SFVec2f(evt.touches[1].screenX, evt.touches[1].screenY);

                    var distance = touch1.subtract(touch0);
                    var middle = distance.multiply(0.5).add(touch0);
                    var squareDistance = distance.dot(distance);

                    var deltaMiddle = middle.subtract(touches.lastMiddle);
                    var deltaZoom = squareDistance - touches.lastSquareDistance;

                    var deltaMove = new x3dom.fields.SFVec3f(
                                                 deltaMiddle.x / screen.width,
                                                -deltaMiddle.y / screen.height,
                                                 deltaZoom / (screen.width * screen.height * 0.2));

                    var rotation = touches.calcAngle(distance);
                    var angleDelta = touches.lastAngle - rotation;
                    touches.lastAngle = rotation;

                    rotMatrix = x3dom.fields.SFMatrix4f.rotationZ(angleDelta);

                    touches.lastMiddle = middle;
                    touches.lastDistance = distance;
                    touches.lastSquareDistance = squareDistance;

                    doc.onMoveView(that.gl, deltaMove, rotMatrix);
                }
            }
            else if (evt.touches.length) {
                pos = this.parent.mousePosition(evt.touches[0]);
                doc.onDrag(that.gl, pos.x, pos.y, 1);
            }

            doc.needRender = true;
        };
        
        var touchMoveHandlerMoz = function(evt)
        {
			evt.preventDefault();
          
			for(var i=0; i<mozilla_ids.length; ++i)
				if(mozilla_ids[i] == evt.streamId)
					mozilla_touches.touches[i] = evt;
          
			touchMoveHandler(mozilla_touches, this.parent.doc);
        };
        
        // === Touch end ===
        var touchEndHandler = function(evt, doc)
        {
            this.isMulti = false;
			evt.preventDefault();
			touches.visualizeTouches(evt);
			
			if (doc == null)
				doc = this.parent.doc;

			doc._viewarea._isMoving = false;

			// reinit first finger for rotation
			if (touches.numTouches == 2 && evt.touches.length == 1)
				touches.lastDrag = new x3dom.fields.SFVec2f(evt.touches[0].screenX, evt.touches[0].screenY);
			
			var dblClick = false;
			
			if (evt.touches.length < 2) {
			    if (touches.numTouches == 1)
			        dblClick = true;
			    touches.numTouches = evt.touches.length;
			}

            if (touches.examineNavType) {
                for(var i = 0; i < touches.lastLayer.length; i++) {
                    var pos = touches.lastLayer[i][1];

                    doc.onPick(that.gl, pos.x, pos.y);

                    if (doc._scene._vf.pickMode.toLowerCase() !== "box") {
                        doc._viewarea.prepareEvents(pos.x, pos.y, 1, "onmouseup");
                        doc._viewarea._pickingInfo.lastClickObj = doc._viewarea._pickingInfo.pickObj;

                        // click means that mousedown _and_ mouseup were detected on same element
                        if (doc._viewarea._pickingInfo.pickObj &&
                            doc._viewarea._pickingInfo.pickObj ===
                            doc._viewarea._pickingInfo.lastClickObj) {

                            doc._viewarea.prepareEvents(pos.x, pos.y, 1, "onclick");
                        }
                    }
                    else {
                        var line = doc._viewarea.calcViewRay(pos.x, pos.y);
                        var isect = doc._scene.doIntersect(line);
                        var obj = line.hitObject;

                        if (isect && obj) {
                            doc._viewarea._pick.setValues(line.hitPoint);
                            doc._viewarea.checkEvents(obj, pos.x, pos.y, 1, "onclick");

                            x3dom.debug.logInfo("Hit '" + obj._xmlNode.localName + "/ " +
                                                obj._DEF + "' at pos " + doc._viewarea._pick);
                        }
                    }
                }

                if (dblClick) {
                    var now = new Date().getTime();
                    var dist = touches.firstTouchPoint.subtract(touches.lastDrag).length();

                    if (dist < 18 && now - touches.firstTouchTime < 180)
                        doc.onDoubleClick(that.gl, 0, 0);

                    touches.firstTouchTime = now;
                    touches.firstTouchPoint = touches.lastDrag;
                }
            }
            else if (touches.lastLayer.length) {
                pos = touches.lastLayer[0][1];
                doc.onMouseRelease(that.gl, pos.x, pos.y, 0, 1);
            }
			
			doc.needRender = true;
        };
        
        var touchEndHandlerMoz = function(evt)
        {
			this.isMulti = false;
			evt.preventDefault();
          
			var remove_index = -1;
			for(var i=0; i<mozilla_ids.length; ++i)
				if(mozilla_ids[i] == evt.streamId)
					remove_index = i;
              
			if(remove_index != -1)
			{
				mozilla_ids.splice(remove_index, 1);
				mozilla_touches.touches.splice(remove_index, 1);
			}
          
			touchEndHandler(mozilla_touches, this.parent.doc);
        };

        if (!this.disableTouch)
        {
            // mozilla touch events
            this.canvas.addEventListener('MozTouchDown',  touchStartHandlerMoz, true);
            this.canvas.addEventListener('MozTouchMove',  touchMoveHandlerMoz,  true);
            this.canvas.addEventListener('MozTouchUp',    touchEndHandlerMoz,   true);

            // w3c / apple touch events (in Chrome via chrome://flags)
            this.canvas.addEventListener('touchstart',    touchStartHandler, true);
            this.canvas.addEventListener('touchmove',     touchMoveHandler,  true);
            this.canvas.addEventListener('touchend',      touchEndHandler,   true);
        }
    }
    
    /** Helper that converts a point from node coordinates to page coordinates 
        FIXME: does NOT work when x3dom.css is not included so that x3d element is not floating
    */
    this.mousePosition = function(evt)
    {
        var convertPoint = window.webkitConvertPointFromNodeToPage;
        var x = 0, y = 0;

        if ( "getBoundingClientRect" in document.documentElement ) {
            var elem = evt.target.offsetParent;    // should be x3dElem
    		var box = elem.getBoundingClientRect();
    		
    		var scrollLeft =  window.pageXOffset || document.body.scrollLeft;
    		var scrollTop =  window.pageYOffset || document.body.scrollTop;
            
            var compStyle = document.defaultView.getComputedStyle(elem, null);
            
    		var paddingLeft = parseFloat(compStyle.getPropertyValue('padding-left'));
    		var borderLeftWidth = parseFloat(compStyle.getPropertyValue('border-left-width'));
            
    		var paddingTop = parseFloat(compStyle.getPropertyValue('padding-top'));
    		var borderTopWidth = parseFloat(compStyle.getPropertyValue('border-top-width'));
    		
    		x = Math.round(evt.pageX - (box.left + paddingLeft + borderLeftWidth + scrollLeft));
    		y = Math.round(evt.pageY - (box.top + paddingTop + borderTopWidth + scrollTop));
        }
        else if (convertPoint) {
            var point = convertPoint(evt.target, new WebKitPoint(0, 0));

            x = Math.round(point.x);
            y = Math.round(point.y);
        }
        else {
    		x3dom.debug.logError('NO getBoundingClientRect, NO webkitConvertPointFromNodeToPage');
    	}
    	
    	return new x3dom.fields.SFVec2f(x, y);
    };
};

x3dom.X3DCanvas.prototype.tick = function()
{
    try {
        var runtime = this.x3dElem.runtime;

        var d = new Date().getTime();
        var diff = d - this.lastTimeFPSWasTaken;

        var fps = 1000.0 / (d - this.fps_t0);
        this.fps_t0 = d;

        // update routes and stuff
        this.doc.advanceTime(d / 1000.0);
        var animD = new Date().getTime() - d;

        if (this.doc.needRender) {
            // calc average frames per second
            if (diff >= 1000) {
                runtime.fps = this.framesSinceLastTime / (diff / 1000.0);
                runtime.addMeasurement('FPS', runtime.fps);

                this.framesSinceLastTime = 0;
                this.lastTimeFPSWasTaken = d;
            }
            this.framesSinceLastTime++;

            runtime.addMeasurement('ANIM', animD);

            if (runtime.isReady == false) {
                runtime.ready();
                runtime.isReady = true;
            }

            runtime.enterFrame();

            if (this.backend == 'flash') {
                if (this.isFlashReady) {
                    this.canvas.setFPS({fps: fps});

                    this.doc.needRender = false;
                    this.doc.render(this.gl);
                }
            }
            else {
                // picking might require another pass
                this.doc.needRender = false;
                this.doc.render(this.gl);

                if (!this.doc._scene._vf.doPickPass)
                    runtime.removeMeasurement('PICKING');
            }

            runtime.exitFrame();
        }

        if (this.progressDiv) {
            if (this.doc.downloadCount > 0) {
                runtime.addInfo("#LOADS:", this.doc.downloadCount);
            } else {
                runtime.removeInfo("#LOADS:");
            }

            if (this.doc.properties.getProperty("showProgress") !== 'false') {
                if (this.progressDiv) {
                    this.progressDiv.childNodes[0].textContent = 'Loading: ' + (+this.doc.downloadCount);
                    if (this.doc.downloadCount > 0) {
                        this.progressDiv.style.display = 'inline';
                    } else {
                        this.progressDiv.style.display = 'none';
                    }

                    /*
                    var myThat = this;
                    window.setTimeout( function() {
                        myThat.doc.downloadCount = 0;
                        myThat.progressDiv.style.display = 'none';
                    }, 10000 );
                    */
                }
            } else {
                this.progressDiv.style.display = 'none';
            }
        }
    } catch (e) {
        x3dom.debug.logException(e);
        throw e;
    }
};

/** Loads the given @p uri.
    @param uri can be a uri or an X3D node
    @param sceneElemPos
    @param settings properties
    */
x3dom.X3DCanvas.prototype.load = function(uri, sceneElemPos, settings) {
    this.doc = new x3dom.X3DDocument(this.canvas, this.gl, settings);
    var x3dCanvas = this;

    this.doc.onload = function () {
        //x3dom.debug.logInfo("loaded '" + uri + "'");
		
        if (x3dCanvas.hasRuntime) {

			// requestAnimationFrame https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/sdk/demos/common/webgl-utils.js
			(function mainloop(){
                x3dCanvas.watchForResize();
        		x3dCanvas.tick();
			    window.requestAnimFrame(mainloop, x3dCanvas);
		    })();

        } else {
            x3dCanvas.tick();
        }
    };

    this.x3dElem.render = function() {
        if (x3dCanvas.hasRuntime) {
            x3dCanvas.doc.needRender = true;
        } else {
            x3dCanvas.doc.render(x3dCanvas.gl);
        }
    };

    this.x3dElem.context = x3dCanvas.gl.ctx3d;

    this.doc.onerror = function () {
        alert('Failed to load X3D document');
    };

    this.doc.load(uri, sceneElemPos);
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/**
 * Class: x3dom.runtime
 *
 * Runtime proxy object to get and set runtime parameters. This object
 * is attached to each X3D element and can be used in the following manner:
 *
 * > var e = document.getElementById('the_x3delement');
 * > e.runtime.showAll();
 * > e.runtime.resetView();
 * > ...
 */

// Global runtime
/**
 * @namespace Namespace container for Runtime module
 */
x3dom.runtime = {};

/** c'tor */
x3dom.Runtime = function(doc, canvas) {
    this.doc = doc;
    this.canvas = canvas;
    
    this.config = {};
    this.isReady = false;
    
    this.fps = 0;
      
    this.states = { measurements: [], infos: [] };
};


x3dom.Runtime.prototype.addMeasurement = function (title, value) {
    this.states.measurements[title] = value;
};

x3dom.Runtime.prototype.removeMeasurement = function (title) {
    if (this.states.measurements[title]) {
        delete this.states.measurements[title];
    }
};

x3dom.Runtime.prototype.addInfo = function (title, value) {
    this.states.infos[title] = value;
};

x3dom.Runtime.prototype.removeInfo = function (title) {
    delete this.states.infos[title];
};


x3dom.Runtime.prototype.initialize = function(doc, canvas) {
    this.doc = doc;
    this.canvas = canvas;

    // place to hold configuration data, i.e. flash backend path, etc.
    // format and structure needs to be decided.
    this.config = {};
    this.isReady = false;
    
    this.fps = 0;
};


/**
 * APIFunction: noBackendFound
 *
 * This method is called once the system initialized and is not ready to 
 * render the first time because there is no backend found. By default this
 * method noop. You can however override it with your own implementation.
 *
 * > x3dom.runtime.noBackendFound = function() {
 * >    alert("Dingel Dingel Ding Dong...");
 * > }
 *
 * It is important to create this override before the document onLoad event has 
 * fired. Therefore putting it directly under the inclusion of x3dom.js is the 
 * preferred way to ensure overloading of this function.
 */
x3dom.Runtime.prototype.noBackendFound = function() {
    x3dom.debug.logInfo('No backend found. Unable to render.');
};

/**
 * APIFunction: ready
 *
 * This method is called once the system initialized and is ready to render
 * the first time. It is therefore possible to execute custom
 * action by overriding this method in your code:
 *
 * > x3dom.runtime.ready = function() {
 * >    alert("About to render something the first time");
 * > }
 *
 * It is important to create this override before the document onLoad event has fired.
 * Therefore putting it directly under the inclusion of x3dom.js is the preferred
 * way to ensure overloading of this function.
 *
 * Parameters:
 * 		element - The x3d element this handler is acting upon
 */
x3dom.Runtime.prototype.ready = function() {
    x3dom.debug.logInfo('System ready.');
};

/**
 * APIFunction: enterFrame
 *
 * This method is called just before the next frame is
 * rendered. It is therefore possible to execute custom
 * action by overriding this method in your code:
 *
 * > var element = document.getElementById('my_element');
 * > element.runtime.enterFrame = function() {
 *     alert('hello custom enter frame');
 * };
 *
 * If you have more than one X3D element in your HTML
 * During initialization, just after ready() executed and before the very first frame
 * is rendered, only the global override of this method works. If you need to execute
 * code before the first frame renders, it is therefore best to use the ready()
 * function instead.
 *
 * Parameters:
 * 		element - The x3d element this handler is acting upon
 */
x3dom.Runtime.prototype.enterFrame = function() {
    //x3dom.debug.logInfo('Render frame imminent');
    // to be overwritten by user
};

/**
 * APIFunction: exitFrame
 *
 * This method is called just after the current frame was
 * rendered. It is therefore possible to execute custom
 * action by overriding this method in your code:
 *
 * > var element = document.getElementById('my_element');
 * > element.runtime.exitFrame = function() {
 *     alert('hello custom exit frame');
 * };
 *
 * Parameters:
 * 		element - The x3d element this handler is acting upon
 */
x3dom.Runtime.prototype.exitFrame = function() {
    //x3dom.debug.logInfo('Render frame finished');
    // to be overwritten by user
};

/**
 * APIFunction: triggerRedraw
 *
 * triggers a redraw of the scene
 *
 */
x3dom.Runtime.prototype.triggerRedraw = function() {
    this.canvas.doc.needRender = true;
};

/**
 * APIFunction: getActiveBindable
 *
 * Returns the currently active bindable DOM element of the given type.
 * typeName must be a valid Bindable node (e.g. Viewpoint, Background, etc.).
 *
 * For example:
 *
 *   > var element, bindable;
 *   > element = document.getElementById('the_x3delement');
 *   > bindable = element.runtime.getActiveBindable('background');
 *   > bindable.setAttribute('bind', 'false');
 *
 * Parameters:
 * 		typeName - Bindable type name
 *
 * Returns:
 * 		The active DOM element
 */
x3dom.Runtime.prototype.getActiveBindable = function(typeName) {
    var stacks;
    var i, current, result;
    var type;

    stacks = this.canvas.doc._bindableBag._stacks;
    result = [];

    type = x3dom.nodeTypesLC[typeName.toLowerCase()];

    if (!type) {
        x3dom.debug.logError('No node of type "' + typeName + '" found.');
        return null;
    }

    for (i=0; i < stacks.length; i++) {
        current = stacks[i].getActive();
            if (current._xmlNode !== undefined && x3dom.isa(current, type) ) {
                result.push(current);
            }
    }
    return result[0] ? result[0]._xmlNode : null;
};

/**
 * APIFunction: nextView
 *
 * Navigates tho the next viewpoint
 *
 */
x3dom.Runtime.prototype.nextView = function() {
    var stack = this.canvas.doc._scene.getViewpoint()._stack;
    if (stack) {
        stack.switchTo('next');
    } else {
        x3dom.debug.logError('No valid ViewBindable stack.');
    }
};

/**
 * APIFunction: prevView
 *
 * Navigates tho the previous viewpoint
 *
 */
x3dom.Runtime.prototype.prevView = function() {
    var stack = this.canvas.doc._scene.getViewpoint()._stack;
    if (stack) {
        stack.switchTo('prev');
    } else {
        x3dom.debug.logError('No valid ViewBindable stack.');
    }
};

/**
 * Function: viewpoint
 *
 * Returns the current viewpoint.
 *
 * Returns:
 * 		The viewpoint
 */
x3dom.Runtime.prototype.viewpoint = function() {
    return this.canvas.doc._scene.getViewpoint();
};

/**
 * Function: viewMatrix
 *
 * Returns the current view matrix.
 *
 * Returns:
 * 		Matrix object
 */
x3dom.Runtime.prototype.viewMatrix = function() {
    return this.canvas.doc._viewarea.getViewMatrix();
};

/**
 * Function: projectionMatrix
 *
 * Returns the current projection matrix.
 *
 * Returns:
 * 		Matrix object
 */
x3dom.Runtime.prototype.projectionMatrix = function() {
    return this.canvas.doc._viewarea.getProjectionMatrix();
};

/**
 * Function: getWorldToCameraCoordinatesMatrix
 *
 * Returns the current world to camera coordinates matrix.
 *
 * Returns:
 * 		Matrix object
 */
x3dom.Runtime.prototype.getWorldToCameraCoordinatesMatrix = function() {
    return this.canvas.doc._viewarea.getWCtoCCMatrix();
};

/**
 * Function: getCameraToWorldCoordinatesMatrix
 *
 * Returns the current camera to world coordinates matrix.
 *
 * Returns:
 * 		Matrix object
 */
x3dom.Runtime.prototype.getCameraToWorldCoordinatesMatrix = function() {
    return this.canvas.doc._viewarea.getCCtoWCMatrix();
};

/**
 * Function: getViewingRay
 *
 * Returns the viewing ray for a given (x, y) position.
 *
 * Returns:
 * 		Line object
 */
x3dom.Runtime.prototype.getViewingRay = function(x, y) {
    return this.canvas.doc._viewarea.calcViewRay(x, y);
};

/**
 * Function: shootRay
 *
 * Returns pickPosition, pickNormal, and pickObject for a given (x, y) position.
 *
 * Returns:
 * 		{pickPosition, pickNormal, pickObject}
 */
x3dom.Runtime.prototype.shootRay = function(x, y) {
    var doc = this.canvas.doc;
    var info = doc._viewarea._pickingInfo;

    doc.onPick(this.canvas.gl, x, y);

    return {
        pickPosition: info.pickObj ? info.pickPos  : null,
        pickNormal:   info.pickObj ? info.pickNorm : null,
        pickObject:   info.pickObj ? info.pickObj._xmlNode : null
    };
};

/**
 * Function: getWidth
 *
 * Returns the width of the canvas element.
 */
x3dom.Runtime.prototype.getWidth = function() {
    return this.canvas.doc._viewarea._width;
};

/**
 * Function: getHeight
 *
 * Returns the width of the canvas element.
 */
x3dom.Runtime.prototype.getHeight = function() {
    return this.canvas.doc._viewarea._height;
};

/**
 * Function: mousePosition
 *
 * Returns the 2d canvas layer position [x, y] for a given mouse event, i.e.,
 * the mouse cursor's x and y positions relative to the canvas (x3d) element.
 */
x3dom.Runtime.prototype.mousePosition = function(event) {
    var pos = this.canvas.mousePosition(event);
    
    return [pos.x, pos.y];
};

/**
 * Function: calcCanvasPos
 *
 * Returns the 2d screen position [cx, cy] for a given point [wx, wy, wz] in world coordinates.
 */
x3dom.Runtime.prototype.calcCanvasPos = function(wx, wy, wz) {
    var pnt = new x3dom.fields.SFVec3f(wx, wy, wz);
    
    var mat = this.canvas.doc._viewarea.getWCtoCCMatrix();
    var pos = mat.multFullMatrixPnt(pnt);
    
    var w = this.canvas.doc._viewarea._width;
    var h = this.canvas.doc._viewarea._height;
    
    var x = Math.round((pos.x + 1) * (w - 1) / 2);
    var y = Math.round((h - 1) * (1 - pos.y) / 2);
    
    return [x, y];
};

/**
 * Function: calcPagePos
 *
 * Returns the 2d page (returns the mouse coordinates relative to the document) position [cx, cy] 
 * for a given point [wx, wy, wz] in world coordinates.
 */
x3dom.Runtime.prototype.calcPagePos = function(wx, wy, wz) {
    var elem = this.canvas.canvas.offsetParent;

    if (!elem) {
        x3dom.debug.logError("Can't calc page pos without offsetParent.");
        return [0, 0];
    }
    
	var canvasPos = elem.getBoundingClientRect();
	var mousePos = this.calcCanvasPos(wx, wy, wz);
	
	var scrollLeft = window.pageXOffset || document.body.scrollLeft;
	var scrollTop = window.pageYOffset || document.body.scrollTop;

    var compStyle = document.defaultView.getComputedStyle(elem, null);
	
	var paddingLeft = parseFloat(compStyle.getPropertyValue('padding-left'));
	var borderLeftWidth = parseFloat(compStyle.getPropertyValue('border-left-width'));
		
	var paddingTop = parseFloat(compStyle.getPropertyValue('padding-top'));
	var borderTopWidth = parseFloat(compStyle.getPropertyValue('border-top-width'));
		
	var x = canvasPos.left + paddingLeft + borderLeftWidth + scrollLeft + mousePos[0];
    var y = canvasPos.top + paddingTop + borderTopWidth + scrollTop + mousePos[1];
    
    return [x, y];
};

/**
 * Function: calcClientPos
 *
 * Returns the 2d client (returns the mouse coordinates relative to the window) position [cx, cy] 
 * for a given point [wx, wy, wz] in world coordinates.
 */
x3dom.Runtime.prototype.calcClientPos = function(wx, wy, wz) {
    var elem = this.canvas.canvas.offsetParent;

    if (!elem) {
        x3dom.debug.logError("Can't calc client pos without offsetParent.");
        return [0, 0];
    }

    var canvasPos = elem.getBoundingClientRect();
    var mousePos = this.calcCanvasPos(wx, wy, wz);

    var compStyle = document.defaultView.getComputedStyle(elem, null);
	
	var paddingLeft = parseFloat(compStyle.getPropertyValue('padding-left'));
	var borderLeftWidth = parseFloat(compStyle.getPropertyValue('border-left-width'));
		
	var paddingTop = parseFloat(compStyle.getPropertyValue('padding-top'));
	var borderTopWidth = parseFloat(compStyle.getPropertyValue('border-top-width'));
	
	var x = canvasPos.left + paddingLeft + borderLeftWidth + mousePos[0];
    var y = canvasPos.top + paddingTop + borderTopWidth + mousePos[1];
    
    return [x, y];
};

/**
 * Function: getScreenshot
 *
 * Returns a Base64 encoded png image consisting of the current rendering.
 *
 * Returns:
 * 		The Base64 encoded PNG image string
 */
x3dom.Runtime.prototype.getScreenshot = function() {
	var url = "";
	var backend = this.canvas.backend;
	var canvas = this.canvas.canvas;

	if(canvas) {
		if(backend == "flash") {
			url = canvas.getScreenshot();
		}
		else {
			// first flip along y axis
			var canvas2d = document.createElement("canvas");
			canvas2d.width = canvas.width;
			canvas2d.height = canvas.height;

			var ctx = canvas2d.getContext("2d");
			ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height);
			ctx.scale(1, -1);
			ctx.translate(0, -canvas.height);

			url = canvas2d.toDataURL();
		}
	}
	
	return url;
};

/**
 * Function: getCanvas
 *
 * Returns the internal canvas element (only valid for WebGL backend)
 *
 * Returns:
 * 		The internal canvas element
 */
x3dom.Runtime.prototype.getCanvas = function() {
    return this.canvas.canvas;
};

/**
 * Function: lightMatrix
 *
 * Returns the current light matrix.
 *
 * Returns:
 * 		The light matrix
 */
x3dom.Runtime.prototype.lightMatrix = function() {
    this.canvas.doc._viewarea.getLightMatrix();
};

/**
 * APIFunction: resetView
 *
 * Resets the view to initial.
 *
 */
x3dom.Runtime.prototype.resetView = function() {
    this.canvas.doc._viewarea.resetView();
};

/**
 * Function: lightView
 *
 * Navigates to the first light, if any.
 *
 * Returns:
 * 		True if navigation was possible, false otherwise.
 */
x3dom.Runtime.prototype.lightView = function() {
    if (this.canvas.doc._nodeBag.lights.length > 0) {
        this.canvas.doc._viewarea.animateTo(this.canvas.doc._viewarea.getLightMatrix()[0],
                                            this.canvas.doc._scene.getViewpoint());
        return true;
    } else {
        x3dom.debug.logInfo("No lights to navigate to.");
        return false;
    }
};

/**
 * APIFunction: uprightView
 *
 * Navigates to upright view
 *
 */
x3dom.Runtime.prototype.uprightView = function() {
    this.canvas.doc._viewarea.uprightView();
};

/**
 * APIFunction: fitAll
 *
 * Zooms so that all objects are fully visible. Without change the actual Viewpoint orientation
 *
 * Parameter:
 *     updateCenterOfRotation - a boolean value that specifies if the new center of rotation is set
 *
 */
x3dom.Runtime.prototype.fitAll = function(updateCenterOfRotation)
{
    if (updateCenterOfRotation === undefined) {
        updateCenterOfRotation = true;
    }

    var scene = this.canvas.doc._scene;
    scene.updateVolume();

    var min = x3dom.fields.SFVec3f.copy(scene._lastMin);
    var max = x3dom.fields.SFVec3f.copy(scene._lastMax);

    this.canvas.doc._viewarea.fit(min, max, updateCenterOfRotation);
};

/**
 * APIFunction: fitObject
 *
 * Zooms so that a given object are fully visible. Without change the actual Viewpoint orientation
 *
 * Parameter:
 *     updateCenterOfRotation - a boolean value that specifies if the new center of rotation is set
 *
 */
x3dom.Runtime.prototype.fitObject = function(obj, updateCenterOfRotation)
{
    if (obj && obj._x3domNode)
    {
        if (updateCenterOfRotation === undefined) {
            updateCenterOfRotation = true;
        }

        var min = x3dom.fields.SFVec3f.MAX();
        var max = x3dom.fields.SFVec3f.MIN();

        var vol = obj._x3domNode.getVolume();
        vol.getBounds(min, max);

        if (!x3dom.isa(obj._x3domNode, x3dom.nodeTypes.Transform))
        {
            var mat = obj._x3domNode.getCurrentTransform();

            min = mat.multMatrixPnt(min);
            max = mat.multMatrixPnt(max);
        }

        this.canvas.doc._viewarea.fit(min, max, updateCenterOfRotation);
    }
};

/**
 * APIFunction: showAll
 *
 * Zooms so that all objects are fully visible.
 *
 * Parameter:
 *     axis - the axis as string: posX, negX, posY, negY, posZ, negZ
 *
 */
x3dom.Runtime.prototype.showAll = function(axis) {
    this.canvas.doc._viewarea.showAll(axis);
};

/**
 * APIFunction: showObject
 *
 * Zooms so that a given object is fully visible in the middle of the screen.
 *
 * Parameter:
 *     obj  - the scene-graph element on which to focus
 */
x3dom.Runtime.prototype.showObject = function(obj)
{
    if (obj && obj._x3domNode)
    {
        var min = x3dom.fields.SFVec3f.MAX();
        var max = x3dom.fields.SFVec3f.MIN();

        var vol = obj._x3domNode.getVolume();
        vol.getBounds(min, max);

        var mat = obj._x3domNode.getCurrentTransform();

        min = mat.multMatrixPnt(min);
        max = mat.multMatrixPnt(max);

        var viewarea = this.canvas.doc._viewarea;

        // assume FOV_smaller as camera's fovMode
        var focalLen = (viewarea._width < viewarea._height) ?
                        viewarea._width : viewarea._height;

        var n0 = new x3dom.fields.SFVec3f(0, 0, 1);    // facingDir
        var viewpoint = this.canvas.doc._scene.getViewpoint();
        var fov = viewpoint.getFieldOfView() / 2.0;
        var ta = Math.tan(fov);

        if (Math.abs(ta) > x3dom.fields.Eps) {
            focalLen /= ta;
        }

        var w = viewarea._width - 1;
        var h = viewarea._height - 1;

        var frame = 0.25;
        var minScreenPos = new x3dom.fields.SFVec2f(frame * w, frame * h);

        frame = 0.75;
        var maxScreenPos = new x3dom.fields.SFVec2f(frame * w, frame * h);

        var dia2 = max.subtract(min).multiply(0.5);     // half diameter
        var rw = dia2.length();                         // approx radius

        var pc = min.add(dia2);                         // center in wc
        var vc = maxScreenPos.subtract(minScreenPos).multiply(0.5);

        var rs = 1.5 * vc.length();
        vc = vc.add(minScreenPos);

        var dist = 1.0;
        if (rs > x3dom.fields.Eps) {
            dist = (rw / rs) * Math.sqrt(vc.x*vc.x + vc.y*vc.y + focalLen*focalLen);
        }

        n0 = mat.multMatrixVec(n0).normalize();
        n0 = n0.multiply(dist);
        var p0 = pc.add(n0);

        var qDir = x3dom.fields.Quaternion.rotateFromTo(new x3dom.fields.SFVec3f(0, 0, 1), n0);
        var R = qDir.toMatrix();

        var T = x3dom.fields.SFMatrix4f.translation(p0.negate());
        var M = x3dom.fields.SFMatrix4f.translation(p0);

        M = M.mult(R).mult(T).mult(M);
        var viewmat = M.inverse();

        viewarea.animateTo(viewmat, viewpoint);
    }
};

/**
 * APIMethod getCenter
 *
 * Returns the center of a X3DShapeNode or X3DGeometryNode.
 *
 * Parameters:
 *    domNode: the node for which its center shall be returned
 *
 *  Returns:
 *    Node center (or null if no Shape or Geometry)
 */
x3dom.Runtime.prototype.getCenter = function(domNode) {
    if (domNode && domNode._x3domNode &&
        (this.isA(domNode, "X3DShapeNode") || this.isA(domNode, "X3DGeometryNode")))
    {
        return domNode._x3domNode.getCenter();
    }
    
    return null;
};

/**
 * APIMethod getCurrentTransform
 *
 * Returns the current to world transformation of a node.
 *
 * Parameters:
 *    domNode: the node for which its transformation shall be returned
 *
 *  Returns:
 *    Transformation matrix (or null no valid node is given)
 */
x3dom.Runtime.prototype.getCurrentTransform = function(domNode) {
    if (domNode && domNode._x3domNode)
    {
        return domNode._x3domNode.getCurrentTransform();
    }
    
    return null;
};

/**
 * APIMethod getBBox
 *
 * Returns the bounding box of a node.
 *
 * Parameters:
 *    domNode: the node for which its volume shall be returned
 *
 *  Returns:
 *    The min and max positions of the node's bounding box.
 */
x3dom.Runtime.prototype.getBBox = function(domNode) {
    if (domNode && domNode._x3domNode && this.isA(domNode, "X3DBoundedNode"))
    {
        var vol = domNode._x3domNode.getVolume();

        return {
            min: x3dom.fields.SFVec3f.copy(vol.min),
            max: x3dom.fields.SFVec3f.copy(vol.max)
        }
    }

    return null;
};

/**
 * APIMethod getSceneBBox
 *
 * Returns the bounding box of the scene.
 *
 *  Returns:
 *    The min and max positions of the scene's bounding box.
 */
x3dom.Runtime.prototype.getSceneBBox = function() {
    var scene = this.canvas.doc._scene;
    scene.updateVolume();
    
    return {
        min: x3dom.fields.SFVec3f.copy(scene._lastMin),
        max: x3dom.fields.SFVec3f.copy(scene._lastMax)
    }
};

/**
 * APIFunction: debug
 *
 * Displays or hides the debug window. If parameter is omitted,
 * the current visibility status is returned.
 *
 * Parameter:
 *     show - true to show debug window, false to hide
 *
 * Returns:
 *     Current visibility status of debug window (true=visible, false=hidden)
 */
x3dom.Runtime.prototype.debug = function(show) {
    var doc = this.canvas.doc;
    if (doc._viewarea._visDbgBuf === undefined)
        doc._viewarea._visDbgBuf = (doc._x3dElem.getAttribute("showLog") === 'true');

    if (arguments.length > 0) {
        if (show === true) {
            doc._viewarea._visDbgBuf = true;
            x3dom.debug.logContainer.style.display = "block";
        }
        else {
            doc._viewarea._visDbgBuf = false;
            x3dom.debug.logContainer.style.display = "none";
        }
    }
    else {
        doc._viewarea._visDbgBuf = !doc._viewarea._visDbgBuf;
        x3dom.debug.logContainer.style.display = (doc._viewarea._visDbgBuf == true) ? "block" : "none";
    }
    doc.needRender = true;

    return doc._viewarea._visDbgBuf;
};

/**
 * APIFunction: navigationType
 *
 * Readout of the currently active navigation.
 *
 * Returns:
 *     A string representing the active navigation type
 */
x3dom.Runtime.prototype.navigationType = function() {
    return this.canvas.doc._scene.getNavigationInfo().getType();
};

/**
 * APIFunction: noNav
 *
 * Switches to noNav mode
 */
x3dom.Runtime.prototype.noNav = function() {
    this.canvas.doc._scene.getNavigationInfo().setType("none");
};

/**
 * APIFunction: examine
 *
 * Switches to examine mode
 */
x3dom.Runtime.prototype.examine = function() {
    this.canvas.doc._scene.getNavigationInfo().setType("examine");
};

/**
 * APIFunction: turnTable
 *
 * Switches to turnTable mode
 */
x3dom.Runtime.prototype.turnTable = function() {
    this.canvas.doc._scene.getNavigationInfo().setType("turntable");
};

/**
 * APIFunction: fly
 *
 * Switches to fly mode
 */
x3dom.Runtime.prototype.fly = function() {
    this.canvas.doc._scene.getNavigationInfo().setType("fly");
};

/**
 * APIFunction: freeFly
 *
 * Switches to freeFly mode
 */
x3dom.Runtime.prototype.freeFly = function() {
    this.canvas.doc._scene.getNavigationInfo().setType("freefly");
};

/**
 * APIFunction: lookAt
 *
 * Switches to lookAt mode
 */
x3dom.Runtime.prototype.lookAt = function() {
    this.canvas.doc._scene.getNavigationInfo().setType("lookat");
};
/**
 * APIFunction: lookAround
 *
 * Switches to lookAround mode
 */
x3dom.Runtime.prototype.lookAround = function() {
    this.canvas.doc._scene.getNavigationInfo().setType("lookaround");
};

/**
 * APIFunction: walk
 *
 * Switches to walk mode
 */
x3dom.Runtime.prototype.walk = function() {
    this.canvas.doc._scene.getNavigationInfo().setType("walk");
};

/**
 * APIFunction: game
 *
 * Switches to game mode
 */
x3dom.Runtime.prototype.game = function() {
    this.canvas.doc._scene.getNavigationInfo().setType("game");
};

/**
 * APIFunction: helicopter
 *
 * Switches to helicopter mode
 */
x3dom.Runtime.prototype.helicopter = function() {
    this.canvas.doc._scene.getNavigationInfo().setType("helicopter");
};

/**
 * Function: resetExamin
 *
 * Resets all variables required by examine mode to init state
 */
 x3dom.Runtime.prototype.resetExamin = function() {
    var viewarea = this.canvas.doc._viewarea;
    viewarea._rotMat = x3dom.fields.SFMatrix4f.identity();
    viewarea._transMat = x3dom.fields.SFMatrix4f.identity();
    viewarea._movement = new x3dom.fields.SFVec3f(0, 0, 0);
    viewarea._needNavigationMatrixUpdate = true;
    this.canvas.doc.needRender = true;
 };

/**
 * Function: togglePoints
 *
 * Toggles points attribute
 */
x3dom.Runtime.prototype.togglePoints = function(lines) {
    var doc = this.canvas.doc;
    var mod = (lines === true) ? 3 : 2;

    doc._viewarea._points = ++doc._viewarea._points % mod;
    doc.needRender = true;

    return doc._viewarea._points;
};

/**
 * Function: pickRect
 *
 * Returns an array of all shape elements that are within the picked rectangle 
 * defined by (x1, y1) and (x2, y2) in canvas coordinates
 */
x3dom.Runtime.prototype.pickRect = function(x1, y1, x2, y2) {
    return this.canvas.doc.onPickRect(this.canvas.gl, x1, y1, x2, y2);
};

/**
 * Function: pickMode
 *
 * Get the current pickMode intersect type
 *
 * Parameters:
 *		internal - true/false. If given return the internal representation.
 *                 Only use for debugging.
 *
 * Returns:
 * 		The current intersect type value suitable to use with changePickMode
 *      If parameter is, given, provide with internal representation.
 */
x3dom.Runtime.prototype.pickMode = function(options) {
    if (options && options.internal === true) {
        return this.canvas.doc._scene._vf.pickMode;
    }
    return this.canvas.doc._scene._vf.pickMode.toLowerCase();
};

/**
 * Function: changePickMode
 *
 * Alter the value of intersect type. Can be one of: box, idBuf, idBuf24, idBufId, color, texCoord.
 * Other values are ignored.
 *
 * Parameters:
 *		type - The new intersect type: box, idBuf, idBuf24, idBufId, color, texCoord
 *
 * Returns:
 * 		true if the type has been changed, false otherwise
 */
x3dom.Runtime.prototype.changePickMode = function(type) {
    // pick type one of : box, idBuf, idBuf24, idBufId, color, texCoord
    type = type.toLowerCase();

    switch(type) {
        case 'idbuf':    type = 'idBuf';    break;
        case 'idbuf24':  type = 'idBuf24';  break;
        case 'idbufid':  type = 'idBufId';  break;
        case 'texcoord': type = 'texCoord'; break;
        case 'color':    type = 'color';    break;
        case 'box':      type = 'box';      break;
        default:
            x3dom.debug.logWarning("Switch pickMode to "+ type + ' unknown intersect type');
            type = undefined;
    }

    if (type !== undefined) {
        this.canvas.doc._scene._vf.pickMode = type;
        x3dom.debug.logInfo("Switched pickMode to '" + type + "'.");
        return true;
    }

    return false;
};

/**
 * APIFunction: speed
 *
 *	Get the current speed value. If parameter is given the new speed value is set.
 *
 * Parameters:
 *		newSpeed - The new speed value (optional)
 *
 * Returns:
 * 		The current speed value
 */
x3dom.Runtime.prototype.speed = function(newSpeed) {
    var navi = this.canvas.doc._scene.getNavigationInfo();
    if (newSpeed) {
        navi._vf.speed = newSpeed;
        x3dom.debug.logInfo("Changed navigation speed to " + navi._vf.speed);
    }
    return navi._vf.speed;
};

/**
 * APIFunction: statistics
 *
 * Get or set statistics info. If parameter is omitted, this method
 * only returns the the visibility status of the statistics info overlay.
 *
 * Parameters:
 *		mode - true or false. To enable or disable the statistics info
 *
 * Returns:
 * 		The current visibility of the statistics info (true = visible, false = invisible)
 */
x3dom.Runtime.prototype.statistics = function(mode) {
    var states = this.canvas.stateViewer;
    if (states) {
        this.canvas.doc.needRender = true;
        if (mode === true) {
            states.display(mode);
            return true;
        }
        else if (mode === false) {
            states.display(mode);
            return false;
        }
        else {
            states.display(!states.active);
            // if no parameter is given return current status (false = not visible, true = visible)
            return states.active;
        }
    }
    return false;
};

/**
 * Function: processIndicator
 *
 * Enable or disable the process indicator. If parameter is omitted, this method
 * only returns the the visibility status of the progress bar overlay.
 *
 * Parameters:
 *		mode - true or false. To enable or disable the progress indicator
 *
 * Returns:
 * 		The current visibility of the progress indicator info (true = visible, false = invisible)
 */
x3dom.Runtime.prototype.processIndicator = function(mode) {
    var processDiv = this.canvas.progressDiv;
    if (processDiv) {
        if (mode === true) {
            processDiv.style.display = 'inline';
            return true;
        }
        else if (mode === false) {
            processDiv.style.display = 'none';
            return false;
        }

        // if no parameter is given return current status (false = not visible, true = visible)
        return processDiv.style.display != 'none'
    }
    return false;
};

/** Get properties */
x3dom.Runtime.prototype.properties = function() {
    return this.canvas.doc.properties;
};

/** Get current backend name */
x3dom.Runtime.prototype.backendName = function() {
    return this.canvas.backend;
};

/** Get current framerate */
x3dom.Runtime.prototype.getFPS = function() {
    return this.fps;
};


/**
 * APIMethod isA
 *
 * Test a DOM node object against a node type string. This method
 * can be used to determine the "type" of a DOM node.
 *
 * Parameters:
 *    domNode: the node to test for
 *    nodeType: node name to test domNode against
 *
 *  Returns:
 *    True or false
 */
x3dom.Runtime.prototype.isA = function(domNode, nodeType) {
    var inherits = false;
    
    if (nodeType && domNode && domNode._x3domNode) {
        if (nodeType === "") {
            nodeType = "X3DNode";
        }
        inherits = x3dom.isa(domNode._x3domNode, 
                             x3dom.nodeTypesLC[nodeType.toLowerCase()]);
    }
    
    return inherits;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

x3dom.detectActiveX = function() {
    var isInstalled = false;  
    
    if (window.ActiveXObject)  {  
        var control = null;  

        try  {  
            control = new ActiveXObject('AVALONATX.InstantPluginATXCtrl.1');  
        } catch (e) {
        }  
        
        if (control) {
            isInstalled = true;  
        }
    }
    
    return isInstalled;
};

x3dom.rerouteSetAttribute = function(node, browser) {
    // save old setAttribute method
    node._setAttribute = node.setAttribute;
    node.setAttribute = function(name, value) {
        var id = node.getAttribute("_x3domNode");
        var anode = browser.findNode(id);
        
        if (anode)
            return anode.parseField(name, value);
        else
            return 0;
    };

    for(var i=0; i < node.childNodes.length; i++) {
        var child = node.childNodes[i];
        x3dom.rerouteSetAttribute(child, browser);
    }
};

x3dom.insertActiveX = function(x3d) {
    
    if (typeof x3dom.atxCtrlCounter == 'undefined') {
        x3dom.atxCtrlCounter = 0;
    }
 
    var height = x3d.getAttribute("height");
    var width  = x3d.getAttribute("width");

    var parent = x3d.parentNode;
    
    var divelem = document.createElement("div");
    divelem.setAttribute("id", "x3dplaceholder");

    var inserted = parent.insertBefore(divelem, x3d);
    
    // hide x3d div
    var hiddenx3d = document.createElement("div");
    hiddenx3d.style.display = "none";
    parent.appendChild(hiddenx3d);
    parent.removeChild(x3d);
    hiddenx3d.appendChild(x3d);
     
    var atx = document.createElement("object");
    
    var containerName = "Avalon" + x3dom.atxCtrlCounter;
    x3dom.atxCtrlCounter++;
    
    atx.setAttribute("id", containerName);
    atx.setAttribute("classid", "CLSID:F3254BA0-99FF-4D14-BD81-EDA9873A471E");
    atx.setAttribute("width",   width   ? width     : "500");
    atx.setAttribute("height",  height  ? height    : "500");
    
    inserted.appendChild(atx);
    
    var atxctrl = document.getElementById(containerName);
    var browser = atxctrl.getBrowser();
    var scene   = browser.importDocument(x3d);
    browser.replaceWorld(scene);
        
    // add backtrack method to get browser from x3d node instead of the ctrl
    x3d.getBrowser = function() {
        return atxctrl.getBrowser();
    };
    
    x3dom.rerouteSetAttribute(x3d, browser);
};

// holds the UserAgent feature
x3dom.userAgentFeature = {
    supportsDOMAttrModified: false
};


(function loadX3DOM() {

    var onload = function() {
        var i,j;  // counters

        // Search all X3D elements in the page
        var x3ds = document.getElementsByTagName('X3D');
        var w3sg = document.getElementsByTagName('webSG');	// FIXME

        // ~~ Components and params {{{ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        var params;
        var settings = new x3dom.Properties();  // stores the stuff in <param>
        var validParams = array_to_object([ 
            'showLog', 
            'showStat',
            'showProgress', 
            'PrimitiveQuality', 
            'components', 
            'loadpath', 
            'disableDoubleClick',
            'backend',
            'altImg',
            'flashrenderer',
            'swfpath',
            'runtimeEnabled',
            'keysEnabled',
            'showTouchpoints',
            'disableTouch',
            'maxActiveDownloads'
        ]);
        var components, prefix;
		var showLoggingConsole = false;

        // for each X3D element
        for (i=0; i < x3ds.length; i++) {

            // default parameters
            settings.setProperty("showLog", x3ds[i].getAttribute("showLog") || 'false');
            settings.setProperty("showStat", x3ds[i].getAttribute("showStat") || 'false');
            settings.setProperty("showProgress", x3ds[i].getAttribute("showProgress") || 'true');
            settings.setProperty("PrimitiveQuality", x3ds[i].getAttribute("PrimitiveQuality") || 'High');

            // for each param element inside the X3D element
            // add settings to properties object
            params = x3ds[i].getElementsByTagName('PARAM');
            for (j=0; j < params.length; j++) {
                if (params[j].getAttribute('name') in validParams) {
                    settings.setProperty(params[j].getAttribute('name'), params[j].getAttribute('value'));
                } else {
                    //x3dom.debug.logError("Unknown parameter: " + params[j].getAttribute('name'));
                }
            }

            // enable log
            if (settings.getProperty('showLog') === 'true') {
				showLoggingConsole = true;
            }

            if (typeof X3DOM_SECURITY_OFF != 'undefined' && X3DOM_SECURITY_OFF === true) {
                // load components from params or default to x3d attribute
                components = settings.getProperty('components', x3ds[i].getAttribute("components"));
                if (components) {
                    prefix = settings.getProperty('loadpath', x3ds[i].getAttribute("loadpath"));
                    components = components.trim().split(',');
                    for (j=0; j < components.length; j++) {
                        x3dom.loadJS(components[j] + ".js", prefix);
                    }
                }
            }

            // src=foo.x3d adding inline node, not a good idea, but...
            if (typeof X3DOM_SECURITY_OFF != 'undefined' && X3DOM_SECURITY_OFF === true) {
                if (x3ds[i].getAttribute("src")) {
                    var _scene = document.createElement("scene");
                    var _inl = document.createElement("Inline");
                    _inl.setAttribute("url", x3ds[i].getAttribute("src"));
                    _scene.appendChild(_inl);
                    x3ds[i].appendChild(_scene);
                }
            }
        }
        // }}}
		
		if (showLoggingConsole == true) {
			x3dom.debug.activate(true);
		} else {
			x3dom.debug.activate(false);
		}

        // Convert the collection into a simple array (is this necessary?)
        x3ds = Array.map(x3ds, function (n) {
            n.hasRuntime = true;
            return n;
        });
        w3sg = Array.map(w3sg, function (n) {
            n.hasRuntime = false;
            return n;
        });
        
        for (i=0; i<w3sg.length; i++) {
            x3ds.push(w3sg[i]);
        }

        if (x3dom.versionInfo !== undefined) {
            x3dom.debug.logInfo("X3DOM version " + x3dom.versionInfo.version + ", " +
                                "Revison <a href='https://github.com/x3dom/x3dom/tree/"+ x3dom.versionInfo.revision +"'>"
                                + x3dom.versionInfo.revision + "</a>, " +
                                "Date " + x3dom.versionInfo.date);
        }
        
        x3dom.debug.logInfo("Found " + (x3ds.length - w3sg.length) + " X3D and " + 
                            w3sg.length + " (experimental) WebSG nodes...");
        
        // Create a HTML canvas for every X3D scene and wrap it with
        // an X3D canvas and load the content
        var x3d_element;
        var x3dcanvas;
        var altDiv, altP, aLnk, altImg;
        var t0, t1;

        for (i=0; i < x3ds.length; i++)
        {
            x3d_element = x3ds[i];

            // http://www.howtocreate.co.uk/wrongWithIE/?chapter=navigator.plugins
            if (x3dom.detectActiveX()) {
                x3dom.insertActiveX(x3d_element);
                continue;
            }
        
            x3dcanvas = new x3dom.X3DCanvas(x3d_element, i);

            if (x3dcanvas.gl === null) {

                altDiv = document.createElement("div");
                altDiv.setAttribute("class", "x3dom-nox3d");
                altDiv.setAttribute("id", "x3dom-nox3d");

                altP = document.createElement("p");
                altP.appendChild(document.createTextNode("WebGL is not yet supported in your browser. "));
                aLnk = document.createElement("a");
                aLnk.setAttribute("href","http://www.x3dom.org/?page_id=9");
                aLnk.appendChild(document.createTextNode("Follow link for a list of supported browsers... "));
                
                altDiv.appendChild(altP);
                altDiv.appendChild(aLnk);
                
                x3dcanvas.x3dElem.appendChild(altDiv);

                // remove the stats div (it's not added when WebGL doesn't work)
                if (x3dcanvas.stateViewer) { 
                    x3d_element.removeChild(x3dcanvas.stateViewer.viewer);
                }

                continue;
            }
            
            t0 = new Date().getTime();

            x3ds[i].runtime = new x3dom.Runtime(x3ds[i], x3dcanvas);
            x3ds[i].runtime.initialize(x3ds[i], x3dcanvas);

            if (x3dom.runtime.ready) {
                x3ds[i].runtime.ready = x3dom.runtime.ready;
            }
            
            // no backend found method system wide call
            if (x3dcanvas.backend == '') {
                x3dom.runtime.noBackendFound();
            }
            
            x3dcanvas.load(x3ds[i], i, settings);

            // show or hide statistics based on param/x3d attribute settings
            if (settings.getProperty('showStat') === 'true') {
                x3ds[i].runtime.statistics(true);
            } else {
                x3ds[i].runtime.statistics(false);
            }

            if (settings.getProperty('showProgress') === 'true') {
                if (settings.getProperty('showProgress') === 'bar'){
                    x3dcanvas.progressDiv.setAttribute("class", "x3dom-progress bar");
                }
                x3ds[i].runtime.processIndicator(true);
            } else {
                x3ds[i].runtime.processIndicator(false);
            }

            x3dom.canvases.push(x3dcanvas);

			t1 = new Date().getTime() - t0;
            x3dom.debug.logInfo("Time for setup and init of GL element no. " + i + ": " + t1 + " ms.");
        }
        
        var ready = (function(eventType) {
            var evt = null;

            if (document.createEvent) {
                evt = document.createEvent("Events");    
                evt.initEvent(eventType, true, true);     
                document.dispatchEvent(evt);              
            } else if (document.createEventObject) {
                evt = document.createEventObject();
                // http://stackoverflow.com/questions/1874866/how-to-fire-onload-event-on-document-in-ie
                document.body.fireEvent('on' + eventType, evt);   
            }
        })('load');
    };
    
    var onunload = function() {
        if (x3dom.canvases) {
            for (var i=0; i<x3dom.canvases.length; i++) {
                x3dom.canvases[i].doc.shutdown(x3dom.canvases[i].gl);
            }
            x3dom.canvases = [];
        }
    };
    
    /** Initializes an <x3d> root element that was added after document load.
     *
     *  If there already was an <x3d> element, it needs to be removed before:
     *  var x3d = document.getElementsByTagName("x3d")[0];
	 *	x3d.parentNode.removeChild(x3d);
     */
    x3dom.reload = function() {
        onunload();
        onload();
    };
	
    /* FIX PROBLEM IN CHROME - HACK - searching for better solution !!! */
	if (navigator.userAgent.indexOf("Chrome") != -1) {
		document.__getElementsByTagName = document.getElementsByTagName;
		
		document.getElementsByTagName = function(tag) {
			var obj = [];
			var elems = this.__getElementsByTagName("*");

			if(tag =="*"){
				obj = elems;
			} else {
				tag = tag.toUpperCase();
				for (var i = 0; i < elems.length; i++) {
					var tagName = elems[i].tagName.toUpperCase();		
					if (tagName === tag) {
						obj.push(elems[i]);
					}
				}
			}
			
            return obj;
        };

		document.__getElementById = document.getElementById;
        document.getElementById = function(id) {
            var obj = this.__getElementById(id);
            
            if (!obj) {
                var elems = this.__getElementsByTagName("*");
                for (var i=0; i<elems.length && !obj; i++) {
                    if (elems[i].getAttribute("id") === id) {
                        obj = elems[i];
                    }
                }
            }
            return obj;
        };
		
	} else { /* END OF HACK */
        document.__getElementById = document.getElementById;
        document.getElementById = function(id) {
            var obj = this.__getElementById(id);
            
            if (!obj) {
                var elems = this.getElementsByTagName("*");
                for (var i=0; i<elems.length && !obj; i++) {
                    if (elems[i].getAttribute("id") === id) {
                        obj = elems[i];
                    }
                }
            }
            return obj;
        };
	}
    
    if (window.addEventListener)  {
        window.addEventListener('load', onload, false);
        window.addEventListener('unload', onunload, false);
        window.addEventListener('reload', onunload, false);
    } else if (window.attachEvent) {
        window.attachEvent('onload', onload);
        window.attachEvent('onunload', onunload);
        window.attachEvent('onreload', onunload);
    }

    // Initialize if we were loaded after 'DOMContentLoaded' already fired.
    // This can happen if the script was loaded by other means.
    if (document.readyState === "complete") {
        window.setTimeout( function() { onload(); }, 20 );
    }
})();

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/**
 * @namespace Cache namespace
 */
x3dom.Cache = function () {
    this.textures = [];
    this.shaders = [];
};

/**
 * Returns a Texture 2D
 */
x3dom.Cache.prototype.getTexture2D = function (gl, doc, url, bgnd, withCredentials, scale) {
    var textureIdentifier = url;

    if (this.textures[textureIdentifier] === undefined) {
        this.textures[textureIdentifier] = x3dom.Utils.createTexture2D(gl, doc, url, bgnd, withCredentials, scale);
    }

    return this.textures[textureIdentifier];
};

/**
 * Returns a Cube Texture
 */
x3dom.Cache.prototype.getTextureCube = function (gl, doc, url, bgnd, withCredentials, scale) {
    var textureIdentifier = "";

    for (var i = 0; i < url.length; ++i) {
        textureIdentifier += url[i] + "|";
    }

    if (this.textures[textureIdentifier] === undefined) {
        this.textures[textureIdentifier] = x3dom.Utils.createTextureCube(gl, doc, url, bgnd, withCredentials, scale);
    }

    return this.textures[textureIdentifier];
};

/**
 * Returns one of the default shader programs
 */
x3dom.Cache.prototype.getShader = function (gl, shaderIdentifier) {
    var program = null;

    //Check if shader is in cache
    if (this.shaders[shaderIdentifier] === undefined) {
        //Choose shader based on identifier
        switch (shaderIdentifier) {
            case x3dom.shader.PICKING:
                program = new x3dom.shader.PickingShader(gl);
                break;
            case x3dom.shader.PICKING_24:
                program = new x3dom.shader.Picking24Shader(gl);
                break;
            case x3dom.shader.PICKING_ID:
                program = new x3dom.shader.PickingIdShader(gl);
                break;
            case x3dom.shader.PICKING_COLOR:
                program = new x3dom.shader.PickingColorShader(gl);
                break;
            case x3dom.shader.PICKING_TEXCOORD:
                program = new x3dom.shader.PickingTexcoordShader(gl);
                break;
            case x3dom.shader.FRONTGROUND_TEXTURE:
                program = new x3dom.shader.FrontgroundTextureShader(gl);
                break;
            case x3dom.shader.BACKGROUND_TEXTURE:
                program = new x3dom.shader.BackgroundTextureShader(gl);
                break;
            case x3dom.shader.BACKGROUND_SKYTEXTURE:
                program = new x3dom.shader.BackgroundSkyTextureShader(gl);
                break;
            case x3dom.shader.BACKGROUND_CUBETEXTURE:
                program = new x3dom.shader.BackgroundCubeTextureShader(gl);
                break;
            case x3dom.shader.SHADOW:
                program = new x3dom.shader.ShadowShader(gl);
                break;
            case x3dom.shader.BLUR:
                program = new x3dom.shader.BlurShader(gl);
                break;
            case x3dom.shader.DEPTH:
                //program = new x3dom.shader.DepthShader(gl);
                break;
            case x3dom.shader.NORMAL:
                program = new x3dom.shader.NormalShader(gl);
                break;
            default:
                break;
        }

        if (program)
            this.shaders[shaderIdentifier] = x3dom.Utils.wrapProgram(gl, program, shaderIdentifier);
        else
            x3dom.debug.logError("Couldn't create shader: " + shaderIdentifier);
    }

    return this.shaders[shaderIdentifier];
};

/**
 * Returns a dynamic generated shader program by viewarea and shape
 */
x3dom.Cache.prototype.getDynamicShader = function (gl, viewarea, shape) {
    //Generate Properties
    var properties = x3dom.Utils.generateProperties(viewarea, shape);

    var shaderID = properties.id;

    if (this.shaders[shaderID] === undefined) {
        var program;
        if (properties.CSHADER >= 0) {
            program = new x3dom.shader.ComposedShader(gl, shape);
        } else {
            program = (x3dom.caps.MOBILE && !properties.CSSHADER) ?
                            new x3dom.shader.DynamicMobileShader(gl, properties) :
                            new x3dom.shader.DynamicShader(gl, properties);
        }
        this.shaders[shaderID] = x3dom.Utils.wrapProgram(gl, program, shaderID);
    }

    return this.shaders[shaderID];
};

/**
 * Returns a dynamic generated shader program by properties
 */
x3dom.Cache.prototype.getShaderByProperties = function (gl, shape, properties) {

    //Get shaderID
    var shaderID = properties.id;

    if (this.shaders[shaderID] === undefined)
    {
        var program;
        if (properties.CSHADER >= 0) {
            program = new x3dom.shader.ComposedShader(gl, shape);
        } else {
            program = (x3dom.caps.MOBILE && !properties.CSSHADER) ? new x3dom.shader.DynamicMobileShader(gl, properties) :
                new x3dom.shader.DynamicShader(gl, properties);
        }
        this.shaders[shaderID] = x3dom.Utils.wrapProgram(gl, program, shaderID);
    }

    return this.shaders[shaderID];
};

/**
 * Returns the dynamically created shadow rendering shader
 */
x3dom.Cache.prototype.getShadowRenderingShader = function (gl, shadowedLights) {
    var ID = "shadow";
    for (var i = 0; i < shadowedLights.length; i++) {
        if (x3dom.isa(shadowedLights[i], x3dom.nodeTypes.SpotLight))
            ID += "S";
        else if (x3dom.isa(shadowedLights[i], x3dom.nodeTypes.PointLight))
            ID += "P";
        else
            ID += "D";
    }

    if (this.shaders[ID] === undefined) {
        var program = new x3dom.shader.ShadowRenderingShader(gl, shadowedLights);
        this.shaders[ID] = x3dom.Utils.wrapProgram(gl, program, ID);
    }
    return this.shaders[ID];
};

/**
 * Release texture and shader resources
 */
x3dom.Cache.prototype.Release = function (gl) {
    for (var texture in this.textures) {
        gl.deleteTexture(this.textures[texture]);
    }
    this.textures = [];

    for (var shaderId in this.shaders) {
        var shader = this.shaders[shaderId];
        var glShaders = gl.getAttachedShaders(shader.program);
        for (var i=0; i<glShaders.length; ++i) {
            gl.detachShader(shader.program, glShaders[i]);
            gl.deleteShader(glShaders[i]);
        }
        gl.deleteProgram(shader.program)
    }
    this.shaders = [];
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


function startDashVideo(recurl, texturediv) {
    var vars = function () {
            var vars = {};
            var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) {
                vars[key] = value;
            });
            return vars;
        },
        url = recurl,
        video,
        context,
        player;

    if (vars && vars.hasOwnProperty("url")) {
        url = vars.url;
    }

    video = document.querySelector(texturediv);
    context = new Dash.di.DashContext();
    player = new MediaPlayer(context);

    player.startup();

    player.attachView(video);
    player.setAutoPlay(false);

    player.attachSource(url);
}


/**
 * Texture
 */
x3dom.Texture = function (gl, doc, cache, node) {
    this.gl = gl;
    this.doc = doc;
    this.cache = cache;
    this.node = node;

    this.samplerName = "diffuseMap";
    this.type = gl.TEXTURE_2D;
    this.format = gl.RGBA;
    this.magFilter = gl.LINEAR;
    this.minFilter = gl.LINEAR;
    this.wrapS = gl.REPEAT;
    this.wrapT = gl.REPEAT;
    this.genMipMaps = false;
    this.texture = null;
    this.ready = false;

    this.dashtexture = false;

    var tex = this.node;
    var suffix = "mpd";

    if (x3dom.isa(tex, x3dom.nodeTypes.MovieTexture)) {
        // for dash we are lazy and check only the first url
        if (tex._vf.url[0].indexOf(suffix, tex._vf.url[0].length - suffix.length) !== -1) {
            this.dashtexture = true;
            // we need to initially place the script for the dash player once in the document,
            // but insert this additional script only, if really needed and Dash is requested!
            var js = document.getElementById("AdditionalDashVideoScript");
            if (!js) {
                js = document.createElement("script");
                js.setAttribute("type", "text/javascript");
                js.setAttribute("src", x3dom.Texture.dashVideoScriptFile);
                js.setAttribute("id", "AdditionalDashVideoScript");
                js.onload = function() {
                    var texObj;
                    while ( (texObj = x3dom.Texture.loadDashVideos.pop()) ) {
                        x3dom.Texture.textNum++;
                        texObj.update();
                    }
                    js.ready = true;
                };
                document.getElementsByTagName('head')[0].appendChild(js);
            }
            if (js.ready === true) {
                // count dash players and add this number to the class name for future reference
                // (append in id too, for play, pause etc)
                x3dom.Texture.textNum++;
                // update can be directly called as script is already loaded
                this.update();
            }
            else {
                // push to stack and process later when script has loaded
                x3dom.Texture.loadDashVideos.push(this);
            }
        }
    }

    if (!this.dashtexture) {
        this.update();
    }
};

x3dom.Texture.dashVideoScriptFile = "dash.all.js";
x3dom.Texture.loadDashVideos = [];
x3dom.Texture.textNum = 0;


x3dom.Texture.prototype.update = function()
{
	if ( x3dom.isa(this.node, x3dom.nodeTypes.Text) )
	{
		this.updateText();
	}
	else
	{
		this.updateTexture();
	}
};

x3dom.Texture.prototype.updateTexture = function()
{
	var gl  = this.gl;
	var doc = this.doc;
	var tex = this.node;
	
	//Set sampler
	this.samplerName = tex._type;

	//Set texture type
	if ( x3dom.isa(tex, x3dom.nodeTypes.X3DEnvironmentTextureNode) ) {
		this.type = gl.TEXTURE_CUBE_MAP;
	} else {
		this.type = gl.TEXTURE_2D;
	}
	
	//Set texture format
	if (x3dom.isa(tex, x3dom.nodeTypes.PixelTexture)) {
		switch (tex._vf.image.comp)
		{
			case 1: this.format = gl.LUMINANCE; break;
			case 2: this.format = gl.LUMINANCE_ALPHA; break;
			case 3: this.format = gl.RGB; break;
			case 4: this.format = gl.RGBA; break;
		}
	} else {
		this.format = gl.RGBA;
	}
	
	//Looking for child texture
	var childTex = (tex._video !== undefined && 
					tex._video !== null && 
					tex._needPerFrameUpdate !== undefined && 
					tex._needPerFrameUpdate === true);
	
	//Set texture min, mag, wrapS and wrapT
	if (tex._cf.textureProperties.node !== null) {
		var texProp = tex._cf.textureProperties.node;
		
		this.wrapS = x3dom.Utils.boundaryModesDic(gl, texProp._vf.boundaryModeS);
        this.wrapT = x3dom.Utils.boundaryModesDic(gl, texProp._vf.boundaryModeT);

		this.minFilter = x3dom.Utils.minFilterDic(gl, texProp._vf.minificationFilter);
		this.magFilter = x3dom.Utils.magFilterDic(gl, texProp._vf.magnificationFilter);
		
		if (texProp._vf.generateMipMaps === true) {
			this.genMipMaps = true;
						
			if (this.minFilter == gl.NEAREST) {
				this.minFilter  = gl.NEAREST_MIPMAP_NEAREST;
			} else if (this.minFilter == gl.LINEAR) {
				this.minFilter  = gl.LINEAR_MIPMAP_LINEAR;
			}
		} else {
			this.genMipMaps = false;
			
			if ( (this.minFilter == gl.LINEAR_MIPMAP_LINEAR) ||
				 (this.minFilter == gl.LINEAR_MIPMAP_NEAREST) ) {
				this.minFilter  = gl.LINEAR;
			} else if ( (this.minFilter == gl.NEAREST_MIPMAP_LINEAR) ||
					    (this.minFilter == gl.NEAREST_MIPMAP_NEAREST) ) {
				this.minFilter  = gl.NEAREST;
			}
		}
	} else {
		if (tex._vf.repeatS == false || this.samplerName == "displacementMap") {
			this.wrapS = gl.CLAMP_TO_EDGE;
		}
		if (tex._vf.repeatT == false || this.samplerName == "displacementMap") {
			this.wrapT = gl.CLAMP_TO_EDGE;
		}
	}
	
	//Set texture
	if (tex._isCanvas && tex._canvas)
	{
		if (this.texture == null) {
			this.texture = gl.createTexture()
		}
        this.texture.width  = tex._canvas.width;
        this.texture.height = tex._canvas.height;

		gl.bindTexture(this.type, this.texture);
        gl.texImage2D(this.type, 0, this.format, this.format, gl.UNSIGNED_BYTE, tex._canvas);
		gl.bindTexture(this.type, null);
	}
	else if (x3dom.isa(tex, x3dom.nodeTypes.RenderedTexture))
    {
        if (tex._webgl && tex._webgl.fbo) {
		    this.texture = tex._webgl.fbo.tex;
        }
        else {
            this.texture = null;
            x3dom.debug.logError("Try updating RenderedTexture without FBO initialized!");
        }
	}
	else if (x3dom.isa(tex, x3dom.nodeTypes.PixelTexture))
	{
		if (this.texture == null) {
			this.texture = gl.createTexture()
		}
        this.texture.width  = tex._vf.image.width;
        this.texture.height = tex._vf.image.height;
		
		var pixelArr = tex._vf.image.toGL();
		var pixelArrfont_size = tex._vf.image.width * tex._vf.image.height * tex._vf.image.comp;
		
		while (pixelArr.length < pixelArrfont_size) {
			pixelArr.push(0);
		}
		
		var pixels = new Uint8Array(pixelArr);
		
		gl.bindTexture(this.type, this.texture);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.texImage2D(this.type, 0, this.format, 
                      tex._vf.image.width, tex._vf.image.height, 0, 
                      this.format, gl.UNSIGNED_BYTE, pixels);
		gl.bindTexture(this.type, null);
	}
	else if (x3dom.isa(tex, x3dom.nodeTypes.MovieTexture) || childTex)
    {
        var that = this;
        var p = document.getElementsByTagName('body')[0];

        if (this.texture == null) {
            this.texture = gl.createTexture();
        }

        if (this.dashtexture) {
            var element_vid = document.createElement('div');
            element_vid.setAttribute('class', 'dash-video-player' + x3dom.Texture.textNum);
            tex._video = document.createElement('video');
            tex._video.setAttribute('autobuffer', 'true');

            var scriptToRun = document.createElement('script');
            scriptToRun.setAttribute('type', 'text/javascript');
            scriptToRun.innerHTML = 'startDashVideo("' + tex._vf.url[0] +
                                    '",".dash-video-player' + x3dom.Texture.textNum + ' video")';
            element_vid.appendChild(scriptToRun);
            element_vid.appendChild(tex._video);
            p.appendChild(element_vid);
            tex._video.style.visibility = "hidden";
        }
        else {
            if (!childTex) {
                tex._video = document.createElement('video');
                tex._video.setAttribute('autobuffer', 'true');
                p.appendChild(tex._video);
                tex._video.style.visibility = "hidden";
            }
            for (var i = 0; i < tex._vf.url.length; i++) {
                var videoUrl = tex._nameSpace.getURL(tex._vf.url[i]);
                x3dom.debug.logInfo('Adding video file: ' + videoUrl);
                var src = document.createElement('source');
                src.setAttribute('src', videoUrl);
                tex._video.appendChild(src);
            }
        }

		var updateMovie = function()
		{	
			gl.bindTexture(that.type, that.texture);
			gl.texImage2D(that.type, 0, that.format, that.format, gl.UNSIGNED_BYTE, tex._video);
			gl.bindTexture(that.type, null);
			doc.needRender = true;
		};
		
		var startVideo = function()
		{       	
			tex._video.play();
			tex._intervalID = setInterval(updateMovie, 16);
		};
		
		var videoDone = function()
		{
			clearInterval(tex._intervalID);		
			if (tex._vf.loop === true)
			{
				tex._video.play();
				tex._intervalID = setInterval(updateMovie, 16);
			}
		};
		
		// Start listening for the canplaythrough event, so we do not
		// start playing the video until we can do so without stuttering
		tex._video.addEventListener("canplaythrough", startVideo, true);

		// Start listening for the ended event, so we can stop the
		// texture update when the video is finished playing
		tex._video.addEventListener("ended", videoDone, true);	
	}
	else if (x3dom.isa(tex, x3dom.nodeTypes.X3DEnvironmentTextureNode)) 
	{
		this.texture = this.cache.getTextureCube(gl, doc, tex.getTexUrl(), false, 
		                                         tex._vf.withCredentials, tex._vf.scale);
	}
	else 
	{
		this.texture = this.cache.getTexture2D(gl, doc, tex._nameSpace.getURL(tex._vf.url[0]), 
		                                       false, tex._vf.withCredentials, tex._vf.scale);
	}
};

x3dom.Texture.prototype.updateText = function()
{
	var gl = this.gl;
	
	this.wrapS			= gl.CLAMP_TO_EDGE;
	this.wrapT			= gl.CLAMP_TO_EDGE;
	
	var fontStyleNode = this.node._cf.fontStyle.node;

    var font_family = 'serif';
    var font_style = 'normal';
    var font_justify = 'left';
    var font_size = 1.0;
    var font_spacing = 1.0;
    var font_horizontal = true;
    var font_language = "";

    if ( fontStyleNode !== null )
	{
		var fonts = fontStyleNode._vf.family.toString();

		// clean attribute values and split in array
		fonts = fonts.trim().replace(/\'/g,'').replace(/\,/, ' ');
		fonts = fonts.split(" ");
		
		font_family = Array.map(fonts, function(s) {
			if (s == 'SANS') { return 'sans-serif'; }
			else if (s == 'SERIF') { return 'serif'; }
			else if (s == 'TYPEWRITER') { return 'monospace'; }
			else { return ''+s+''; }  //'Verdana' 
		}).join(",");
		
		font_style = fontStyleNode._vf.style.toString().replace(/\'/g,'');
		switch (font_style.toUpperCase()) {
			case 'PLAIN': 		font_style = 'normal'; 		break;
			case 'BOLD': 		font_style = 'bold'; 		break;
			case 'ITALIC': 		font_style = 'italic'; 		break;
			case 'BOLDITALIC': 	font_style = 'italic bold'; break;
			default: 			font_style = 'normal';
		}
		
		var leftToRight = fontStyleNode._vf.leftToRight ? 'ltr' : 'rtl';
		var topToBottom = fontStyleNode._vf.topToBottom;
		
		// TODO: make it possible to use multiple values
		font_justify = fontStyleNode._vf.justify[0].toString().replace(/\'/g,'');
		
		switch (font_justify.toUpperCase()) {
			case 'BEGIN': 	font_justify = 'left'; 		break;
			case 'END': 	font_justify = 'right'; 	break;
			case 'FIRST': 	font_justify = 'left'; 		break; // not clear what to do with this one
			case 'MIDDLE': 	font_justify = 'center'; 	break;
			default: 		font_justify = 'left'; 		break;
		}

		font_size 		= fontStyleNode._vf.size;
		font_spacing 	= fontStyleNode._vf.spacing;
		font_horizontal = fontStyleNode._vf.horizontal;
		font_language 	= fontStyleNode._vf.language;

        if (font_size < 0.1) font_size = 0.1;
        if (font_size > 2.3) font_size = 2.3;
	}
	
	var textX, textY;
	var paragraph = this.node._vf.string;
	var text_canvas = document.createElement('canvas');
	text_canvas.dir = leftToRight;
	var textHeight = font_size * 42; // pixel size relative to local coordinate system
	var textAlignment = font_justify;			
	
	// needed to make webfonts work
	document.body.appendChild(text_canvas);

	var text_ctx = text_canvas.getContext('2d');
	
	// calculate font font_size in px
	text_ctx.font = font_style + " " + textHeight + "px " + font_family;

	var maxWidth = text_ctx.measureText(paragraph[0]).width;
    var i;

	// calculate maxWidth
	for(i = 1; i < paragraph.length; i++) {
		if(text_ctx.measureText(paragraph[i]).width > maxWidth)
			maxWidth = text_ctx.measureText(paragraph[i]).width;
	}
	
	text_canvas.width = maxWidth;
	text_canvas.height = textHeight * paragraph.length; 

	switch(textAlignment) {
		case "left": 	textX = 0; 						break;
		case "center": 	textX = text_canvas.width/2; 	break;
		case "right": 	textX = text_canvas.width;		break;
	}

	var txtW =  text_canvas.width;
	var txtH = text_canvas.height;

	text_ctx.fillStyle = 'rgba(0,0,0,0)';
	text_ctx.fillRect(0, 0, text_ctx.canvas.width, text_ctx.canvas.height);
	
	// write white text with black border
	text_ctx.fillStyle = 'white';		
	text_ctx.lineWidth = 2.5;
	text_ctx.strokeStyle = 'grey';
	text_ctx.textBaseline = 'top';

	text_ctx.font = font_style + " " + textHeight + "px " + font_family;
	text_ctx.textAlign = textAlignment;

	// create the multiline text
	for(i = 0; i < paragraph.length; i++) {
		textY = i*textHeight;          
		text_ctx.fillText(paragraph[i], textX,  textY);
	}
	
	if( this.texture === null )
	{
		this.texture = gl.createTexture();
	}
	
	gl.bindTexture(this.type, this.texture);
	gl.texImage2D(this.type, 0, this.format, this.format, gl.UNSIGNED_BYTE, text_canvas);
	gl.bindTexture(this.type, null);
	
	//remove canvas after Texture creation
	document.body.removeChild(text_canvas);
	
	var w = txtW / 100.0;
    	var h = txtH / 100.0;
	
	this.node._mesh._positions[0] = [-w,-h+.4,0, w,-h+.4,0, w,h+.4,0, -w,h+.4,0];

    this.node.invalidateVolume();
    Array.forEach(this.node._parentNodes, function (node) {
        node.setAllDirty();
    });
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

x3dom.shader = {};

x3dom.shader.PICKING = "picking";
x3dom.shader.PICKING_24 = "picking24";
x3dom.shader.PICKING_ID = "pickingId";
x3dom.shader.PICKING_COLOR = "pickingColor";
x3dom.shader.PICKING_TEXCOORD = "pickingTexCoord";
x3dom.shader.FRONTGROUND_TEXTURE = "frontgroundTexture";
x3dom.shader.BACKGROUND_TEXTURE = "backgroundTexture";
x3dom.shader.BACKGROUND_SKYTEXTURE = "backgroundSkyTexture";
x3dom.shader.BACKGROUND_CUBETEXTURE = "backgroundCubeTexture";
x3dom.shader.SHADOW = "shadow";
x3dom.shader.BLUR = "blur";
x3dom.shader.DEPTH = "depth";
x3dom.shader.NORMAL = "normal";

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */
 
 
/*******************************************************************************
* Material
********************************************************************************/
 x3dom.shader.material = function() {
	var shaderPart = "uniform vec3  diffuseColor;\n" +
					 "uniform vec3  specularColor;\n" +
					 "uniform vec3  emissiveColor;\n" +
					 "uniform float shininess;\n" +
					 "uniform float transparency;\n" +
					 "uniform float ambientIntensity;\n";
					 
	return shaderPart;
};
						 
/*******************************************************************************
* Fog
********************************************************************************/						 
x3dom.shader.fog = function() {

	var shaderPart = "uniform vec3  fogColor;\n" +
					 "uniform float fogType;\n" +
					 "uniform float fogRange;\n" +
					 "varying vec3 fragEyePosition;\n" +
					 "float calcFog(in vec3 eye) {\n" +
					 "   float f0 = 0.0;\n" +      
					 "   if(fogType == 0.0) {\n" +
					 "       if(length(eye) < fogRange){\n" +
					 "           f0 = (fogRange-length(eye)) / fogRange;\n" +
					 "       }\n" +
					 "   }else{\n" +
					 "       if(length(eye) < fogRange){\n" +
					 "           f0 = exp(-length(eye) / (fogRange-length(eye) ) );\n" +
					 "       }\n" +
					 "   }\n" +
					 "   f0 = clamp(f0, 0.0, 1.0);\n" +
					 "   return f0;\n" +
					 "}\n";
					 
	return shaderPart;
};

/*******************************************************************************
* Gamma correction support: initial declaration
********************************************************************************/
x3dom.shader.gammaCorrectionDecl = function(properties) {
	var shaderPart = "";
    if (properties.GAMMACORRECTION === "none") {
        // do not emit any declaration. 1.0 shall behave 'as without gamma'.
    } else if (properties.GAMMACORRECTION === "fastlinear") {
        // This is a slightly optimized gamma correction
        // which uses a gamma of 2.0 instead of 2.2. Gamma 2.0 is less costly
        // to encode in terms of cycles as sqrt() is usually optimized
        // in hardware.
        shaderPart += "vec4 gammaEncode(vec4 color){\n" +
                      "  vec4 tmp = sqrt(color);\n" +
                      "  return vec4(tmp.rgb, color.a);\n" +
                      "}\n";

        shaderPart += "vec4 gammaDecode(vec4 color){\n" +
                      "  vec4 tmp = color * color;\n" +
                      "  return vec4(tmp.rgb, color.a);\n" +
                      "}\n";

        shaderPart += "vec3 gammaEncode(vec3 color){\n" +
                      "  return sqrt(color);\n" +
                      "}\n";

        shaderPart += "vec3 gammaDecode(vec3 color){\n" +
                      "  return (color * color);\n" +
                      "}\n";
    } else {
        // The preferred implementation compensating for a gamma of 2.2, which closely
        // follows sRGB; alpha remains linear
        // minor opt: 1.0 / 2.2 = 0.4545454545454545
        shaderPart += "const vec4 gammaEncode4Vector = vec4(0.4545454545454545, 0.4545454545454545, 0.4545454545454545, 1.0);\n";
        shaderPart += "const vec4 gammaDecode4Vector = vec4(2.2, 2.2, 2.2, 1.0);\n";

        shaderPart += "vec4 gammaEncode(vec4 color){\n" +
                      "    return pow(color, gammaEncode4Vector);\n" +
                      "}\n";

        shaderPart += "vec4 gammaDecode(vec4 color){\n" +
                      "    return pow(color, gammaDecode4Vector);\n" +
                      "}\n";

        // RGB; minor opt: 1.0 / 2.2 = 0.4545454545454545
        shaderPart += "const vec3 gammaEncode3Vector = vec3(0.4545454545454545, 0.4545454545454545, 0.4545454545454545);\n";
        shaderPart += "const vec3 gammaDecode3Vector = vec3(2.2, 2.2, 2.2);\n";

        shaderPart += "vec3 gammaEncode(vec3 color){\n" +
                      "    return pow(color, gammaEncode3Vector);\n" +
                      "}\n";

        shaderPart += "vec3 gammaDecode(vec3 color){\n" +
                      "    return pow(color, gammaDecode3Vector);\n" +
                      "}\n";
    }
	return shaderPart;
};

/*******************************************************************************
* Gamma correction support: encoding and decoding of given expressions
* 
* Unlike other shader parts these javascript functions wrap the same-named gamma
* correction shader functions (if applicable). When gamma correction is  not used,
* the expression will be returned verbatim. Consequently, any terminating semicolon
* is to be issued by the caller.
********************************************************************************/
x3dom.shader.encodeGamma = function(properties, expr) {
    if (properties.GAMMACORRECTION === "none") {
        // Naive implementation: no-op, return verbatim
        return expr;
    } else {
        // The 2.0 and 2.2 cases are transparent at the call site
        return "gammaEncode (" + expr + ")";
    }
};

x3dom.shader.decodeGamma = function(properties, expr) {
    if (properties.GAMMACORRECTION === "none") {
        // Naive implementation: no-op, return verbatim
        return expr;
    } else {
        // The 2.0 and 2.2 cases are transparent at the call site
        return "gammaDecode (" + expr + ")";
    }
};

/*******************************************************************************
* Shadow
********************************************************************************/
x3dom.shader.rgbaPacking = function() {
	var shaderPart = "";
		shaderPart += 	
					"vec4 packDepth(float depth){\n" +
					"	depth = (depth + 1.0)*0.5;\n" +
					"	vec4 outVal = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n" +
					"	outVal = fract(outVal);\n" +
					"  	outVal -= outVal.yzww * vec4(1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n" +
					"  	return outVal;\n" +
					"}\n";
		
		shaderPart += 	
					"float unpackDepth(vec4 color){\n" +
					"	float depth = dot(color, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0));\n" +
					"	return (2.0*depth - 1.0);\n" + 
					"}\n";
	return shaderPart;
};

x3dom.shader.shadowRendering = function(){
	//determine if and how much a given position is influenced by given light
	var shaderPart = "";
	shaderPart +=
				"float getLightInfluence(float lType, float lShadowIntensity, float lOn, vec3 lLocation, vec3 lDirection, " + 
				"float lCutOffAngle, float lBeamWidth, vec3 lAttenuation, float lRadius, vec3 eyeCoords) {\n" +
				"	if (lOn == 0.0 || lShadowIntensity == 0.0){ return 0.0;\n" +
				"	} else if (lType == 0.0) {\n" +
				"		return 1.0;\n" +
				"	} else {\n" +
				"   	float attenuation = 0.0;\n" +
				"   	vec3 lightVec = (lLocation - (eyeCoords));\n" +
				"   	float distance = length(lightVec);\n" +
				"		lightVec = normalize(lightVec);\n" +
				"		eyeCoords = normalize(-eyeCoords);\n" +
				"   	if(lRadius == 0.0 || distance <= lRadius) {\n" +
				"       	attenuation = 1.0 / max(lAttenuation.x + lAttenuation.y * distance + lAttenuation.z * (distance * distance), 1.0);\n" +
				"		}\n" +
				" 		if (lType == 1.0) return attenuation;\n" +
				"   	float spotAngle = acos(max(0.0, dot(-lightVec, normalize(lDirection))));\n" +
				"   	if(spotAngle >= lCutOffAngle) return 0.0;\n" +
				"   	else if(spotAngle <= lBeamWidth) return attenuation;\n" +
				"   	else return attenuation * (spotAngle - lCutOffAngle) / (lBeamWidth - lCutOffAngle);\n" +
				"	}\n" +
				"}\n";
	
	// get light space depth of view sample and all entries of the shadow map
	shaderPart += 	
				"void getShadowValues(inout vec4 shadowMapValues, inout float viewSampleDepth, in mat4 lightMatrix, in vec4 worldCoords, in sampler2D shadowMap){\n" +
				"	vec4 lightSpaceCoords = lightMatrix*worldCoords;\n" +
				"	vec3 lightSpaceCoordsCart = lightSpaceCoords.xyz / lightSpaceCoords.w;\n" +
				"	vec2 textureCoords = (lightSpaceCoordsCart.xy + 1.0)*0.5;\n" +
				"	viewSampleDepth = lightSpaceCoordsCart.z;\n" +	
				"	shadowMapValues = texture2D(shadowMap, textureCoords);\n";
	if (!x3dom.caps.FP_TEXTURES  || x3dom.caps.MOBILE)
		shaderPart +=	"	shadowMapValues = vec4(1.0,1.0,unpackDepth(shadowMapValues),1.0);\n";
	shaderPart +="}\n";

	
	// get light space depth of view sample and all entries of the shadow map for point lights
	shaderPart += 	
				"void getShadowValuesPointLight(inout vec4 shadowMapValues, inout float viewSampleDepth, in vec3 lLocation, in vec4 worldCoords, in mat4 lightViewMatrix," +
				"in mat4 lMatrix_0, in mat4 lMatrix_1, in mat4 lMatrix_2, in mat4 lMatrix_3, in mat4 lMatrix_4, in mat4 lMatrix_5," +
				"in sampler2D shadowMap_0, in sampler2D shadowMap_1, in sampler2D shadowMap_2, in sampler2D shadowMap_3,"+
				"in sampler2D shadowMap_4, in sampler2D shadowMap_5){\n" +
				"	vec4 transformed = lightViewMatrix * worldCoords;\n" +
				"	vec3 lightVec = normalize(transformed.xyz/transformed.w);\n"+
				"	vec3 lightVecAbs = abs(lightVec);\n" +
				"	float maximum = max(max(lightVecAbs.x, lightVecAbs.y),lightVecAbs.z);\n" +
				"	if (lightVecAbs.x == maximum) {\n" +
				"		if (lightVec.x < 0.0) getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_3,worldCoords,shadowMap_3);\n"+		//right
				"		else getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_1,worldCoords,shadowMap_1);\n" +						//left
				"	}\n" +
				"	else if (lightVecAbs.y == maximum) {\n" +
				"		if (lightVec.y < 0.0) getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_4,worldCoords,shadowMap_4);\n"+		//front
				"		else getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_5,worldCoords,shadowMap_5);\n" +						//back
				"	}\n" +
				"	else if (lightVec.z < 0.0) getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_0,worldCoords,shadowMap_0);\n"+	//bottom
				"	else getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_2,worldCoords,shadowMap_2);\n" +							//top
				"}\n";	

	// get light space depth of view sample and all entries of the shadow map
	shaderPart += 	
				"void getShadowValuesCascaded(inout vec4 shadowMapValues, inout float viewSampleDepth, in vec4 worldCoords, in float eyeDepth, in mat4 lMatrix_0, in mat4 lMatrix_1, in mat4 lMatrix_2,"+
				"in mat4 lMatrix_3, in mat4 lMatrix_4, in mat4 lMatrix_5, in sampler2D shadowMap_0, in sampler2D shadowMap_1, in sampler2D shadowMap_2,"+
				"in sampler2D shadowMap_3, in sampler2D shadowMap_4, in sampler2D shadowMap_5, in float split_0, in float split_1, in float split_2, in float split_3, in float split_4){\n" +
				"	if (eyeDepth < split_0) getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_0, worldCoords, shadowMap_0);\n" +
				"	else if (eyeDepth < split_1) getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_1, worldCoords, shadowMap_1);\n" +
				"	else if (eyeDepth < split_2) getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_2, worldCoords, shadowMap_2);\n" +
				"	else if (eyeDepth < split_3) getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_3, worldCoords, shadowMap_3);\n" +
				"	else if (eyeDepth < split_4) getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_4, worldCoords, shadowMap_4);\n" +
				"	else getShadowValues(shadowMapValues, viewSampleDepth, lMatrix_5, worldCoords, shadowMap_5);\n" +																
				"}\n";	
				
	shaderPart += 	
				"float ESM(float shadowMapDepth, float viewSampleDepth, float offset){\n";
	if (!x3dom.caps.FP_TEXTURES || x3dom.caps.MOBILE)
			shaderPart += 	"	return exp(-80.0*(1.0-offset)*(viewSampleDepth - shadowMapDepth));\n";
	else 	shaderPart += 	"	return shadowMapDepth * exp(-80.0*(1.0-offset)*viewSampleDepth);\n";
	shaderPart +="}\n";	


	shaderPart += 	
				"float VSM(vec2 moments, float viewSampleDepth, float offset){\n"+
				"	viewSampleDepth = (viewSampleDepth + 1.0) * 0.5;\n" +
				"	if (viewSampleDepth <= moments.x) return 1.0;\n" +
				"	float variance = moments.y - moments.x * moments.x;\n" +
				"	variance = max(variance, 0.00002 + offset*0.01);\n" +
				"	float d = viewSampleDepth - moments.x;\n" +
				"	return variance/(variance + d*d);\n" +
				"}\n";	
			
	
	return shaderPart;
};


/*******************************************************************************
* Light
********************************************************************************/
x3dom.shader.light = function(numLights) {

	var shaderPart = "";

	for(var l=0; l<numLights; l++) {
		shaderPart += 	"uniform float light"+l+"_On;\n" +
						"uniform float light"+l+"_Type;\n" +
						"uniform vec3  light"+l+"_Location;\n" +
						"uniform vec3  light"+l+"_Direction;\n" +
						"uniform vec3  light"+l+"_Color;\n" +
						"uniform vec3  light"+l+"_Attenuation;\n" +
						"uniform float light"+l+"_Radius;\n" +
						"uniform float light"+l+"_Intensity;\n" +
						"uniform float light"+l+"_AmbientIntensity;\n" +
						"uniform float light"+l+"_BeamWidth;\n" +
						"uniform float light"+l+"_CutOffAngle;\n" +
						"uniform float light"+l+"_ShadowIntensity;\n";
	}
	
	shaderPart += 	"void lighting(in float lType, in vec3 lLocation, in vec3 lDirection, in vec3 lColor, in vec3 lAttenuation, " + 
					"in float lRadius, in float lIntensity, in float lAmbientIntensity, in float lBeamWidth, " +
					"in float lCutOffAngle, in vec3 N, in vec3 V, inout vec3 ambient, inout vec3 diffuse, " +
					"inout vec3 specular)\n" +
					"{\n" +
					"   vec3 L;\n" +
					"   float spot = 1.0, attentuation = 0.0;\n" +
					"   if(lType == 0.0) {\n" +
					"       L = -normalize(lDirection);\n" +
					"		V = normalize(V);\n" +
					"		attentuation = 1.0;\n" +
					"   } else{\n" +
					"       L = (lLocation - (-V));\n" +
					"       float d = length(L);\n" +
					"		L = normalize(L);\n" +
					"		V = normalize(V);\n" +
					"       if(lRadius == 0.0 || d <= lRadius) {\n" +
					"       	attentuation = 1.0 / max(lAttenuation.x + lAttenuation.y * d + lAttenuation.z * (d * d), 1.0);\n" +
					"		}\n" +
					"       if(lType == 2.0) {\n" +
					"           float spotAngle = acos(max(0.0, dot(-L, normalize(lDirection))));\n" +
					"           if(spotAngle >= lCutOffAngle) spot = 0.0;\n" +
					"           else if(spotAngle <= lBeamWidth) spot = 1.0;\n" +
					"           else spot = (spotAngle - lCutOffAngle ) / (lBeamWidth - lCutOffAngle);\n" +
					"       }\n" +
					"   }\n" +
					
					"   vec3  H = normalize( L + V );\n" +
					"   float NdotL = max(0.0, dot(L, N));\n" +
					"   float NdotH = max(0.0, dot(H, N));\n" +
					
					"   float ambientFactor  = lAmbientIntensity * ambientIntensity;\n" +
					"   float diffuseFactor  = lIntensity * NdotL;\n" +
					"   float specularFactor = lIntensity * pow(NdotH, shininess*128.0);\n" +
					"   ambient  += lColor * ambientFactor * attentuation * spot;\n" +
					"   diffuse  += lColor * diffuseFactor * attentuation * spot;\n" +
					"   specular += lColor * specularFactor * attentuation * spot;\n" +  
                    "}\n";
						
	return shaderPart;
};

/*******************************************************************************
 * cotangent_frame
 ********************************************************************************/
x3dom.shader.TBNCalculation = function() {
    var shaderPart = "";

    shaderPart += "mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)\n" +
        "{\n" +
        "    // get edge vectors of the pixel triangle\n" +
        "    vec3 dp1 = dFdx( p );\n" +
        "    vec3 dp2 = dFdy( p );\n" +
        "    vec2 duv1 = dFdx( uv );\n" +
        "    vec2 duv2 = dFdy( uv );\n" +
        "\n" +
        "    // solve the linear system\n" +
        "    vec3 dp2perp = cross( dp2, N );\n" +
        "    vec3 dp1perp = cross( N, dp1 );\n" +
        "    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n" +
        "    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n" +
        "\n" +
        "    // construct a scale-invariant frame\n" +
        "    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );\n" +
        "    return mat3( T * invmax, B * invmax, N );\n" +
        "}\n\n";

    shaderPart += "vec3 perturb_normal( vec3 N, vec3 V, vec2 texcoord )\n" +
        "{\n" +
        "    // assume N, the interpolated vertex normal and\n" +
        "    // V, the view vector (vertex to eye)\n" +
        "    vec3 map = texture2D(normalMap, texcoord ).xyz;\n" +
        "    map = map * 255./127. - 128./127.;\n" +
        "    mat3 TBN = cotangent_frame(N, -V, texcoord);\n" +
        "    return normalize(TBN * map);\n" +
        "}\n\n";

    return shaderPart;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final Shader program
 */
x3dom.shader.DynamicShader = function(gl, properties)
{
	this.program = gl.createProgram();
	
	var vertexShader 	= this.generateVertexShader(gl, properties);
	var fragmentShader 	= this.generateFragmentShader(gl, properties);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.DynamicShader.prototype.generateVertexShader = function(gl, properties)
{
	var shader = "";
	
	/*******************************************************************************
	* Generate dynamic attributes & uniforms & varyings
	********************************************************************************/
	
	//Default Matrices
	shader += "uniform mat4 modelViewMatrix;\n";
    shader += "uniform mat4 modelViewProjectionMatrix;\n";
	
	//Positions
	if(properties.POSCOMPONENTS == 3) {
		shader += "attribute vec3 position;\n";
	} else if(properties.POSCOMPONENTS == 4) {
		shader += "attribute vec4 position;\n";
	}
	
  //IG stuff
	if(properties.IMAGEGEOMETRY) {
		shader += "uniform vec3 IG_bboxMin;\n";
		shader += "uniform vec3 IG_bboxMax;\n";
		shader += "uniform float IG_coordTextureWidth;\n";
		shader += "uniform float IG_coordTextureHeight;\n";
		shader += "uniform vec2 IG_implicitMeshSize;\n";
		
		for( var i = 0; i < properties.IG_PRECISION; i++ ) {
			shader += "uniform sampler2D IG_coords" + i + "\n;";
		}
		
		if(properties.IG_INDEXED) {
			shader += "uniform sampler2D IG_index;\n";
			shader += "uniform float IG_indexTextureWidth;\n";
			shader += "uniform float IG_indexTextureHeight;\n";
		}
	}
    
    //PG stuff
    if (properties.POPGEOMETRY) {
        shader += "uniform float PG_precisionLevel;\n";
        shader += "uniform float PG_powPrecision;\n";
        shader += "uniform vec3 PG_maxBBSize;\n";
        shader += "uniform vec3 PG_bbMin;\n";
        shader += "uniform vec3 PG_bbMaxModF;\n";
        shader += "uniform vec3 PG_bboxShiftVec;\n";
        shader += "uniform float PG_numAnchorVertices;\n";
        shader += "attribute float PG_vertexID;\n";
    }
	
	//Normals
	if(properties.LIGHTS) {
		shader += "varying vec3 fragNormal;\n";
		shader += "uniform mat4 normalMatrix;\n";
		if(properties.IMAGEGEOMETRY) {		
			shader += "uniform sampler2D IG_normals;\n";	
		} else {
			if(properties.NORCOMPONENTS == 2) {
				if(properties.POSCOMPONENTS != 4) {
					shader += "attribute vec2 normal;\n";
				}
			} else if(properties.NORCOMPONENTS == 3) {
				shader += "attribute vec3 normal;\n";
			}
		}
	}
		
	//Init Colors. In the vertex shader we do not compute any color so
    //is is safe to ignore gamma here.
	if(properties.VERTEXCOLOR) {	
		if(properties.IMAGEGEOMETRY) {
			shader += "uniform sampler2D IG_colors;\n";
			if(properties.COLCOMPONENTS == 3) {
				shader += "varying vec3 fragColor;\n";
			} else if(properties.COLCOMPONENTS == 4) {
				shader += "varying vec4 fragColor;\n";
			}
		} else {
			if(properties.COLCOMPONENTS == 3) {
				shader += "attribute vec3 color;\n";
				shader += "varying vec3 fragColor;\n";
			} else if(properties.COLCOMPONENTS == 4) {
				shader += "attribute vec4 color;\n";
				shader += "varying vec4 fragColor;\n";
			}
		}
	}

	//Textures
	if(properties.TEXTURED || properties.CSSHADER) {
		shader += "varying vec2 fragTexcoord;\n";
		if(!properties.SPHEREMAPPING) {
			if(properties.IMAGEGEOMETRY) {
				shader += "uniform sampler2D IG_texCoords;\n";
			} else {
				shader += "attribute vec2 texcoord;\n";
			}
		}
		if(properties.TEXTRAFO){
			shader += "uniform mat4 texTrafoMatrix;\n";
		}

		if(properties.NORMALMAP && !x3dom.caps.STD_DERIVATIVES) {

            x3dom.debug.logWarning("Your System doesn't support the 'OES_STANDARD_DERIVATIVES' Extension. " +
                                   "You must set tangents and binormals manually via the FloatVertexAttribute-Node " +
                                   "to use normal maps");

			shader += "attribute vec3 tangent;\n";
			shader += "attribute vec3 binormal;\n";
			shader += "varying vec3 fragTangent;\n";
			shader += "varying vec3 fragBinormal;\n";
		}

		if(properties.CUBEMAP) {
			shader += "varying vec3 fragViewDir;\n";
			shader += "uniform mat4 viewMatrix;\n";
		}
        if (properties.DISPLACEMENTMAP) {
          shader += "uniform sampler2D displacementMap;\n";
          shader += "uniform float displacementFactor;\n";
          shader += "uniform float displacementWidth;\n";
          shader += "uniform float displacementHeight;\n";
            shader += "uniform float displacementAxis;\n";
        }
        if (properties.DIFFPLACEMENTMAP) {
            shader += "uniform sampler2D diffuseDisplacementMap;\n";
            shader += "uniform float displacementFactor;\n";
            shader += "uniform float displacementWidth;\n";
            shader += "uniform float displacementHeight;\n";
            shader += "uniform float displacementAxis;\n";
        }
	}
	
	//Lights & Fog
	if(properties.LIGHTS || properties.FOG){
		shader += "uniform vec3 eyePosition;\n";
		shader += "varying vec3 fragPosition;\n";
		if(properties.FOG) {
			shader += "varying vec3 fragEyePosition;\n";
		}
	}
	
	//Bounding Boxes
	if(properties.REQUIREBBOX) {
		shader += "uniform vec3 bgCenter;\n";
		shader += "uniform vec3 bgSize;\n";
		shader += "uniform float bgPrecisionMax;\n";
	}
	if(properties.REQUIREBBOXNOR) {
		shader += "uniform float bgPrecisionNorMax;\n";
	}
	if(properties.REQUIREBBOXCOL) {
		shader += "uniform float bgPrecisionColMax;\n";
	}
	if(properties.REQUIREBBOXTEX) {
		shader += "uniform float bgPrecisionTexMax;\n";
	}

      
	/*******************************************************************************
	* Generate main function
	********************************************************************************/
	shader += "void main(void) {\n";
	
	//Set point size
	shader += "gl_PointSize = 2.0;\n";	
  
	/*******************************************************************************
	* Start of special Geometry switch
	********************************************************************************/
	if(properties.IMAGEGEOMETRY) {
		//Indices
		if(properties.IG_INDEXED) {
			shader += "vec2 halfPixel = vec2(0.5/IG_indexTextureWidth,0.5/IG_indexTextureHeight);\n";
			shader += "vec2 IG_texCoord = vec2(position.x*(IG_implicitMeshSize.x/IG_indexTextureWidth), position.y*(IG_implicitMeshSize.y/IG_indexTextureHeight)) + halfPixel;\n";
			shader += "vec2 IG_indices = texture2D( IG_index, IG_texCoord ).rg;\n";
			shader += "halfPixel = vec2(0.5/IG_coordTextureWidth,0.5/IG_coordTextureHeight);\n";
			shader += "IG_texCoord = (IG_indices * 0.996108948) + halfPixel;\n";
		} else {
			shader += "vec2 halfPixel = vec2(0.5/IG_coordTextureWidth, 0.5/IG_coordTextureHeight);\n";
			shader += "vec2 IG_texCoord = vec2(position.x*(IG_implicitMeshSize.x/IG_coordTextureWidth), position.y*(IG_implicitMeshSize.y/IG_coordTextureHeight)) + halfPixel;\n";
		}
		
		//Positions
		shader += "vec3 temp = vec3(0.0, 0.0, 0.0);\n";
		shader += "vec3 vertPosition = vec3(0.0, 0.0, 0.0);\n";
		
		for(var i=0; i<properties.IG_PRECISION; i++) {
			shader += "temp = 255.0 * texture2D( IG_coords" + i + ", IG_texCoord ).rgb;\n";
			shader += "vertPosition *= 256.0;\n";
			shader += "vertPosition += temp;\n";
		}
		
		shader += "vertPosition /= (pow(2.0, 8.0 * " + properties.IG_PRECISION + ".0) - 1.0);\n";
		shader += "vertPosition = vertPosition * (IG_bboxMax - IG_bboxMin) + IG_bboxMin;\n";
	
		//Normals
		if(properties.LIGHTS) {
			shader += "vec3 vertNormal = texture2D( IG_normals, IG_texCoord ).rgb;\n";
			shader += "vertNormal = vertNormal * 2.0 - 1.0;\n";
		}
		
		//Colors
		if(properties.VERTEXCOLOR) {
			if(properties.COLCOMPONENTS == 3) {
				shader += "fragColor = texture2D( IG_colors, IG_texCoord ).rgb;\n";
			} else if(properties.COLCOMPONENTS == 4) {
				shader += "fragColor = texture2D( IG_colors, IG_texCoord ).rgba;\n";
			}
		}
		
		//TexCoords
		if(properties.TEXTURED || properties.CSSHADER) {
			shader += "vec4 IG_doubleTexCoords = texture2D( IG_texCoords, IG_texCoord );\n";
			shader += "vec2 vertTexCoord;";
			shader += "vertTexCoord.r = (IG_doubleTexCoords.r * 0.996108948) + (IG_doubleTexCoords.b * 0.003891051);\n";
			shader += "vertTexCoord.g = (IG_doubleTexCoords.g * 0.996108948) + (IG_doubleTexCoords.a * 0.003891051);\n";
		}
	} else {
		//Positions
		shader += "vec3 vertPosition = position.xyz;\n";
		
        if (properties.POPGEOMETRY) {
          //compute offset using bounding box and test if vertPosition <= PG_bbMaxModF 
          shader += "vec3 offsetVec = step(vertPosition / bgPrecisionMax, PG_bbMaxModF) * PG_bboxShiftVec;\n";
          
          //coordinate truncation, computation of current maximum possible value
          //PG_vertexID currently mimics use of gl_VertexID
          shader += "if ((PG_precisionLevel <= 2.0) || PG_vertexID >= PG_numAnchorVertices) {\n";
          shader += "   vertPosition = floor(vertPosition / PG_powPrecision) * PG_powPrecision;\n";
          shader += "   vertPosition /= (65536.0 - PG_powPrecision);\n";
          shader += "}\n";
          shader += "else {\n";
          shader += "   vertPosition /= bgPrecisionMax;\n";
          shader += "}\n";
          
          //translate coordinates, where PG_bbMin := floor(bbMin / size) 
          shader += "vertPosition = (vertPosition + offsetVec + PG_bbMin) * PG_maxBBSize;\n";
        }
		else if(properties.REQUIREBBOX) {
          shader += "vertPosition = bgCenter + bgSize * vertPosition / bgPrecisionMax;\n";
		}

		//Normals
		if(properties.LIGHTS) {
			if(properties.NORCOMPONENTS == 2) {
				if (properties.POSCOMPONENTS == 4) {
					// (theta, phi) encoded in low/high byte of position.w
					shader += "vec3 vertNormal = vec3(position.w / 256.0); \n";
					shader += "vertNormal.x = floor(vertNormal.x) / 255.0; \n";
					shader += "vertNormal.y = fract(vertNormal.y) * 1.00392156862745; \n"; //256.0 / 255.0
				}
				else if (properties.REQUIREBBOXNOR) {
					shader += "vec3 vertNormal = vec3(normal.xy, 0.0) / bgPrecisionNorMax;\n";                    
				}

				shader += "vec2 thetaPhi = 3.14159265358979 * vec2(vertNormal.x, vertNormal.y*2.0-1.0); \n";
				shader += "vec4 sinCosThetaPhi = sin( vec4(thetaPhi, thetaPhi + 1.5707963267949) ); \n";

				shader += "vertNormal.x = sinCosThetaPhi.x * sinCosThetaPhi.w; \n";
				shader += "vertNormal.y = sinCosThetaPhi.x * sinCosThetaPhi.y; \n";
				shader += "vertNormal.z = sinCosThetaPhi.z; \n";                
			} else {
				shader += "vec3 vertNormal = normal;\n";
				if (properties.REQUIREBBOXNOR) {
                    shader += "vertNormal = vertNormal / bgPrecisionNorMax;\n";                    
				}
                if (properties.BITLODGEOMETRY || properties.POPGEOMETRY) {
                    shader += "vertNormal = 2.0*vertNormal - 1.0;\n";
                }                
			}
		}
		
		//Colors
		if(properties.VERTEXCOLOR){
			shader += "fragColor = color;\n";
            
			if(properties.REQUIREBBOXCOL) {
                shader += "fragColor = fragColor / bgPrecisionColMax;\n";
			}                              
		}
		
		//TexCoords
		if( (properties.TEXTURED || properties.CSSHADER) && !properties.SPHEREMAPPING) {
			shader += "vec2 vertTexCoord = texcoord;\n";
			if(properties.REQUIREBBOXTEX) {
				shader += "vertTexCoord = vertTexCoord / bgPrecisionTexMax;\n";
			}
		}
	}
	
	/*******************************************************************************
	* End of special Geometry switch
	********************************************************************************/
	
	
	//Normals
	if(properties.LIGHTS) {
        if (properties.DISPLACEMENTMAP || properties.DIFFPLACEMENTMAP && !properties.NORMALMAP) {
          //Map-Tile Size
          shader += "float dx = 1.0 / displacementWidth;\n";
          shader += "float dy = 1.0 / displacementHeight;\n";

          //Get the 4 Vertex Neighbours
          if (properties.DISPLACEMENTMAP)
          {
              shader += "float s1 = texture2D(displacementMap, vec2(vertTexCoord.x - dx, 1.0 - vertTexCoord.y)).r;\n";		 //left
              shader += "float s2 = texture2D(displacementMap, vec2(vertTexCoord.x, 1.0 - vertTexCoord.y - dy)).r;\n";		 //bottom
              shader += "float s3 = texture2D(displacementMap, vec2(vertTexCoord.x + dx, 1.0 - vertTexCoord.y)).r;\n";	   //right
              shader += "float s4 = texture2D(displacementMap, vec2(vertTexCoord.x, 1.0 - vertTexCoord.y + dy)).r;\n";		 //top
          }
          else if (properties.DIFFPLACEMENTMAP)
          {
              shader += "float s1 = texture2D(diffuseDisplacementMap, vec2(vertTexCoord.x - dx, 1.0 - vertTexCoord.y)).a;\n";		 //left
              shader += "float s2 = texture2D(diffuseDisplacementMap, vec2(vertTexCoord.x, 1.0 - vertTexCoord.y - dy)).a;\n";		 //bottom
              shader += "float s3 = texture2D(diffuseDisplacementMap, vec2(vertTexCoord.x + dx, 1.0 - vertTexCoord.y)).a;\n";	   //right
              shader += "float s4 = texture2D(diffuseDisplacementMap, vec2(vertTexCoord.x, 1.0 - vertTexCoord.y + dy)).a;\n";		 //top
          }

          //Coeffiecent for smooth/sharp Normals
          shader += "float coef = displacementFactor;\n";

          //Calculate the Normal
          shader += "vec3 calcNormal;\n";

          shader += "if (displacementAxis == 0.0) {\n"; //X
          shader += "calcNormal = vec3((s1 - s3) * coef, -5.0, (s2 - s4) * coef);\n";
          shader += "} else if(displacementAxis == 1.0) {\n"; //Y
          shader += "calcNormal = vec3((s1 - s3) * coef, -5.0, (s2 - s4) * coef);\n";
          shader += "} else {\n"; //Z
          shader += "calcNormal = vec3((s1 - s3) * coef, -(s2 - s4) * coef, 5.0);\n";
          shader += "}\n";


          //normalized Normal
          shader += "calcNormal = normalize(calcNormal);\n";
          shader += "fragNormal = (normalMatrix * vec4(calcNormal, 0.0)).xyz;\n";
        }
        else
        {
            shader += "fragNormal = (normalMatrix * vec4(vertNormal, 0.0)).xyz;\n";
        }
	}
    
	//Textures
	if(properties.TEXTURED || properties.CSSHADER){
		if(properties.CUBEMAP) {
			shader += "fragViewDir = (viewMatrix[3].xyz);\n";
		} else if (properties.SPHEREMAPPING) {
			shader += " fragTexcoord = 0.5 + fragNormal.xy / 2.0;\n";
		} else if(properties.TEXTRAFO) {
			shader += " fragTexcoord = (texTrafoMatrix * vec4(vertTexCoord, 1.0, 1.0)).xy;\n";
		} else {
			shader += " fragTexcoord = vertTexCoord;\n";
			
			// LOD LUT HACK ###
			if (properties.POPGEOMETRY && x3dom.debug.usePrecisionLevelAsTexCoord === true)
			    // remap texCoords to texel middle with w = 16 and tc' := 1 / (2 * w) + tc * (w - 1) / w
                shader += "fragTexcoord = vec2(0.03125 + 0.9375 * (PG_precisionLevel / 16.0), 1.0);";
			// LOD LUT HACK ###
		}

		if(properties.NORMALMAP  && !x3dom.caps.STD_DERIVATIVES) {
			shader += "fragTangent  = (normalMatrix * vec4(tangent, 0.0)).xyz;\n";
			shader += "fragBinormal = (normalMatrix * vec4(binormal, 0.0)).xyz;\n";
		}
	}
	
	//Lights & Fog
	if(properties.LIGHTS || properties.FOG){    
		shader += "fragPosition = (modelViewMatrix * vec4(vertPosition, 1.0)).xyz;\n";
		if (properties.FOG) {
			shader += "fragEyePosition = eyePosition - fragPosition;\n";
		}
	}
  
	//Displacement
    if (properties.DISPLACEMENTMAP) {
        shader += "vertPosition += normalize(vertNormal) * texture2D(displacementMap, vec2(fragTexcoord.x, 1.0-fragTexcoord.y)).r * displacementFactor;\n";
    }
    else if (properties.DIFFPLACEMENTMAP)
    {
        shader += "vertPosition += normalize(vertNormal) * texture2D(diffuseDisplacementMap, vec2(fragTexcoord.x, 1.0-fragTexcoord.y)).a * displacementFactor;\n";
    }
  
  //Positions
	shader += "gl_Position = modelViewProjectionMatrix * vec4(vertPosition, 1.0);\n";
  
	//END OF SHADER
	shader += "}\n";
	
	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	//x3dom.debug.logInfo("VERTEX:\n" + shader);
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.DynamicShader.prototype.generateFragmentShader = function(gl, properties)
{
	/*var shader = "#ifdef GL_ES\n" +
    			 "  precision highp float;\n" +
    			 "#endif\n\n";*/
    
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";
	
	/*******************************************************************************
	* Generate dynamic uniforms & varyings
	********************************************************************************/
	
	//Default Matrices
	shader += "uniform mat4 modelMatrix;\n";
    shader += "uniform mat4 modelViewMatrix;\n";
	
	//Material
	shader += x3dom.shader.material();
	
	//Colors
	if(properties.VERTEXCOLOR){
		if(properties.COLCOMPONENTS == 3){
			shader += "varying vec3 fragColor;  \n";
		}else if(properties.COLCOMPONENTS == 4){
			shader += "varying vec4 fragColor;  \n";
		}
	}
	
	//Textures
	if(properties.TEXTURED || properties.CSSHADER) {
		shader += "varying vec2 fragTexcoord;\n";
		if((properties.TEXTURED || properties.DIFFUSEMAP) && !properties.CUBEMAP) {
			shader += "uniform sampler2D diffuseMap;\n";
		} else if(properties.CUBEMAP) {
			shader += "uniform samplerCube cubeMap;\n";
			shader += "varying vec3 fragViewDir;\n";
			shader += "uniform mat4 modelViewMatrixInverse;\n";
		}
		if(properties.SPECMAP){
			shader += "uniform sampler2D specularMap;\n";
		}
        if (properties.DISPLACEMENTMAP) {
          shader += "uniform sampler2D displacementMap;\n";
          shader += "uniform float displacementWidth;\n";
          shader += "uniform float displacementHeight;\n";
        }
        if (properties.DIFFPLACEMENTMAP) {
            shader += "uniform sampler2D diffuseDisplacementMap;\n";
            shader += "uniform float displacementWidth;\n";
            shader += "uniform float displacementHeight;\n";
        }
        if(properties.NORMALMAP){
            shader += "uniform sampler2D normalMap;\n";

            if(x3dom.caps.STD_DERIVATIVES) {
                shader += "#extension GL_OES_standard_derivatives:enable\n";
                shader += x3dom.shader.TBNCalculation();
            } else {
                shader += "varying vec3 fragTangent;\n";
                shader += "varying vec3 fragBinormal;\n";
            }
        }
	}
	
	//Fog
	if(properties.FOG) {
		shader += x3dom.shader.fog();
	}
	
	//Lights
	if(properties.LIGHTS) {
		shader += "varying vec3 fragNormal;\n";
    shader += "varying vec3 fragPosition;\n";
		shader += x3dom.shader.light(properties.LIGHTS);
	}

    // Declare gamma correction for color computation (see property "GAMMACORRECTION")
    shader += x3dom.shader.gammaCorrectionDecl(properties);
 
 
	/*******************************************************************************
	* Generate main function
	********************************************************************************/
	shader += "void main(void) {\n";
	
	//Init color. In the fragment shader we are treating color linear by
    //gamma-adjusting actively before doing lighting computations. At the end
    //the color value is encoded again. See shader propery GAMMACORRECTION.
    shader += "vec4 color;\n";
	shader += "color.rgb = " + x3dom.shader.decodeGamma(properties, "diffuseColor") + ";\n";
	shader += "color.a = 1.0 - transparency;\n";
			
	if(properties.VERTEXCOLOR) {
		if(properties.COLCOMPONENTS === 3){
			shader += "color.rgb = " + x3dom.shader.decodeGamma(properties,"fragColor") + ";\n";
		}else if(properties.COLCOMPONENTS === 4){
			shader += "color = " + x3dom.shader.decodeGamma(properties, "fragColor") + ";\n";
		}
	}
	
	if(properties.LIGHTS) {
		shader += "vec3 ambient   = vec3(0.0, 0.0, 0.0);\n";
		shader += "vec3 diffuse   = vec3(0.0, 0.0, 0.0);\n";
		shader += "vec3 specular  = vec3(0.0, 0.0, 0.0);\n";
		shader += "vec3 normal 	  = normalize(fragNormal);\n";
		shader += "vec3 eye 	  = -fragPosition;\n";
		
		//Normalmap
		if(properties.NORMALMAP){
			shader += "vec3 n = normalize( fragNormal );\n";

            if (x3dom.caps.STD_DERIVATIVES) {
                shader += "normal = perturb_normal( n, fragPosition, vec2(fragTexcoord.x, 1.0-fragTexcoord.y) );\n";
            } else {
                shader += "vec3 t = normalize( fragTangent );\n";
                shader += "vec3 b = normalize( fragBinormal );\n";
                shader += "mat3 tangentToWorld = mat3(t, b, n);\n";

                shader += "normal = texture2D( normalMap, vec2(fragTexcoord.x, 1.0-fragTexcoord.y) ).rgb;\n";
                shader += "normal = 2.0 * normal - 1.0;\n";
                shader += "normal = normalize( normal * tangentToWorld );\n";

                shader += "normal.y = -normal.y;\n";
                shader += "normal.x = -normal.x;\n";
            }
		}
		
		//Solid
		if(!properties.SOLID) {
			shader += "if (dot(normal, eye) < 0.0) {\n";
			shader += "  normal *= -1.0;\n";
			shader += "}\n";
		}
		
		//Calculate lights
		for(var l=0; l<properties.LIGHTS; l++) {
			shader += " lighting(light"+l+"_Type, " +
								"light"+l+"_Location, " +
								"light"+l+"_Direction, " +
								"light"+l+"_Color, " + 
								"light"+l+"_Attenuation, " +
								"light"+l+"_Radius, " +
								"light"+l+"_Intensity, " + 
								"light"+l+"_AmbientIntensity, " +
								"light"+l+"_BeamWidth, " +
								"light"+l+"_CutOffAngle, " +
								"normal, eye, ambient, diffuse, specular);\n";
		}
		
		//Specularmap
		if(properties.SPECMAP) {
			shader += "specular *= " + x3dom.shader.decodeGamma(properties, "texture2D(specularMap, vec2(fragTexcoord.x, 1.0-fragTexcoord.y)).rgb") + ";\n";
		}
		
		//Textures
		if(properties.TEXTURED || properties.DIFFUSEMAP || properties.DIFFPLACEMENTMAP){
			if(properties.CUBEMAP) {
				shader += "vec3 viewDir = normalize(fragViewDir);\n";
				shader += "vec3 reflected = reflect(viewDir, normal);\n";
				shader += "reflected = (modelViewMatrixInverse * vec4(reflected,0.0)).xyz;\n";
				shader += "vec4 texColor = " + x3dom.shader.decodeGamma(properties, "textureCube(cubeMap, reflected)") + ";\n";
				shader += "color.a *= texColor.a;\n";
			}
            else if (properties.DIFFPLACEMENTMAP)
            {
                shader += "vec2 texCoord = vec2(fragTexcoord.x, 1.0-fragTexcoord.y);\n";
                shader += "vec4 texColor = texture2D(diffuseDisplacementMap, texCoord);\n";
            }
            else
            {
				shader += "vec2 texCoord = vec2(fragTexcoord.x, 1.0-fragTexcoord.y);\n";
				shader += "vec4 texColor = " + x3dom.shader.decodeGamma(properties, "texture2D(diffuseMap, texCoord)") + ";\n";
				shader += "color.a *= texColor.a;\n";
			}
			if(properties.BLENDING){
				shader += "color.rgb = (emissiveColor + ambient*color.rgb + diffuse*color.rgb + specular*specularColor);\n";
				if(properties.CUBEMAP) {
					shader += "color.rgb = mix(color.rgb, texColor.rgb, vec3(0.75));\n";
				} else {
					shader += "color.rgb *= texColor.rgb;\n";
				}
			}else{
				shader += "color.rgb = (emissiveColor + ambient*texColor.rgb + diffuse*texColor.rgb + specular*specularColor);\n";
			}
		}else{
			shader += "color.rgb = (emissiveColor + ambient*color.rgb + diffuse*color.rgb + specular*specularColor);\n";
		}
		
	} else {
		if (properties.APPMAT && !properties.VERTEXCOLOR) {
			shader += "color = vec4(0.0, 0.0, 0.0, 1.0 - transparency);\n";
		}
		
		if(properties.TEXTURED || properties.DIFFUSEMAP){
			shader += "vec2 texCoord = vec2(fragTexcoord.x, 1.0-fragTexcoord.y);\n";
			shader += "vec4 texColor = " + x3dom.shader.decodeGamma(properties, "texture2D(diffuseMap, texCoord)") + ";\n";
			shader += "color.a = texColor.a;\n";
			if(properties.BLENDING){
				shader += "color.rgb += emissiveColor.rgb;\n";
				shader += "color.rgb *= texColor.rgb;\n";
			} else {
				shader += "color = texColor;\n";
			}
		} else if(!properties.VERTEXCOLOR && !properties.POINTLINE2D){
			shader += "color.rgb += emissiveColor;\n";
		} else if(!properties.VERTEXCOLOR && properties.POINTLINE2D){
			shader += "color.rgb = emissiveColor;\n";
		}
	}
	
	//Fog
	if(properties.FOG){
		shader += "float f0 = calcFog(fragEyePosition);\n";
		shader += "color.rgb = fogColor * (1.0-f0) + f0 * (color.rgb);\n";
	}
	
	//Kill pixel
	if(properties.TEXT) {
		shader += "if (color.a <= 0.5) discard;\n";
	} else {
		shader += "if (color.a <= 0.1) discard;\n";
	}

    //Output the gamma encoded result.
    shader += "gl_FragColor = " + x3dom.shader.encodeGamma(properties, "color") + ";\n";
	
	//End Of Shader
	shader += "}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
    //x3dom.debug.logInfo("FRAGMENT:\n" + shader);
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final Shader program
 */
x3dom.shader.DynamicMobileShader = function(gl, properties)
{
	this.program = gl.createProgram();
	
	var vertexShader 	= this.generateVertexShader(gl, properties);
	var fragmentShader 	= this.generateFragmentShader(gl, properties);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.DynamicMobileShader.prototype.generateVertexShader = function(gl, properties)
{
	var shader = "";
	
	/*******************************************************************************
	* Generate dynamic attributes & uniforms & varyings
	********************************************************************************/
	
	//Material
	shader += x3dom.shader.material();
	
	//Default Matrices
	shader += "uniform mat4 normalMatrix;\n";
	shader += "uniform mat4 modelViewMatrix;\n";
    shader += "uniform mat4 modelViewProjectionMatrix;\n";
	
	//Positions
	if(properties.POSCOMPONENTS == 3) {
		shader += "attribute vec3 position;\n";
	} else if(properties.POSCOMPONENTS == 4) {
		shader += "attribute vec4 position;\n";
	}
	
  //IG stuff
	if(properties.IMAGEGEOMETRY) {
		shader += "uniform vec3 IG_bboxMin;\n";
		shader += "uniform vec3 IG_bboxMax;\n";
		shader += "uniform float IG_coordTextureWidth;\n";
		shader += "uniform float IG_coordTextureHeight;\n";
		shader += "uniform vec2 IG_implicitMeshSize;\n";
		
		for( var i = 0; i < properties.IG_PRECISION; i++ ) {
			shader += "uniform sampler2D IG_coords" + i + "\n;";
		}
		
		if(properties.IG_INDEXED) {
			shader += "uniform sampler2D IG_index;\n";
			shader += "uniform float IG_indexTextureWidth;\n";
			shader += "uniform float IG_indexTextureHeight;\n";
		}
	}
	
    //PG stuff
    if (properties.POPGEOMETRY) {
        shader += "uniform float PG_precisionLevel;\n";
        shader += "uniform float PG_powPrecision;\n";
        shader += "uniform vec3 PG_maxBBSize;\n";
        shader += "uniform vec3 PG_bbMin;\n";
        shader += "uniform vec3 PG_bbMaxModF;\n";
        shader += "uniform vec3 PG_bboxShiftVec;\n";
        shader += "uniform float PG_numAnchorVertices;\n";
        shader += "attribute float PG_vertexID;\n";
    }
  
	//Normals
	if(!properties.POINTLINE2D) {
		if(properties.IMAGEGEOMETRY) {		
			shader += "uniform sampler2D IG_normals;\n";	
		} else {
			if(properties.NORCOMPONENTS == 2) {
				if(properties.POSCOMPONENTS != 4) {
					shader += "attribute vec2 normal;\n";
				}
			} else if(properties.NORCOMPONENTS == 3) {
				shader += "attribute vec3 normal;\n";
			}
		}
	}
	
	//Colors
	shader += "varying vec4 fragColor;\n";
	if(properties.VERTEXCOLOR){
		if(properties.IMAGEGEOMETRY) {
			shader += "uniform sampler2D IG_colors;";
		} else {
			if(properties.COLCOMPONENTS == 3){
				shader += "attribute vec3 color;";
			} else if(properties.COLCOMPONENTS == 4) {
				shader += "attribute vec4 color;";
			}
		}
	}
	
	//Textures
	if(properties.TEXTURED) {
		shader += "varying vec2 fragTexcoord;\n";
		if(properties.IMAGEGEOMETRY) {
			shader += "uniform sampler2D IG_texCoords;";
		} else {
			shader += "attribute vec2 texcoord;\n";
		}
		if(properties.TEXTRAFO){
			shader += "uniform mat4 texTrafoMatrix;\n";
		}
		if(!properties.BLENDING) {
			shader += "varying vec3 fragAmbient;\n";
			shader += "varying vec3 fragDiffuse;\n";
		}
		if(properties.CUBEMAP) {
			shader += "varying vec3 fragViewDir;\n";
			shader += "varying vec3 fragNormal;\n";
			shader += "uniform mat4 viewMatrix;\n";
		}
	}
	
	//Fog
	if(properties.FOG) {
		shader += x3dom.shader.fog();
	}
	
	//Lights
	if(properties.LIGHTS) {
		shader += x3dom.shader.light(properties.LIGHTS);
	}
	
	//Bounding Boxes
	if(properties.REQUIREBBOX) {
		shader += "uniform vec3 bgCenter;\n";
		shader += "uniform vec3 bgSize;\n";
		shader += "uniform float bgPrecisionMax;\n";
	}
	if(properties.REQUIREBBOXNOR) {
		shader += "uniform float bgPrecisionNorMax;\n";
	}
	if(properties.REQUIREBBOXCOL) {
		shader += "uniform float bgPrecisionColMax;\n";
	}
	if(properties.REQUIREBBOXTEX) {
		shader += "uniform float bgPrecisionTexMax;\n";
	}

    
	/*******************************************************************************
	* Generate main function
	********************************************************************************/
	shader += "void main(void) {\n";
	
	//Set point size
	shader += "gl_PointSize = 2.0;\n";
	
	/*******************************************************************************
	* Start of ImageGeometry switch
	********************************************************************************/
	if(properties.IMAGEGEOMETRY) {
		//Indices
		if(properties.IG_INDEXED) {
			shader += "vec2 halfPixel = vec2(0.5/IG_indexTextureWidth,0.5/IG_indexTextureHeight);\n";
			shader += "vec2 IG_texCoord = vec2(position.x*(IG_implicitMeshSize.x/IG_indexTextureWidth), position.y*(IG_implicitMeshSize.y/IG_indexTextureHeight)) + halfPixel;\n";
			shader += "vec2 IG_indices = texture2D( IG_index, IG_texCoord ).rg;\n";
			shader += "halfPixel = vec2(0.5/IG_coordTextureWidth,0.5/IG_coordTextureHeight);\n";
			shader += "IG_texCoord = (IG_indices * 0.996108948) + halfPixel;\n";
		} else {
			shader += "vec2 halfPixel = vec2(0.5/IG_coordTextureWidth, 0.5/IG_coordTextureHeight);\n";
			shader += "vec2 IG_texCoord = vec2(position.x*(IG_implicitMeshSize.x/IG_coordTextureWidth), position.y*(IG_implicitMeshSize.y/IG_coordTextureHeight)) + halfPixel;\n";
		}
		
		//Positions
		shader += "vec3 temp = vec3(0.0, 0.0, 0.0);\n";
		shader += "vec3 vertPosition = vec3(0.0, 0.0, 0.0);\n";
		
		for(var i=0; i<properties.IG_PRECISION; i++) {
			shader += "temp = 255.0 * texture2D( IG_coords" + i + ", IG_texCoord ).rgb;\n";
			shader += "vertPosition *= 256.0;\n";
			shader += "vertPosition += temp;\n";
		}
		
		shader += "vertPosition /= (pow(2.0, 8.0 * " + properties.IG_PRECISION + ".0) - 1.0);\n";
		shader += "vertPosition = vertPosition * (IG_bboxMax - IG_bboxMin) + IG_bboxMin;\n";
	
		//Normals
		if(!properties.POINTLINE2D) {
			shader += "vec3 vertNormal = texture2D( IG_normals, IG_texCoord ).rgb;\n";
			shader += "vertNormal = vertNormal * 2.0 - 1.0;\n";
		}
		
		//Colors
		if(properties.VERTEXCOLOR) {
			if(properties.COLCOMPONENTS == 3) {
				shader += "vec3 vertColor = texture2D( IG_colors, IG_texCoord ).rgb;";
			} else if(properties.COLCOMPONENTS  == 4) {
				shader += "vec4 vertColor = texture2D( IG_colors, IG_texCoord ).rgba;";
			}
		}
		
		//TexCoords
		if(properties.TEXTURED) {
			shader += "vec4 IG_doubleTexCoords = texture2D( IG_texCoords, IG_texCoord );\n";
			shader += "vec2 vertTexCoord;";
			shader += "vertTexCoord.r = (IG_doubleTexCoords.r * 0.996108948) + (IG_doubleTexCoords.b * 0.003891051);\n";
			shader += "vertTexCoord.g = (IG_doubleTexCoords.g * 0.996108948) + (IG_doubleTexCoords.a * 0.003891051);\n";
		}
	} else {
		//Positions
		shader += "vec3 vertPosition = position.xyz;\n";
        
        if (properties.POPGEOMETRY) {
          //compute offset using bounding box and test if vertPosition <= PG_bbMaxModF 
          shader += "vec3 offsetVec = step(vertPosition / bgPrecisionMax, PG_bbMaxModF) * PG_bboxShiftVec;\n";
          
          //coordinate truncation, computation of current maximum possible value
          //PG_vertexID currently mimics use of gl_VertexID
          shader += "if ((PG_precisionLevel <= 2.0) || PG_vertexID >= PG_numAnchorVertices) {\n";
          shader += "   vertPosition = floor(vertPosition / PG_powPrecision) * PG_powPrecision;\n";
          shader += "   vertPosition /= (65536.0 - PG_powPrecision);\n";
          shader += "}\n";
          shader += "else {\n";
          shader += "   vertPosition /= bgPrecisionMax;\n";
          shader += "}\n";
          
          //translate coordinates, where PG_bbMin := floor(bbMin / size) 
          shader += "vertPosition = (vertPosition + offsetVec + PG_bbMin) * PG_maxBBSize;\n";
        }
		else if(properties.REQUIREBBOX || properties.BITLODGEOMETRY) {
          shader += "vertPosition = bgCenter + bgSize * vertPosition / bgPrecisionMax;\n";
		}
	
		//Normals
		if(!properties.POINTLINE2D) {
			if (properties.NORCOMPONENTS == 2) {
				if (properties.POSCOMPONENTS == 4) {
					// (theta, phi) encoded in low/high byte of position.w
					shader += "vec3 vertNormal = vec3(position.w / 256.0); \n";
					shader += "vertNormal.x = floor(vertNormal.x) / 255.0; \n";
					shader += "vertNormal.y = fract(vertNormal.y) * 1.00392156862745; \n"; //256.0 / 255.0
				} else if (properties.REQUIREBBOXNOR && !properties.BITLODGEOMETRY) {
					shader += "vec3 vertNormal = vec3(normal.xy, 0.0) / bgPrecisionNorMax;\n";
				} else {
					shader += "vec3 vertNormal = vec3(normal.xy, 0.0);\n";
				}
				
				shader += "vec2 thetaPhi = 3.14159265358979 * vec2(vertNormal.x, vertNormal.y*2.0-1.0); \n";

				// Doing approximation with Taylor series and using cos(x) = sin(x+PI/2)
				shader += "vec4 sinCosThetaPhi = vec4(thetaPhi, thetaPhi + 1.5707963267949); \n";

				shader += "vec4 thetaPhiPow2 = sinCosThetaPhi * sinCosThetaPhi; \n";
				shader += "vec4 thetaPhiPow3 =  thetaPhiPow2  * sinCosThetaPhi; \n";
				shader += "vec4 thetaPhiPow5 =  thetaPhiPow3  * thetaPhiPow2; \n";
				shader += "vec4 thetaPhiPow7 =  thetaPhiPow5  * thetaPhiPow2; \n";
				shader += "vec4 thetaPhiPow9 =  thetaPhiPow7  * thetaPhiPow2; \n";

				shader += "sinCosThetaPhi +=  -0.16666666667   * thetaPhiPow3; \n";
				shader += "sinCosThetaPhi +=   0.00833333333   * thetaPhiPow5; \n";
				shader += "sinCosThetaPhi +=  -0.000198412698  * thetaPhiPow7; \n";
				shader += "sinCosThetaPhi +=   0.0000027557319 * thetaPhiPow9; \n";

				shader += "vertNormal.x = sinCosThetaPhi.x * sinCosThetaPhi.w; \n";
				shader += "vertNormal.y = sinCosThetaPhi.x * sinCosThetaPhi.y; \n";
				shader += "vertNormal.z = sinCosThetaPhi.z; \n";
			} else {
				shader += "vec3 vertNormal = normal;\n";
				if (properties.REQUIREBBOXNOR) {
                    shader += "vertNormal = vertNormal / bgPrecisionNorMax;\n";
				}   
                if (properties.BITLODGEOMETRY || properties.POPGEOMETRY) {                    
                    shader += "vertNormal = 2.0*vertNormal - 1.0;\n";                    
                }                
			}
		}
		
		//Colors
		if(properties.VERTEXCOLOR) {
			if(properties.COLCOMPONENTS == 3) {
				shader += "vec3 vertColor = color;";
			} else if(properties.COLCOMPONENTS  == 4) {
				shader += "vec4 vertColor = color;";
			}
			if(properties.REQUIREBBOXNOR) {
				shader += "vertColor = vertColor / bgPrecisionColMax;\n";
			}
		}
		
		//TexCoords
		if(properties.TEXTURED) {
			shader += "vec2 vertTexCoord = texcoord;\n";
			if(properties.REQUIREBBOXTEX) {
				shader += "vertTexCoord = vertTexCoord / bgPrecisionTexMax;\n";
			}
		}
	}
	/*******************************************************************************
	* End of ImageGeometry switch
	********************************************************************************/
	
	//positions to model-view-space
	shader += "vec3 positionMV = (modelViewMatrix * vec4(vertPosition, 1.0)).xyz;\n";
	
	//normals to model-view-space
	if(!properties.POINTLINE2D) {
		shader += "vec3 normalMV = normalize( (normalMatrix * vec4(vertNormal, 0.0)).xyz );\n";
	}
	
	shader += "vec3 eye = -positionMV;\n";
	
	//Colors
	if (properties.VERTEXCOLOR) {
		shader += "vec3 rgb = vertColor.rgb;\n";	
		if(properties.COLCOMPONENTS == 4) {
			shader += "float alpha = vertColor.a;\n";
		} else if(properties.COLCOMPONENTS == 3) {
			shader += "float alpha = 1.0 - transparency;\n";
		}
	} else {
		shader += "vec3 rgb = diffuseColor;\n";
		shader += "float alpha = 1.0 - transparency;\n";
	}
	
	//Calc TexCoords
	if(properties.TEXTURED){
		if(properties.CUBEMAP) {
			shader += "fragViewDir = viewMatrix[3].xyz;\n";
			shader += "fragNormal = normalMV;\n";
		} else if(properties.SPHEREMAPPING) {
			shader += " fragTexcoord = 0.5 + normalMV.xy / 2.0;\n";
		} else if(properties.TEXTRAFO) {
			shader += " fragTexcoord = (texTrafoMatrix * vec4(vertTexCoord, 1.0, 1.0)).xy;\n";
		} else {
			shader += " fragTexcoord = vertTexCoord;\n";
			
			// LOD LUT HACK ###
			if (properties.POPGEOMETRY && x3dom.debug.usePrecisionLevelAsTexCoord === true)
			    // remap texCoords to texel middle with w = 16 and tc' := 1 / (2 * w) + tc * (w - 1) / w
                shader += "fragTexcoord = vec2(0.03125 + 0.9375 * (PG_precisionLevel / 16.0), 1.0);";
			// LOD LUT HACK ###
		}
	}
	
	//calc lighting
	if(properties.LIGHTS) {
		shader += "vec3 ambient   = vec3(0.0, 0.0, 0.0);\n";
		shader += "vec3 diffuse   = vec3(0.0, 0.0, 0.0);\n";
		shader += "vec3 specular  = vec3(0.0, 0.0, 0.0);\n";
		
		//Solid
		if(!properties.SOLID) {
			shader += "if (dot(normalMV, eye) < 0.0) {\n";
			shader += "	 normalMV *= -1.0;\n";
			shader += "}\n";
		}
		
		//Calculate lighting
		for(var i=0; i<properties.LIGHTS; i++) {		
			shader += " lighting(light"+i+"_Type," +
								"light"+i+"_Location," +
								"light"+i+"_Direction," +
								"light"+i+"_Color," + 
								"light"+i+"_Attenuation," +
								"light"+i+"_Radius," +
								"light"+i+"_Intensity," + 
								"light"+i+"_AmbientIntensity," +
								"light"+i+"_BeamWidth," +
								"light"+i+"_CutOffAngle," +
								"normalMV, eye, ambient, diffuse, specular);\n";
		}
		
		//Textures & blending
		if(properties.TEXTURED  && !properties.BLENDING) {
			shader += "fragAmbient = ambient;\n";
			shader += "fragDiffuse = diffuse;\n";
			shader += "fragColor.rgb = (emissiveColor + specular*specularColor);\n";
			shader += "fragColor.a = alpha;\n";
		} else {
			shader += "fragColor.rgb = (emissiveColor + ambient*rgb + diffuse*rgb + specular*specularColor);\n";
			shader += "fragColor.a = alpha;\n";
		}
	} else {
		if (properties.APPMAT && !properties.VERTEXCOLOR) {
			shader += "rgb = vec3(0.0, 0.0, 0.0);\n";
		}
		if(properties.TEXTURED && !properties.BLENDING) {
			shader += "fragAmbient = vec3(0.0);\n";
			shader += "fragDiffuse = vec3(1.0);\n";
			shader += "fragColor.rgb = vec3(0.0);\n";
			shader += "fragColor.a = alpha;\n";
		} else if(!properties.VERTEXCOLOR && properties.POINTLINE2D){
			shader += "fragColor.rgb = emissiveColor;\n";
			shader += "fragColor.a = alpha;\n";
		} else {
			shader += "fragColor.rgb = rgb + emissiveColor;\n";
			shader += "fragColor.a = alpha;\n";
		}
	}
	
	//Fog
	if(properties.FOG) {
		shader += "float f0 = calcFog(-positionMV);\n";
		shader += "fragColor.rgb = fogColor * (1.0-f0) + f0 * (fragColor.rgb);\n";
	}

	//Output
	shader += "gl_Position = modelViewProjectionMatrix * vec4(vertPosition, 1.0);\n";
	
	//End of shader
	shader += "}\n";

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[DynamicMobileShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.DynamicMobileShader.prototype.generateFragmentShader = function(gl, properties)
{
	var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";
	
	/*******************************************************************************
	* Generate dynamic uniforms & varyings
	********************************************************************************/
	//Colors
	shader += "varying vec4 fragColor;\n";
	
	//Textures
	if(properties.TEXTURED) {
		if(properties.CUBEMAP) {
			shader += "uniform samplerCube cubeMap;\n";
			shader += "varying vec3 fragViewDir;\n";
			shader += "varying vec3 fragNormal;\n";
			shader += "uniform mat4 modelViewMatrixInverse;\n";
		} else {
			shader += "uniform sampler2D diffuseMap;           \n";
			shader += "varying vec2 fragTexcoord;       \n";
		}
		if(!properties.BLENDING) {
			shader += "varying vec3 fragAmbient;\n";
			shader += "varying vec3 fragDiffuse;\n";
		}
	}
	
	/*******************************************************************************
	* Generate main function
	********************************************************************************/
	shader += "void main(void) {\n";
	
	//Colors
	shader += "vec4 color = fragColor;\n";
	
	//Textures
	if(properties.TEXTURED){
		if(properties.CUBEMAP) {
			shader += "vec3 normal = normalize(fragNormal);\n";
			shader += "vec3 viewDir = normalize(fragViewDir);\n";
			shader += "vec3 reflected = reflect(viewDir, normal);\n";
			shader += "reflected = (modelViewMatrixInverse * vec4(reflected,0.0)).xyz;\n";
			shader += "vec4 texColor = textureCube(cubeMap, reflected);\n";
		} else {
			shader += "vec4 texColor = texture2D(diffuseMap, vec2(fragTexcoord.s, 1.0-fragTexcoord.t));\n";
		}
		if(properties.BLENDING) {
			if(properties.CUBEMAP) {
				shader += "color.rgb = mix(color.rgb, texColor.rgb, vec3(0.75));\n";
				shader += "color.a = texColor.a;\n";
			} else {
				shader += "color.rgb *= texColor.rgb;\n";
				shader += "color.a *= texColor.a;\n";
			}
		} else {
			shader += "color.rgb += fragAmbient*texColor.rgb + fragDiffuse*texColor.rgb;\n";
			shader += "color.a *= texColor.a;\n";
		}
	} 
	
	//Kill pixel
	if(properties.TEXT) {
		shader += "if (color.a <= 0.5) discard;\n";
	} else {
		shader += "if (color.a <= 0.1) discard;\n";
	}
	
	//Output
	shader += "gl_FragColor = color;\n";
	
	//End of shader
	shader += "}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[DynamicMobileShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final Shader program
 */
x3dom.shader.ComposedShader = function(gl, shape)
{
	this.program = gl.createProgram();
	
	var vertexShader 	= this.generateVertexShader(gl, shape);
	var fragmentShader 	= this.generateFragmentShader(gl, shape);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.ComposedShader.prototype.generateVertexShader = function(gl, shape)
{
	var shader = shape._cf.appearance.node._shader._vertex._vf.url[0];

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[ComposedShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.ComposedShader.prototype.generateFragmentShader = function(gl, shape)
{
	var shader = shape._cf.appearance.node._shader._fragment._vf.url[0];

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[ComposedShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final Shader program
 */
x3dom.shader.NormalShader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader   = this.generateVertexShader(gl);
	var fragmentShader = this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.NormalShader.prototype.generateVertexShader = function(gl)
{
	var shader =    "attribute vec3 position;\n" +
                    "attribute vec3 normal;\n" +
                    "uniform vec3 bgCenter;\n" +
                    "uniform vec3 bgSize;\n" +
                    "uniform float bgPrecisionMax;\n" +
                    "uniform float bgPrecisionNorMax;\n" +
                    "uniform mat4 normalMatrix;\n" +
                    "uniform mat4 modelViewProjectionMatrix;\n" +
                    "varying vec3 fragNormal;\n" +
                    
                    "void main(void) {\n" +
                    "    vec3 pos = bgCenter + bgSize * position / bgPrecisionMax;\n" +
                    "    fragNormal = (normalMatrix * vec4(normal / bgPrecisionNorMax, 0.0)).xyz;\n" +
                    //"    fragNormal = normal;\n" +
                    "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);\n" +
                    "}\n";

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[NormalShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.NormalShader.prototype.generateFragmentShader = function(gl)
{
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";

	shader += "varying vec3 fragNormal;\n" +
					
					"void main(void) {\n" +
					"    gl_FragColor = vec4(normalize(fragNormal) / 2.0 + 0.5, 1.0);\n" +
					"}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[NormalShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final Shader program
 */
x3dom.shader.PickingShader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader   = this.generateVertexShader(gl);
	var fragmentShader = this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.PickingShader.prototype.generateVertexShader = function(gl)
{
	var shader = "";

    var popUniforms = "";
    var popDecoder = "";

    // leave possibility to disable this stuff...
    {
        popUniforms +=  "uniform float popGeometry;\n" +
                        "uniform float PG_precisionLevel;\n" +
                        "uniform float PG_powPrecision;\n" +
                        "uniform vec3 PG_maxBBSize;\n" +
                        "uniform vec3 PG_bbMin;\n" +
                        "uniform vec3 PG_bbMaxModF;\n" +
                        "uniform vec3 PG_bboxShiftVec;\n";

        popDecoder +=   "   else if (popGeometry != 0.0) {\n" +
                        "		vec3 offsetVec = step(pos / bgPrecisionMax, PG_bbMaxModF) * PG_bboxShiftVec;\n" +
                        "		if (PG_precisionLevel <= 2.0) {\n" +
                        "   		pos = floor(pos / PG_powPrecision) * PG_powPrecision;\n" +
                        "   		pos /= (65536.0 - PG_powPrecision);\n" +
                        "		}\n" +
                        "		else {\n" +
                        "   		pos /= bgPrecisionMax;\n" +
                        "		}\n" +
                        "		pos = (pos + offsetVec + PG_bbMin) * PG_maxBBSize;\n" +
                        "	}\n" +
                        "   else\n";
    }

    if (!x3dom.caps.MOBILE) {
        shader =    "attribute vec3 position;\n" +
                    "attribute vec2 texcoord;\n" +
					"uniform vec3 bgCenter;\n" +
					"uniform vec3 bgSize;\n" +
					"uniform float bgPrecisionMax;\n" +
					"uniform mat4 modelMatrix;\n" +
					"uniform mat4 modelViewProjectionMatrix;\n" +
					"uniform vec3 from;\n" +
					"varying vec3 worldCoord;\n" +
					"varying vec2 idCoord;\n" +
					"uniform float writeShadowIDs;\n" +
                    //image geometry
					"uniform float imageGeometry;\n" +
					"uniform vec3 IG_bboxMin;\n" +
					"uniform vec3 IG_bboxMax;\n" +
					"uniform float IG_coordTextureWidth;\n" +
					"uniform float IG_coordTextureHeight;\n" +
					"uniform float IG_indexTextureWidth;\n" +
					"uniform float IG_indexTextureHeight;\n" +
					"uniform sampler2D IG_indexTexture;\n" +
					"uniform sampler2D IG_coordinateTexture;\n" +
					"uniform vec2 IG_implicitMeshSize;\n" +
                    //pop geometry
                    popUniforms +

					"void main(void) {\n" +
					"   gl_PointSize = 2.0;\n" +
                    "   vec3 pos = position;\n" +

					"   if (writeShadowIDs > 0.0) {\n" +
					"	    idCoord = vec2((texcoord.x + writeShadowIDs) / 256.0);\n" +
    				"       idCoord.x = floor(idCoord.x) / 255.0;\n" +
    				"       idCoord.y = fract(idCoord.y) * 1.00392156862745;\n" +
					"	}\n" +
					"	if (imageGeometry != 0.0) {\n" +
					"		vec2 IG_texCoord;\n" +
					"		if(imageGeometry == 1.0) {\n" +
					"			vec2 halfPixel = vec2(0.5/IG_indexTextureWidth,0.5/IG_indexTextureHeight);\n" +
					"			IG_texCoord = vec2(position.x*(IG_implicitMeshSize.x/IG_indexTextureWidth), position.y*(IG_implicitMeshSize.y/IG_indexTextureHeight)) + halfPixel;\n" +
					"			vec2 IG_index = texture2D( IG_indexTexture, IG_texCoord ).rg;\n" + 
					"			IG_texCoord = IG_index * 0.996108948;\n" +
					"		} else {\n" +
					"			vec2 halfPixel = vec2(0.5/IG_coordTextureWidth, 0.5/IG_coordTextureHeight);\n" +
					"			IG_texCoord = vec2(position.x*(IG_implicitMeshSize.x/IG_coordTextureWidth), position.y*(IG_implicitMeshSize.y/IG_coordTextureHeight)) + halfPixel;\n" +
					"		}\n" +
					"		pos = texture2D( IG_coordinateTexture, IG_texCoord ).rgb;\n" +
					"	 	pos = pos * (IG_bboxMax - IG_bboxMin) + IG_bboxMin;\n" +
                    "	} \n" +

                    popDecoder +
                    "   {\n" +
					"		pos = bgCenter + bgSize * pos / bgPrecisionMax;\n" +
					"	}\n" +
                    "	worldCoord = (modelMatrix * vec4(pos, 1.0)).xyz - from;\n" +
                    "	gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);\n" +
					"}\n";
    }
    else {
        shader =    "attribute vec3 position;\n" +
                    "attribute vec2 texcoord;\n" +
                    "uniform vec3 bgCenter;\n" +
                    "uniform vec3 bgSize;\n" +
                    "uniform float bgPrecisionMax;\n" +
					"uniform float writeShadowIDs;\n" +
                    "uniform mat4 modelMatrix;\n" +
                    "uniform mat4 modelViewProjectionMatrix;\n" +
                    "uniform vec3 from;\n" +
                    "varying vec3 worldCoord;\n" +
                    "varying vec2 idCoord;\n" +
                    //pop geometry
                    popUniforms +
                    
                    "void main(void) {\n" +
                    "    gl_PointSize = 2.0;\n" +
                    "    vec3 pos = position;\n" +
					"    if (writeShadowIDs > 0.0) {\n" +
					"	    idCoord = vec2((texcoord.x + writeShadowIDs) / 256.0);\n" +
    				"       idCoord.x = floor(idCoord.x) / 255.0;\n" +
    				"       idCoord.y = fract(idCoord.y) * 1.00392156862745;\n" +
					"	 }\n" +

                    popDecoder +
                    "	 {\n" +
                    "       pos = bgCenter + bgSize * pos / bgPrecisionMax;\n" +
                    "	 }\n" +
                    "    worldCoord = (modelMatrix * vec4(pos, 1.0)).xyz - from;\n" +
                    "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);\n" +
                    "}\n";
    }

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[PickingShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.PickingShader.prototype.generateFragmentShader = function(gl)
{
    var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
    shader +=    " precision highp float;\n";
    shader +=    "#else\n";
    shader +=    " precision mediump float;\n";
    shader +=    "#endif\n\n";

    shader +=   "uniform float writeShadowIDs;\n" +
                "uniform float highBit;\n" +
                "uniform float lowBit;\n" +
                "uniform float sceneSize;\n" +
                "varying vec3 worldCoord;\n" +
                "varying vec2 idCoord;\n" +

                "void main(void) {\n" +
                "    vec4 col = vec4(0.0, 0.0, highBit, lowBit);\n" +
                "    if (writeShadowIDs > 0.0) {\n" +
                "       col.ba = idCoord;\n" +
                "	 }\n" +
                "    float d = length(worldCoord) / sceneSize;\n" +
                "    vec2 comp = fract(d * vec2(256.0, 1.0));\n" +
                "    col.rg = comp - (comp.rr * vec2(0.0, 1.0/256.0));\n" +
                "    gl_FragColor = col;\n" +
                "}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        x3dom.debug.logError("[PickingShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));
    }

    return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final Shader program
 */
x3dom.shader.Picking24Shader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader   = this.generateVertexShader(gl);
	var fragmentShader = this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.Picking24Shader.prototype.generateVertexShader = function(gl)
{
	var shader = "";

    if (!x3dom.caps.MOBILE) {
        shader =    "attribute vec3 position;\n" +
                    "attribute vec2 texcoord;\n" +
					"uniform vec3 bgCenter;\n" +
					"uniform vec3 bgSize;\n" +
					"uniform float bgPrecisionMax;\n" +
					"uniform mat4 modelMatrix;\n" +
					"uniform mat4 modelViewProjectionMatrix;\n" +
					"uniform vec3 from;\n" +
					"varying vec3 worldCoord;\n" +
					"varying vec3 idCoord;\n" +
					"uniform float writeShadowIDs;\n" +
					"uniform float imageGeometry;\n" +
					"uniform vec3 IG_bboxMin;\n" +
					"uniform vec3 IG_bboxMax;\n" +
					"uniform float IG_coordTextureWidth;\n" +
					"uniform float IG_coordTextureHeight;\n" +
					"uniform float IG_indexTextureWidth;\n" +
					"uniform float IG_indexTextureHeight;\n" +
					"uniform sampler2D IG_indexTexture;\n" +
					"uniform sampler2D IG_coordinateTexture;\n" +
					"uniform vec2 IG_implicitMeshSize;\n" +
					
					"void main(void) {\n" +
                    "   gl_PointSize = 2.0;\n" +
					"   if (writeShadowIDs > 0.0) {\n" +
                    //      composed id is at least 32 (= 2*16) bit + num bits for max-orig-shape-id
                    "       float ID = (texcoord.y * 65536.0 + texcoord.x) + writeShadowIDs;\n" +
                    //      however, let's ignore this and assume a maximum of 24 bits for all id's
                    "       float h = floor(ID / 256.0);\n" +
                    "       idCoord.x = ID - (h * 256.0);\n" +
                    "       idCoord.z = floor(h / 256.0);\n" +
                    "       idCoord.y = h - (idCoord.z * 256.0);\n" +
                    "       idCoord = idCoord.zyx / 255.0;\n" +
					"	}\n" +
					"	if (imageGeometry != 0.0) {\n" +
					"		vec2 IG_texCoord;\n" +
					"		if(imageGeometry == 1.0) {\n" +
					"			vec2 halfPixel = vec2(0.5/IG_indexTextureWidth,0.5/IG_indexTextureHeight);\n" +
					"			IG_texCoord = vec2(position.x*(IG_implicitMeshSize.x/IG_indexTextureWidth), position.y*(IG_implicitMeshSize.y/IG_indexTextureHeight)) + halfPixel;\n" +
					"			vec2 IG_index = texture2D( IG_indexTexture, IG_texCoord ).rg;\n" + 
					"			IG_texCoord = IG_index * 0.996108948;\n" +
					"		} else {\n" +
					"			vec2 halfPixel = vec2(0.5/IG_coordTextureWidth, 0.5/IG_coordTextureHeight);\n" +
					"			IG_texCoord = vec2(position.x*(IG_implicitMeshSize.x/IG_coordTextureWidth), position.y*(IG_implicitMeshSize.y/IG_coordTextureHeight)) + halfPixel;\n" +
					"		}\n" +
					"		vec3 pos = texture2D( IG_coordinateTexture, IG_texCoord ).rgb;\n" +
					"	 	pos = pos * (IG_bboxMax - IG_bboxMin) + IG_bboxMin;\n" +
					"    	worldCoord = (modelMatrix * vec4(pos, 1.0)).xyz - from;\n" +
					"		gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);\n" +
					"	} else {\n" +
					"		vec3 pos = bgCenter + bgSize * position / bgPrecisionMax;\n" +
					"		worldCoord = (modelMatrix * vec4(pos, 1.0)).xyz - from;\n" +
					"		gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);\n" +
					"	}\n" +
					"}\n";
    }
    else {
        shader =    "attribute vec3 position;\n" +
                    "attribute vec2 texcoord;\n" +
                    "uniform vec3 bgCenter;\n" +
                    "uniform vec3 bgSize;\n" +
                    "uniform float bgPrecisionMax;\n" +
					"uniform float writeShadowIDs;\n" +
                    "uniform mat4 modelMatrix;\n" +
                    "uniform mat4 modelViewProjectionMatrix;\n" +
                    "uniform vec3 from;\n" +
                    "varying vec3 worldCoord;\n" +
                    "varying vec3 idCoord;\n" +
                    
                    "void main(void) {\n" +
                    "    gl_PointSize = 2.0;\n" +
                    "    if (writeShadowIDs > 0.0) {\n" +
                    //      composed id is at least 32 (= 2*16) bit + num bits for max-orig-shape-id
                    "       float ID = (texcoord.y * 65536.0 + texcoord.x) + writeShadowIDs;\n" +
                    //      however, let's ignore this and assume a maximum of 24 bits for all id's
                    "       float h = floor(ID / 256.0);\n" +
                    "       idCoord.x = ID - (h * 256.0);\n" +
                    "       idCoord.z = floor(h / 256.0);\n" +
                    "       idCoord.y = h - (idCoord.z * 256.0);\n" +
                    "       idCoord = idCoord.zyx / 255.0;\n" +
                    "	 }\n" +
                    "    vec3 pos = bgCenter + bgSize * position / bgPrecisionMax;\n" +
                    "    worldCoord = (modelMatrix * vec4(pos, 1.0)).xyz - from;\n" +
                    "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);\n" +
                    "}\n";
    }

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[Picking24Shader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.Picking24Shader.prototype.generateFragmentShader = function(gl)
{
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";

	shader += "uniform float writeShadowIDs;\n" +
					"uniform float highBit;\n" +
					"uniform float lowBit;\n" +
					"uniform float sceneSize;\n" +
					"varying vec3 worldCoord;\n" +
					"varying vec3 idCoord;\n" +
					
					"void main(void) {\n" +
					"    vec4 col = vec4(0.0, 0.0, highBit, lowBit);\n" +
					"    if (writeShadowIDs > 0.0) {\n" +
    				"       col.gba = idCoord;\n" +
					"	 }\n" +
					"    col.r = length(worldCoord) / sceneSize;\n" +
					"    gl_FragColor = col;\n" +
					"}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[Picking24Shader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final Shader program
 */
x3dom.shader.PickingIdShader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader   = this.generateVertexShader(gl);
	var fragmentShader = this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.PickingIdShader.prototype.generateVertexShader = function(gl)
{
	var shader =    "attribute vec3 position;\n" +
                    "attribute vec2 texcoord;\n" +
                    "uniform vec3 bgCenter;\n" +
                    "uniform vec3 bgSize;\n" +
                    "uniform float bgPrecisionMax;\n" +
					"uniform float writeShadowIDs;\n" +
                    "uniform mat4 modelMatrix;\n" +
                    "uniform mat4 modelViewProjectionMatrix;\n" +
                    "varying vec2 idCoord;\n" +
                    
                    "void main(void) {\n" +
					"    if (writeShadowIDs > 0.0) {\n" +
					"	    idCoord = vec2((texcoord.x + writeShadowIDs) / 256.0);\n" +
    				"       idCoord.x = floor(idCoord.x) / 255.0;\n" +
    				"       idCoord.y = fract(idCoord.y) * 1.00392156862745;\n" +
					"	 }\n" +
                    "    vec3 pos = bgCenter + bgSize * position / bgPrecisionMax;\n" +
                    "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);\n" +
                    "}\n";

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[PickingIdShader] VertexShader " + gl.getShaderInfoLog(vertexShader));
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.PickingIdShader.prototype.generateFragmentShader = function(gl)
{
    var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
    shader    += " precision highp float;\n";
    shader    += "#else\n";
    shader    += " precision mediump float;\n";
    shader    += "#endif\n\n";

    shader   += "uniform float writeShadowIDs;\n" +
                "uniform float highBit;\n" +
                "uniform float lowBit;\n" +
                "varying vec2 idCoord;\n" +

                "void main(void) {\n" +
                "    vec4 col = vec4(highBit, lowBit, 0.0, 0.0);\n" +
                "    if (writeShadowIDs > 0.0) {\n" +
                "       col.ba = idCoord;\n" +
                "	 }\n" +
                "    gl_FragColor = col;\n" +
                "}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[PickingIdShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final Shader program
 */
x3dom.shader.PickingColorShader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader 	= this.generateVertexShader(gl);
	var fragmentShader 	= this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.PickingColorShader.prototype.generateVertexShader = function(gl)
{
	var shader = 	"attribute vec3 position;\n" +
					"attribute vec3 color;\n" +
					"varying vec3 fragColor;\n" +
					"uniform mat4 modelViewProjectionMatrix;\n" +
					"\n" +
					"void main(void) {\n" +
					"    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);\n" +
					"    gl_PointSize = 2.0;\n" + 
					"    fragColor = color;\n" +
					"}\n";

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[PickingColorShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.PickingColorShader.prototype.generateFragmentShader = function(gl)
{
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";

	shader += "uniform float lowBit;\n" +
					"varying vec3 fragColor;\n" +
					"\n" +
					"void main(void) {\n" +
					"    gl_FragColor = vec4(fragColor, lowBit);\n" +
					"}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[PickingColorShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final Shader program
 */
x3dom.shader.PickingTexcoordShader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader 	= this.generateVertexShader(gl);
	var fragmentShader 	= this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.PickingTexcoordShader.prototype.generateVertexShader = function(gl)
{
	var shader = 	"attribute vec3 position;\n" +
					"attribute vec2 texcoord;\n" +
					"varying vec3 fragColor;\n" +
					"uniform mat4 modelViewProjectionMatrix;\n" +
					"" +
					"void main(void) {\n" +
					"    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);\n" +
					"    fragColor = vec3(abs(texcoord.x), abs(texcoord.y), 0.0);\n" +
					"}\n";

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[PickingTexcoordShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.PickingTexcoordShader.prototype.generateFragmentShader = function(gl)
{
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";

	shader += "uniform float lowBit;\n" +
					"varying vec3 fragColor;\n" +
					"\n" +
					"void main(void) {\n" +
					"    gl_FragColor = vec4(fragColor, lowBit);\n" +
					"}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[PickingTexcoordShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final ShadowShader program
 */
x3dom.shader.FrontgroundTextureShader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader 	= this.generateVertexShader(gl);
	var fragmentShader 	= this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.FrontgroundTextureShader.prototype.generateVertexShader = function(gl)
{
	var shader = 	"attribute vec3 position;\n" +
					"varying vec2 fragTexCoord;\n" +
					"\n" +
					"void main(void) {\n" +
					"    vec2 texCoord = (position.xy + 1.0) * 0.5;\n" +
					"    fragTexCoord = texCoord;\n" +
					"    gl_Position = vec4(position.xy, 0.0, 1.0);\n" +
					"}\n";

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[FrontgroundTextureShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.FrontgroundTextureShader.prototype.generateFragmentShader = function(gl)
{
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";

	shader += "uniform sampler2D tex;\n" +
				"varying vec2 fragTexCoord;\n" +
				"\n" +
				"void main(void) {\n" +
				"    vec4 col = texture2D(tex, fragTexCoord);\n" +
				"    gl_FragColor = vec4(col.rgb, 1.0);\n" +
				"}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[FrontgroundTextureShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};


/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final ShadowShader program
 */
x3dom.shader.BackgroundTextureShader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader 	= this.generateVertexShader(gl);
	var fragmentShader 	= this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.BackgroundTextureShader.prototype.generateVertexShader = function(gl)
{
	var shader = 	"attribute vec3 position;\n" +
					"varying vec2 fragTexCoord;\n" +
					"\n" +
					"void main(void) {\n" +
					"    vec2 texCoord = (position.xy + 1.0) * 0.5;\n" +
					"    fragTexCoord = texCoord;\n" +
					"    gl_Position = vec4(position.xy, 0.0, 1.0);\n" +
					"}\n";

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[BackgroundTextureShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.BackgroundTextureShader.prototype.generateFragmentShader = function(gl)
{
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";

	shader += "uniform sampler2D tex;\n" +
				"varying vec2 fragTexCoord;\n" +
				"\n" +
				"void main(void) {\n" +
				"    gl_FragColor = texture2D(tex, fragTexCoord);\n" +
				"}";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[BackgroundTextureShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};


/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final ShadowShader program
 */
x3dom.shader.BackgroundSkyTextureShader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader 	= this.generateVertexShader(gl);
	var fragmentShader 	= this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.BackgroundSkyTextureShader.prototype.generateVertexShader = function(gl)
{
	var shader = 	"attribute vec3 position;\n" +
					"attribute vec2 texcoord;\n" +
					"uniform mat4 modelViewProjectionMatrix;\n" +
					"varying vec2 fragTexCoord;\n" +
					"\n" +
					"void main(void) {\n" +
					"    fragTexCoord = texcoord;\n" +
					"    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);\n" +
					"}\n";

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[BackgroundSkyTextureShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.BackgroundSkyTextureShader.prototype.generateFragmentShader = function(gl)
{
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";

	shader += "uniform sampler2D tex;\n" +
				"varying vec2 fragTexCoord;\n" +
				"\n" +
				"void main(void) {\n" +
				"    gl_FragColor = texture2D(tex, fragTexCoord);\n" +
				"}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[BackgroundSkyTextureShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final ShadowShader program
 */
x3dom.shader.BackgroundCubeTextureShader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader 	= this.generateVertexShader(gl);
	var fragmentShader 	= this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.BackgroundCubeTextureShader.prototype.generateVertexShader = function(gl)
{
	var shader = 	"attribute vec3 position;\n" +
					"uniform mat4 modelViewProjectionMatrix;\n" +
					"varying vec3 fragNormal;\n" +
					"\n" +
					"void main(void) {\n" +
					"    fragNormal = normalize(position);\n" +
					"    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);\n" +
					"}\n";

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[BackgroundCubeTextureShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.BackgroundCubeTextureShader.prototype.generateFragmentShader = function(gl)
{
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";

	shader +=	"uniform samplerCube tex;\n" +
				"varying vec3 fragNormal;\n" +
				"\n" +
				"float magn(float val) {\n" +
				"    return ((val >= 0.0) ? val : -1.0 * val);\n" +
				"}" +
				"\n" +
				"void main(void) {\n" +
				"    vec3 normal = -reflect(normalize(fragNormal), vec3(0.0,0.0,1.0));\n" +
				"    if (magn(normal.y) >= magn(normal.x) && magn(normal.y) >= magn(normal.z))\n" +
				"        normal.xz = -normal.xz;\n" +
				"    gl_FragColor = textureCube(tex, normal);\n" +
				"}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[BackgroundCubeTextureShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final ShadowShader program
 */
x3dom.shader.ShadowShader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader 	= this.generateVertexShader(gl);
	var fragmentShader 	= this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.ShadowShader.prototype.generateVertexShader = function(gl)
{
	var shader = "";
	if (!x3dom.caps.MOBILE) {
	
		shader +=   "attribute vec3 position;\n" +
					"uniform mat4 modelViewProjectionMatrix;\n" +
					"varying vec4 projCoords;\n" +
					//bitLOD 
					"uniform vec3 bgCenter;\n" +
					"uniform vec3 bgSize;\n" +
					"uniform float bgPrecisionMax;\n" +
					//image geometry 
					"uniform float imageGeometry;\n" +
					"uniform vec3 IG_bboxMin;\n" +
					"uniform vec3 IG_bboxMax;\n" +
					"uniform float IG_coordTextureWidth;\n" +
					"uniform float IG_coordTextureHeight;\n" +
					"uniform float IG_indexTextureWidth;\n" +
					"uniform float IG_indexTextureHeight;\n" +
					"uniform sampler2D IG_indexTexture;\n" +
					"uniform sampler2D IG_coordinateTexture;\n" +
					"uniform vec2 IG_implicitMeshSize;\n" +
                    //pop geometry
                    "uniform float popGeometry;\n" +
                    "uniform float PG_precisionLevel;\n" +
                    "uniform float PG_powPrecision;\n" +
                    "uniform vec3 PG_maxBBSize;\n" +
                    "uniform vec3 PG_bbMin;\n" +
                    "uniform vec3 PG_bbMaxModF;\n" +
                    "uniform vec3 PG_bboxShiftVec;\n" +

					//MAIN
					"void main(void) {\n" +
					"	vec3 pos;\n" +
					"	if (imageGeometry != 0.0) {\n" +
						//IG
					"		vec2 IG_texCoord;\n" +
					"		if(imageGeometry == 1.0) {\n" +
					"			vec2 halfPixel = vec2(0.5/IG_indexTextureWidth,0.5/IG_indexTextureHeight);\n" +
					"			IG_texCoord = vec2(position.x*(IG_implicitMeshSize.x/IG_indexTextureWidth), position.y*(IG_implicitMeshSize.y/IG_indexTextureHeight)) + halfPixel;\n" +
					"			vec2 IG_index = texture2D( IG_indexTexture, IG_texCoord ).rg;\n" + 
					"			IG_texCoord = IG_index * 0.996108948;\n" +
					"		} else {\n" +
					"			vec2 halfPixel = vec2(0.5/IG_coordTextureWidth, 0.5/IG_coordTextureHeight);\n" +
					"			IG_texCoord = vec2(position.x*(IG_implicitMeshSize.x/IG_coordTextureWidth), position.y*(IG_implicitMeshSize.y/IG_coordTextureHeight)) + halfPixel;\n" +
					"		}\n" +
					"		pos = texture2D( IG_coordinateTexture, IG_texCoord ).rgb;\n" +
					"	 	pos = pos * (IG_bboxMax - IG_bboxMin) + IG_bboxMin;\n" +
					"	} else if (popGeometry != 0.0){\n" +
						//PG
                    "		pos = position;\n" +
                    "		vec3 offsetVec = step(pos / bgPrecisionMax, PG_bbMaxModF) * PG_bboxShiftVec;\n" +
                    "		if (PG_precisionLevel <= 2.0) {\n" +
                    "   		pos = floor(pos / PG_powPrecision) * PG_powPrecision;\n" +
                    "   		pos /= (65536.0 - PG_powPrecision);\n" +
                    "		}\n" +
                    "		else {\n" +
                    "   		pos /= bgPrecisionMax;\n" +
                    "		}\n" +
                    "		pos = (pos + offsetVec + PG_bbMin) * PG_maxBBSize;\n" +
					"	} else {\n" +
						//BG
					"		pos = bgCenter + bgSize * position / bgPrecisionMax;\n" +
					"	}\n" +
					"   projCoords = modelViewProjectionMatrix * vec4(pos, 1.0);\n" +
					"   gl_Position = projCoords;\n" +
					"}\n";
	} else {
		shader = 	"attribute vec3 position;\n" +
                    "uniform vec3 bgCenter;\n" +
                    "uniform vec3 bgSize;\n" +
                    "uniform float bgPrecisionMax;\n" +
                    "uniform mat4 modelViewProjectionMatrix;\n" +
					"varying vec4 projCoords;\n" +
                    
                    "void main(void) {\n" +
                    "	vec3 pos = bgCenter + bgSize * position / bgPrecisionMax;\n" +
					"	projCoords = modelViewProjectionMatrix * vec4(pos, 1.0);\n" +					
                    "	gl_Position = projCoords;\n" +
                    "}\n";
	}

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[ShadowShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.ShadowShader.prototype.generateFragmentShader = function(gl)
{
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";

	shader += "varying vec4 projCoords;\n" +
				"uniform float offset;\n" +
				"uniform bool cameraView;\n";
	if(!x3dom.caps.FP_TEXTURES || x3dom.caps.MOBILE) 
		shader += 	x3dom.shader.rgbaPacking();
	
	shader +=	"void main(void) {\n" +
				"    vec3 proj = (projCoords.xyz / projCoords.w);\n";

 	if(!x3dom.caps.FP_TEXTURES || x3dom.caps.MOBILE) {
		shader +=	"gl_FragColor = packDepth(proj.z);\n";
	} else {
		//use variance shadow maps, when not rendering from camera view
		//shader +=	"if (!cameraView) proj.z = exp((1.0-offset)*80.0*proj.z);\n";
		shader +=	"	if (!cameraView){\n" +
					"		proj.z = (proj.z + 1.0)*0.5;\n" +
					"		proj.y = proj.z * proj.z;\n" +
					"	}\n";
		shader +=	"	gl_FragColor = vec4(proj, 1.0);\n";
	}
	shader +=	"}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[ShadowShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final Shader program
 */
x3dom.shader.ShadowRenderingShader = function(gl,shadowedLights)
{
	this.program = gl.createProgram();
	var vertexShader 	= this.generateVertexShader(gl);
	var fragmentShader 	= this.generateFragmentShader(gl,shadowedLights);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.ShadowRenderingShader.prototype.generateVertexShader = function(gl)
{
	var shader = "";
	shader += "attribute vec2 position;\n";

	shader += "varying vec2 vPosition;\n";
	
	shader += "void main(void) {\n";
	shader += " vPosition = position;\n";
	shader += " gl_Position = vec4(position, -1.0, 1.0);\n";
	shader += "}\n";
	
	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[ShadowRendering] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.ShadowRenderingShader.prototype.generateFragmentShader = function(gl,shadowedLights)
{
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";

	shader += "uniform mat4 inverseViewProj;\n";
	shader += "uniform mat4 inverseProj;\n";
	shader += "varying vec2 vPosition;\n";
	shader += "uniform sampler2D sceneMap;\n";  
	for (var i=0; i<5; i++)
		shader += "uniform float cascade"+i+"_Depth;\n";
	
	
	for(var l=0; l<shadowedLights.length; l++) {
	shader +=	"uniform float light"+l+"_On;\n" +
				"uniform float light"+l+"_Type;\n" +
				"uniform vec3  light"+l+"_Location;\n" +
				"uniform vec3  light"+l+"_Direction;\n" +
				"uniform vec3  light"+l+"_Attenuation;\n" +
				"uniform float light"+l+"_Radius;\n" +
				"uniform float light"+l+"_BeamWidth;\n" +
				"uniform float light"+l+"_CutOffAngle;\n" +
				"uniform float light"+l+"_ShadowIntensity;\n" +
				"uniform float light"+l+"_ShadowOffset;\n" +
				"uniform mat4 light"+l+"_ViewMatrix;\n";
		for (var j=0; j<6; j++){
			shader += "uniform mat4 light"+l+"_"+j+"_Matrix;\n";
			shader += "uniform sampler2D light"+l+"_"+j+"_ShadowMap;\n"; 
		}
		for (var j=0; j<5; j++)
			shader += "uniform float light"+l+"_"+j+"_Split;\n"; 

		
	}
	if (!x3dom.caps.FP_TEXTURES || x3dom.caps.MOBILE) 
		shader += 	x3dom.shader.rgbaPacking();				
	
	shader += x3dom.shader.shadowRendering();
    
    shader += x3dom.shader.gammaCorrectionDecl({});  //TODO shader properties?
	
	shader += 	"void main(void) {\n" +
				"	float shadowValue = 1.0;\n" +
				"	vec2 texCoordsSceneMap = (vPosition + 1.0)*0.5;\n" +
				"	vec4 projCoords = texture2D(sceneMap, texCoordsSceneMap);\n" +
				"	if (projCoords != vec4(1.0,1.0,1.0,0.0)){\n";
	if (!x3dom.caps.FP_TEXTURES || x3dom.caps.MOBILE){ 
		shader += 	"	projCoords.z = unpackDepth(projCoords);\n" +
					"	projCoords.w = 1.0;\n";
	}
	
	//reconstruct world and view coordinates from scene map
	shader += 	"	projCoords = projCoords / projCoords.w;\n" +
				"	projCoords.xy = vPosition;\n" +
				"	vec4 eyeCoords = inverseProj*projCoords;\n" +
				"	vec4 worldCoords = inverseViewProj*projCoords;\n" +
				"	float lightInfluence = 0.0;\n";
	
	for(var l=0; l<shadowedLights.length; l++) {
		shader += 
				"	lightInfluence = getLightInfluence(light"+l+"_Type, light"+l+"_ShadowIntensity, light"+l+"_On, light"+l+"_Location, light"+l+"_Direction, " +
						"light"+l+"_CutOffAngle, light"+l+"_BeamWidth, light"+l+"_Attenuation, light"+l+"_Radius, eyeCoords.xyz/eyeCoords.w);\n" +
				"	if (lightInfluence != 0.0){\n" +
				"		vec4 shadowMapValues;\n" +
				"		float viewSampleDepth;\n";
				

		if (!x3dom.isa(shadowedLights[l], x3dom.nodeTypes.PointLight)){
			shader += "		getShadowValuesCascaded(shadowMapValues, viewSampleDepth, worldCoords, -eyeCoords.z/eyeCoords.w,"+
								"light"+l+"_0_Matrix,light"+l+"_1_Matrix,light"+l+"_2_Matrix,light"+l+"_3_Matrix,light"+l+"_4_Matrix,light"+l+"_5_Matrix,"+
								"light"+l+"_0_ShadowMap,light"+l+"_1_ShadowMap,light"+l+"_2_ShadowMap,light"+l+"_3_ShadowMap,"+
								"light"+l+"_4_ShadowMap,light"+l+"_5_ShadowMap, light"+l+"_0_Split, light"+l+"_1_Split, light"+l+"_2_Split, light"+l+"_3_Split, \n"+
								"light"+l+"_4_Split);\n";
		} else {
			shader += "		getShadowValuesPointLight(shadowMapValues, viewSampleDepth, light"+l+"_Location, worldCoords, light"+l+"_ViewMatrix, "+
								"light"+l+"_0_Matrix,light"+l+"_1_Matrix,light"+l+"_2_Matrix,light"+l+"_3_Matrix,light"+l+"_4_Matrix,light"+l+"_5_Matrix,"+
								"light"+l+"_0_ShadowMap,light"+l+"_1_ShadowMap,light"+l+"_2_ShadowMap,light"+l+"_3_ShadowMap,"+
								"light"+l+"_4_ShadowMap,light"+l+"_5_ShadowMap);\n";
		}		
	
		if (!x3dom.caps.FP_TEXTURES || x3dom.caps.MOBILE)	
			shader += 	"	shadowValue *= clamp(ESM(shadowMapValues.z, viewSampleDepth, light"+l+"_ShadowOffset), "+
						"				1.0 - light"+l+"_ShadowIntensity*lightInfluence, 1.0);\n";
		else
			shader += 	" 	shadowValue *= clamp(VSM(shadowMapValues.zy, viewSampleDepth, light"+l+"_ShadowOffset), "+
						"				1.0 - light"+l+"_ShadowIntensity*lightInfluence, 1.0);\n";				
		shader += 		"	}\n";
		
	}
					
	shader += 	"}\n" + 
                // In principle we should fix the place where this is multplied in instead
                // of overcompensating for the subsequent error from here. This way of doing
                // gamma correction explots the rule that (a*b)^x = a^x * b^x (x being the
                // gamma coefficient), i.e. the umbra is corrected for now, the penumbra
                // is incorrect and full light is zero here so unaffected as well.
				"	gl_FragColor = " + x3dom.shader.encodeGamma({}, "vec4(shadowValue, shadowValue, shadowValue, 1.0)") + ";\n" +
				"}\n";

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[ShadowRendering] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/**
 * Generate the final BlurShader program 
 * (gaussian blur for 3x3, 5x5 and 7x7 kernels)
 */
x3dom.shader.BlurShader = function(gl)
{
	this.program = gl.createProgram();
	
	var vertexShader 	= this.generateVertexShader(gl);
	var fragmentShader 	= this.generateFragmentShader(gl);
	
	gl.attachShader(this.program, vertexShader);
    gl.attachShader(this.program, fragmentShader);
    
    // optional, but position should be at location 0 for performance reasons
    gl.bindAttribLocation(this.program, 0, "position");
    
	gl.linkProgram(this.program);
	
	return this.program;
};

/**
 * Generate the vertex shader
 */
x3dom.shader.BlurShader.prototype.generateVertexShader = function(gl)
{
	var shader = "";
	shader += "attribute vec2 position;\n";

	shader += "varying vec2 vPosition;\n";
	
	shader += "void main(void) {\n";
	shader += " vPosition = position;\n";
	shader += " gl_Position = vec4(position, -1.0, 1.0);\n";
	shader += "}\n";

	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, shader);
    gl.compileShader(vertexShader);
		
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[BlurShader] VertexShader " + gl.getShaderInfoLog(vertexShader));		
	}
	
	return vertexShader;
};

/**
 * Generate the fragment shader
 */
x3dom.shader.BlurShader.prototype.generateFragmentShader = function(gl)
{
  var shader = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
  shader += "precision highp float;\n";
  shader += "#else\n";
  shader += " precision mediump float;\n";
  shader += "#endif\n\n";

	shader += "varying vec2 vPosition;\n" +
					"uniform sampler2D texture;\n" +
					"uniform bool horizontal;\n" +
					"uniform float pixelSizeHor;\n" +
					"uniform float pixelSizeVert;\n" +
					"uniform int filterSize;\n";

	if (!x3dom.caps.FP_TEXTURES || x3dom.caps.MOBILE){
	shader +=		x3dom.shader.rgbaPacking() +
	
					"void main(void) {\n" +
					"	vec2 texCoords = (vPosition + 1.0)*0.5;\n" +
					"	vec2 offset;\n" +
					"	if (horizontal) offset = vec2(pixelSizeHor, 0.0);\n" +
					"	else offset = vec2(0.0, pixelSizeVert);\n" +
					"	float depth = unpackDepth(texture2D(texture, texCoords));\n" +
					"	if (filterSize == 3){\n" +		
					"		depth = depth * 0.3844;\n" +
					"		depth += 0.3078*unpackDepth(texture2D(texture, texCoords-offset));\n" +
					"		depth += 0.3078*unpackDepth(texture2D(texture, texCoords+offset));\n" +
					"	} else if (filterSize == 5){\n" +	
					"		depth = depth * 0.2921;\n" +
					"		depth += 0.2339*unpackDepth(texture2D(texture, texCoords-offset));\n" +
					"		depth += 0.2339*unpackDepth(texture2D(texture, texCoords+offset));\n" +	
					"		depth += 0.1201*unpackDepth(texture2D(texture, texCoords-2.0*offset));\n" +
					"		depth += 0.1201*unpackDepth(texture2D(texture, texCoords+2.0*offset));\n" +
					"	} else if (filterSize == 7){\n" +	
					"		depth = depth * 0.2161;\n" +
					"		depth += 0.1907*unpackDepth(texture2D(texture, texCoords-offset));\n" +
					"		depth += 0.1907*unpackDepth(texture2D(texture, texCoords+offset));\n" +	
					"		depth += 0.1311*unpackDepth(texture2D(texture, texCoords-2.0*offset));\n" +
					"		depth += 0.1311*unpackDepth(texture2D(texture, texCoords+2.0*offset));\n" +
					"		depth += 0.0702*unpackDepth(texture2D(texture, texCoords-3.0*offset));\n" +
					"		depth += 0.0702*unpackDepth(texture2D(texture, texCoords+3.0*offset));\n" +					
					"	}\n" + 
					"	gl_FragColor = packDepth(depth);\n" + 
					"}\n";
	} else{
	shader +=		"void main(void) {\n" +
					"	vec2 texCoords = (vPosition + 1.0)*0.5;\n" +
					"	vec2 offset;\n" +
					"	if (horizontal) offset = vec2(pixelSizeHor, 0.0);\n" +
					"	else offset = vec2(0.0, pixelSizeVert);\n" +
					"	vec4 color = texture2D(texture, texCoords);\n" +
					"	if (filterSize == 3){\n" +		
					"		color = color * 0.3844;\n" +
					"		color += 0.3078*texture2D(texture, texCoords-offset);\n" +
					"		color += 0.3078*texture2D(texture, texCoords+offset);\n" +
					"	} else if (filterSize == 5){\n" +	
					"		color = color * 0.2921;\n" +
					"		color += 0.2339*texture2D(texture, texCoords-offset);\n" +
					"		color += 0.2339*texture2D(texture, texCoords+offset);\n" +	
					"		color += 0.1201*texture2D(texture, texCoords-2.0*offset);\n" +
					"		color += 0.1201*texture2D(texture, texCoords+2.0*offset);\n" +
					"	} else if (filterSize == 7){\n" +	
					"		color = color * 0.2161;\n" +
					"		color += 0.1907*texture2D(texture, texCoords-offset);\n" +
					"		color += 0.1907*texture2D(texture, texCoords+offset);\n" +	
					"		color += 0.1311*texture2D(texture, texCoords-2.0*offset);\n" +
					"		color += 0.1311*texture2D(texture, texCoords+2.0*offset);\n" +
					"		color += 0.0702*texture2D(texture, texCoords-3.0*offset);\n" +
					"		color += 0.0702*texture2D(texture, texCoords+3.0*offset);\n" +					
					"	}\n" + 
					"	gl_FragColor = color;\n" + 
					"}\n";
	}				

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, shader);
    gl.compileShader(fragmentShader);
		
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		x3dom.debug.logError("[BlurShader] FragmentShader " + gl.getShaderInfoLog(fragmentShader));		
	}
	
	return fragmentShader;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


x3dom.gfx_webgl = (function () {

    /*****************************************************************************
     * Context constructor
     *****************************************************************************/
    function Context(ctx3d, canvas, name, x3dElem) {
        this.ctx3d = ctx3d;
        this.canvas = canvas;
        this.name = name;
        this.x3dElem = x3dElem;
        this.IG_PositionBuffer = null;
        this.cache = new x3dom.Cache();
        this.stateManager = new x3dom.StateManager(ctx3d);
        this.activeShader = null;
    }


    /*****************************************************************************
     * Return context name
     *****************************************************************************/
    Context.prototype.getName = function () {
        return this.name;
    };


    /*****************************************************************************
     * Setup the 3D context and init some things
     *****************************************************************************/
    function setupContext(canvas, forbidMobileShaders, forceMobileShaders, tryWebGL2, x3dElem) {
        var validContextNames = ['webgl', 'experimental-webgl', 'moz-webgl', 'webkit-3d'];

        if (tryWebGL2) {
            validContextNames = ['experimental-webgl2'].concat(validContextNames);
        }

        var ctx = null;
        // Context creation params
        var ctxAttribs = {
            alpha: true,
            depth: true,
            stencil: true,
            antialias: true,
            premultipliedAlpha: false,
            preserveDrawingBuffer: true
        };

        for (var i = 0; i < validContextNames.length; i++) {
            try {
                ctx = canvas.getContext(validContextNames[i], ctxAttribs);
                if (ctx) {
                    var newCtx = new Context(ctx, canvas, 'webgl', x3dElem);

                    try {
                        //Save CAPS
                        x3dom.caps.VENDOR = ctx.getParameter(ctx.VENDOR);
                        x3dom.caps.VERSION = ctx.getParameter(ctx.VERSION);
                        x3dom.caps.RENDERER = ctx.getParameter(ctx.RENDERER);
                        x3dom.caps.SHADING_LANGUAGE_VERSION = ctx.getParameter(ctx.SHADING_LANGUAGE_VERSION);
                        x3dom.caps.RED_BITS = ctx.getParameter(ctx.RED_BITS);
                        x3dom.caps.GREEN_BITS = ctx.getParameter(ctx.GREEN_BITS);
                        x3dom.caps.BLUE_BITS = ctx.getParameter(ctx.BLUE_BITS);
                        x3dom.caps.ALPHA_BITS = ctx.getParameter(ctx.ALPHA_BITS);
                        x3dom.caps.DEPTH_BITS = ctx.getParameter(ctx.DEPTH_BITS);
                        x3dom.caps.MAX_VERTEX_ATTRIBS = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
                        x3dom.caps.MAX_VERTEX_TEXTURE_IMAGE_UNITS = ctx.getParameter(ctx.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                        x3dom.caps.MAX_VARYING_VECTORS = ctx.getParameter(ctx.MAX_VARYING_VECTORS);
                        x3dom.caps.MAX_VERTEX_UNIFORM_VECTORS = ctx.getParameter(ctx.MAX_VERTEX_UNIFORM_VECTORS);
                        x3dom.caps.MAX_COMBINED_TEXTURE_IMAGE_UNITS = ctx.getParameter(ctx.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                        x3dom.caps.MAX_TEXTURE_SIZE = ctx.getParameter(ctx.MAX_TEXTURE_SIZE);
                        x3dom.caps.MAX_TEXTURE_IMAGE_UNITS = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
                        x3dom.caps.MAX_CUBE_MAP_TEXTURE_SIZE = ctx.getParameter(ctx.MAX_CUBE_MAP_TEXTURE_SIZE);
                        x3dom.caps.COMPRESSED_TEXTURE_FORMATS = ctx.getParameter(ctx.COMPRESSED_TEXTURE_FORMATS);
                        x3dom.caps.MAX_RENDERBUFFER_SIZE = ctx.getParameter(ctx.MAX_RENDERBUFFER_SIZE);
                        x3dom.caps.MAX_VIEWPORT_DIMS = ctx.getParameter(ctx.MAX_VIEWPORT_DIMS);
                        x3dom.caps.ALIASED_LINE_WIDTH_RANGE = ctx.getParameter(ctx.ALIASED_LINE_WIDTH_RANGE);
                        x3dom.caps.ALIASED_POINT_SIZE_RANGE = ctx.getParameter(ctx.ALIASED_POINT_SIZE_RANGE);
                        x3dom.caps.SAMPLES = ctx.getParameter(ctx.SAMPLES);
                        x3dom.caps.INDEX_UINT = ctx.getExtension("OES_element_index_uint");
                        x3dom.caps.FP_TEXTURES = ctx.getExtension("OES_texture_float");
                        x3dom.caps.FPL_TEXTURES = ctx.getExtension("OES_texture_float_linear");
                        x3dom.caps.STD_DERIVATIVES = ctx.getExtension("OES_standard_derivatives");
                        x3dom.caps.DRAW_BUFFERS = ctx.getExtension("WEBGL_draw_buffers");
                        x3dom.caps.EXTENSIONS = ctx.getSupportedExtensions();

                        var extString = x3dom.caps.EXTENSIONS.toString().replace(/,/g, ", ");
                        x3dom.debug.logInfo(validContextNames[i] + " context found\nVendor: " + x3dom.caps.VENDOR +
                            ", Renderer: " + x3dom.caps.RENDERER + ", " + "Version: " + x3dom.caps.VERSION + ", " +
                            "ShadingLangV.: " + x3dom.caps.SHADING_LANGUAGE_VERSION
                            + ", MSAA samples: " + x3dom.caps.SAMPLES + "\nExtensions: " + extString);

                        if (x3dom.caps.INDEX_UINT) {
                            x3dom.Utils.maxIndexableCoords = 4294967295;
                        }

                        x3dom.caps.MOBILE = (function (a) {
                            return (/android.+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|e\-|e\/|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(di|rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|xda(\-|2|g)|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
                        })(navigator.userAgent || navigator.vendor || window.opera);

                        // explicitly disable for iPad and the like
                        if (x3dom.caps.RENDERER.indexOf("PowerVR") >= 0 ||
                            navigator.appVersion.indexOf("Mobile") > -1 ||
                            // coarse guess to find out old SM 2.0 hardware (e.g. Intel):
                            x3dom.caps.MAX_VARYING_VECTORS <= 8 ||
                            x3dom.caps.MAX_VERTEX_TEXTURE_IMAGE_UNITS < 2) {
                            x3dom.caps.MOBILE = true;
                        }

                        if (x3dom.caps.MOBILE) {
                            if (forbidMobileShaders) {
                                x3dom.caps.MOBILE = false;
                                x3dom.debug.logWarning("Detected mobile graphics card! " +
                                    "But being forced to desktop shaders which might not work!");
                            }
                            else {
                                x3dom.debug.logWarning("Detected mobile graphics card! " +
                                    "Using low quality shaders without ImageGeometry support!");
                            }
                        }
                        else {
                            if (forceMobileShaders) {
                                x3dom.caps.MOBILE = true;
                                x3dom.debug.logWarning("Detected desktop graphics card! " +
                                    "But being forced to mobile shaders with lower quality!");
                            }
                        }
                    }
                    catch (ex) {
                        x3dom.debug.logWarning(
                            "Your browser probably supports an older WebGL version. " +
                            "Please try the old mobile runtime instead:\n" +
                            "http://www.x3dom.org/x3dom/src_mobile/x3dom.js");
                        newCtx = null;
                    }

                    return newCtx;
                }
            }
            catch (e) { x3dom.debug.logWarning(e); }
        }
        return null;
    }


    /*****************************************************************************
     * Setup GL objects for given shape
     *****************************************************************************/
    Context.prototype.setupShape = function (gl, drawable, viewarea) {
        var q = 0, q5;
        var textures, t;
        var vertices, positionBuffer;
        var indicesBuffer, indexArray;

        var shape = drawable.shape;
        var geoNode = shape._cf.geometry.node;

        if (shape._webgl !== undefined) {
            var needFullReInit = false;

            // TODO; do same for texcoords etc.!
            if (shape._dirty.colors === true &&
                shape._webgl.shader.color === undefined && geoNode._mesh._colors[0].length) {
                // required since otherwise shape._webgl.shader.color stays undefined
                // and thus the wrong shader will be chosen although there are colors
                needFullReInit = true;
            }

            // cleanup vertex buffer objects
            if (needFullReInit && shape._cleanupGLObjects) {
                shape._cleanupGLObjects(true, false);
            }

            //Check for dirty Textures
            if (shape._dirty.texture === true) {
                //Check for Texture add or remove
                if (shape._webgl.texture.length != shape.getTextures().length) {
                    //Delete old Textures
                    for (t = 0; t < shape._webgl.texture.length; ++t) {
                        shape._webgl.texture.pop();
                    }

                    //Generate new Textures
                    textures = shape.getTextures();

                    for (t = 0; t < textures.length; ++t) {
                        shape._webgl.texture.push(new x3dom.Texture(gl, shape._nameSpace.doc, this.cache, textures[t]));
                    }

                    //Set dirty shader
                    shape._dirty.shader = true;

                    //Set dirty texture Coordinates
                    if (shape._webgl.shader.texcoord === undefined)
                        shape._dirty.texcoords = true;
                }
                else {
                    //If someone remove and append at the same time, texture count don't change
                    //and we have to check if all nodes the same as before
                    textures = shape.getTextures();

                    for (t = 0; t < textures.length; ++t) {
                        if (textures[t] === shape._webgl.texture[t].node) {
                            //only update the texture
                            shape._webgl.texture[t].update();
                        }
                        else {
                            //Set texture to null for recreation
                            shape._webgl.texture[t].texture = null;

                            //Set new node
                            shape._webgl.texture[t].node = textures[t];

                            //Update new node
                            shape._webgl.texture[t].update();
                        }
                    }
                }
                shape._dirty.texture = false;
            }

            //Check if we need a new shader
            shape._webgl.shader = this.cache.getShaderByProperties(gl, shape, shape.getShaderProperties(viewarea));


            if (!needFullReInit && shape._webgl.binaryGeometry == 0)    // THINKABOUTME: What about PopGeo & Co.?
            {
                for (q = 0; q < shape._webgl.positions.length; q++)
                {
                    q5 = 5 * q;

                    if (shape._dirty.positions == true || shape._dirty.indexes == true) {
                        if (shape._webgl.shader.position !== undefined) {
                            shape._webgl.indexes[q] = geoNode._mesh._indices[q];

                            gl.deleteBuffer(shape._webgl.buffers[q5]);

                            indicesBuffer = gl.createBuffer();
                            shape._webgl.buffers[q5] = indicesBuffer;

                            // explicitly check first positions array for consistency
                            if (x3dom.caps.INDEX_UINT && (geoNode._mesh._positions[0].length / 3 > 65535)) {
                                indexArray = new Uint32Array(shape._webgl.indexes[q]);
                                shape._webgl.indexType = gl.UNSIGNED_INT;
                            }
                            else {
                                indexArray = new Uint16Array(shape._webgl.indexes[q]);
                                shape._webgl.indexType = gl.UNSIGNED_SHORT;
                            }

                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
                            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);

                            indexArray = null;

                            // vertex positions
                            shape._webgl.positions[q] = geoNode._mesh._positions[q];

                            // TODO; don't delete VBO but use glMapBuffer() and DYNAMIC_DRAW
                            gl.deleteBuffer(shape._webgl.buffers[q5 + 1]);

                            positionBuffer = gl.createBuffer();
                            shape._webgl.buffers[q5 + 1] = positionBuffer;

                            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shape._webgl.buffers[q5]);

                            vertices = new Float32Array(shape._webgl.positions[q]);

                            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

                            gl.vertexAttribPointer(shape._webgl.shader.position,
                                geoNode._mesh._numPosComponents,
                                shape._webgl.coordType, false,
                                shape._coordStrideOffset[0], shape._coordStrideOffset[1]);

                            vertices = null;
                        }

                        shape._dirty.positions = false;
                        shape._dirty.indexes = false;
                    }

                    if (shape._dirty.colors == true) {
                        if (shape._webgl.shader.color !== undefined) {
                            shape._webgl.colors[q] = geoNode._mesh._colors[q];

                            gl.deleteBuffer(shape._webgl.buffers[q5 + 4]);

                            colorBuffer = gl.createBuffer();
                            shape._webgl.buffers[q5 + 4] = colorBuffer;

                            colors = new Float32Array(shape._webgl.colors[q]);

                            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

                            gl.vertexAttribPointer(shape._webgl.shader.color,
                                geoNode._mesh._numColComponents,
                                shape._webgl.colorType, false,
                                shape._colorStrideOffset[0], shape._colorStrideOffset[1]);

                            colors = null;
                        }

                        shape._dirty.colors = false;
                    }

                    if (shape._dirty.normals == true) {
                        if (shape._webgl.shader.normal !== undefined) {
                            shape._webgl.normals[q] = geoNode._mesh._normals[q];

                            gl.deleteBuffer(shape._webgl.buffers[q5 + 2]);

                            normalBuffer = gl.createBuffer();
                            shape._webgl.buffers[q5 + 2] = normalBuffer;

                            normals = new Float32Array(shape._webgl.normals[q]);

                            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

                            gl.vertexAttribPointer(shape._webgl.shader.normal,
                                geoNode._mesh._numNormComponents,
                                shape._webgl.normalType, false,
                                shape._normalStrideOffset[0], shape._normalStrideOffset[1]);

                            normals = null;
                        }

                        shape._dirty.normals = false;
                    }

                    if (shape._dirty.texcoords == true) {
                        if (shape._webgl.shader.texcoord !== undefined) {
                            shape._webgl.texcoords[q] = geoNode._mesh._texCoords[q];

                            gl.deleteBuffer(shape._webgl.buffers[q5 + 3]);

                            texCoordBuffer = gl.createBuffer();
                            shape._webgl.buffers[q5 + 3] = texCoordBuffer;

                            texCoords = new Float32Array(shape._webgl.texcoords[q]);

                            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

                            gl.vertexAttribPointer(shape._webgl.shader.texCoord,
                                geoNode._mesh._numTexComponents,
                                shape._webgl.texCoordType, false,
                                shape._texCoordStrideOffset[0], shape._texCoordStrideOffset[1]);

                            texCoords = null;
                        }

                        shape._dirty.texcoords = false;
                    }
                }
            }
            else
            {
                // TODO; does not yet work with shared objects
                /*
                var spOld = shape._webgl.shader;
                if (shape._cleanupGLObjects && needFullReInit)
                    shape._cleanupGLObjects(true, false);

                // complete setup is sort of brute force, thus optimize!
                x3dom.BinaryContainerLoader.setupBinGeo(shape, spOld, gl, viewarea, this);
                shape.unsetGeoDirty();
                */
            }

            if (shape._webgl.imageGeometry != 0) {
                for (t = 0; t < shape._webgl.texture.length; ++t) {
                    shape._webgl.texture[t].updateTexture();
                }

                geoNode.unsetGeoDirty();
                shape.unsetGeoDirty();
            }

            if (!needFullReInit) {
                // we're done
                return;
            }
        }
        else if (!(x3dom.isa(geoNode, x3dom.nodeTypes.Text) ||
                   x3dom.isa(geoNode, x3dom.nodeTypes.BinaryGeometry) ||
                   x3dom.isa(geoNode, x3dom.nodeTypes.PopGeometry) ||
                   x3dom.isa(geoNode, x3dom.nodeTypes.BitLODGeometry)) &&
                  (!geoNode || geoNode._mesh._positions[0].length < 1))
        {
            if (x3dom.caps.MAX_VERTEX_TEXTURE_IMAGE_UNITS < 2 &&
                x3dom.isa(geoNode, x3dom.nodeTypes.ImageGeometry)) {
                x3dom.debug.logError("Can't render ImageGeometry nodes with only " +
                    x3dom.caps.MAX_VERTEX_TEXTURE_IMAGE_UNITS +
                    " vertex texture units. Please upgrade your GPU!");
            }
            else {
                x3dom.debug.logError("NO VALID MESH OR NO VERTEX POSITIONS SET!");
            }
            return;
        }

        // we're on init, thus reset all dirty flags
        shape.unsetDirty();

        // dynamically attach clean-up method for GL objects
        if (!shape._cleanupGLObjects)
        {
            shape._cleanupGLObjects = function (force, delGL)
            {
                // FIXME; what if complete tree is removed? Then _parentNodes.length may be greater 0.
                if (this._webgl && ((arguments.length > 0 && force) || this._parentNodes.length == 0))
                {
                    var sp = this._webgl.shader;

                    for (var q = 0; q < this._webgl.positions.length; q++) {
                        var q5 = 5 * q;

                        if (sp.position !== undefined) {
                            gl.deleteBuffer(this._webgl.buffers[q5 + 1]);
                            gl.deleteBuffer(this._webgl.buffers[q5]);
                        }

                        if (sp.normal !== undefined) {
                            gl.deleteBuffer(this._webgl.buffers[q5 + 2]);
                        }

                        if (sp.texcoord !== undefined) {
                            gl.deleteBuffer(this._webgl.buffers[q5 + 3]);
                        }

                        if (sp.color !== undefined) {
                            gl.deleteBuffer(this._webgl.buffers[q5 + 4]);
                        }
                    }

                    for (var df = 0; df < this._webgl.dynamicFields.length; df++) {
                        var attrib = this._webgl.dynamicFields[df];

                        if (sp[attrib.name] !== undefined) {
                            gl.deleteBuffer(attrib.buf);
                        }
                    }

                    if (delGL === undefined)
                        delGL = true;

                    if (delGL) {
                        delete this._webgl;

                        // be optimistic, one shape removed makes room for another one
                        x3dom.BinaryContainerLoader.outOfMemory = false;
                    }
                }
            };  // shape._cleanupGLObjects()
        }


        shape._webgl = {
            positions: geoNode._mesh._positions,
            normals: geoNode._mesh._normals,
            texcoords: geoNode._mesh._texCoords,
            colors: geoNode._mesh._colors,
            indexes: geoNode._mesh._indices,
            //indicesBuffer,positionBuffer,normalBuffer,texcBuffer,colorBuffer
            //buffers: [{},{},{},{},{}],
            indexType: gl.UNSIGNED_SHORT,
            coordType: gl.FLOAT,
            normalType: gl.FLOAT,
            texCoordType: gl.FLOAT,
            colorType: gl.FLOAT,
            texture: [],
            dirtyLighting: x3dom.Utils.checkDirtyLighting(viewarea),
            imageGeometry: 0,   // 0 := no IG,  1 := indexed IG, -1  := non-indexed IG
            binaryGeometry: 0,  // 0 := no BG,  1 := indexed BG, -1  := non-indexed BG
            popGeometry: 0,     // 0 := no PG,  1 := indexed PG, -1  := non-indexed PG
            bitLODGeometry: 0   // 0 := no BLG, 1 := indexed BLG, -1 := non-indexed BLG
        };

        //Set Textures		
        textures = shape.getTextures();
        for (t = 0; t < textures.length; ++t) {
            shape._webgl.texture.push(new x3dom.Texture(gl, shape._nameSpace.doc, this.cache, textures[t]));
        }

        //Set Shader
        //shape._webgl.shader = this.cache.getDynamicShader(gl, viewarea, shape);
        //shape._webgl.shader = this.cache.getShaderByProperties(gl, drawable.properties);
        shape._webgl.shader = this.cache.getShaderByProperties(gl, shape, shape.getShaderProperties(viewarea));

        // init vertex attribs
        var sp = shape._webgl.shader;
        var currAttribs = 0;

        shape._webgl.buffers = [];
        shape._webgl.dynamicFields = [];

        //Set Geometry Primitive Type
        if (x3dom.isa(geoNode, x3dom.nodeTypes.X3DBinaryContainerGeometryNode))
        {
            shape._webgl.primType = [];

            for (var primCnt = 0; primCnt < geoNode._vf.primType.length; ++primCnt)
            {
                shape._webgl.primType.push(x3dom.Utils.primTypeDic(gl, geoNode._vf.primType[primCnt]));
            }
        }
        else
        {
            shape._webgl.primType = x3dom.Utils.primTypeDic(gl, geoNode._mesh._primType);
        }

        // Binary container geometries need special handling
        if (x3dom.isa(geoNode, x3dom.nodeTypes.BinaryGeometry))
        {
            x3dom.BinaryContainerLoader.setupBinGeo(shape, sp, gl, viewarea, this);
        }
        else if (x3dom.isa(geoNode, x3dom.nodeTypes.PopGeometry))
        {
            x3dom.BinaryContainerLoader.setupPopGeo(shape, sp, gl, viewarea, this);
        }
        else if (x3dom.isa(geoNode, x3dom.nodeTypes.BitLODGeometry))
        {
            x3dom.BinaryContainerLoader.setupBitLODGeo(shape, sp, gl, viewarea, this);
        }
        else if (x3dom.isa(geoNode, x3dom.nodeTypes.ImageGeometry))
        {
            x3dom.BinaryContainerLoader.setupImgGeo(shape, sp, gl, viewarea, this);
        }
        else // No special BinaryMesh, but IFS or similar
        {
            for (q = 0; q < shape._webgl.positions.length; q++)
            {
                q5 = 5 * q;

                if (sp.position !== undefined) {
                    // bind indices for drawElements() call
                    indicesBuffer = gl.createBuffer();
                    shape._webgl.buffers[q5] = indicesBuffer;

                    // explicitly check first positions array for consistency
                    if (x3dom.caps.INDEX_UINT && (shape._webgl.positions[0].length / 3 > 65535)) {
                        indexArray = new Uint32Array(shape._webgl.indexes[q]);
                        shape._webgl.indexType = gl.UNSIGNED_INT;
                    }
                    else {
                        indexArray = new Uint16Array(shape._webgl.indexes[q]);
                        shape._webgl.indexType = gl.UNSIGNED_SHORT;
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);

                    indexArray = null;

                    positionBuffer = gl.createBuffer();
                    shape._webgl.buffers[q5 + 1] = positionBuffer;
                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

                    vertices = new Float32Array(shape._webgl.positions[q]);

                    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

                    gl.vertexAttribPointer(sp.position,
                        geoNode._mesh._numPosComponents,
                        shape._webgl.coordType, false,
                        shape._coordStrideOffset[0], shape._coordStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.position);

                    vertices = null;
                }
                if (sp.normal !== undefined || shape._webgl.normals[q]) {
                    var normalBuffer = gl.createBuffer();
                    shape._webgl.buffers[q5 + 2] = normalBuffer;

                    var normals = new Float32Array(shape._webgl.normals[q]);

                    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

                    gl.vertexAttribPointer(sp.normal,
                        geoNode._mesh._numNormComponents,
                        shape._webgl.normalType, false,
                        shape._normalStrideOffset[0], shape._normalStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.normal);

                    normals = null;
                }
                if (sp.texcoord !== undefined) {
                    var texcBuffer = gl.createBuffer();
                    shape._webgl.buffers[q5 + 3] = texcBuffer;

                    var texCoords = new Float32Array(shape._webgl.texcoords[q]);

                    gl.bindBuffer(gl.ARRAY_BUFFER, texcBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

                    gl.vertexAttribPointer(sp.texcoord,
                        geoNode._mesh._numTexComponents,
                        shape._webgl.texCoordType, false,
                        shape._texCoordStrideOffset[0], shape._texCoordStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.texcoord);

                    texCoords = null;
                }
                if (sp.color !== undefined) {
                    var colorBuffer = gl.createBuffer();
                    shape._webgl.buffers[q5 + 4] = colorBuffer;

                    var colors = new Float32Array(shape._webgl.colors[q]);

                    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

                    gl.vertexAttribPointer(sp.color,
                        geoNode._mesh._numColComponents,
                        shape._webgl.colorType, false,
                        shape._colorStrideOffset[0], shape._colorStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.color);

                    colors = null;
                }
            }

            // TODO; FIXME; handle geometry with split mesh that has dynamic fields!
            for (var df in geoNode._mesh._dynamicFields)
            {
                if (!geoNode._mesh._dynamicFields.hasOwnProperty(df))
                    continue;

                var attrib = geoNode._mesh._dynamicFields[df];

                shape._webgl.dynamicFields[currAttribs] = {
                    buf: {}, name: df, numComponents: attrib.numComponents };

                if (sp[df] !== undefined) {
                    var attribBuffer = gl.createBuffer();
                    shape._webgl.dynamicFields[currAttribs++].buf = attribBuffer;

                    var attribs = new Float32Array(attrib.value);

                    gl.bindBuffer(gl.ARRAY_BUFFER, attribBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, attribs, gl.STATIC_DRAW);

                    gl.vertexAttribPointer(sp[df], attrib.numComponents, gl.FLOAT, false, 0, 0);

                    attribs = null;
                }
            }
        } // Standard geometry
    };


    /*****************************************************************************
     * Mainly manages rendering of backgrounds and buffer clearing
     *****************************************************************************/
    Context.prototype.setupScene = function (gl, bgnd) {
        var sphere = null;
        var texture = null;

        var that = this;

        if (bgnd._webgl !== undefined) {
            if (!bgnd._dirty) {
                return;
            }

            if (bgnd._webgl.texture !== undefined && bgnd._webgl.texture) {
                gl.deleteTexture(bgnd._webgl.texture);
            }
            if (bgnd._cleanupGLObjects) {
                bgnd._cleanupGLObjects();
            }
            bgnd._webgl = {};
        }

        bgnd._dirty = false;

        var url = bgnd.getTexUrl();
        var i = 0;
        var w = 1, h = 1;

        if (url.length > 0 && url[0].length > 0) {
            if (url.length >= 6 && url[1].length > 0 && url[2].length > 0 &&
                url[3].length > 0 && url[4].length > 0 && url[5].length > 0) {
                sphere = new x3dom.nodeTypes.Sphere();

                bgnd._webgl = {
                    positions: sphere._mesh._positions[0],
                    indexes: sphere._mesh._indices[0],
                    buffers: [
                        {}, {}
                    ]
                };

                bgnd._webgl.primType = gl.TRIANGLES;

                bgnd._webgl.shader = this.cache.getShader(gl, x3dom.shader.BACKGROUND_CUBETEXTURE);

                bgnd._webgl.texture = x3dom.Utils.createTextureCube(gl, bgnd._nameSpace.doc, url,
                    true, bgnd._vf.withCredentials, true);
            }
            else {
                bgnd._webgl = {
                    positions: [-w, -h, 0, -w, h, 0, w, -h, 0, w, h, 0],
                    indexes: [0, 1, 2, 3],
                    buffers: [
                        {}, {}
                    ]
                };

                url = bgnd._nameSpace.getURL(url[0]);

                bgnd._webgl.texture = x3dom.Utils.createTexture2D(gl, bgnd._nameSpace.doc, url,
                    true, bgnd._vf.withCredentials, true);

                bgnd._webgl.primType = gl.TRIANGLE_STRIP;

                bgnd._webgl.shader = this.cache.getShader(gl, x3dom.shader.BACKGROUND_TEXTURE);
            }
        }
        else {
            if (bgnd.getSkyColor().length > 1 || bgnd.getGroundColor().length) {
                sphere = new x3dom.nodeTypes.Sphere();
                texture = gl.createTexture();

                bgnd._webgl = {
                    positions: sphere._mesh._positions[0],
                    texcoords: sphere._mesh._texCoords[0],
                    indexes: sphere._mesh._indices[0],
                    buffers: [
                        {}, {}, {}
                    ],
                    texture: texture,
                    primType: gl.TRIANGLES
                };

                var N = x3dom.Utils.nextHighestPowerOfTwo(
                    bgnd.getSkyColor().length + bgnd.getGroundColor().length + 2);
                N = (N < 512) ? 512 : N;

                var n = bgnd._vf.groundAngle.length;
                var tmp = [], arr = [];
                var colors = [], sky = [0];

                for (i = 0; i < bgnd._vf.skyColor.length; i++) {
                    colors[i] = bgnd._vf.skyColor[i];
                }

                for (i = 0; i < bgnd._vf.skyAngle.length; i++) {
                    sky[i + 1] = bgnd._vf.skyAngle[i];
                }

                if (n > 0 || bgnd._vf.groundColor.length == 1) {
                    if (sky[sky.length - 1] < Math.PI / 2) {
                        sky[sky.length] = Math.PI / 2 - x3dom.fields.Eps;
                        colors[colors.length] = colors[colors.length - 1];
                    }

                    for (i = n - 1; i >= 0; i--) {
                        if ((i == n - 1) && (Math.PI - bgnd._vf.groundAngle[i] <= Math.PI / 2)) {
                            sky[sky.length] = Math.PI / 2;
                            colors[colors.length] = bgnd._vf.groundColor[bgnd._vf.groundColor.length - 1];
                        }
                        sky[sky.length] = Math.PI - bgnd._vf.groundAngle[i];
                        colors[colors.length] = bgnd._vf.groundColor[i + 1];
                    }

                    if (n == 0 && bgnd._vf.groundColor.length == 1) {
                        sky[sky.length] = Math.PI / 2;
                        colors[colors.length] = bgnd._vf.groundColor[0];
                    }
                    sky[sky.length] = Math.PI;
                    colors[colors.length] = bgnd._vf.groundColor[0];
                }
                else {
                    if (sky[sky.length - 1] < Math.PI) {
                        sky[sky.length] = Math.PI;
                        colors[colors.length] = colors[colors.length - 1];
                    }
                }

                for (i = 0; i < sky.length; i++) {
                    sky[i] /= Math.PI;
                }

                x3dom.debug.assert(sky.length == colors.length);

                var interp = new x3dom.nodeTypes.ColorInterpolator();

                interp._vf.key = new x3dom.fields.MFFloat(sky);
                interp._vf.keyValue = new x3dom.fields.MFColor(colors);

                for (i = 0; i < N; i++) {
                    interp._vf.set_fraction = i / (N - 1.0);

                    interp.fieldChanged("set_fraction");
                    tmp[i] = interp._vf.value_changed;
                }

                tmp.reverse();

                var alpha = Math.floor((1.0 - bgnd.getTransparency()) * 255);

                for (i = 0; i < tmp.length; i++) {
                    arr.push(Math.floor(tmp[i].r * 255),
                             Math.floor(tmp[i].g * 255),
                             Math.floor(tmp[i].b * 255),
                             alpha);
                }

                var pixels = new Uint8Array(arr);
                var format = gl.RGBA;

                N = pixels.length / 4;

                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                gl.texImage2D(gl.TEXTURE_2D, 0, format, 1, N, 0, format, gl.UNSIGNED_BYTE, pixels);
                gl.bindTexture(gl.TEXTURE_2D, null);

                bgnd._webgl.shader = this.cache.getShader(gl, x3dom.shader.BACKGROUND_SKYTEXTURE);
            }
            else {
                // Impl. gradient bg etc., e.g. via canvas 2d? But can be done via CSS anyway...
                bgnd._webgl = {};
            }
        }

        if (bgnd._webgl.shader) {
            var sp = bgnd._webgl.shader;

            var positionBuffer = gl.createBuffer();
            bgnd._webgl.buffers[1] = positionBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            var vertices = new Float32Array(bgnd._webgl.positions);

            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            gl.vertexAttribPointer(sp.position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(sp.position);

            var indicesBuffer = gl.createBuffer();
            bgnd._webgl.buffers[0] = indicesBuffer;

            var indexArray = new Uint16Array(bgnd._webgl.indexes);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);

            vertices = null;
            indexArray = null;

            if (sp.texcoord !== undefined) {
                var texcBuffer = gl.createBuffer();
                bgnd._webgl.buffers[2] = texcBuffer;

                var texcoords = new Float32Array(bgnd._webgl.texcoords);

                gl.bindBuffer(gl.ARRAY_BUFFER, texcBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);

                gl.vertexAttribPointer(sp.texcoord, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(sp.texcoord);

                texcoords = null;
            }

            bgnd._cleanupGLObjects = function () {
                var sp = this._webgl.shader;

                if (sp.position !== undefined) {
                    gl.deleteBuffer(this._webgl.buffers[0]);
                    gl.deleteBuffer(this._webgl.buffers[1]);
                }
                if (sp.texcoord !== undefined) {
                    gl.deleteBuffer(this._webgl.buffers[2]);
                }
            };
        }

        bgnd._webgl.render = function (gl, mat_view, mat_proj)
        {
            var sp = bgnd._webgl.shader;
            var alpha = 1.0 - bgnd.getTransparency();

            var mat_scene = null;
            var projMatrix_22 = mat_proj._22,
                projMatrix_23 = mat_proj._23;
            var camPos = mat_view.e3();

            if ((sp !== undefined && sp !== null) &&
                (sp.texcoord !== undefined && sp.texcoord !== null) &&
                (bgnd._webgl.texture !== undefined && bgnd._webgl.texture !== null)) {
                gl.clearColor(0, 0, 0, alpha);
                gl.clearDepth(1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

                that.stateManager.frontFace(gl.CCW);
                that.stateManager.disable(gl.CULL_FACE);
                that.stateManager.disable(gl.DEPTH_TEST);
                that.stateManager.disable(gl.BLEND);

                that.stateManager.useProgram(sp);

                if (!sp.tex) {
                    sp.tex = 0;
                }

                // adapt projection matrix to better near/far
                mat_proj._22 = 100001 / 99999;
                mat_proj._23 = 200000 / 99999;
                // center viewpoint
                mat_view._03 = 0;
                mat_view._13 = 0;
                mat_view._23 = 0;

                mat_scene = mat_proj.mult(mat_view);
                sp.modelViewProjectionMatrix = mat_scene.toGL();

                mat_view._03 = camPos.x;
                mat_view._13 = camPos.y;
                mat_view._23 = camPos.z;

                mat_proj._22 = projMatrix_22;
                mat_proj._23 = projMatrix_23;

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, bgnd._webgl.texture);

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bgnd._webgl.buffers[0]);

                gl.bindBuffer(gl.ARRAY_BUFFER, bgnd._webgl.buffers[1]);
                gl.vertexAttribPointer(sp.position, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(sp.position);

                gl.bindBuffer(gl.ARRAY_BUFFER, bgnd._webgl.buffers[2]);
                gl.vertexAttribPointer(sp.texcoord, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(sp.texcoord);

                gl.drawElements(bgnd._webgl.primType, bgnd._webgl.indexes.length, gl.UNSIGNED_SHORT, 0);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, null);

                gl.disableVertexAttribArray(sp.position);
                gl.disableVertexAttribArray(sp.texcoord);

                gl.clear(gl.DEPTH_BUFFER_BIT);
            }
            else if (!sp || !bgnd._webgl.texture ||
                    (bgnd._webgl.texture.textureCubeReady !== undefined &&
                     bgnd._webgl.texture.textureCubeReady !== true)) {
                var bgCol = bgnd.getSkyColor().toGL();

                gl.clearColor(bgCol[0], bgCol[1], bgCol[2], alpha);
                gl.clearDepth(1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            }
            else {
                gl.clearColor(0, 0, 0, alpha);
                gl.clearDepth(1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

                that.stateManager.frontFace(gl.CCW);
                that.stateManager.disable(gl.CULL_FACE);
                that.stateManager.disable(gl.DEPTH_TEST);
                that.stateManager.disable(gl.BLEND);

                that.stateManager.useProgram(sp);

                if (!sp.tex) {
                    sp.tex = 0;
                }

                if (bgnd._webgl.texture.textureCubeReady) {
                    // adapt projection matrix to better near/far
                    mat_proj._22 = 100001 / 99999;
                    mat_proj._23 = 200000 / 99999;
                    // center viewpoint
                    mat_view._03 = 0;
                    mat_view._13 = 0;
                    mat_view._23 = 0;

                    mat_scene = mat_proj.mult(mat_view);
                    sp.modelViewProjectionMatrix = mat_scene.toGL();

                    mat_view._03 = camPos.x;
                    mat_view._13 = camPos.y;
                    mat_view._23 = camPos.z;

                    mat_proj._22 = projMatrix_22;
                    mat_proj._23 = projMatrix_23;

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, bgnd._webgl.texture);

                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                }
                else {
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, bgnd._webgl.texture);

                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                }

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bgnd._webgl.buffers[0]);
                gl.bindBuffer(gl.ARRAY_BUFFER, bgnd._webgl.buffers[1]);
                gl.vertexAttribPointer(sp.position, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(sp.position);

                gl.drawElements(bgnd._webgl.primType, bgnd._webgl.indexes.length, gl.UNSIGNED_SHORT, 0);

                gl.disableVertexAttribArray(sp.position);

                gl.activeTexture(gl.TEXTURE0);
                if (bgnd._webgl.texture.textureCubeReady) {
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }

                gl.clear(gl.DEPTH_BUFFER_BIT);
            }
        };
    };


    /*****************************************************************************
     * Setup Frontgrounds
     *****************************************************************************/
    Context.prototype.setupFgnds = function (gl, scene) {
        if (scene._fgnd !== undefined) {
            return;
        }

        var that = this;

        var w = 1, h = 1;
        scene._fgnd = {};

        scene._fgnd._webgl = {
            positions: [-w, -h, 0, -w, h, 0, w, -h, 0, w, h, 0],
            indexes: [0, 1, 2, 3],
            buffers: [
                {}, {}
            ]
        };

        scene._fgnd._webgl.primType = gl.TRIANGLE_STRIP;

        scene._fgnd._webgl.shader = this.cache.getShader(gl, x3dom.shader.FRONTGROUND_TEXTURE);

        var sp = scene._fgnd._webgl.shader;

        var positionBuffer = gl.createBuffer();
        scene._fgnd._webgl.buffers[1] = positionBuffer;
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        var vertices = new Float32Array(scene._fgnd._webgl.positions);

        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        gl.vertexAttribPointer(sp.position, 3, gl.FLOAT, false, 0, 0);

        var indicesBuffer = gl.createBuffer();
        scene._fgnd._webgl.buffers[0] = indicesBuffer;

        var indexArray = new Uint16Array(scene._fgnd._webgl.indexes);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);

        vertices = null;
        indexArray = null;

        scene._fgnd._webgl.render = function (gl, tex) {
            scene._fgnd._webgl.texture = tex;

            that.stateManager.frontFace(gl.CCW);
            that.stateManager.disable(gl.CULL_FACE);
            that.stateManager.disable(gl.DEPTH_TEST);

            that.stateManager.useProgram(sp);

            if (!sp.tex) {
                sp.tex = 0;
            }

            //this.stateManager.enable(gl.TEXTURE_2D);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, scene._fgnd._webgl.texture);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, scene._fgnd._webgl.buffers[0]);
            gl.bindBuffer(gl.ARRAY_BUFFER, scene._fgnd._webgl.buffers[1]);
            gl.vertexAttribPointer(sp.position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(sp.position);

            gl.drawElements(scene._fgnd._webgl.primType, scene._fgnd._webgl.indexes.length, gl.UNSIGNED_SHORT, 0);

            gl.disableVertexAttribArray(sp.position);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, null);
            //this.stateManager.disable(gl.TEXTURE_2D);
        };
    };


    /*****************************************************************************
     * Render Shadow-Pass
     *****************************************************************************/
    Context.prototype.renderShadowPass = function (gl, viewarea, mat_scene, mat_view, targetFbo, camOffset, isCameraView)
    {
        var scene = viewarea._scene;
        var sp = scene._webgl.shadowShader;

        this.stateManager.bindFramebuffer(gl.FRAMEBUFFER, targetFbo.fbo);
        this.stateManager.viewport(0, 0, targetFbo.width, targetFbo.height);

        this.stateManager.useProgram(sp);

        sp.cameraView = isCameraView;
        sp.offset = camOffset;

        // workaround for old graphics cards/ drivers
        {
            sp.PG_precisionLevel = 1.0;
            sp.PG_powPrecision = 1.0;
            sp.PG_maxBBSize = [0, 0, 0];
            sp.PG_bbMin = [0, 0, 0];
            sp.PG_bbMaxModF = [0, 0, 0];
            sp.PG_bboxShiftVec = [0, 0, 0];
        }

        gl.clearColor(1.0, 1.0, 1.0, 0.0);
        gl.clearDepth(1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        this.stateManager.depthFunc(gl.LEQUAL);
        this.stateManager.enable(gl.DEPTH_TEST);
        this.stateManager.enable(gl.CULL_FACE);
        this.stateManager.disable(gl.BLEND);

        var bgCenter = x3dom.fields.SFVec3f.NullVector.toGL();
        var bgSize = x3dom.fields.SFVec3f.OneVector.toGL();

        var env = scene.getEnvironment();
        var excludeTrans = env._vf.shadowExcludeTransparentObjects;

        var i, n = scene.drawableCollection.length;

        for (i = 0; i < n; i++)
        {
            var drawable = scene.drawableCollection.get(i);
            var trafo = drawable.transform;
            var shape = drawable.shape;

            var s_gl = shape._webgl;

            if (!s_gl || (excludeTrans && drawable.sortType == 'transparent')) {
                continue;
            }

            var s_geo = shape._cf.geometry.node;
            var s_msh = s_geo._mesh;

            sp.modelViewProjectionMatrix = mat_scene.mult(trafo).toGL();

            //Set ImageGeometry switch
            sp.imageGeometry = s_gl.imageGeometry;
            sp.popGeometry = s_gl.popGeometry;

            if (s_gl.coordType != gl.FLOAT) {
                if (!s_gl.popGeometry && (s_gl.bitLODGeometry || x3dom.Utils.isUnsignedType(s_geo._vf.coordType))) {
                    sp.bgCenter = s_geo.getMin().toGL();
                }
                else {
                    sp.bgCenter = s_geo._vf.position.toGL();
                }
                sp.bgSize = s_geo._vf.size.toGL();
                sp.bgPrecisionMax = s_geo.getPrecisionMax('coordType');
            }
            else {
                sp.bgCenter = bgCenter;
                sp.bgSize = bgSize;
                sp.bgPrecisionMax = 1;
            }

            if (s_gl.colorType != gl.FLOAT) {
                sp.bgPrecisionColMax = s_geo.getPrecisionMax('colorType');
            }

            if (s_gl.texCoordType != gl.FLOAT) {
                sp.bgPrecisionTexMax = s_geo.getPrecisionMax('texCoordType');
            }

            if (s_gl.imageGeometry != 0 && !x3dom.caps.MOBILE)  // FIXME: mobile errors
            {
                sp.IG_bboxMin = s_geo.getMin().toGL();
                sp.IG_bboxMax = s_geo.getMax().toGL();
                sp.IG_implicitMeshSize = s_geo._vf.implicitMeshSize.toGL();  // FIXME

                var coordTex = x3dom.Utils.findTextureByName(s_gl.texture, "IG_coords0");
                if (coordTex) {
                    sp.IG_coordTextureWidth = coordTex.texture.width;
                    sp.IG_coordTextureHeight = coordTex.texture.height;
                }

                if (s_gl.imageGeometry == 1) {
                    var indexTex = x3dom.Utils.findTextureByName(s_gl.texture, "IG_index");
                    if (indexTex) {
                        sp.IG_indexTextureWidth = indexTex.texture.width;
                        sp.IG_indexTextureHeight = indexTex.texture.height;
                    }

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, indexTex.texture);

                    gl.activeTexture(gl.TEXTURE1);
                    gl.bindTexture(gl.TEXTURE_2D, coordTex.texture);
                }
                else {
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, coordTex.texture);
                }

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

                var texUnit = 0;
                if (s_geo.getIndexTexture()) {
                    if (!sp.IG_indexTexture) {
                        sp.IG_indexTexture = texUnit++;
                    }
                }
                if (s_geo.getCoordinateTexture(0)) {
                    if (!sp.IG_coordinateTexture) {
                        sp.IG_coordinateTexture = texUnit++;
                    }
                }
            }

            if (shape.isSolid()) {
                this.stateManager.enable(gl.CULL_FACE);

                if (shape.isCCW()) {
                    this.stateManager.frontFace(gl.CCW);
                }
                else {
                    this.stateManager.frontFace(gl.CW);
                }
            }
            else {
                this.stateManager.disable(gl.CULL_FACE);
            }

            //PopGeometry: adapt LOD and set shader variables
            if (s_gl.popGeometry) {
                var model_view = mat_view.mult(trafo);
                this.updatePopState(drawable, s_geo, sp, s_gl, scene, model_view, viewarea, this.x3dElem.runtime.fps);
            }


            //== end== code stolen from picking pass
            for (var q = 0, q_n = s_gl.positions.length; q < q_n; q++) {
                var q5 = 5 * q;
                var v, v_n, offset;

                if ( !(sp.position !== undefined && s_gl.buffers[q5 + 1] && s_gl.indexes[q]) )
                    continue;

                // set buffers
                if (s_gl.buffers[q5]) {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, s_gl.buffers[q5]);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, s_gl.buffers[q5 + 1]);

                gl.vertexAttribPointer(sp.position,
                    s_msh._numPosComponents, s_gl.coordType, false,
                    shape._coordStrideOffset[0], shape._coordStrideOffset[1]);
                gl.enableVertexAttribArray(sp.position);

                if (s_gl.binaryGeometry > 0 || s_gl.popGeometry > 0 || s_gl.bitLODGeometry > 0) {
                    for (v = 0, offset = 0, v_n = s_geo._vf.vertexCount.length; v < v_n; v++) {
                        gl.drawElements(s_gl.primType[v], s_geo._vf.vertexCount[v], s_gl.indexType,
                                        x3dom.Utils.getByteAwareOffset(offset, s_gl.indexType, gl));
                        offset += s_geo._vf.vertexCount[v];
                    }
                }
                else if (s_gl.binaryGeometry < 0 || s_gl.popGeometry < 0 || s_gl.bitLODGeometry < 0 || s_gl.imageGeometry) {
                    if (s_gl.bitLODtotalVertexCount !== undefined) {
                        gl.drawArrays(gl.TRIANGLES, 0, s_gl.bitLODtotalVertexCount);
                    }
                    else {
                        for (v = 0, offset = 0, v_n = s_geo._vf.vertexCount.length; v < v_n; v++) {
                            gl.drawArrays(s_gl.primType[v], offset, s_geo._vf.vertexCount[v]);
                            offset += s_geo._vf.vertexCount[v];
                        }
                    }
                }
                else if (s_geo.hasIndexOffset()) {
                    var indOff = shape.tessellationProperties();
                    for (v = 0, v_n = indOff.length; v < v_n; v++) {
                        gl.drawElements(s_gl.primType, indOff[v].count, s_gl.indexType,
                            indOff[v].offset * x3dom.Utils.getOffsetMultiplier(s_gl.indexType, gl));
                    }
                }
                else if (s_gl.indexes[q].length == 0) {
                    gl.drawArrays(s_gl.primType, 0, s_gl.positions[q].length / 3);
                }
                else {
                    gl.drawElements(s_gl.primType, s_gl.indexes[q].length, s_gl.indexType, 0);
                }

                gl.disableVertexAttribArray(sp.position);
            }

            //Clean Texture units for IG
            if (s_gl.imageGeometry != 0 && !x3dom.caps.MOBILE) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, null);
                if (s_gl.imageGeometry == 1) {
                    gl.activeTexture(gl.TEXTURE1);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
            }
        }

        gl.flush();
        this.stateManager.bindFramebuffer(gl.FRAMEBUFFER, null);
    };

    /*****************************************************************************
     * Render Picking-Pass
     *****************************************************************************/
    Context.prototype.renderPickingPass = function (gl, scene, mat_view, mat_scene, from, sceneSize,
                                                    pickMode, lastX, lastY, width, height)
    {
        var ps = scene._webgl.pickScale;
        var bufHeight = scene._webgl.fboPick.height;
        var x = lastX * ps;
        var y = (bufHeight - 1) - lastY * ps;
        var sp = null;

        switch (pickMode) {
            case 0: sp = scene._webgl.pickShader;         break;
            case 1: sp = scene._webgl.pickColorShader;    break;
            case 2: sp = scene._webgl.pickTexCoordShader; break;
            case 3: sp = scene._webgl.pickShader24;       break;
            case 4: sp = scene._webgl.pickShaderId;       break;
            default: break;
        }
        if (!sp) {   // error
            return;
        }

        this.stateManager.bindFramebuffer(gl.FRAMEBUFFER, scene._webgl.fboPick.fbo);
        this.stateManager.viewport(0, 0, scene._webgl.fboPick.width, bufHeight);

        //gl.scissor(x, y, width, height);
        //gl.enable(gl.SCISSOR_TEST);

        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clearDepth(1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        var viewarea = scene.drawableCollection.viewarea;
        var env = scene.getEnvironment();
        var n = scene.drawableCollection.length;

        if (env._vf.smallFeatureCulling && env._lowPriorityThreshold < 1 && viewarea.isMovingOrAnimating()) {
            n = Math.floor(n * env._lowPriorityThreshold);
            if (!n && scene.drawableCollection.length)
                n = 1;   // render at least one object
        }

        var bgCenter = x3dom.fields.SFVec3f.NullVector.toGL();
        var bgSize = x3dom.fields.SFVec3f.OneVector.toGL();

        this.stateManager.depthFunc(gl.LEQUAL);
        this.stateManager.enable(gl.DEPTH_TEST);
        this.stateManager.enable(gl.CULL_FACE);
        this.stateManager.disable(gl.BLEND);

        this.stateManager.useProgram(sp);

        // workaround for old graphics cards/ drivers
        if (pickMode == 0)  //pop geo only here impl.
        {
            sp.PG_precisionLevel = 1.0;
            sp.PG_powPrecision = 1.0;
            sp.PG_maxBBSize = [0, 0, 0];
            sp.PG_bbMin = [0, 0, 0];
            sp.PG_bbMaxModF = [0, 0, 0];
            sp.PG_bboxShiftVec = [0, 0, 0];
        }

        this.stateManager.lineWidth(2);     // bigger lines for better picking

        for (var i = 0; i < n; i++)
        {
            var drawable = scene.drawableCollection.get(i);
            var trafo = drawable.transform;
            var shape = drawable.shape;
            var s_gl = shape._webgl;

            if (!s_gl || shape._objectID < 1 || !shape._vf.isPickable) {
                continue;
            }

            var s_geo = shape._cf.geometry.node;
            var s_msh = s_geo._mesh;

            sp.modelMatrix = trafo.toGL();
            sp.modelViewProjectionMatrix = mat_scene.mult(trafo).toGL();

            sp.lowBit  = (shape._objectID & 255) / 255.0;
            sp.highBit = (shape._objectID >>> 8) / 255.0;

            sp.from = from.toGL();
            sp.sceneSize = sceneSize;

            //Set ImageGeometry switch
            sp.imageGeometry = s_gl.imageGeometry;
            sp.popGeometry = s_gl.popGeometry;

            // Set IDs perVertex switch
            sp.writeShadowIDs = (s_gl.binaryGeometry != 0 && s_geo._vf.idsPerVertex) ?
                                (x3dom.nodeTypes.Shape.objectID + 2) : 0;

            if (s_gl.coordType != gl.FLOAT) {
                if (!s_gl.popGeometry && (s_gl.bitLODGeometry || x3dom.Utils.isUnsignedType(s_geo._vf.coordType))) {
                    sp.bgCenter = s_geo.getMin().toGL();
                }
                else {
                    sp.bgCenter = s_geo._vf.position.toGL();
                }
                sp.bgSize = s_geo._vf.size.toGL();
                sp.bgPrecisionMax = s_geo.getPrecisionMax('coordType');
            }
            else {
                sp.bgCenter = bgCenter;
                sp.bgSize = bgSize;
                sp.bgPrecisionMax = 1;
            }
            if (s_gl.colorType != gl.FLOAT) {
                sp.bgPrecisionColMax = s_geo.getPrecisionMax('colorType');
            }
            if (s_gl.texCoordType != gl.FLOAT) {
                sp.bgPrecisionTexMax = s_geo.getPrecisionMax('texCoordType');
            }

            if (s_gl.imageGeometry != 0 && !x3dom.caps.MOBILE)  // FIXME: mobile errors
            {
                sp.IG_bboxMin = s_geo.getMin().toGL();
                sp.IG_bboxMax = s_geo.getMax().toGL();
                sp.IG_implicitMeshSize = s_geo._vf.implicitMeshSize.toGL();  // FIXME

                var coordTex = x3dom.Utils.findTextureByName(s_gl.texture, "IG_coords0");
                if (coordTex) {
                    sp.IG_coordTextureWidth = coordTex.texture.width;
                    sp.IG_coordTextureHeight = coordTex.texture.height;
                }

                if (s_gl.imageGeometry == 1) {
                    var indexTex = x3dom.Utils.findTextureByName(s_gl.texture, "IG_index");
                    if (indexTex) {
                        sp.IG_indexTextureWidth = indexTex.texture.width;
                        sp.IG_indexTextureHeight = indexTex.texture.height;
                    }

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, indexTex.texture);

                    gl.activeTexture(gl.TEXTURE1);
                    gl.bindTexture(gl.TEXTURE_2D, coordTex.texture);
                }
                else {
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, coordTex.texture);
                }

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

                var texUnit = 0;
                if (s_geo.getIndexTexture()) {
                    if (!sp.IG_indexTexture) {
                        sp.IG_indexTexture = texUnit++;
                    }
                }
                if (s_geo.getCoordinateTexture(0)) {
                    if (!sp.IG_coordinateTexture) {
                        sp.IG_coordinateTexture = texUnit++;
                    }
                }
            }

            if (shape.isSolid()) {
                this.stateManager.enable(gl.CULL_FACE);

                if (shape.isCCW()) {
                    this.stateManager.frontFace(gl.CCW);
                }
                else {
                    this.stateManager.frontFace(gl.CW);
                }
            }
            else {
                this.stateManager.disable(gl.CULL_FACE);
            }

            //PopGeometry: adapt LOD and set shader variables
            if (s_gl.popGeometry) {
                var model_view = mat_view.mult(trafo);
                // FIXME; viewarea's width/height twice as big as render buffer size, which leads to too high precision
                // the correct viewarea here would be one that holds this half-sized render buffer
                this.updatePopState(drawable, s_geo, sp, s_gl, scene, model_view, viewarea, this.x3dElem.runtime.fps);
            }


            for (var q = 0, q_n = s_gl.positions.length; q < q_n; q++) {
                var q5 = 5 * q;
                var v, v_n, offset;

                if ( !(sp.position !== undefined && s_gl.buffers[q5 + 1] && s_gl.indexes[q]) )
                    continue;

                // set buffers
                if (s_gl.buffers[q5]) {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, s_gl.buffers[q5]);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, s_gl.buffers[q5 + 1]);

                gl.vertexAttribPointer(sp.position,
                    s_msh._numPosComponents, s_gl.coordType, false,
                    shape._coordStrideOffset[0], shape._coordStrideOffset[1]);
                gl.enableVertexAttribArray(sp.position);

                if (sp.texcoord !== undefined && s_gl.buffers[q5 + 3]) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, s_gl.buffers[q5 + 3]);

                    gl.vertexAttribPointer(sp.texcoord,
                        s_msh._numTexComponents, s_gl.texCoordType, false,
                        shape._texCoordStrideOffset[0], shape._texCoordStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.texcoord);
                }
                if (sp.color !== undefined && s_gl.buffers[q5 + 4]) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, s_gl.buffers[q5 + 4]);

                    gl.vertexAttribPointer(sp.color,
                        s_msh._numColComponents, s_gl.colorType, false,
                        shape._colorStrideOffset[0], shape._colorStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.color);
                }

                // render mesh
                if (s_gl.binaryGeometry > 0 || s_gl.popGeometry > 0 || s_gl.bitLODGeometry > 0) {
                    for (v = 0, offset = 0, v_n = s_geo._vf.vertexCount.length; v < v_n; v++) {
                        gl.drawElements(s_gl.primType[v], s_geo._vf.vertexCount[v], s_gl.indexType,
                                        x3dom.Utils.getByteAwareOffset(offset, s_gl.indexType, gl));
                        offset += s_geo._vf.vertexCount[v];
                    }
                }
                else if (s_gl.binaryGeometry < 0 || s_gl.popGeometry < 0 || s_gl.bitLODGeometry < 0 || s_gl.imageGeometry) {
                    if (s_gl.bitLODtotalVertexCount !== undefined) {
                        gl.drawArrays(gl.TRIANGLES, 0, s_gl.bitLODtotalVertexCount);
                    }
                    else {
                        for (v = 0, offset = 0, v_n = s_geo._vf.vertexCount.length; v < v_n; v++) {
                            gl.drawArrays(s_gl.primType[v], offset, s_geo._vf.vertexCount[v]);
                            offset += s_geo._vf.vertexCount[v];
                        }
                    }
                }
                else if (s_geo.hasIndexOffset()) {
                    var indOff = shape.tessellationProperties();
                    for (v = 0, v_n = indOff.length; v < v_n; v++) {
                        gl.drawElements(s_gl.primType, indOff[v].count, s_gl.indexType,
                            indOff[v].offset * x3dom.Utils.getOffsetMultiplier(s_gl.indexType, gl));
                    }
                }
                else if (s_gl.indexes[q].length == 0) {
                    gl.drawArrays(s_gl.primType, 0, s_gl.positions[q].length / 3);
                }
                else {
                    gl.drawElements(s_gl.primType, s_gl.indexes[q].length, s_gl.indexType, 0);
                }

                gl.disableVertexAttribArray(sp.position);

                if (sp.texcoord !== undefined && s_gl.buffers[q5 + 3]) {
                    gl.disableVertexAttribArray(sp.texcoord);
                }
                if (sp.color !== undefined && s_gl.buffers[q5 + 4]) {
                    gl.disableVertexAttribArray(sp.color);
                }
            }

            //Clean Texture units for IG
            if (s_gl.imageGeometry != 0 && !x3dom.caps.MOBILE) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, null);
                if (s_gl.imageGeometry == 1) {
                    gl.activeTexture(gl.TEXTURE1);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
            }
        }

        this.stateManager.lineWidth(1);

        gl.flush();

        try {
            // 4 = 1 * 1 * 4; then take width x height window (exception pickRect)
            var data = new Uint8Array(4 * width * height);

            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);

            scene._webgl.fboPick.pixelData = data;
        }
        catch (se) {
            scene._webgl.fboPick.pixelData = [];
            // No Exception on file:// when starting with additional flags:
            //    chrome.exe --disable-web-security
            x3dom.debug.logException(se + " (cannot pick)");
        }

        //gl.disable(gl.SCISSOR_TEST);

        this.stateManager.bindFramebuffer(gl.FRAMEBUFFER, null);
    };

    /*****************************************************************************
     * Render single Shape
     *****************************************************************************/
    Context.prototype.renderShape = function (drawable, viewarea, slights, numLights, mat_view, mat_scene,
                                              mat_light, mat_proj, gl)
    {
        var shape = drawable.shape;
        var transform = drawable.transform;

        if (!shape || !shape._webgl || !transform) {
            x3dom.debug.logError("[Context|RenderShape] No valid Shape!");
            return;
        }

        var s_gl = shape._webgl;
        var sp = s_gl.shader;

        if (!sp) {
            x3dom.debug.logError("[Context|RenderShape] No Shader is set!");
            return;
        }

        var changed = this.stateManager.useProgram(sp);

        //===========================================================================
        // Set special Geometry variables
        //===========================================================================
        var s_app = shape._cf.appearance.node;
        var s_geo = shape._cf.geometry.node;
        var s_msh = s_geo._mesh;

        var scene = viewarea._scene;
        var tex = null;

        if (s_gl.coordType != gl.FLOAT) {
            if (!s_gl.popGeometry && (s_gl.bitLODGeometry || x3dom.Utils.isUnsignedType(s_geo._vf.coordType))) {
                sp.bgCenter = s_geo.getMin().toGL();
            }
            else {
                sp.bgCenter = s_geo._vf.position.toGL();
            }
            sp.bgSize = s_geo._vf.size.toGL();
            sp.bgPrecisionMax = s_geo.getPrecisionMax('coordType');
        }
        else {
            sp.bgCenter = [0, 0, 0];
            sp.bgSize = [1, 1, 1];
            sp.bgPrecisionMax = 1;
        }
        if (s_gl.colorType != gl.FLOAT) {
            sp.bgPrecisionColMax = s_geo.getPrecisionMax('colorType');
        }
        else {
            sp.bgPrecisionColMax = 1;
        }
        if (s_gl.texCoordType != gl.FLOAT) {
            sp.bgPrecisionTexMax = s_geo.getPrecisionMax('texCoordType');
        }
        else {
            sp.bgPrecisionTexMax = 1;
        }
        if (s_gl.normalType != gl.FLOAT) {
            sp.bgPrecisionNorMax = s_geo.getPrecisionMax('normalType');
        }
        else {
            sp.bgPrecisionNorMax = 1;
        }

        if (s_gl.imageGeometry != 0) {
            sp.IG_bboxMin = s_geo.getMin().toGL();
            sp.IG_bboxMax = s_geo.getMax().toGL();
            sp.IG_implicitMeshSize = s_geo._vf.implicitMeshSize.toGL();  // FIXME

            tex = x3dom.Utils.findTextureByName(s_gl.texture, "IG_coords0");
            if (tex) {
                sp.IG_coordTextureWidth = tex.texture.width;
                sp.IG_coordTextureHeight = tex.texture.height;
            }

            if (s_gl.imageGeometry == 1) {
                tex = x3dom.Utils.findTextureByName(s_gl.texture, "IG_index");
                if (tex) {
                    sp.IG_indexTextureWidth = tex.texture.width;
                    sp.IG_indexTextureHeight = tex.texture.height;
                }
            }
            tex = null;
        }

        //===========================================================================
        // Set fog
        //===========================================================================
        // TODO: when no state/shader switch happens, all light/fog/... uniforms don't need to be set again
        var fog = scene.getFog();

        // THINKABOUTME: changed flag only works as long as lights and fog are global
        if (fog && changed) {
            sp.fogColor = fog._vf.color.toGL();
            sp.fogRange = fog._vf.visibilityRange;
            sp.fogType = (fog._vf.fogType == "LINEAR") ? 0.0 : 1.0;
        }

        //===========================================================================
        // Set Material
        //===========================================================================
        var mat = s_app ? s_app._cf.material.node : null;
        var shader = s_app ? s_app._shader : null;

        if (s_gl.csshader) {
            sp.diffuseColor = shader._vf.diffuseFactor.toGL();
            sp.specularColor = shader._vf.specularFactor.toGL();
            sp.emissiveColor = shader._vf.emissiveFactor.toGL();
            sp.shininess = shader._vf.shininessFactor;
            sp.ambientIntensity = (shader._vf.ambientFactor.x +
                                   shader._vf.ambientFactor.y +
                                   shader._vf.ambientFactor.z) / 3;
            sp.transparency = 1.0 - shader._vf.alphaFactor;

            if (shader.getDisplacementMap()) {
              tex = x3dom.Utils.findTextureByName(s_gl.texture, "displacementMap");
              sp.displacementWidth = tex.texture.width;
              sp.displacementHeight = tex.texture.height;
              sp.displacementFactor = shader._vf.displacementFactor;
              sp.displacementAxis = (shader._vf.displacementAxis == "x") ? 0.0 :
                                    (shader._vf.displacementAxis == "y") ? 1.0 : 2.0;
            }
            else if (shader.getDiffuseDisplacementMap()) {
                tex = x3dom.Utils.findTextureByName(s_gl.texture, "diffuseDisplacementMap");
                sp.displacementWidth = tex.texture.width;
                sp.displacementHeight = tex.texture.height;
                sp.displacementFactor = shader._vf.displacementFactor;
                sp.displacementAxis = (shader._vf.displacementAxis == "x") ? 0.0 :
                                      (shader._vf.displacementAxis == "y") ? 1.0 : 2.0;
            }
        }
        else if (mat) {
            sp.diffuseColor = mat._vf.diffuseColor.toGL();
            sp.specularColor = mat._vf.specularColor.toGL();
            sp.emissiveColor = mat._vf.emissiveColor.toGL();
            sp.shininess = mat._vf.shininess;
            sp.ambientIntensity = mat._vf.ambientIntensity;
            sp.transparency = mat._vf.transparency;
        }
        else {
            sp.diffuseColor = [1.0, 1.0, 1.0];
            sp.specularColor = [0.0, 0.0, 0.0];
            sp.emissiveColor = [0.0, 0.0, 0.0];
            sp.shininess = 0.0;
            sp.ambientIntensity = 1.0;
            sp.transparency = 0.0;
        }

        //Look for user-defined shaders
        if (shader) {
            if (x3dom.isa(shader, x3dom.nodeTypes.ComposedShader)) {
                for (var fName in shader._vf) {
                    if (shader._vf.hasOwnProperty(fName) && fName !== 'language') {
                        var field = shader._vf[fName];
                        if (field) {
                            if (field.toGL) {
                                sp[fName] = field.toGL();
                            }
                            else {
                                sp[fName] = field;
                            }
                        }
                    }
                }
            }
            else if (x3dom.isa(shader, x3dom.nodeTypes.CommonSurfaceShader)) {
                s_gl.csshader = shader;
            }
        }

        //===========================================================================
        // Set Lights
        //===========================================================================
        for (var p = 0; p < numLights && changed; p++) {
            // FIXME; getCurrentTransform() doesn't work for shared lights/objects!
            var light_transform = mat_view.mult(slights[p].getCurrentTransform());

            if (x3dom.isa(slights[p], x3dom.nodeTypes.DirectionalLight)) {
                sp['light' + p + '_Type'] = 0.0;
                sp['light' + p + '_On'] = (slights[p]._vf.on) ? 1.0 : 0.0;
                sp['light' + p + '_Color'] = slights[p]._vf.color.toGL();
                sp['light' + p + '_Intensity'] = slights[p]._vf.intensity;
                sp['light' + p + '_AmbientIntensity'] = slights[p]._vf.ambientIntensity;
                sp['light' + p + '_Direction'] = light_transform.multMatrixVec(slights[p]._vf.direction).toGL();
                sp['light' + p + '_Attenuation'] = [1.0, 1.0, 1.0];
                sp['light' + p + '_Location'] = [1.0, 1.0, 1.0];
                sp['light' + p + '_Radius'] = 0.0;
                sp['light' + p + '_BeamWidth'] = 0.0;
                sp['light' + p + '_CutOffAngle'] = 0.0;
                sp['light' + p + '_ShadowIntensity'] = slights[p]._vf.shadowIntensity;
            }
            else if (x3dom.isa(slights[p], x3dom.nodeTypes.PointLight)) {
                sp['light' + p + '_Type'] = 1.0;
                sp['light' + p + '_On'] = (slights[p]._vf.on) ? 1.0 : 0.0;
                sp['light' + p + '_Color'] = slights[p]._vf.color.toGL();
                sp['light' + p + '_Intensity'] = slights[p]._vf.intensity;
                sp['light' + p + '_AmbientIntensity'] = slights[p]._vf.ambientIntensity;
                sp['light' + p + '_Direction'] = [1.0, 1.0, 1.0];
                sp['light' + p + '_Attenuation'] = slights[p]._vf.attenuation.toGL();
                sp['light' + p + '_Location'] = light_transform.multMatrixPnt(slights[p]._vf.location).toGL();
                sp['light' + p + '_Radius'] = slights[p]._vf.radius;
                sp['light' + p + '_BeamWidth'] = 0.0;
                sp['light' + p + '_CutOffAngle'] = 0.0;
                sp['light' + p + '_ShadowIntensity'] = slights[p]._vf.shadowIntensity;
            }
            else if (x3dom.isa(slights[p], x3dom.nodeTypes.SpotLight)) {
                sp['light' + p + '_Type'] = 2.0;
                sp['light' + p + '_On'] = (slights[p]._vf.on) ? 1.0 : 0.0;
                sp['light' + p + '_Color'] = slights[p]._vf.color.toGL();
                sp['light' + p + '_Intensity'] = slights[p]._vf.intensity;
                sp['light' + p + '_AmbientIntensity'] = slights[p]._vf.ambientIntensity;
                sp['light' + p + '_Direction'] = light_transform.multMatrixVec(slights[p]._vf.direction).toGL();
                sp['light' + p + '_Attenuation'] = slights[p]._vf.attenuation.toGL();
                sp['light' + p + '_Location'] = light_transform.multMatrixPnt(slights[p]._vf.location).toGL();
                sp['light' + p + '_Radius'] = slights[p]._vf.radius;
                sp['light' + p + '_BeamWidth'] = slights[p]._vf.beamWidth;
                sp['light' + p + '_CutOffAngle'] = slights[p]._vf.cutOffAngle;
                sp['light' + p + '_ShadowIntensity'] = slights[p]._vf.shadowIntensity;
            }
        }

        //===========================================================================
        // Set HeadLight
        //===========================================================================
        var nav = scene.getNavigationInfo();

        if (nav._vf.headlight && changed) {
            numLights = (numLights) ? numLights : 0;
            sp['light' + numLights + '_Type'] = 0.0;
            sp['light' + numLights + '_On'] = 1.0;
            sp['light' + numLights + '_Color'] = [1.0, 1.0, 1.0];
            sp['light' + numLights + '_Intensity'] = 1.0;
            sp['light' + numLights + '_AmbientIntensity'] = 0.0;
            sp['light' + numLights + '_Direction'] = [0.0, 0.0, -1.0];
            sp['light' + numLights + '_Attenuation'] = [1.0, 1.0, 1.0];
            sp['light' + numLights + '_Location'] = [1.0, 1.0, 1.0];
            sp['light' + numLights + '_Radius'] = 0.0;
            sp['light' + numLights + '_BeamWidth'] = 0.0;
            sp['light' + numLights + '_CutOffAngle'] = 0.0;
            sp['light' + numLights + '_ShadowIntensity'] = 0.0;
        }


        //===========================================================================
        // Set DepthMode
        //===========================================================================
        var depthMode = s_app ? s_app._cf.depthMode.node : null;
        if (depthMode)
        {
            if (depthMode._vf.enableDepthTest)
            {
                //Enable Depth Test
                this.stateManager.enable(gl.DEPTH_TEST);

                //Set Depth Mask
                this.stateManager.depthMask(!depthMode._vf.readOnly);
                
                //Set Depth Function
                this.stateManager.depthFunc(x3dom.Utils.depthFunc(gl, depthMode._vf.depthFunc));

                //Set Depth Range
                this.stateManager.depthRange(depthMode._vf.zNearRange, depthMode._vf.zFarRange);
            }
            else
            {
                //Disable Depth Test
                this.stateManager.disable(gl.DEPTH_TEST);
            }
        } 
        else //Set Defaults
        {
            this.stateManager.enable(gl.DEPTH_TEST);
            this.stateManager.depthMask(true);
            this.stateManager.depthFunc(gl.LEQUAL);
        }

        //===========================================================================
        // Set BlendMode
        //===========================================================================
        var blendMode = s_app ? s_app._cf.blendMode.node : null;
        if (blendMode)
        {
            var srcFactor  = x3dom.Utils.blendFunc(gl, blendMode._vf.srcFactor);
            var destFactor = x3dom.Utils.blendFunc(gl, blendMode._vf.destFactor);

            if (srcFactor && destFactor)
            {
                //Enable Blending
                this.stateManager.enable(gl.BLEND);

                //Set Blend Function
                this.stateManager.blendFuncSeparate(srcFactor, destFactor, gl.ONE, gl.ONE);

                //Set Blend Color
                this.stateManager.blendColor(blendMode._vf.color.r,
                                             blendMode._vf.color.g,
                                             blendMode._vf.color.b,
                                             1.0 - blendMode._vf.colorTransparency);

                //Set Blend Equation
                this.stateManager.blendEquation(x3dom.Utils.blendEquation(gl, blendMode._vf.equation));
            }
            else
            {
                this.stateManager.disable(gl.BLEND);
            }
        }
        else //Set Defaults
        {
            this.stateManager.enable(gl.BLEND);
            this.stateManager.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
        }

        //===========================================================================
        // Set ColorMaskMode
        //===========================================================================
        var colorMaskMode = s_app ? s_app._cf.colorMaskMode.node : null;
        if (colorMaskMode)
        {
            this.stateManager.colorMask(colorMaskMode._vf.maskR,
                                        colorMaskMode._vf.maskG,
                                        colorMaskMode._vf.maskB,
                                        colorMaskMode._vf.maskA);
        }
        else //Set Defaults
        {
            this.stateManager.colorMask(true, true, true, true);
        }

        //===========================================================================
        // Set LineProperties (only linewidthScaleFactor, interpreted as lineWidth)
        //===========================================================================
        var lineProperties = s_app ? s_app._cf.lineProperties.node : null;
        if (lineProperties)
        {
            this.stateManager.lineWidth(lineProperties._vf.linewidthScaleFactor);
        }
        else //Set Defaults
        {
            this.stateManager.lineWidth(1);
        }

        if (shape.isSolid()) {
            this.stateManager.enable(gl.CULL_FACE);

            if (shape.isCCW()) {
                this.stateManager.frontFace(gl.CCW);
            }
            else {
                this.stateManager.frontFace(gl.CW);
            }
        }
        else {
            this.stateManager.disable(gl.CULL_FACE);
        }


        // transformation matrices
        var model_view = mat_view.mult(transform);
        var model_view_inv = model_view.inverse();

        sp.modelViewMatrix = model_view.toGL();
        sp.viewMatrix = mat_view.toGL();

        sp.normalMatrix = model_view_inv.transpose().toGL();
        sp.modelViewMatrixInverse = model_view_inv.toGL();

        sp.projectionMatrix = mat_proj.toGL();
        sp.modelViewProjectionMatrix = mat_scene.mult(transform).toGL();


        //PopGeometry: adapt LOD and set shader variables
        if (s_gl.popGeometry) {
            this.updatePopState(drawable, s_geo, sp, s_gl, scene, model_view, viewarea, this.x3dElem.runtime.fps);
        }


        for (var cnt = 0, cnt_n = s_gl.texture.length; cnt < cnt_n; cnt++) {
            tex = s_gl.texture[cnt];

            gl.activeTexture(gl.TEXTURE0 + cnt);
            gl.bindTexture(tex.type, tex.texture);
            gl.texParameteri(tex.type, gl.TEXTURE_WRAP_S, tex.wrapS);
            gl.texParameteri(tex.type, gl.TEXTURE_WRAP_T, tex.wrapT);
            gl.texParameteri(tex.type, gl.TEXTURE_MAG_FILTER, tex.magFilter);
            gl.texParameteri(tex.type, gl.TEXTURE_MIN_FILTER, tex.minFilter);

            // TODO: this is expensive and probably only required on change, track e.g. via stateManager
            if (tex.genMipMaps) {
                gl.generateMipmap(tex.type);
            }

            if (!shader || !x3dom.isa(shader, x3dom.nodeTypes.ComposedShader)) {
                if (!sp[tex.samplerName])
                    sp[tex.samplerName] = cnt;
            }
        }

        if (s_app && s_app._cf.textureTransform.node) {
            var texTrafo = s_app.texTransformMatrix();
            sp.texTrafoMatrix = texTrafo.toGL();
        }


        // TODO; FIXME; what if geometry with split mesh has dynamic fields?
        var attrib = null;
        var df, df_n = s_gl.dynamicFields.length;

        for (df = 0; df < df_n; df++) {
            attrib = s_gl.dynamicFields[df];

            if (sp[attrib.name] !== undefined) {
                gl.bindBuffer(gl.ARRAY_BUFFER, attrib.buf);

                gl.vertexAttribPointer(sp[attrib.name], attrib.numComponents, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(sp[attrib.name]);
            }
        }

        // render object
        var v, v_n, offset;
        
        for (var q = 0, q_n = s_gl.positions.length; q < q_n; q++) {
            var q5 = 5 * q;

            if ( !(sp.position !== undefined && s_gl.buffers[q5 + 1] && s_gl.indexes[q]) )
                continue;

            if (s_gl.buffers[q5]) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, s_gl.buffers[q5]);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, s_gl.buffers[q5 + 1]);

            gl.vertexAttribPointer(sp.position,
                s_msh._numPosComponents, s_gl.coordType, false,
                shape._coordStrideOffset[0], shape._coordStrideOffset[1]);
            gl.enableVertexAttribArray(sp.position);

            if (sp.normal !== undefined && s_gl.buffers[q5 + 2]) {
                gl.bindBuffer(gl.ARRAY_BUFFER, s_gl.buffers[q5 + 2]);

                gl.vertexAttribPointer(sp.normal,
                    s_msh._numNormComponents, s_gl.normalType, false,
                    shape._normalStrideOffset[0], shape._normalStrideOffset[1]);
                gl.enableVertexAttribArray(sp.normal);
            }
            if (sp.texcoord !== undefined && s_gl.buffers[q5 + 3]) {
                gl.bindBuffer(gl.ARRAY_BUFFER, s_gl.buffers[q5 + 3]);

                gl.vertexAttribPointer(sp.texcoord,
                    s_msh._numTexComponents, s_gl.texCoordType, false,
                    shape._texCoordStrideOffset[0], shape._texCoordStrideOffset[1]);
                gl.enableVertexAttribArray(sp.texcoord);
            }
            if (sp.color !== undefined && s_gl.buffers[q5 + 4]) {
                gl.bindBuffer(gl.ARRAY_BUFFER, s_gl.buffers[q5 + 4]);

                gl.vertexAttribPointer(sp.color,
                    s_msh._numColComponents, s_gl.colorType, false,
                    shape._colorStrideOffset[0], shape._colorStrideOffset[1]);
                gl.enableVertexAttribArray(sp.color);
            }
            if (s_gl.popGeometry != 0 && s_gl.buffers[q5 + 5]) {
                //special case: mimic gl_VertexID
                gl.bindBuffer(gl.ARRAY_BUFFER, s_gl.buffers[q5 + 5]);

                gl.vertexAttribPointer(sp.PG_vertexID, 1, gl.FLOAT, false, 4, 0);
                gl.enableVertexAttribArray(sp.PG_vertexID);
            }

            // TODO: implement surface with additional wireframe render mode (independent from poly mode)
            var renderMode = viewarea.getRenderMode();

            if (renderMode > 0) {
                var polyMode = (renderMode == 1) ? gl.POINTS : gl.LINES;

                if (s_gl.binaryGeometry > 0 || s_gl.popGeometry > 0 || s_gl.bitLODGeometry > 0) {
                    for (v = 0, offset = 0, v_n = s_geo._vf.vertexCount.length; v < v_n; v++) {
                        gl.drawElements(polyMode, s_geo._vf.vertexCount[v], s_gl.indexType,
                                        x3dom.Utils.getByteAwareOffset(offset, s_gl.indexType, gl));
                        offset += s_geo._vf.vertexCount[v];
                    }
                }
                else if (s_gl.binaryGeometry < 0 || s_gl.popGeometry < 0 || s_gl.bitLODGeometry < 0 ||
                         s_gl.imageGeometry) {
                    for (v = 0, offset = 0, v_n = s_geo._vf.vertexCount.length; v < v_n; v++) {
                        gl.drawArrays(polyMode, offset, s_geo._vf.vertexCount[v]);
                        offset += s_geo._vf.vertexCount[v];
                    }
                }
                else if (s_gl.indexes[q].length == 0) {
                    gl.drawArrays(polyMode, 0, s_gl.positions[q].length / 3);
                }
                else {
                    gl.drawElements(polyMode, s_gl.indexes[q].length, s_gl.indexType, 0);
                }
            }
            else {
                if (s_gl.binaryGeometry > 0 || s_gl.popGeometry > 0 || s_gl.bitLODGeometry > 0) {
                    for (v = 0, offset = 0, v_n = s_geo._vf.vertexCount.length; v < v_n; v++) {
                        gl.drawElements(s_gl.primType[v], s_geo._vf.vertexCount[v], s_gl.indexType,
                                        x3dom.Utils.getByteAwareOffset(offset, s_gl.indexType, gl));
                        offset += s_geo._vf.vertexCount[v];
                    }
                }
                else if (s_gl.binaryGeometry < 0 || s_gl.popGeometry < 0 || s_gl.bitLODGeometry < 0 || s_gl.imageGeometry) {
                    if (s_gl.bitLODtotalVertexCount !== undefined) {
                        gl.drawArrays(gl.TRIANGLES, 0, s_gl.bitLODtotalVertexCount);
                    }
                    else {
                        for (v = 0, offset = 0, v_n = s_geo._vf.vertexCount.length; v < v_n; v++) {
                            gl.drawArrays(s_gl.primType[v], offset, s_geo._vf.vertexCount[v]);
                            offset += s_geo._vf.vertexCount[v];
                        }
                    }
                }
                else if (s_geo.hasIndexOffset()) {
                    // IndexedTriangleStripSet with primType TRIANGLE_STRIP,
                    // and Patch geometry from external BVHRefiner component
                    var indOff = shape.tessellationProperties();
                    for (v = 0, v_n = indOff.length; v < v_n; v++) {
                        gl.drawElements(s_gl.primType, indOff[v].count, s_gl.indexType,
                            indOff[v].offset * x3dom.Utils.getOffsetMultiplier(s_gl.indexType, gl));
                    }
                }
                else if (s_gl.indexes[q].length == 0) {
                    gl.drawArrays(s_gl.primType, 0, s_gl.positions[q].length / 3);
                }
                else {
                    gl.drawElements(s_gl.primType, s_gl.indexes[q].length, s_gl.indexType, 0);
                }
            }

            // disable all used vertex attributes
            gl.disableVertexAttribArray(sp.position);

            if (sp.normal !== undefined) {
                gl.disableVertexAttribArray(sp.normal);
            }
            if (sp.texcoord !== undefined) {
                gl.disableVertexAttribArray(sp.texcoord);
            }
            if (sp.color !== undefined) {
                gl.disableVertexAttribArray(sp.color);
            }
            if (s_gl.popGeometry != 0 && sp.PG_vertexID !== undefined) {
                gl.disableVertexAttribArray(sp.PG_vertexID);    // mimic gl_VertexID
            }
        } // end for loop over attrib arrays

        for (df = 0; df < df_n; df++) {
            attrib = s_gl.dynamicFields[df];

            if (sp[attrib.name] !== undefined) {
                gl.disableVertexAttribArray(sp[attrib.name]);
            }
        }

        // update stats
        if (s_gl.imageGeometry) {
            v_n = s_geo._vf.vertexCount.length;
            this.numDrawCalls += v_n;

            for (v = 0; v < v_n; v++) {
                if (s_gl.primType[v] == gl.TRIANGLE_STRIP)
                    this.numFaces += (s_geo._vf.vertexCount[v] - 2);
                else
                    this.numFaces += (s_geo._vf.vertexCount[v] / 3);

                this.numCoords += s_geo._vf.vertexCount[v];
            }
        }
        else {
            this.numCoords += s_msh._numCoords;
            this.numFaces  += s_msh._numFaces;

            if (s_gl.binaryGeometry || s_gl.popGeometry || s_gl.bitLODGeometry) {
                this.numDrawCalls += s_geo._vf.vertexCount.length;
            }
            else if (s_geo.hasIndexOffset()) {
                this.numDrawCalls += shape.tessellationProperties().length;
            }
            else {
                this.numDrawCalls += q_n;
            }
        }

        // reset to default values for possibly user defined render states
        if (depthMode) {
            this.stateManager.enable(gl.DEPTH_TEST);
            this.stateManager.depthMask(true);
            this.stateManager.depthFunc(gl.LEQUAL);
            this.stateManager.depthRange(0, 1);
        }

        if (blendMode) {
            this.stateManager.enable(gl.BLEND);
            this.stateManager.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
            this.stateManager.blendColor(1, 1, 1, 1);
            this.stateManager.blendEquation(gl.FUNC_ADD);
        }

        if (colorMaskMode) {
            this.stateManager.colorMask(true, true, true, true);
        }

        if (lineProperties) {
            this.stateManager.lineWidth(1);
        }

        // cleanup textures
        var s_gl_tex = s_gl.texture;
        cnt_n = s_gl_tex ? s_gl_tex.length : 0;

        for (cnt = 0; cnt < cnt_n; cnt++) {
            if (!s_gl_tex[cnt])
                continue;

            if (s_app && s_app._cf.texture.node) {
                tex = s_app._cf.texture.node.getTexture(cnt);
                gl.activeTexture(gl.TEXTURE0 + cnt);

                if (x3dom.isa(tex, x3dom.nodeTypes.X3DEnvironmentTextureNode)) {
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
            }
        }
    };

    /*****************************************************************************
     * PopGeometry: adapt LOD and set shader variables
     *****************************************************************************/
    Context.prototype.updatePopState = function (drawable, popGeo, sp, s_gl, scene, model_view, viewarea, currFps)
    {
        var tol = x3dom.nodeTypes.PopGeometry.ErrorToleranceFactor * popGeo._vf.precisionFactor;

        if (currFps <= 1 || viewarea.isMovingOrAnimating()) {
            tol *= x3dom.nodeTypes.PopGeometry.PrecisionFactorOnMove;
        }

        var currentLOD = 16;

        if (tol > 0) {

            //BEGIN CLASSIC CODE
            var viewpoint = scene.getViewpoint();
            var imgPlaneHeightAtDistOne = viewpoint.getImgPlaneHeightAtDistOne();
            var near = viewpoint.getNear();
            var center = model_view.multMatrixPnt(popGeo._vf.position);

            var tightRad   = model_view.multMatrixVec(popGeo._vf.size).length()      * 0.5;
            var largestRad = model_view.multMatrixVec(popGeo._vf.maxBBSize).length() * 0.5;

            //distance is estimated conservatively using the bounding sphere
            var dist = Math.max(-center.z - tightRad, near);
            var projPixelLength = dist * (imgPlaneHeightAtDistOne / viewarea._height);

            //compute LOD using bounding sphere
            var arg = (2 * largestRad) / (tol * projPixelLength);
            //END CLASSIC CODE

            //BEGIN EXPERIMENTAL CODE
            //compute LOD using screen-space coverage of bounding sphere
            //@todo: the coverage should be distinct from priority
            //var cov = drawable.priority;
            //@todo: here, we need to decide whether we want to keep the ModF-encoding with
            //       respect to the largest bounding box... if not, change this and the shaders
            //cov *= (popGeo._vf.maxBBSize.length() / popGeo._vf.size.length());
            //var arg = cov / tol;
            //END EXPERIMENTAL CODE

            // use precomputed log(2.0) = 0.693147180559945
            currentLOD = Math.ceil(Math.log(arg) / 0.693147180559945);
            currentLOD = (currentLOD < 1) ? 1 : ((currentLOD > 16) ? 16 : currentLOD);
        }

        //take care of user-controlled min and max values
        var minPrec = popGeo._vf.minPrecisionLevel, maxPrec = popGeo._vf.maxPrecisionLevel;

        currentLOD = (minPrec != -1 && currentLOD < minPrec) ? minPrec : currentLOD;
        currentLOD = (maxPrec != -1 && currentLOD > maxPrec) ? maxPrec : currentLOD;

        //assign rendering resolution, according to currently loaded data and LOD
        var currentLOD_min = (s_gl.levelsAvailable < currentLOD) ? s_gl.levelsAvailable : currentLOD;
        currentLOD = currentLOD_min;

        //@todo: only for demonstration purposes!!!
        if (tol <= 1)
            currentLOD = (currentLOD == popGeo.getNumLevels()) ? 16 : currentLOD;

        //here, we tell X3DOM how many faces / vertices get displayed in the stats
        var hasIndex = popGeo._vf.indexedRendering;
        var p_msh = popGeo._mesh;

        p_msh._numCoords = 0;
        p_msh._numFaces = 0;

        //@todo: this assumes pure TRIANGLES data (and gets overwritten from shadow/picking pass!!!)
        for (var i = 0; i < currentLOD_min; ++i) {  // currentLOD breaks loop
            var numVerticesAtLevel_i = s_gl.numVerticesAtLevel[i];
            p_msh._numCoords += numVerticesAtLevel_i;
            p_msh._numFaces += (hasIndex ? popGeo.getNumIndicesByLevel(i) : numVerticesAtLevel_i) / 3;
        }

        x3dom.nodeTypes.PopGeometry.numRenderedVerts += p_msh._numCoords;
        x3dom.nodeTypes.PopGeometry.numRenderedTris += p_msh._numFaces;

        //this field is mainly thought for the use with external statistics
        //@todo: does not work with instances
        p_msh.currentLOD = currentLOD;

        //here, we tell X3DOM how many vertices get rendered
        //@todo: this assumes pure TRIANGLES data
        popGeo.adaptVertexCount(hasIndex ? p_msh._numFaces * 3 : p_msh._numCoords);

        // finally set shader variables...
        sp.PG_maxBBSize = popGeo._vf.maxBBSize.toGL();

        sp.PG_bbMin = popGeo._bbMinBySize;  // floor(bbMin / maxBBSize)

        sp.PG_numAnchorVertices = popGeo._vf.numAnchorVertices;

        sp.PG_bbMaxModF    = popGeo._vf.bbMaxModF.toGL();
        sp.PG_bboxShiftVec = popGeo._vf.bbShiftVec.toGL();

        sp.PG_precisionLevel = currentLOD;

        //mimics Math.pow(2.0, 16.0 - currentLOD);
        sp.PG_powPrecision = x3dom.nodeTypes.PopGeometry.powLUT[currentLOD - 1];
    };


    /*****************************************************************************
     * Render ColorBuffer-Pass for picking
     *****************************************************************************/
    Context.prototype.pickValue = function (viewarea, x, y, buttonState, viewMat, sceneMat)
    {
        var gl = this.ctx3d;
        var scene = viewarea._scene;

        // method requires that scene has already been rendered at least once
        if (!gl || !scene || !scene._webgl || !scene.drawableCollection) {
            return false;
        }

        var pm = scene._vf.pickMode.toLowerCase();
        var pickMode = 0;

        switch (pm) {
            case "box":      return false;
            case "idbuf":    pickMode = 0; break;
            case "idbuf24":  pickMode = 3; break;
            case "idbufid":  pickMode = 4; break;
            case "color":    pickMode = 1; break;
            case "texcoord": pickMode = 2; break;
        }

        x3dom.Utils.startMeasure("picking");

        // ViewMatrix and ViewProjectionMatrix
        var mat_view, mat_scene;

        if (arguments.length > 4) {
            mat_view = viewMat;
            mat_scene = sceneMat;
        }
        else {
            mat_view = viewarea._last_mat_view;
            mat_scene = viewarea._last_mat_scene;
        }

        // remember correct scene bbox
        var min = x3dom.fields.SFVec3f.copy(scene._lastMin);
        var max = x3dom.fields.SFVec3f.copy(scene._lastMax);
        // get current camera position
        var from = mat_view.inverse().e3();

        // get bbox of scene bbox and camera position
        var _min = x3dom.fields.SFVec3f.copy(from);
        var _max = x3dom.fields.SFVec3f.copy(from);

        if (_min.x > min.x) { _min.x = min.x; }
        if (_min.y > min.y) { _min.y = min.y; }
        if (_min.z > min.z) { _min.z = min.z; }

        if (_max.x < max.x) { _max.x = max.x; }
        if (_max.y < max.y) { _max.y = max.y; }
        if (_max.z < max.z) { _max.z = max.z; }

        // temporarily set scene size to include camera
        scene._lastMin.setValues(_min);
        scene._lastMax.setValues(_max);

        // get scalar scene size and adapted projection matrix
        var sceneSize = scene._lastMax.subtract(scene._lastMin).length();
        var cctowc = viewarea.getCCtoWCMatrix();

        // restore correct scene bbox
        scene._lastMin.setValues(min);
        scene._lastMax.setValues(max);

        // for deriving shadow ids together with shape ids
        var baseID = x3dom.nodeTypes.Shape.objectID + 2;


        // render to texture for reading pixel values
        this.renderPickingPass(gl, scene, mat_view, mat_scene, from, sceneSize, pickMode, x, y, 2, 2);

        // the pixel values under mouse cursor
        var pixelData = scene._webgl.fboPick.pixelData;

        if (pixelData && pixelData.length)
        {
            var pickPos = new x3dom.fields.SFVec3f(0, 0, 0);
            var pickNorm = new x3dom.fields.SFVec3f(0, 0, 1);

            var index = 0;
            var objId = pixelData[index + 3], shapeId;

            var pixelOffset = 1.0 / scene._webgl.pickScale;
            var denom = 1.0 / 256.0;
            var dist, line, lineoff, right, up;

            if (pickMode == 0) {
                objId += 256 * pixelData[index + 2];

                dist = (pixelData[index    ] / 255.0) * denom +
                       (pixelData[index + 1] / 255.0);

                line = viewarea.calcViewRay(x, y, cctowc);

                pickPos = line.pos.add(line.dir.multiply(dist * sceneSize));

                index = 4;      // get right pixel
                dist = (pixelData[index    ] / 255.0) * denom +
                       (pixelData[index + 1] / 255.0);

                lineoff = viewarea.calcViewRay(x + pixelOffset, y, cctowc);

                right = lineoff.pos.add(lineoff.dir.multiply(dist * sceneSize));
                right = right.subtract(pickPos).normalize();

                index = 8;      // get top pixel
                dist = (pixelData[index    ] / 255.0) * denom +
                       (pixelData[index + 1] / 255.0);

                lineoff = viewarea.calcViewRay(x, y - pixelOffset, cctowc);

                up = lineoff.pos.add(lineoff.dir.multiply(dist * sceneSize));
                up = up.subtract(pickPos).normalize();

                pickNorm = right.cross(up).normalize();
            }
            else if (pickMode == 3) {
                objId +=   256 * pixelData[index + 2] +
                         65536 * pixelData[index + 1];

                dist = pixelData[index] / 255.0;

                line = viewarea.calcViewRay(x, y, cctowc);

                pickPos = line.pos.add(line.dir.multiply(dist * sceneSize));

                index = 4;      // get right pixel
                dist = pixelData[index] / 255.0;

                lineoff = viewarea.calcViewRay(x + pixelOffset, y, cctowc);

                right = lineoff.pos.add(lineoff.dir.multiply(dist * sceneSize));
                right = right.subtract(pickPos).normalize();

                index = 8;      // get top pixel
                dist = pixelData[index] / 255.0;

                lineoff = viewarea.calcViewRay(x, y - pixelOffset, cctowc);

                up = lineoff.pos.add(lineoff.dir.multiply(dist * sceneSize));
                up = up.subtract(pickPos).normalize();

                pickNorm = right.cross(up).normalize();
            }
            else if (pickMode == 4) {
                objId += 256 * pixelData[index + 2];

                shapeId  =       pixelData[index + 1];
                shapeId += 256 * pixelData[index    ];

                // check if standard shape picked without special shadow id
                if (objId == 0 && (shapeId > 0 && shapeId < baseID)) {
                    objId = shapeId;
                }
            }
            else {
                pickPos.x = pixelData[index    ];
                pickPos.y = pixelData[index + 1];
                pickPos.z = pixelData[index + 2];
            }
            //x3dom.debug.logInfo(pickPos + " / " + objId);

            var eventType = "shadowObjectIdChanged";
            var shadowObjectIdChanged, event;
            var button = Math.max(buttonState >>> 8, buttonState & 255);

            if (objId >= baseID) {
                objId -= baseID;

                var hitObject;

                if (pickMode != 4) {
                    viewarea._pickingInfo.pickPos = pickPos;
                    viewarea._pick.setValues(pickPos);

                    viewarea._pickingInfo.pickNorm = pickNorm;
                    viewarea._pickNorm.setValues(pickNorm);

                    viewarea._pickingInfo.pickObj = null;
                    viewarea._pickingInfo.lastClickObj = null;

                    hitObject = scene._xmlNode;
                }
                else {
                    viewarea._pickingInfo.pickObj = x3dom.nodeTypes.Shape.idMap.nodeID[shapeId];

                    hitObject = viewarea._pickingInfo.pickObj._xmlNode;
                }

                shadowObjectIdChanged = (viewarea._pickingInfo.shadowObjectId != objId);
                viewarea._pickingInfo.shadowObjectId = objId;
                //x3dom.debug.logInfo(baseID + " + " + objId);

                if ((shadowObjectIdChanged || button) && scene._xmlNode &&
                    (scene._xmlNode["on" + eventType] || scene._xmlNode.hasAttribute("on" + eventType) ||
                     scene._listeners[eventType]))
                {
                    event = {
                        target: scene._xmlNode,
                        type: eventType,
                        button: button, mouseup: ((buttonState >>> 8) > 0),
                        layerX: x, layerY: y,
                        shadowObjectId: objId,
                        worldX: pickPos.x, worldY: pickPos.y, worldZ: pickPos.z,
                        normalX: pickNorm.x, normalY: pickNorm.y, normalZ: pickNorm.z,
                        hitPnt: pickPos.toGL(),
                        hitObject: hitObject,
                        cancelBubble: false,
                        stopPropagation: function () { this.cancelBubble = true; },
                        preventDefault:  function () { this.cancelBubble = true; }
                    };
                    scene.callEvtHandler(("on" + eventType), event);
                }

                if (scene._shadowIdMap && scene._shadowIdMap.mapping) {
                    var shIds = scene._shadowIdMap.mapping[objId].usage;
                    // find corresponding dom tree object
                    for (var c = 0; c < shIds.length; c++) {
                        var shObj = scene._nameSpace.defMap[shIds[c]];
                        // FIXME; bbox test too coarse (+ should include trafo)
                        if (shObj.doIntersect(line)) {
                            viewarea._pickingInfo.pickObj = shObj;
                            break;
                        }
                    }
                }
            }
            else {
                shadowObjectIdChanged = (viewarea._pickingInfo.shadowObjectId != -1);
                viewarea._pickingInfo.shadowObjectId = -1;     // nothing hit

                if ( shadowObjectIdChanged && scene._xmlNode &&
                    (scene._xmlNode["on" + eventType] || scene._xmlNode.hasAttribute("on" + eventType) ||
                     scene._listeners[eventType]) )
                {
                    event = {
                        target: scene._xmlNode,
                        type: eventType,
                        button: button, mouseup: ((buttonState >>> 8) > 0),
                        layerX: x, layerY: y,
                        shadowObjectId: viewarea._pickingInfo.shadowObjectId,
                        cancelBubble: false,
                        stopPropagation: function () { this.cancelBubble = true; },
                        preventDefault:  function () { this.cancelBubble = true; }
                    };
                    scene.callEvtHandler(("on" + eventType), event);
                }

                if (objId > 0) {
                    //x3dom.debug.logInfo(x3dom.nodeTypes.Shape.idMap.nodeID[objId]._DEF + " // " +
                    //                    x3dom.nodeTypes.Shape.idMap.nodeID[objId]._xmlNode.localName);
                    viewarea._pickingInfo.pickPos = pickPos;
                    viewarea._pickingInfo.pickNorm = pickNorm;
                    viewarea._pickingInfo.pickObj = x3dom.nodeTypes.Shape.idMap.nodeID[objId];
                }
                else {
                    viewarea._pickingInfo.pickObj = null;
                    //viewarea._pickingInfo.lastObj = null;
                    viewarea._pickingInfo.lastClickObj = null;
                }
            }
        }

        var pickTime = x3dom.Utils.stopMeasure("picking");
        this.x3dElem.runtime.addMeasurement('PICKING', pickTime);

        return true;
    };

    /*****************************************************************************
     * Render ColorBuffer-Pass for picking sub window
     *****************************************************************************/
    Context.prototype.pickRect = function (viewarea, x1, y1, x2, y2)
    {
        var gl = this.ctx3d;
        var scene = viewarea ? viewarea._scene : null;

        // method requires that scene has already been rendered at least once
        if (!gl || !scene || !scene._webgl || !scene.drawableCollection)
            return false;

        // values not fully correct but unnecessary anyway, just to feed the shader
        var from = viewarea._last_mat_view.inverse().e3();
        var sceneSize = scene._lastMax.subtract(scene._lastMin).length();

        var x = (x1 <= x2) ? x1 : x2;
        var y = (y1 >= y2) ? y1 : y2;
        var width  = (1 + Math.abs(x2 - x1)) * scene._webgl.pickScale;
        var height = (1 + Math.abs(y2 - y1)) * scene._webgl.pickScale;

        // render to texture for reading pixel values
        this.renderPickingPass(gl, scene, viewarea._last_mat_view, viewarea._last_mat_scene,
               from, sceneSize, 0, x, y, (width < 1) ? 1 : width, (height < 1) ? 1 : height);

        var index;
        var pickedObjects = [];

        // get objects in rectangle
        for (index = 0; scene._webgl.fboPick.pixelData &&
                        index < scene._webgl.fboPick.pixelData.length; index += 4) {
            var objId = scene._webgl.fboPick.pixelData[index + 3] +
                scene._webgl.fboPick.pixelData[index + 2] * 256;

            if (objId > 0)
                pickedObjects.push(objId);
        }
        pickedObjects.sort();

        // make found object IDs unique
        var pickedObjectsTemp = (function (arr) {
            var a = [], l = arr.length;
            for (var i = 0; i < l; i++) {
                for (var j = i + 1; j < l; j++) {
                    if (arr[i] === arr[j])
                        j = ++i;
                }
                a.push(arr[i]);
            }
            return a;
        })(pickedObjects);
        pickedObjects = pickedObjectsTemp;

        var pickedNodes = [];

        for (index = 0; index < pickedObjects.length; index++) {
            var obj = pickedObjects[index];

            obj = x3dom.nodeTypes.Shape.idMap.nodeID[obj];
            obj = (obj && obj._xmlNode) ? obj._xmlNode : null;

            if (obj)
                pickedNodes.push(obj);
        }

        return pickedNodes;
    };

    /*****************************************************************************
     * Render Scene (Main-Pass)
     *****************************************************************************/
    Context.prototype.renderScene = function (viewarea)
    {
        var gl = this.ctx3d;
        var scene = viewarea._scene;

        if (gl === null || scene === null) {
            return;
        }

        var rentex = viewarea._doc._nodeBag.renderTextures;
        var rt_tex, rtl_i, rtl_n = rentex.length;

        // for initFbo
        var type = gl.UNSIGNED_BYTE;
        var shadowType = gl.UNSIGNED_BYTE;
        var nearestFilt = false;

        if (x3dom.caps.FP_TEXTURES && !x3dom.caps.MOBILE) {
            type = gl.FLOAT;
            shadowType = gl.FLOAT;
            if (!x3dom.caps.FPL_TEXTURES) {
                nearestFilt = true;
            }
        }

        var shadowedLights, numShadowMaps;
        var i, j, n, size, sizeAvailable;

        scene.updateVolume();
		
        if (!scene._webgl)
        {
            scene._webgl = {};

            this.setupFgnds(gl, scene);

            // scale factor for mouse coords and width/ height (low res for speed-up)
            scene._webgl.pickScale = 0.5;

            scene._webgl._currFboWidth = Math.round(this.canvas.width * scene._webgl.pickScale);
            scene._webgl._currFboHeight = Math.round(this.canvas.height * scene._webgl.pickScale);

            // TODO: FIXME when spec ready: readPixels not (yet?) available for float textures
            // https://bugzilla.mozilla.org/show_bug.cgi?id=681903
            // https://www.khronos.org/webgl/public-mailing-list/archives/1108/msg00025.html
            scene._webgl.fboPick = this.initFbo(gl,
                                   scene._webgl._currFboWidth, scene._webgl._currFboHeight, true, gl.UNSIGNED_BYTE);
            scene._webgl.fboPick.pixelData = null;

            //Set picking shaders
            scene._webgl.pickShader = this.cache.getShader(gl, x3dom.shader.PICKING);
            scene._webgl.pickShader24 = this.cache.getShader(gl, x3dom.shader.PICKING_24);
            scene._webgl.pickShaderId = this.cache.getShader(gl, x3dom.shader.PICKING_ID);
            scene._webgl.pickColorShader = this.cache.getShader(gl, x3dom.shader.PICKING_COLOR);
            scene._webgl.pickTexCoordShader = this.cache.getShader(gl, x3dom.shader.PICKING_TEXCOORD);

            scene._webgl.normalShader = this.cache.getShader(gl, x3dom.shader.NORMAL);

            //Initialize shadow maps
			scene._webgl.fboShadow = [];
			
			shadowedLights = viewarea.getShadowedLights();
            n = shadowedLights.length;

			for (i=0; i<n; i++)
            {
				size = shadowedLights[i]._vf.shadowMapSize;

				if (!x3dom.isa(shadowedLights[i], x3dom.nodeTypes.PointLight))
					//cascades for directional lights
					numShadowMaps = Math.max(1,Math.min(shadowedLights[i]._vf.shadowCascades,6));		
				else 
					//six maps for point lights
					numShadowMaps = 6;
					
				scene._webgl.fboShadow[i] = [];
				
				for (j=0; j < numShadowMaps; j++)
					scene._webgl.fboShadow[i][j] = this.initFbo(gl, size, size, nearestFilt, shadowType);
			}
			
			if (scene._webgl.fboShadow.length > 0)
				scene._webgl.fboScene = this.initFbo(gl, this.canvas.width, this.canvas.height, nearestFilt, shadowType);
			scene._webgl.fboBlur = [];
						
			//initialize blur fbo (different fbos for different sizes)
			for (i=0; i<n; i++)
            {
				size = scene._webgl.fboShadow[i][0].height;
				sizeAvailable = false;

				for (j = 0; j < scene._webgl.fboBlur.length; j++){
					if (size == scene._webgl.fboBlur[j].height) 
						sizeAvailable = true;
				}
				if (!sizeAvailable) 
					scene._webgl.fboBlur[scene._webgl.fboBlur.length] = this.initFbo(gl, size, size, nearestFilt, shadowType);
			}
			
			//initialize Data for post processing
			scene._webgl.ppBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, scene._webgl.ppBuffer);
			var vertices = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);		
			
			scene._webgl.shadowShader = this.cache.getShader(gl, x3dom.shader.SHADOW);
            
            // TODO; for testing do it on init, but must be refreshed on node change!
            for (rtl_i = 0; rtl_i < rtl_n; rtl_i++) {
                rt_tex = rentex[rtl_i];
                rt_tex._webgl = {};
                rt_tex._webgl.fbo = this.initFbo(gl,
                    rt_tex._vf.dimensions[0],
                    rt_tex._vf.dimensions[1], nearestFilt, type);
            }

            viewarea._last_mat_view = x3dom.fields.SFMatrix4f.identity();
            viewarea._last_mat_proj = x3dom.fields.SFMatrix4f.identity();
            viewarea._last_mat_scene = x3dom.fields.SFMatrix4f.identity();

            this._calledViewpointChangedHandler = false;
        }
        else // updates needed?
        {
            var fboWidth = Math.round(this.canvas.width * scene._webgl.pickScale);
            var fboHeight = Math.round(this.canvas.height * scene._webgl.pickScale);

            if (scene._webgl._currFboWidth !== fboWidth ||
                scene._webgl._currFboHeight !== fboHeight) {
                scene._webgl._currFboWidth = fboWidth;
                scene._webgl._currFboHeight = fboHeight;

                scene._webgl.fboPick = this.initFbo(gl, fboWidth, fboHeight, true, scene._webgl.fboPick.typ);
                scene._webgl.fboPick.pixelData = null;

                x3dom.debug.logInfo("Refreshed picking FBO to size (" + fboWidth + ", " + fboHeight + ")");
            }

            for (rtl_i = 0; rtl_i < rtl_n; rtl_i++) {
                rt_tex = rentex[rtl_i];
                if (rt_tex._webgl && rt_tex._webgl.fbo &&
                    rt_tex._webgl.fbo.width  == rt_tex._vf.dimensions[0] &&
                    rt_tex._webgl.fbo.height == rt_tex._vf.dimensions[1])
                    continue;

                rt_tex.invalidateGLObject();
                rt_tex._webgl = {};
                rt_tex._webgl.fbo = this.initFbo(gl,
                                    rt_tex._vf.dimensions[0], rt_tex._vf.dimensions[1], nearestFilt, type);
                x3dom.debug.logInfo("Init/resize RenderedTexture_" + rtl_i + " to size " +
                                    rt_tex._vf.dimensions[0] + " x " + rt_tex._vf.dimensions[1]);
            }			
			
			//reinitialize shadow fbos if necessary
			shadowedLights = viewarea.getShadowedLights();
            n = shadowedLights.length;

			for (i=0; i<n; i++) {
				size = shadowedLights[i]._vf.shadowMapSize;

				if (!x3dom.isa(shadowedLights[i], x3dom.nodeTypes.PointLight))
					//cascades for directional lights
					numShadowMaps = Math.max(1,Math.min(shadowedLights[i]._vf.shadowCascades,6));				
				else 
					//six maps for point lights
					numShadowMaps = 6;		
				
				if (typeof scene._webgl.fboShadow[i] === "undefined" ||
                    scene._webgl.fboShadow[i].length != numShadowMaps ||
					scene._webgl.fboShadow[i][0].height != size) {
					scene._webgl.fboShadow[i] = [];
					for (j=0;j<numShadowMaps;j++){
						scene._webgl.fboShadow[i][j] = this.initFbo(gl, size, size, nearestFilt, shadowType);
					}
				}			
			}
			
			//reinitialize blur fbos if necessary
			for (i=0; i<n; i++){
				size = scene._webgl.fboShadow[i][0].height;
				
				sizeAvailable = false;
				for (j = 0; j < scene._webgl.fboBlur.length; j++){
					if (size == scene._webgl.fboBlur[j].height) 
						sizeAvailable = true;
				}
				if (!sizeAvailable) 
					scene._webgl.fboBlur[scene._webgl.fboBlur.length] = this.initFbo(gl, size, size, nearestFilt, shadowType);
			}

			if (scene._webgl.fboShadow.length > 0 && typeof scene._webgl.fboScene == "undefined" || scene._webgl.fboScene &&
				(this.canvas.width != scene._webgl.fboScene.width || this.canvas.height != scene._webgl.fboScene.height)) {
				scene._webgl.fboScene = this.initFbo(gl, this.canvas.width, this.canvas.height, nearestFilt, shadowType);
			}
        }

        var env = scene.getEnvironment();
        // update internal flags
        env.checkSanity();

        var bgnd = scene.getBackground();
        // setup or update bgnd
        this.setupScene(gl, bgnd);

        this.numFaces = 0;
        this.numCoords = 0;
        this.numDrawCalls = 0;

        var mat_proj = viewarea.getProjectionMatrix();
        var mat_view = viewarea.getViewMatrix();

        // fire viewpointChanged event
        if (!this._calledViewpointChangedHandler || !viewarea._last_mat_view.equals(mat_view)) {
            var e_viewpoint = scene.getViewpoint();
            var e_eventType = "viewpointChanged";

            try {
                if ( e_viewpoint._xmlNode &&
                    (e_viewpoint._xmlNode["on" + e_eventType] ||
                     e_viewpoint._xmlNode.hasAttribute("on" + e_eventType) ||
                     e_viewpoint._listeners[e_eventType]) ) {
                    var e_viewtrafo = e_viewpoint.getCurrentTransform();
                    e_viewtrafo = e_viewtrafo.inverse().mult(mat_view);
                    var e_mat = e_viewtrafo.inverse();

                    var e_rotation = new x3dom.fields.Quaternion(0, 0, 1, 0);
                    e_rotation.setValue(e_mat);
                    var e_translation = e_mat.e3();

                    var e_event = {
                        target: e_viewpoint._xmlNode,
                        type: e_eventType,
                        matrix: e_viewtrafo,
                        position: e_translation,
                        orientation: e_rotation.toAxisAngle(),
                        cancelBubble: false,
                        stopPropagation: function () { this.cancelBubble = true; },
                        preventDefault:  function () { this.cancelBubble = true; }
                    };

                    e_viewpoint.callEvtHandler(("on" + e_eventType), e_event);

                    this._calledViewpointChangedHandler = true;
                }
            }
            catch (e_e) {
                x3dom.debug.logException(e_e);
            }
        }

        viewarea._last_mat_view = mat_view;
        viewarea._last_mat_proj = mat_proj;

        var mat_scene = mat_proj.mult(mat_view);  //viewarea.getWCtoCCMatrix();
        viewarea._last_mat_scene = mat_scene;


        //===========================================================================
        // Collect drawables (traverse)
        //===========================================================================
        scene.drawableCollection = null;  // Always update needed?

        if (!scene.drawableCollection)
        {
            var drawableCollectionConfig = {
                viewArea: viewarea,
                sortTrans: env._vf.sortTrans,
                viewMatrix: mat_view,
                projMatrix: mat_proj,
                sceneMatrix: mat_scene,
                frustumCulling: true,
                smallFeatureThreshold: env._smallFeatureThreshold,
                context: this,
                gl: gl
            };

            scene.drawableCollection = new x3dom.DrawableCollection(drawableCollectionConfig);

            x3dom.Utils.startMeasure('traverse');

            scene.collectDrawableObjects(x3dom.fields.SFMatrix4f.identity(), scene.drawableCollection, true, false, 0);

            var traverseTime = x3dom.Utils.stopMeasure('traverse');
            this.x3dElem.runtime.addMeasurement('TRAVERSE', traverseTime);
        }

        //===========================================================================
        // Sort drawables
        //===========================================================================      
        x3dom.Utils.startMeasure('sorting');

        scene.drawableCollection.sort();

        var sortTime = x3dom.Utils.stopMeasure('sorting');
        this.x3dElem.runtime.addMeasurement('SORT', sortTime);

        //===========================================================================
        // Render Shadow Pass
        //===========================================================================
        var slights = viewarea.getLights();
        var numLights = slights.length;
        var mat_light;
        var WCToLCMatrices = [];
        var lMatrices = [];
        var shadowCount = 0;

        x3dom.Utils.startMeasure('shadow');

        for (var p = 0; p < numLights; p++) {
            if (slights[p]._vf.shadowIntensity > 0.0) {

                var lightMatrix = viewarea.getLightMatrix()[p];
                shadowMaps = scene._webgl.fboShadow[shadowCount];
                var offset = Math.max(0.0, Math.min(1.0, slights[p]._vf.shadowOffset));

                if (!x3dom.isa(slights[p], x3dom.nodeTypes.PointLight)) {
                    //get cascade count
                    var numCascades = Math.max(1, Math.min(slights[p]._vf.shadowCascades, 6));

                    //calculate transformation matrices
                    mat_light = viewarea.getWCtoLCMatricesCascaded(lightMatrix, slights[p], mat_proj);

                    //render shadow pass
                    for (i = 0; i < numCascades; i++) {
                        this.renderShadowPass(gl, viewarea, mat_light[i], mat_view, shadowMaps[i], offset, false);
                    }
                }
                else {
                    //for point lights 6 render passes
                    mat_light = viewarea.getWCtoLCMatricesPointLight(lightMatrix, slights[p], mat_proj);
                    for (i = 0; i < 6; i++) {
                        this.renderShadowPass(gl, viewarea, mat_light[i], mat_view, shadowMaps[i], offset, false);
                    }
                }
                shadowCount++;

                //save transformations for shadow rendering
                WCToLCMatrices[WCToLCMatrices.length] = mat_light;
                lMatrices[lMatrices.length] = lightMatrix;
            }
        }

        //One pass for depth of scene from camera view (to enable post-processing shading)
        if (shadowCount > 0) {
            this.renderShadowPass(gl, viewarea, mat_scene, mat_view, scene._webgl.fboScene, 0.0, true);
            var shadowTime = x3dom.Utils.stopMeasure('shadow');
            this.x3dElem.runtime.addMeasurement('SHADOW', shadowTime);
        }
        else {
            this.x3dElem.runtime.removeMeasurement('SHADOW');
        }

        mat_light = viewarea.getWCtoLCMatrix(viewarea.getLightMatrix()[0]);

        for (rtl_i = 0; rtl_i < rtl_n; rtl_i++) {
            this.renderRTPass(gl, viewarea, rentex[rtl_i]);
        }

        // rendering
        x3dom.Utils.startMeasure('render');

        this.stateManager.viewport(0, 0, this.canvas.width, this.canvas.height);

        // calls gl.clear etc. (bgnd stuff)
        bgnd._webgl.render(gl, mat_view, mat_proj);

        x3dom.nodeTypes.PopGeometry.numRenderedVerts = 0;
        x3dom.nodeTypes.PopGeometry.numRenderedTris = 0;

        n = scene.drawableCollection.length;

        // Very, very experimental priority culling, currently coupled with frustum and small feature culling
        // TODO; what about shadows?
        if (env._vf.smallFeatureCulling && env._lowPriorityThreshold < 1 && viewarea.isMovingOrAnimating()) {
            n = Math.floor(n * env._lowPriorityThreshold);
            if (!n && scene.drawableCollection.length)
                n = 1;   // render at least one object
        }

        this.stateManager.unsetProgram();

        // render all remaining shapes
        for (i = 0; i < n; i++) {
            var drawable = scene.drawableCollection.get(i);

            this.renderShape(drawable, viewarea, slights, numLights, mat_view, mat_scene, mat_light, mat_proj, gl);
        }

        if (shadowCount > 0)
            this.renderShadows(gl, viewarea, shadowedLights, WCToLCMatrices, lMatrices, mat_view, mat_proj, mat_scene);

        this.stateManager.disable(gl.BLEND);
        this.stateManager.disable(gl.DEPTH_TEST);

        viewarea._numRenderedNodes = n;

        // if _visDbgBuf then show helper buffers in foreground for debugging
        if (viewarea._visDbgBuf !== undefined && viewarea._visDbgBuf)
        {
            var pm = scene._vf.pickMode.toLowerCase();

            if (pm.indexOf("idbuf") == 0 || pm == "color" || pm == "texcoord") {
                this.stateManager.viewport(0, 3 * this.canvas.height / 4,
                                           this.canvas.width / 4, this.canvas.height / 4);
                scene._fgnd._webgl.render(gl, scene._webgl.fboPick.tex);
            }

            if (shadowCount > 0) {
                this.stateManager.viewport(this.canvas.width / 4, 3 * this.canvas.height / 4,
                                           this.canvas.width / 4, this.canvas.height / 4);
                scene._fgnd._webgl.render(gl, scene._webgl.fboScene.tex);
            }

            var row = 3, col = 2;
            for (i = 0; i < shadowCount; i++) {
                var shadowMaps = scene._webgl.fboShadow[i];
                for (j = 0; j < shadowMaps.length; j++) {
                    this.stateManager.viewport(col * this.canvas.width / 4, row * this.canvas.height / 4,
                                               this.canvas.width / 4, this.canvas.height / 4);
                    scene._fgnd._webgl.render(gl, shadowMaps[j].tex);
                    if (col < 2) {
                        col++;
                    } else {
                        col = 0;
                        row--;
                    }
                }
            }

            for (rtl_i = 0; rtl_i < rtl_n; rtl_i++) {
                rt_tex = rentex[rtl_i];

                this.stateManager.viewport(rtl_i * this.canvas.width / 8, 5 * this.canvas.height / 8,
                                           this.canvas.width / 8, this.canvas.height / 8);
                scene._fgnd._webgl.render(gl, rt_tex._webgl.fbo.tex);
            }
        }

        gl.finish();
        //gl.flush();

        var renderTime = x3dom.Utils.stopMeasure('render');

        this.x3dElem.runtime.addMeasurement('RENDER', renderTime);
        this.x3dElem.runtime.addMeasurement('DRAW', (n ? renderTime / n : 0));

        this.x3dElem.runtime.addInfo('#NODES:', scene.drawableCollection.numberOfNodes);
        this.x3dElem.runtime.addInfo('#SHAPES:', viewarea._numRenderedNodes);
        this.x3dElem.runtime.addInfo("#DRAWS:", this.numDrawCalls);
        this.x3dElem.runtime.addInfo("#POINTS:", this.numCoords);
        this.x3dElem.runtime.addInfo("#TRIS:", this.numFaces);

        //scene.drawableObjects = null;
    };

    /*****************************************************************************
     * Render RenderedTexture-Pass
     *****************************************************************************/
    Context.prototype.renderRTPass = function (gl, viewarea, rt)
    {
        switch (rt._vf.update.toUpperCase()) {
            case "NONE":
                return;
            case "NEXT_FRAME_ONLY":
                if (!rt._needRenderUpdate) {
                    return;
                }
                rt._needRenderUpdate = false;
                break;
            case "ALWAYS":
            default:
                break;
        }

        var scene = viewarea._scene;
        var bgnd = null;

        var mat_view = rt.getViewMatrix();
        var mat_proj = rt.getProjectionMatrix();
        var mat_scene = mat_proj.mult(mat_view);

        var lightMatrix = viewarea.getLightMatrix()[0];
        var mat_light = viewarea.getWCtoLCMatrix(lightMatrix);

        var i, n, m = rt._cf.excludeNodes.nodes.length;

        var arr = new Array(m);
        for (i = 0; i < m; i++) {
            var render = rt._cf.excludeNodes.nodes[i]._vf.render;
            if (render === undefined) {
                arr[i] = -1;
            }
            else {
                if (render === true) {
                    arr[i] = 1;
                } else {
                    arr[i] = 0;
                }
            }
            rt._cf.excludeNodes.nodes[i]._vf.render = false;
        }

        this.stateManager.bindFramebuffer(gl.FRAMEBUFFER, rt._webgl.fbo.fbo);

        this.stateManager.viewport(0, 0, rt._webgl.fbo.width, rt._webgl.fbo.height);

        if (rt._cf.background.node === null) {
            gl.clearColor(0, 0, 0, 1);
            gl.clearDepth(1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
        }
        else if (rt._cf.background.node === scene.getBackground()) {
            bgnd = scene.getBackground();
            bgnd._webgl.render(gl, mat_view, mat_proj);
        }
        else {
            bgnd = rt._cf.background.node;
            this.setupScene(gl, bgnd);
            bgnd._webgl.render(gl, mat_view, mat_proj);
        }

        this.stateManager.depthFunc(gl.LEQUAL);
        this.stateManager.enable(gl.DEPTH_TEST);
        this.stateManager.enable(gl.CULL_FACE);

        this.stateManager.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
        this.stateManager.enable(gl.BLEND);

        var slights = viewarea.getLights();
        var numLights = slights.length;

        var transform, shape, drawable;
        var locScene = rt._cf.scene.node;

        if (!locScene || locScene === scene) {
            n = scene.drawableCollection.length;

            if (rt._vf.showNormals) {
                this.renderNormals(gl, scene, scene._webgl.normalShader, mat_view, mat_scene);
            }
            else {
                this.stateManager.unsetProgram();

                for (i = 0; i < n; i++) {
                    drawable = scene.drawableCollection.get(i);

                    this.renderShape(drawable, viewarea, slights, numLights,
                                     mat_view, mat_scene, mat_light, mat_proj, gl);
                }
            }
        }
        else {
            var env = scene.getEnvironment();

            var drawableCollectionConfig = {
                viewArea: viewarea,
                sortTrans: env._vf.sortTrans,
                viewMatrix: mat_view,
                projMatrix: mat_proj,
                sceneMatrix: mat_scene,
                frustumCulling: false,
                smallFeatureThreshold: 1,
                context: this,
                gl: gl
            };

            locScene.numberOfNodes = 0;
            locScene.drawableCollection = new x3dom.DrawableCollection(drawableCollectionConfig);

            locScene.collectDrawableObjects(x3dom.fields.SFMatrix4f.identity(),
                                            locScene.drawableCollection, true, false, 0);

            locScene.drawableCollection.sort();

            n = locScene.drawableCollection.length;

            if (rt._vf.showNormals) {
                this.renderNormals(gl, locScene, scene._webgl.normalShader, mat_view, mat_scene);
            }
            else {
                this.stateManager.unsetProgram();

                for (i = 0; i < n; i++) {
                    drawable = locScene.drawableCollection.get(i);

                    if (!drawable.shape._vf.render) {
                        continue;
                    }

                    this.renderShape(drawable, viewarea, slights, numLights,
                                     mat_view, mat_scene, mat_light, mat_proj, gl);
                }
            }
        }

        this.stateManager.disable(gl.BLEND);
        this.stateManager.disable(gl.DEPTH_TEST);

        gl.flush();
        this.stateManager.bindFramebuffer(gl.FRAMEBUFFER, null);

        for (i = 0; i < m; i++) {
            if (arr[i] !== 0) {
                rt._cf.excludeNodes.nodes[i]._vf.render = true;
            }
        }
    };

    /*****************************************************************************
     * Render Normals
     *****************************************************************************/
    Context.prototype.renderNormals = function (gl, scene, sp, mat_view, mat_scene)
    {
        if (!sp || !scene) {  // error
            return;
        }

        this.stateManager.depthFunc(gl.LEQUAL);
        this.stateManager.enable(gl.DEPTH_TEST);
        this.stateManager.enable(gl.CULL_FACE);
        this.stateManager.disable(gl.BLEND);

        this.stateManager.useProgram(sp);

        var bgCenter = x3dom.fields.SFVec3f.NullVector.toGL();
        var bgSize = x3dom.fields.SFVec3f.OneVector.toGL();

        for (var i = 0, n = scene.drawableCollection.length; i < n; i++)
        {
            var drawable = scene.drawableCollection.get(i);
            var trafo = drawable.transform;
            var shape = drawable.shape;
            var s_gl = shape._webgl;

            if (!s_gl || !shape || !shape._vf.render) {
                continue;
            }

            var s_geo = shape._cf.geometry.node;
            var s_msh = s_geo._mesh;

            var model_view_inv = mat_view.mult(trafo).inverse();
            sp.normalMatrix = model_view_inv.transpose().toGL();
            sp.modelViewProjectionMatrix = mat_scene.mult(trafo).toGL();

            //Set ImageGeometry switch (TODO; also impl. in Shader!)
            sp.imageGeometry = s_gl.imageGeometry;

            if (s_gl.coordType != gl.FLOAT) {
                if (s_gl.bitLODGeometry != 0 || s_gl.popGeometry != 0 ||
                    (s_msh._numPosComponents == 4 && x3dom.Utils.isUnsignedType(s_geo._vf.coordType)))
                    sp.bgCenter = s_geo.getMin().toGL();
                else
                    sp.bgCenter = s_geo._vf.position.toGL();
                sp.bgSize = s_geo._vf.size.toGL();
                sp.bgPrecisionMax = s_geo.getPrecisionMax('coordType');
            }
            else {
                sp.bgCenter = bgCenter;
                sp.bgSize = bgSize;
                sp.bgPrecisionMax = 1;
            }
            if (s_gl.normalType != gl.FLOAT) {
                sp.bgPrecisionNorMax = s_geo.getPrecisionMax('normalType');
            }
            else {
                sp.bgPrecisionNorMax = 1;
            }

            if (shape.isSolid()) {
                this.stateManager.enable(gl.CULL_FACE);

                if (shape.isCCW()) {
                    this.stateManager.frontFace(gl.CCW);
                }
                else {
                    this.stateManager.frontFace(gl.CW);
                }
            }
            else {
                this.stateManager.disable(gl.CULL_FACE);
            }


            // render shape
            for (var q = 0, q_n = s_gl.positions.length; q < q_n; q++) {
                var q5 = 5 * q;
                var v, v_n, offset;

                if ( !(sp.position !== undefined && s_gl.buffers[q5 + 1] && s_gl.indexes[q]) )
                    continue;

                // bind buffers
                if (s_gl.buffers[q5]) {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, s_gl.buffers[q5]);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, s_gl.buffers[q5 + 1]);

                gl.vertexAttribPointer(sp.position,
                    s_msh._numPosComponents, s_gl.coordType, false,
                    shape._coordStrideOffset[0], shape._coordStrideOffset[1]);
                gl.enableVertexAttribArray(sp.position);

                if (sp.normal !== undefined && s_gl.buffers[q5 + 2]) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, s_gl.buffers[q5 + 2]);

                    gl.vertexAttribPointer(sp.normal,
                        s_msh._numNormComponents, s_gl.normalType, false,
                        shape._normalStrideOffset[0], shape._normalStrideOffset[1]);
                    gl.enableVertexAttribArray(sp.normal);
                }

                // draw mesh
                if (s_gl.binaryGeometry > 0 || s_gl.popGeometry > 0 || s_gl.bitLODGeometry > 0) {
                    for (v = 0, offset = 0, v_n = s_geo._vf.vertexCount.length; v < v_n; v++) {
                        gl.drawElements(s_gl.primType[v], s_geo._vf.vertexCount[v], s_gl.indexType,
                                        x3dom.Utils.getByteAwareOffset(offset, s_gl.indexType, gl));
                        offset += s_geo._vf.vertexCount[v];
                    }
                }
                else if (s_gl.binaryGeometry < 0 || s_gl.popGeometry < 0 || s_gl.bitLODGeometry < 0 || s_gl.imageGeometry) {
                    if (s_gl.bitLODtotalVertexCount !== undefined) {
                        gl.drawArrays(gl.TRIANGLES, 0, s_gl.bitLODtotalVertexCount);
                    }
                    else {
                        for (v = 0, offset = 0, v_n = s_geo._vf.vertexCount.length; v < v_n; v++) {
                            gl.drawArrays(s_gl.primType[v], offset, s_geo._vf.vertexCount[v]);
                            offset += s_geo._vf.vertexCount[v];
                        }
                    }
                }
                else if (s_geo.hasIndexOffset()) {
                    var indOff = shape.tessellationProperties();
                    for (v = 0, v_n = indOff.length; v < v_n; v++) {
                        gl.drawElements(s_gl.primType, indOff[v].count, s_gl.indexType,
                            indOff[v].offset * x3dom.Utils.getOffsetMultiplier(s_gl.indexType, gl));
                    }
                }
                else if (s_gl.indexes[q].length == 0) {
                    gl.drawArrays(s_gl.primType, 0, s_gl.positions[q].length / 3);
                }
                else {
                    gl.drawElements(s_gl.primType, s_gl.indexes[q].length, s_gl.indexType, 0);
                }

                gl.disableVertexAttribArray(sp.position);

                if (sp.normal !== undefined) {
                    gl.disableVertexAttribArray(sp.normal);
                }
            }
        }
    };

    /*****************************************************************************
     * Cleanup
     *****************************************************************************/
    Context.prototype.shutdown = function (viewarea) {
        var gl = this.ctx3d;
        var scene = viewarea._scene;

        if (gl == null || !scene) {
            return;
        }

        var bgnd = scene.getBackground();
        if (bgnd._webgl.position !== undefined) {
            gl.deleteBuffer(bgnd._webgl.buffers[1]);
            gl.deleteBuffer(bgnd._webgl.buffers[0]);
        }
        var fgnd = scene._fgnd;
        if (fgnd._webgl.position !== undefined) {
            gl.deleteBuffer(fgnd._webgl.buffers[1]);
            gl.deleteBuffer(fgnd._webgl.buffers[0]);
        }

        var n = scene.drawableCollection ? scene.drawableCollection.length : 0;
        for (var i = 0; i < n; i++) {
            var shape = scene.drawableCollection.get(i).shape;

            if (shape._cleanupGLObjects)
                shape._cleanupGLObjects(true);
        }

        //Release Texture and Shader Resources
        this.cache.Release(gl);
    };

    /*****************************************************************************
     * Start of fbo init stuff
     *****************************************************************************/
    Context.prototype.emptyTexImage2D = function (gl, internalFormat, width, height, format, type) {
        try {
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, null);
        }
        catch (e) {
            // seems to be no longer necessary, but anyway...
            var bytes = 3;
            switch (internalFormat) {
                case gl.DEPTH_COMPONENT:
                    bytes = 3;
                    break;
                case gl.ALPHA:
                    bytes = 1;
                    break;
                case gl.RGB:
                    bytes = 3;
                    break;
                case gl.RGBA:
                    bytes = 4;
                    break;
                case gl.LUMINANCE:
                    bytes = 1;
                    break;
                case gl.LUMINANCE_ALPHA:
                    bytes = 2;
                    break;
            }
            var pixels = new Uint8Array(width * height * bytes);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, pixels);
        }
    };

    /*****************************************************************************
     * Init Texture
     *****************************************************************************/
    Context.prototype.initTex = function (gl, w, h, nearest, type) {
        var tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);

        this.emptyTexImage2D(gl, gl.RGBA, w, h, gl.RGBA, type);
        //this.emptyTexImage2D(gl, gl.DEPTH_COMPONENT16, w, h, gl.DEPTH_COMPONENT, gl.UNSIGNED_BYTE);

        if (nearest) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        }
        else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        }
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        //gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);

        tex.width = w;
        tex.height = h;

        return tex;
    };

    /*****************************************************************************
     * Creates FBO with given size
     * (taken from FBO utilities for WebGL by Emanuele Ruffaldi 2009)
     *
     * Returned Object has rbo, fbo, tex, width, height
     *****************************************************************************/
    Context.prototype.initFbo = function (gl, w, h, nearest, type) {
        var fbo = gl.createFramebuffer();
        var rb = gl.createRenderbuffer();

        var tex = this.initTex(gl, w, h, nearest, type);

        this.stateManager.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.bindRenderbuffer(gl.RENDERBUFFER, rb);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);

        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, rb);
        this.stateManager.bindFramebuffer(gl.FRAMEBUFFER, null);

        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status != gl.FRAMEBUFFER_COMPLETE)
            x3dom.debug.logWarning("[Context|InitFBO] FBO-Status: " + status);

        return {
            fbo: fbo,
            rbo: rb,
            tex: tex,
            width: w,
            height: h,
            typ: type
        };
    };
	
	/*****************************************************************************
    * Draw shadows on screen
    *****************************************************************************/
	Context.prototype.renderShadows = function(gl, viewarea, shadowedLights, wctolc, lMatrices,
                                               mat_view, mat_proj, mat_scene)
    {
		var scene = viewarea._scene;
		
		//don't render shadows with less than 7 textures per fragment shader
		var texLimit = x3dom.caps.MAX_TEXTURE_IMAGE_UNITS;
		
		if (texLimit < 7)
            return;
		
		var texUnits = 1;
		var renderSplit = [ 0 ];

        var shadowMaps, numShadowMaps;
        var i, j, k;
		
		//filter shadow maps and determine, if multiple render passes are needed		
		for (i = 0; i < shadowedLights.length; i++)
        {
            var filterSize = shadowedLights[i]._vf.shadowFilterSize;
            shadowMaps = scene._webgl.fboShadow[i];
            numShadowMaps = shadowMaps.length;

            //filtering
            for (j=0; j<numShadowMaps;j++){
                this.blurTex(gl, scene, shadowMaps[j], filterSize);
            }

            //shader consumes 6 tex units per lights (even if less are bound)
            texUnits+=6;

            if (texUnits > texLimit){
                renderSplit[renderSplit.length] = i;
                texUnits = 7;
            }
		}
		renderSplit[renderSplit.length] = shadowedLights.length;
		
		//render shadows for current render split
        var n = renderSplit.length - 1;
        var mat_proj_inv = mat_proj.inverse();
        var mat_scene_inv = mat_scene.inverse();

        //enable (multiplicative) blending
        this.stateManager.enable(gl.BLEND);
        this.stateManager.blendFunc(gl.DST_COLOR, gl.ZERO);

		for (var s=0; s<n; s++)
        {
			var startIndex = renderSplit[s];
			var endIndex = renderSplit[s+1];
		
			var currentLights = [];
			
			for (k=startIndex; k<endIndex; k++)
				currentLights[currentLights.length] = shadowedLights[k];

			var sp = this.cache.getShadowRenderingShader(gl, currentLights);

            this.stateManager.useProgram(sp);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, scene._webgl.ppBuffer);
			gl.vertexAttribPointer(sp.position, 2, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(sp.position);
			
			//bind depth texture (depth from camera view)
			sp.sceneMap = 0;
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, scene._webgl.fboScene.tex);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			
			//compute inverse projection matrix
			sp.inverseProj = mat_proj_inv.toGL();
			
			//compute inverse view projection matrix
			sp.inverseViewProj = mat_scene_inv.toGL();

			var mat_light;
			var lightMatrix;
			var shadowIndex = 0;

			for (var p=0, pn=currentLights.length; p<pn; p++) {
				//get light matrices and shadow maps for current light
				lightMatrix = lMatrices[p+startIndex];
				mat_light = wctolc[p+startIndex];
				shadowMaps = scene._webgl.fboShadow[p+startIndex]; 
				
				numShadowMaps = mat_light.length;
				
				for (i=0; i< numShadowMaps; i++){
						gl.activeTexture(gl.TEXTURE1 + shadowIndex);
						gl.bindTexture(gl.TEXTURE_2D, shadowMaps[i].tex);
						sp['light'+p+'_'+i+'_ShadowMap'] = shadowIndex+1;
						sp['light'+p+'_'+i+'_Matrix'] = mat_light[i].toGL();
						shadowIndex++;
				}
				sp['light'+p+'_ViewMatrix'] = lightMatrix.toGL();						

				//cascade depths for directional and spot light
				if (!x3dom.isa(currentLights[p], x3dom.nodeTypes.PointLight)){
					for (j=0; j< numShadowMaps; j++){
						var numCascades = Math.max(1,Math.min(currentLights[p]._vf.shadowCascades,6));
						var splitFactor = Math.max(0,Math.min(currentLights[p]._vf.shadowSplitFactor,1));					
						var splitOffset = Math.max(0,Math.min(currentLights[p]._vf.shadowSplitOffset,1));						
						
						var splitDepths = viewarea.getShadowSplitDepths(numCascades, splitFactor, splitOffset, false, mat_proj);
						sp['light'+p+'_'+j+'_Split'] = splitDepths[j+1];
					}
				}
			
				//assign light properties
				var light_transform = mat_view.mult(currentLights[p].getCurrentTransform());
				if(x3dom.isa(currentLights[p], x3dom.nodeTypes.DirectionalLight))
				{
					sp['light'+p+'_Type']             = 0.0;
					sp['light'+p+'_On']               = (currentLights[p]._vf.on) ? 1.0 : 0.0;
					sp['light'+p+'_Direction']        = light_transform.multMatrixVec(currentLights[p]._vf.direction).toGL();
					sp['light'+p+'_Attenuation']      = [1.0, 1.0, 1.0];
					sp['light'+p+'_Location']         = [1.0, 1.0, 1.0];
					sp['light'+p+'_Radius']           = 0.0;
					sp['light'+p+'_BeamWidth']        = 0.0;
					sp['light'+p+'_CutOffAngle']      = 0.0;
					sp['light'+p+'_ShadowIntensity']  = currentLights[p]._vf.shadowIntensity;
					sp['light'+p+'_ShadowCascades']   = currentLights[p]._vf.shadowCascades;
					sp['light'+p+'_ShadowOffset']     = Math.max(0.0,Math.min(1.0,currentLights[p]._vf.shadowOffset));
				}
				else if(x3dom.isa(currentLights[p], x3dom.nodeTypes.PointLight))
				{
					sp['light'+p+'_Type']             = 1.0;
					sp['light'+p+'_On']               = (currentLights[p]._vf.on) ? 1.0 : 0.0;
					sp['light'+p+'_Direction']        = [1.0, 1.0, 1.0];
					sp['light'+p+'_Attenuation']      = currentLights[p]._vf.attenuation.toGL();
					sp['light'+p+'_Location']         = light_transform.multMatrixPnt(currentLights[p]._vf.location).toGL();
					sp['light'+p+'_Radius']           = currentLights[p]._vf.radius;
					sp['light'+p+'_BeamWidth']        = 0.0;
					sp['light'+p+'_CutOffAngle']      = 0.0;
					sp['light'+p+'_ShadowIntensity']  = currentLights[p]._vf.shadowIntensity;
					sp['light'+p+'_ShadowOffset']	  = Math.max(0.0,Math.min(1.0,currentLights[p]._vf.shadowOffset));
				}
				else if(x3dom.isa(currentLights[p], x3dom.nodeTypes.SpotLight))
				{
					sp['light'+p+'_Type']             = 2.0;
					sp['light'+p+'_On']               = (currentLights[p]._vf.on) ? 1.0 : 0.0;
					sp['light'+p+'_Direction']        = light_transform.multMatrixVec(currentLights[p]._vf.direction).toGL();
					sp['light'+p+'_Attenuation']      = currentLights[p]._vf.attenuation.toGL();
					sp['light'+p+'_Location']         = light_transform.multMatrixPnt(currentLights[p]._vf.location).toGL();
					sp['light'+p+'_Radius']           = currentLights[p]._vf.radius;
					sp['light'+p+'_BeamWidth']        = currentLights[p]._vf.beamWidth;
					sp['light'+p+'_CutOffAngle']      = currentLights[p]._vf.cutOffAngle;
					sp['light'+p+'_ShadowIntensity']  = currentLights[p]._vf.shadowIntensity;
					sp['light'+p+'_ShadowCascades']   = currentLights[p]._vf.shadowCascades;
					sp['light'+p+'_ShadowOffset']     = Math.max(0.0,Math.min(1.0,currentLights[p]._vf.shadowOffset));
				}
			}
		
			gl.drawArrays(gl.TRIANGLES,0,6);

			//cleanup
            var nk = shadowIndex + 1;
			for (k=0; k<nk; k++) {
				gl.activeTexture(gl.TEXTURE0 + k);
				gl.bindTexture(gl.TEXTURE_2D, null);	
			} 
			gl.disableVertexAttribArray(sp.position);
		}

        this.stateManager.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    };
	
	/*****************************************************************************
    * Blur texture associated with given fbo
    *****************************************************************************/	
	Context.prototype.blurTex = function(gl, scene, targetFbo, filterSize)
    {
		if (filterSize <= 0)
            return;
		else if (filterSize < 5)
			filterSize = 3;
		else if (filterSize < 7)
			filterSize = 5;
		else
            filterSize = 7;
		
		//first pass (horizontal blur), result stored in fboBlur
		var width = targetFbo.width;
		var height = targetFbo.height;
		var fboBlur = null;
		
		for (var i=0, n=scene._webgl.fboBlur.length; i<n; i++)
			if (height == scene._webgl.fboBlur[i].height) {
                fboBlur = scene._webgl.fboBlur[i];
                break; // THINKABOUTME
            }

		this.stateManager.bindFramebuffer(gl.FRAMEBUFFER, fboBlur.fbo);
		this.stateManager.viewport(0, 0, width, height);
		
		this.stateManager.enable(gl.BLEND);
		this.stateManager.blendFunc(gl.ONE, gl.ZERO);
		this.stateManager.disable(gl.CULL_FACE);
		this.stateManager.disable(gl.DEPTH_TEST);
		
		gl.clearColor(1.0, 1.0, 1.0, 0.0);
		gl.clearDepth(1.0);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		var sp = this.cache.getShader(gl, x3dom.shader.BLUR);

        this.stateManager.useProgram(sp);
		
		//initialize Data for post processing
		gl.bindBuffer(gl.ARRAY_BUFFER, scene._webgl.ppBuffer);
		gl.vertexAttribPointer(sp.position, 2, gl.FLOAT, false, 0, 0);
		gl.enableVertexAttribArray(sp.position);
		
		sp.pixelSizeHor = 1.0/width;
		sp.pixelSizeVert = 1.0/height;
		sp.filterSize = filterSize;
		sp.horizontal = true;
		
		sp.texture = 0;
		
		//bind texture 
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, targetFbo.tex);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		
		gl.drawArrays(gl.TRIANGLES,0,6);
		
		//second pass (vertical blur), result stored in targetFbo
		this.stateManager.bindFramebuffer(gl.FRAMEBUFFER, targetFbo.fbo);
		
		gl.clearColor(1.0, 1.0, 1.0, 0.0);
		gl.clearDepth(1.0);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		sp.horizontal = false;
		
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, fboBlur.tex);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

		gl.drawArrays(gl.TRIANGLES,0,6);

		//cleanup
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.disableVertexAttribArray(sp.position);
        gl.flush();

        this.stateManager.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        this.stateManager.bindFramebuffer(gl.FRAMEBUFFER, null);
		this.stateManager.viewport(0, 0, this.canvas.width, this.canvas.height);
	};
	
    return setupContext;

})();

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

x3dom.bridge = {

    setFlashReady: function (driver, canvas) {
        var x3dCanvas = x3dom.canvases[canvas];
        x3dCanvas.isFlashReady = true;
        x3dom.debug.logInfo('Flash is ready for rendering (' + driver + ')');
    },

    onMouseDown: function (x, y, button, canvas) {
        var x3dCanvas = x3dom.canvases[canvas];
        x3dCanvas.doc.onMousePress(x3dCanvas.gl, x, y, button);
        x3dCanvas.doc.needRender = true;
    },

    onMouseUp: function (x, y, button, canvas) {
        var x3dCanvas = x3dom.canvases[canvas];
        x3dCanvas.doc.onMouseRelease(x3dCanvas.gl, x, y, button);
        x3dCanvas.doc.needRender = true;
    },

    onMouseOver: function (x, y, button, canvas) {
        var x3dCanvas = x3dom.canvases[canvas];
        x3dCanvas.doc.onMouseOver(x3dCanvas.gl, x, y, button);
        x3dCanvas.doc.needRender = true;
    },

    onMouseOut: function (x, y, button, canvas) {
        var x3dCanvas = x3dom.canvases[canvas];
        x3dCanvas.doc.onMouseOut(x3dCanvas.gl, x, y, button);
        x3dCanvas.doc.needRender = true;
    },

    onDoubleClick: function (x, y, canvas) {
        var x3dCanvas = x3dom.canvases[canvas];
        x3dCanvas.doc.onDoubleClick(x3dCanvas.gl, x, y);
        x3dCanvas.doc.needRender = true;
        x3dom.debug.logInfo("dblClick");
    },

    onMouseDrag: function (x, y, button, canvas) {
        var x3dCanvas = x3dom.canvases[canvas];
        x3dCanvas.doc.onDrag(x3dCanvas.gl, x, y, button);
        x3dCanvas.doc.needRender = true;
    },

    onMouseMove: function (x, y, button, canvas) {
        var x3dCanvas = x3dom.canvases[canvas];
        x3dCanvas.doc.onMove(x3dCanvas.gl, x, y, button);
        x3dCanvas.doc.needRender = true;
    },

    onMouseWheel: function (x, y, button, canvas) {
        var x3dCanvas = x3dom.canvases[canvas];
        x3dCanvas.doc.onDrag(x3dCanvas.gl, x, y, button);
        x3dCanvas.doc.needRender = true;
    },

    onKeyDown: function (charCode, canvas) {
        var x3dCanvas = x3dom.canvases[canvas];
        var keysEnabled = x3dCanvas.x3dElem.getAttribute("keysEnabled");
        if (!keysEnabled || keysEnabled.toLowerCase() === "true") {
            x3dCanvas.doc.onKeyPress(charCode);
        }
        x3dCanvas.doc.needRender = true;
    },

    setBBox: function (id, center, size) {
        var shape = x3dom.nodeTypes.Shape.idMap.nodeID[id];
        //shape._vf.bboxCenter.setValues( new x3dom.fields.SFVec3f(center.x,center.y,center.z) );
        //shape._vf.bboxSize.setValues( new x3dom.fields.SFVec3f(size.x,size.y,size.z) );
    },

    setShapeDirty: function (id) {
        var shape = x3dom.nodeTypes.Shape.idMap.nodeID[id];
        shape.setAllDirty();
    }
};


x3dom.gfx_flash = (function () {

    /**
     *
     */
    function Context(object, name, renderType) {
        this.object = object;
        this.name = name;
        this.isAlreadySet = false;
        this.renderType = renderType;
    }

    /**
     *
     */
    function setupContext(object, renderType) {

        //Set max indexable coords
        x3dom.Utils.maxIndexableCoords = 65535;

        //Return new Context
        return new Context(object, 'flash', renderType);
    }

    /**
     *
     */
    Context.prototype.getName = function () {
        return this.name;
    };

    /**
     *
     */
    Context.prototype.renderScene = function (viewarea) {
        //Get Scene from Viewarea
        var scene = viewarea._scene;

        var min = x3dom.fields.SFVec3f.MAX();
        var max = x3dom.fields.SFVec3f.MIN();

        var vol = scene.getVolume();
        vol.getBounds(min, max);

        scene._lastMin = min;
        scene._lastMax = max;

        viewarea._last_mat_view = x3dom.fields.SFMatrix4f.identity();
        viewarea._last_mat_proj = x3dom.fields.SFMatrix4f.identity();
        viewarea._last_mat_scene = x3dom.fields.SFMatrix4f.identity();

        //Dirty HACK
        var viewpoint = scene.getViewpoint();
        if (viewpoint._vf.zNear == -1 || viewpoint._vf.zFar == -1) {
            viewpoint._vf.zFar = 20000;
            viewpoint._vf.zNear = 0.1;
        }

        var mat_view = viewarea.getViewMatrix();
        var mat_proj = viewarea.getProjectionMatrix();
        var mat_scene = mat_proj.mult(mat_view);

        //Setup the flash scene
        this.setupScene(scene, viewarea);

        //Get background node
        var background = scene.getBackground();

        //Setup the background
        this.setupBackground(background);

        //Collect all drawableObjects
        scene.drawableCollection = null;
        var env = scene.getEnvironment();

        var drawableCollectionConfig = {
            viewArea: viewarea,
            sortTrans: env._vf.sortTrans,
            viewMatrix: mat_view,
            projMatrix: mat_proj,
            sceneMatrix: mat_scene,
            frustumCulling: false,
            smallFeatureThreshold: false,
            context: null,
            gl: null
        };

        scene.drawableCollection = new x3dom.DrawableCollection(drawableCollectionConfig);
        scene.collectDrawableObjects(x3dom.fields.SFMatrix4f.identity(), scene.drawableCollection, true, false, 0);

        scene.drawableCollection.concat();

        //Get Number of drawableObjects
        var numDrawableObjects = scene.drawableCollection.length;

        if (numDrawableObjects > 0) {
            var RefList = [];

            //Iterate over all Objects for setup
            for (var i = 0; i < numDrawableObjects; i++) {
                //Get object and transformation
                var drawable = scene.drawableCollection.get(i);
                var trafo = drawable.transform;
                var obj3d = drawable.shape;

                //Count shape references for DEF/USE
                if (RefList[obj3d._objectID] != undefined) {
                    RefList[obj3d._objectID]++;
                } else {
                    RefList[obj3d._objectID] = 0;
                }

                // TODO; move to addDrawable()
                this.setupShape(obj3d, trafo, RefList[obj3d._objectID]);
            }
        }

        //Render the flash scene
        this.object.renderScene();
    };

    /**
     *
     */
    Context.prototype.setupScene = function (scene, viewarea) {

        //Set View-Matrix
        var mat_view = viewarea.getViewMatrix();

        // fire viewpointChanged event
        if (!viewarea._last_mat_view.equals(mat_view)) {
            var e_viewpoint = viewarea._scene.getViewpoint();
            var e_eventType = "viewpointChanged";
            /*TEST*/
            try {
                if (e_viewpoint._xmlNode &&
                    (e_viewpoint._xmlNode["on" + e_eventType] ||
                        e_viewpoint._xmlNode.hasAttribute("on" + e_eventType) ||
                        e_viewpoint._listeners[e_eventType])) {
                    var e_viewtrafo = e_viewpoint.getCurrentTransform();
                    e_viewtrafo = e_viewtrafo.inverse().mult(mat_view);

                    var e_mat = e_viewtrafo.inverse();

                    var e_rotation = new x3dom.fields.Quaternion(0, 0, 1, 0);
                    //e_rotation.setValue(e_mat);

                    var e_translation = e_mat.e3();

                    var e_event = {
                        target: e_viewpoint._xmlNode,
                        type: e_eventType,
                        matrix: e_viewtrafo,
                        position: e_translation,
                        orientation: e_rotation.toAxisAngle(),
                        cancelBubble: false,
                        stopPropagation: function () {
                            this.cancelBubble = true;
                        }
                    };

                    e_viewpoint.callEvtHandler(e_eventType, e_event);
                }
            }
            catch (e_e) {
                x3dom.debug.logException(e_e);
            }
        }

        viewarea._last_mat_view = mat_view;

        //Dirty HACK
        var viewpoint = scene.getViewpoint();
        //viewpoint._vf.zFar = 100;
        //viewpoint._vf.zNear = 0.1;

        var mat_proj = viewarea.getProjectionMatrix();

        this.object.setViewpoint({ fov: viewpoint._vf.fov,
            zFar: viewpoint._vf.zFar,
            zNear: viewpoint._vf.zNear,
            viewMatrix: mat_view.toGL(),
            projectionMatrix: mat_proj.toGL() });

        //Set HeadLight
        var nav = scene.getNavigationInfo();
        if (nav._vf.headlight) {
            /*this.object.setLights( { idx: 0,
             type: 0,
             on: 1.0,
             color: [1.0, 1.0, 1.0],
             intensity: 1.0,
             ambientIntensity: 0.0,
             direction: [0.0, 0.0, 1.0],
             attenuation: [1.0, 1.0, 1.0],
             location: [1.0, 1.0, 1.0],
             radius: 0.0,
             beamWidth: 0.0,
             cutOffAngle: 0.0 } );*/

            this.object.setHeadLight({ id: -1,
                on: 1.0,
                color: [1.0, 1.0, 1.0],
                intensity: 1.0,
                ambientIntensity: 0.0,
                direction: [0.0, 0.0, -1.0] });
        }

        //TODO Set Lights
        if (this.renderType == "deferred") {
            var lights = viewarea.getLights();
            for (var i = 0; i < lights.length; i++) {
                if (lights[i]._dirty) {

                    if (x3dom.isa(lights[i], x3dom.nodeTypes.DirectionalLight)) {
                        this.object.setDirectionalLight({ id: lights[i]._lightID,
                            on: lights[i]._vf.on,
                            color: lights[i]._vf.color.toGL(),
                            intensity: lights[i]._vf.intensity,
                            ambientIntensity: lights[i]._vf.ambientIntensity,
                            direction: lights[i]._vf.direction.toGL() });
                    }
                    else if (x3dom.isa(lights[i], x3dom.nodeTypes.PointLight)) {
                        var light_transform = mat_view.mult(lights[i].getCurrentTransform());

                        this.object.setPointLight({ id: lights[i]._lightID,
                            on: lights[i]._vf.on,
                            color: lights[i]._vf.color.toGL(),
                            intensity: lights[i]._vf.intensity,
                            ambientIntensity: lights[i]._vf.ambientIntensity,
                            attenuation: lights[i]._vf.attenuation.toGL(),
                            location: lights[i]._vf.location.toGL(),
                            radius: lights[i]._vf.radius });
                    }
                    else if (x3dom.isa(lights[i], x3dom.nodeTypes.SpotLight)) {
                        /*this.object.setSpotLight( { id: lights[i]._lightID,
                         on: lights[i]._vf.on,
                         color: lights[i]._vf.color.toGL(),
                         intensity: lights[i]._vf.color.toGL(),
                         ambientIntensity: lights[i]._vf.ambientIntensity,
                         direction: lights[i]._vf.direction.toGL(),
                         attenuation: lights[i]._vf.attenuation.toGL(),
                         location: lights[i]._vf.location.toGL(),
                         radius: lights[i]._vf.radius,
                         beamWidth: lights[i]._vf.beamWidth,
                         cutOffAngle: lights[i]._vf.cutOffAngle } );*/
                    }
                    lights[i]._dirty = false;
                }
            }
        }
    };

    /**
     *
     */
    Context.prototype.setupBackground = function (background) {
        //If background dirty -> update
        if (background._dirty) {
            this.object.setBackground({ texURLs: background.getTexUrl(),
                skyAngle: background._vf.skyAngle,
                skyColor: background.getSkyColor().toGL(),
                groundAngle: background._vf.groundAngle,
                groundColor: background.getGroundColor().toGL(),
                transparency: background.getTransparency() });
            background._dirty = false;
        }
    };

    /**
     *
     */
    Context.prototype.setupShape = function (shape, trafo, refID) {

        //Check shape geometry type
        if (x3dom.isa(shape._cf.geometry.node, x3dom.nodeTypes.PointSet)) {
            x3dom.debug.logError("Flash backend doesn't support PointSets yet");
        } else if (x3dom.isa(shape._cf.geometry.node, x3dom.nodeTypes.IndexedLineSet)) {
            x3dom.debug.logError("Flash backend doesn't support LineSets yet");
        } else if (x3dom.isa(shape._cf.geometry.node, x3dom.nodeTypes.Text)) {
            this.setupText(shape, trafo, refID);
        } else {
            this.setupIndexedFaceSet(shape, trafo, refID);
        }
    };

    Context.prototype.setupIndexedFaceSet = function (shape, trafo, refID) {
        //Set modelMatrix
        this.object.setMeshTransform({ id: shape._objectID,
            refID: refID,
            transform: trafo.toGL() });
        if (refID == 0) {
            //Check if is ImageGeometry or BinaryGeometry
            var isImageGeometry = x3dom.isa(shape._cf.geometry.node, x3dom.nodeTypes.ImageGeometry);
            var isBinaryGeometry = x3dom.isa(shape._cf.geometry.node, x3dom.nodeTypes.BinaryGeometry);
            var isBitLODGeometry = x3dom.isa(shape._cf.geometry.node, x3dom.nodeTypes.BitLODGeometry);

            //Check if Appearance is available
            var appearance = shape._cf.appearance.node;
            var sortType = (appearance) ? shape._cf.appearance.node._vf.sortType : "auto";
            var sortKey = (appearance) ? shape._cf.appearance.node._vf.sortKey : 0

            //Set Mesh Properties
            if (isImageGeometry) {
                this.object.setMeshProperties({ id: shape._objectID,
                    type: "ImageGeometry",
                    sortType: sortType,
                    sortKey: sortKey,
                    solid: shape.isSolid(),
                    bboxMin: shape._cf.geometry.node.getMin().toGL(),
                    bboxMax: shape._cf.geometry.node.getMax().toGL(),
                    bboxCenter: shape._cf.geometry.node.getCenter().toGL(),
                    primType: shape._cf.geometry.node._vf.primType,
                    vertexCount: shape._cf.geometry.node._vf.vertexCount });
            } else if (isBinaryGeometry) {
                this.object.setMeshProperties({ id: shape._objectID,
                    type: "BinaryGeometry",
                    sortType: sortType,
                    sortKey: sortKey,
                    solid: shape.isSolid(),
                    bgCenter: shape._cf.geometry.node._vf.position.toGL(),
                    bgSize: shape._cf.geometry.node._vf.size.toGL(),
                    bboxCenter: shape._cf.geometry.node.getCenter().toGL(),
                    primType: shape._cf.geometry.node._vf.primType,
                    vertexCount: shape._cf.geometry.node._vf.vertexCount });
            } else if (isBitLODGeometry) {
                this.object.setMeshProperties({ id: shape._objectID,
                    type: "BitLODGeometry",
                    sortType: sortType,
                    sortKey: sortKey,
                    solid: shape.isSolid(),
                    bboxMin: shape._cf.geometry.node.getMin().toGL(),
                    bboxMax: shape._cf.geometry.node.getMax().toGL(),
                    bboxCenter: shape._cf.geometry.node.getCenter().toGL(),
                    primType: shape._cf.geometry.node._vf.primType,
                    vertexCount: shape._cf.geometry.node._vf.vertexCount });
            } else {
                this.object.setMeshProperties({ id: shape._objectID,
                    type: "Default",
                    sortType: sortType,
                    sortKey: sortKey,
                    solid: shape.isSolid() });
            }

            //Set indices
            if (shape._dirty.indexes === true) {
                if (isImageGeometry) {
                    //TODO new flash IG implementation
                    /*this.object.setMeshIndices( { id: shape._objectID,
                     idx: 0,
                     indices: shape._cf.geometry.node.getIndexTextureURL() } );*/
                } else if (isBinaryGeometry) {
                    this.object.setMeshIndices({ id: shape._objectID,
                        idx: 0,
                        indices: shape._nameSpace.getURL(shape._cf.geometry.node._vf.index) });


                } else if (isBitLODGeometry) {
                    this.object.setMeshIndices({ id: shape._objectID,
                        idx: 0,
                        indices: shape._nameSpace.getURL(shape._cf.geometry.node._vf.index) });
                } else {
                    //If Mesh is multi indexed we have to split it in Flash
                    if (shape._cf.geometry.node._mesh._multiIndIndices && shape._cf.geometry.node._mesh._multiIndIndices.length)
                    {
                        shape._cf.geometry.node._mesh.splitMesh(3, true);
                    }

                    for (var i = 0; i < shape._cf.geometry.node._mesh._indices.length; i++) {
                        this.object.setMeshIndices({ id: shape._objectID,
                            idx: i,
                            indices: shape._cf.geometry.node._mesh._indices[i] });
                    }
                }
                shape._dirty.indexes = false;
            }

            //Set vertices
            if (shape._dirty.positions === true) {
                if (isImageGeometry) {
                    this.object.setMeshVertices({ id: shape._objectID,
                        idx: 0,
                        //TODO new flash IG implementation coords: shape._cf.geometry.node.getCoordinateTextureURLs(),
                        coordinateTexture0: shape._cf.geometry.node.getCoordinateTextureURL(0),
                        coordinateTexture1: shape._cf.geometry.node.getCoordinateTextureURL(1) });
                } else if (isBinaryGeometry) {
                    this.object.setMeshVertices({ id: shape._objectID,
                        idx: 0,
                        interleaved: shape._cf.geometry.node._hasStrideOffset,
                        vertices: shape._nameSpace.getURL(shape._cf.geometry.node._vf.coord),
                        normals: shape._nameSpace.getURL(shape._cf.geometry.node._vf.normal),
                        texCoords: shape._nameSpace.getURL(shape._cf.geometry.node._vf.texCoord),
                        colors: shape._nameSpace.getURL(shape._cf.geometry.node._vf.color),
                        numColorComponents: shape._cf.geometry.node._mesh._numColComponents,
                        numNormalComponents: shape._cf.geometry.node._mesh._numNormComponents,
                        vertexType: shape._cf.geometry.node._vf.coordType,
                        normalType: shape._cf.geometry.node._vf.normalType,
                        texCoordType: shape._cf.geometry.node._vf.texCoordType,
                        colorType: shape._cf.geometry.node._vf.colorType,
                        vertexStrideOffset: shape._coordStrideOffset,
                        normalStrideOffset: shape._normalStrideOffset,
                        texCoordStrideOffset: shape._texCoordStrideOffset,
                        colorStrideOffset: shape._colorStrideOffset });
                } else if (isBitLODGeometry) {
                    this.object.setMeshVertices({ id: shape._objectID,
                        componentURLs: shape._cf.geometry.node.getComponentsURLs(),
                        componentFormats: shape._cf.geometry.node.getComponentFormats(),
                        componentAttribs: shape._cf.geometry.node.getComponentAttribs()});
                } else {
                    for (var i = 0; i < shape._cf.geometry.node._mesh._positions.length; i++) {
                        this.object.setMeshVertices({ id: shape._objectID,
                            idx: i,
                            vertices: shape._cf.geometry.node._mesh._positions[i] });
                    }
                }
                shape._dirty.positions = false;
            }

            //Set normals
            if (shape._dirty.normals === true) {
                if (isImageGeometry) {
                    this.object.setMeshNormals({ id: shape._objectID,
                        idx: 0,
                        //TODO new flash IG implementation normals: shape._cf.geometry.node.getNormalTextureURLs(),
                        normalTexture: shape._cf.geometry.node.getNormalTextureURL() });
                } else if (isBinaryGeometry) {
                    if (!shape._cf.geometry.node._hasStrideOffset) {
                        this.object.setMeshNormals({ id: shape._objectID,
                            idx: 0,
                            normals: shape._nameSpace.getURL(shape._cf.geometry.node._vf.normal) });
                    }
                } else if (isBitLODGeometry) {
                    //Nothing won't implement!
                } else {
                    if (shape._cf.geometry.node._mesh._normals[0].length) {
                        for (var i = 0; i < shape._cf.geometry.node._mesh._normals.length; i++) {
                            this.object.setMeshNormals({ id: shape._objectID,
                                idx: i,
                                normals: shape._cf.geometry.node._mesh._normals[i] });
                        }
                    }
                }
                shape._dirty.normals = false;
            }

            //Set colors
            if (shape._dirty.colors === true) {
                if (isImageGeometry) {
                    this.object.setMeshColors({ id: shape._objectID,
                        idx: 0,
                        colorTexture: shape._cf.geometry.node.getColorTextureURL(),
                        components: shape._cf.geometry.node._mesh._numColComponents });
                } else if (isBinaryGeometry) {
                    if (!shape._cf.geometry.node._hasStrideOffset) {
                        this.object.setMeshColors({ id: shape._objectID,
                            idx: 0,
                            colors: shape._nameSpace.getURL(shape._cf.geometry.node._vf.color),
                            components: shape._cf.geometry.node._mesh._numColComponents });
                    }
                } else if (isBitLODGeometry) {
                    //Nothing won't implement!
                } else {
                    if (shape._cf.geometry.node._mesh._colors[0].length) {
                        for (var i = 0; i < shape._cf.geometry.node._mesh._colors.length; i++) {
                            this.object.setMeshColors({ id: shape._objectID,
                                idx: i,
                                colors: shape._cf.geometry.node._mesh._colors[i],
                                components: shape._cf.geometry.node._mesh._numColComponents });
                        }
                    }
                }
                shape._dirty.colors = false;
            }

            //Set texture coordinates
            if (shape._dirty.texcoords === true) {
                if (isImageGeometry) {
                    this.object.setMeshTexCoords({ id: shape._objectID,
                        idx: 0,
                        texCoordTexture: shape._cf.geometry.node.getTexCoordTextureURL() });
                } else if (isBinaryGeometry) {
                    if (!shape._cf.geometry.node._hasStrideOffset) {
                        this.object.setMeshTexCoords({ id: shape._objectID,
                            idx: 0,
                            texCoords: shape._nameSpace.getURL(shape._cf.geometry.node._vf.texCoord) });
                    }
                } else if (isBitLODGeometry) {
                    //Nothing, won't implement!
                } else {
                    if (shape._cf.geometry.node._mesh._texCoords[0].length) {
                        for (var i = 0; i < shape._cf.geometry.node._mesh._texCoords.length; i++) {
                            this.object.setMeshTexCoords({ id: shape._objectID,
                                idx: i,
                                texCoords: shape._cf.geometry.node._mesh._texCoords[i] });
                        }
                    }
                }
                shape._dirty.texcoords = false;
            }

            //Set material
            if (shape._dirty.material === true) {
                if (appearance) {
                    var material = shape._cf.appearance.node._cf.material.node;
                    if (material) {
                        this.object.setMeshMaterial({ id: shape._objectID,
                            ambientIntensity: material._vf.ambientIntensity,
                            diffuseColor: material._vf.diffuseColor.toGL(),
                            emissiveColor: material._vf.emissiveColor.toGL(),
                            shininess: material._vf.shininess,
                            specularColor: material._vf.specularColor.toGL(),
                            transparency: material._vf.transparency });
                    }
                }
                shape._dirty.material = false;
            }

            //Set Texture
            if (shape._dirty.texture === true) {
                if (appearance) {
                    var texTrafo = null;
                    if (appearance._cf.textureTransform.node) {
                        texTrafo = appearance.texTransformMatrix().toGL();
                    }

                    var texture = shape._cf.appearance.node._cf.texture.node;

                    if (texture) {
                        if (x3dom.isa(texture, x3dom.nodeTypes.PixelTexture)) {
                            this.object.setPixelTexture({ id: shape._objectID,
                                width: texture._vf.image.width,
                                height: texture._vf.image.height,
                                comp: texture._vf.image.comp,
                                pixels: texture._vf.image.toGL() });
                        } else if (x3dom.isa(texture, x3dom.nodeTypes.ComposedCubeMapTexture)) {
                            this.object.setCubeTexture({ id: shape._objectID,
                                texURLs: texture.getTexUrl() });
                        } else if (texture._isCanvas && texture._canvas) {
                            this.object.setCanvasTexture({ id: shape._objectID,
                                width: texture._canvas.width,
                                height: texture._canvas.height,
                                dataURL: texture._canvas.toDataURL() });
                        } else if (x3dom.isa(texture, x3dom.nodeTypes.MultiTexture)) {
                            x3dom.debug.logError("Flash backend doesn't support MultiTextures yet");
                        } else if (x3dom.isa(texture, x3dom.nodeTypes.MovieTexture)) {
                            x3dom.debug.logError("Flash backend doesn't support MovieTextures yet");
                        } else {
                            this.object.setMeshTexture({ id: shape._objectID,
                                origChannelCount: texture._vf.origChannelCount,
                                repeatS: texture._vf.repeatS,
                                repeatT: texture._vf.repeatT,
                                url: texture._vf.url[0],
                                transform: texTrafo });
                        }
                    } else {
                        this.object.removeTexture({ id: shape._objectID });
                    }
                }
                shape._dirty.texture = false;
            }

            //Set sphere mapping
            if (shape._cf.geometry.node._cf.texCoord !== undefined &&
                shape._cf.geometry.node._cf.texCoord.node !== null &&
                !x3dom.isa(shape._cf.geometry.node._cf.texCoord.node, x3dom.nodeTypes.X3DTextureNode) &&
                shape._cf.geometry.node._cf.texCoord.node._vf.mode) {
                var texMode = shape._cf.geometry.node._cf.texCoord.node._vf.mode;
                if (texMode.toLowerCase() == "sphere") {
                    this.object.setSphereMapping({ id: shape._objectID,
                        sphereMapping: 1 });
                }
                else {
                    this.object.setSphereMapping({ id: shape._objectID,
                        sphereMapping: 0 });
                }
            }
            else {
                this.object.setSphereMapping({ id: shape._objectID,
                    sphereMapping: 0 });
            }
        }
    };

    Context.prototype.setupText = function (shape, trafo, refID) {
        //Set modelMatrix
        this.object.setMeshTransform({ id: shape._objectID,
            refID: refID,
            transform: trafo.toGL() });

        if (refID == 0) {

            /*this.object.setMeshProperties( { id: shape._objectID,
             type: "Text",
             solid: shape.isSolid() } );*/

            //Check if Appearance is available
            var appearance = shape._cf.appearance.node;
            var sortType = (appearance) ? shape._cf.appearance.node._vf.sortType : "auto";
            var sortKey = (appearance) ? shape._cf.appearance.node._vf.sortKey : 0

            if (shape._dirty.text === true) {
                var fontStyleNode = shape._cf.geometry.node._cf.fontStyle.node;
                if (fontStyleNode === null) {
                    this.object.setMeshProperties({ id: shape._objectID,
                        type: "Text",
                        sortType: sortType,
                        sortKey: sortKey,
                        solid: shape.isSolid(),
                        text: shape._cf.geometry.node._vf.string,
                        fontFamily: ['SERIF'],
                        fontStyle: "PLAIN",
                        fontAlign: "BEGIN",
                        fontSize: 32,
                        fontSpacing: 1.0,
                        fontHorizontal: true,
                        fontLanguage: "",
                        fontLeftToRight: true,
                        fontTopToBottom: true });
                } else {
                    this.object.setMeshProperties({ id: shape._objectID,
                        type: "Text",
                        sortType: sortType,
                        sortKey: sortKey,
                        solid: shape.isSolid(),
                        text: shape._cf.geometry.node._vf.string,
                        fontFamily: fontStyleNode._vf.family.toString(),
                        fontStyle: fontStyleNode._vf.style.toString(),
                        fontAlign: fontStyleNode._vf.justify.toString(),
                        fontSize: fontStyleNode._vf.size,
                        fontSpacing: fontStyleNode._vf.spacing,
                        fontHorizontal: fontStyleNode._vf.horizontal,
                        fontLanguage: fontStyleNode._vf.language,
                        fontLeftToRight: fontStyleNode._vf.leftToRight,
                        fontTopToBottom: fontStyleNode._vf.topToBottom });
                }
                shape._dirty.text = false;
            }

            if (shape._dirty.material === true) {
                if (appearance) {
                    var material = shape._cf.appearance.node._cf.material.node;
                    if (material) {
                        this.object.setMeshMaterial({ id: shape._objectID,
                            ambientIntensity: material._vf.ambientIntensity,
                            diffuseColor: material._vf.diffuseColor.toGL(),
                            emissiveColor: material._vf.emissiveColor.toGL(),
                            shininess: material._vf.shininess,
                            specularColor: material._vf.specularColor.toGL(),
                            transparency: material._vf.transparency });
                    }
                }
                shape._dirty.material = false;
            }
        }
    };


    /**
     *
     */
    Context.prototype.pickValue = function (viewarea, x, y, viewMat, sceneMat) {
        var scene = viewarea._scene;

        // method requires that scene has already been rendered at least once
        if (this.object === null || scene === null || scene.drawableCollection === undefined || !scene.drawableCollection || scene._vf.pickMode.toLowerCase() === "box") {
            return false;
        }

        var pickMode = (scene._vf.pickMode.toLowerCase() === "color") ? 1 :
            ((scene._vf.pickMode.toLowerCase() === "texcoord") ? 2 : 0);

        var data = this.object.pickValue({ pickMode: pickMode });

        if (data.objID > 0) {
            viewarea._pickingInfo.pickPos = new x3dom.fields.SFVec3f(data.pickPosX, data.pickPosY, data.pickPosZ);
            viewarea._pickingInfo.pickObj = x3dom.nodeTypes.Shape.idMap.nodeID[data.objID];
        } else {
            viewarea._pickingInfo.pickObj = null;
            viewarea._pickingInfo.lastClickObj = null;
        }

        return true;
    };

    /**
     *
     */
    Context.prototype.shutdown = function (viewarea) {
        // TODO?
    };

    //Return the setup context function
    return setupContext;
})();

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


// ### X3DDocument ###
x3dom.X3DDocument = function(canvas, ctx, settings) {
    this.canvas = canvas;       // The <canvas> elem
    this.ctx = ctx;             // WebGL context object, AKA gl
    this.properties = settings; // showStat, showLog, etc.
    this.needRender = true;     // Trigger redraw if true
    this._x3dElem = null;       // Backref to <X3D> root element (set on parsing)
    this._scene = null;         // Scene root element
    this._viewarea = null;      // Viewport, handles rendering and interaction
    this.downloadCount = 0;     // Counter for objects to be loaded

    // bag for pro-active (or multi-core-like) elements
    this._nodeBag = {
        timer: [],          // TimeSensor (tick)
        lights: [],         // Light
        clipPlanes: [],     // ClipPlane
        followers: [],      // X3DFollowerNode
        trans: [],          // X3DTransformNode (for listening to CSS changes)
        renderTextures: [], // RenderedTexture
        viewarea: []        // Viewport (for updating camera navigation)
    };

    this.onload = function () {};
    this.onerror = function () {};
};

x3dom.X3DDocument.prototype.load = function (uri, sceneElemPos) {
    // Load uri. Get sceneDoc, list of sub-URIs.
    // For each URI, get docs[uri] = whatever, extend list of sub-URIs.

    var uri_docs = {};
    var queued_uris = [uri];
    var doc = this;

    function next_step() {
        // TODO: detect circular inclusions
        // TODO: download in parallel where possible

        if (queued_uris.length === 0) {
            // All done
            doc._setup(uri_docs[uri], uri_docs, sceneElemPos);
            doc.onload();
            return;
        }
        var next_uri = queued_uris.shift();

        if ( x3dom.isX3DElement(next_uri) &&
            (next_uri.localName.toLowerCase() === 'x3d' || next_uri.localName.toLowerCase() === 'websg') )
        {
            // Special case, when passed an X3D node instead of a URI string
            uri_docs[next_uri] = next_uri;
            doc._x3dElem = next_uri;
            next_step();
        }
    }

    next_step();
};

x3dom.findScene = function(x3dElem) {
    var sceneElems = [];

    for (var i=0; i<x3dElem.childNodes.length; i++) {
        var sceneElem = x3dElem.childNodes[i];

        if (sceneElem && sceneElem.localName && sceneElem.localName.toLowerCase() === "scene") {
            sceneElems.push(sceneElem);
        }
    }

    if (sceneElems.length > 1) {
        x3dom.debug.logError("X3D element has more than one Scene child (has " +
                             x3dElem.childNodes.length + ").");
    }
    else {
        return sceneElems[0];
    }
    return null;
};


x3dom.X3DDocument.prototype._setup = function (sceneDoc, uriDocs, sceneElemPos) {
    var doc = this;

    function cleanNodeBag(bag, node) {
        for (var i=0, n=bag.length; i<n; i++) {
            if (bag[i] === node) {
                bag.splice(i, 1);
                break;
            }
        }
    }

    function removeX3DOMBackendGraph(domNode) {
        var children = domNode.childNodes;

        for (var i=0, n=children.length; i<n; i++) {
            removeX3DOMBackendGraph(children[i]);
        }

        if (domNode._x3domNode) {
            var node = domNode._x3domNode;
            var nameSpace = node._nameSpace;

            if (x3dom.isa(node, x3dom.nodeTypes.X3DShapeNode)) {
                if (node._cleanupGLObjects) {
                    node._cleanupGLObjects(true);
                    // TODO: more cleanups, e.g. texture/shader cache?
                }
                if (x3dom.nodeTypes.Shape.idMap.nodeID[node._objectID]) {
                    delete x3dom.nodeTypes.Shape.idMap.nodeID[node._objectID];
                }
            }
            else if (x3dom.isa(node, x3dom.nodeTypes.TimeSensor)) {
                cleanNodeBag(doc._nodeBag.timer, node);
            }
            else if (x3dom.isa(node, x3dom.nodeTypes.X3DLightNode)) {
                cleanNodeBag(doc._nodeBag.lights, node);
            }
            else if (x3dom.isa(node, x3dom.nodeTypes.X3DFollowerNode)) {
                cleanNodeBag(doc._nodeBag.followers, node);
            }
            else if (x3dom.isa(node, x3dom.nodeTypes.X3DTransformNode)) {
                cleanNodeBag(doc._nodeBag.trans, node);
            }
            else if (x3dom.isa(node, x3dom.nodeTypes.RenderedTexture)) {
                cleanNodeBag(doc._nodeBag.renderTextures, node);
            }
            else if (x3dom.isa(node, x3dom.nodeTypes.X3DBindableNode)) {
                var stack = node._stack;
                if (stack) {
                    node.bind(false);
                    cleanNodeBag(stack._bindBag, node);
                }
                // Background may have geometry
                if (node._cleanupGLObjects) {
                    node._cleanupGLObjects();
                }
            }

            if (nameSpace) {
                nameSpace.removeNode(node._DEF);
            }
            node._xmlNode = null;

            delete domNode._x3domNode;
        }
    }

    // Test capturing DOM mutation events on the X3D subscene
    var domEventListener = {
        onAttrModified: function(e) {
            if ('_x3domNode' in e.target) {
                var attrToString = {
                    1: "MODIFICATION",
                    2: "ADDITION",
                    3: "REMOVAL"
                };
                //x3dom.debug.logInfo("MUTATION: " + e.attrName + ", " + e.type + ", attrChange=" + attrToString[e.attrChange]);
                e.target._x3domNode.updateField(e.attrName, e.newValue);
                doc.needRender = true;
            }
        },
        
        onNodeRemoved: function(e) {
            var domNode = e.target;
            if (!domNode)
                return;

            if ('_x3domNode' in domNode.parentNode && '_x3domNode' in domNode) {
                var parent = domNode.parentNode._x3domNode;
                var child = domNode._x3domNode;

                if (parent && child) {
                    parent.removeChild(child);
                    parent.nodeChanged();

                    removeX3DOMBackendGraph(domNode);

                    if (doc._viewarea && doc._viewarea._scene) {
                        doc._viewarea._scene.nodeChanged();
                        doc._viewarea._scene.updateVolume();
                        doc.needRender = true;
                    }
                }
            }
            else if (domNode.localName && domNode.localName.toUpperCase() == "ROUTE" && domNode._nodeNameSpace) {
                var fromNode = domNode._nodeNameSpace.defMap[domNode.getAttribute('fromNode')];
                var toNode = domNode._nodeNameSpace.defMap[domNode.getAttribute('toNode')];

                if (fromNode && toNode) {
                    fromNode.removeRoute(domNode.getAttribute('fromField'), toNode, domNode.getAttribute('toField'));
                }
            }
        },
        
        onNodeInserted: function(e) {
            var child = e.target;
            var parentNode = child.parentNode;
            
            // only act on x3dom nodes, ignore regular HTML
            if ('_x3domNode' in parentNode) {
				if (parentNode.tagName && parentNode.tagName.toLowerCase() == 'inline') {
                    // do nothing
				}
				else {
					var parent = parentNode._x3domNode;
					
					if (parent && parent._nameSpace && (child instanceof Element)) {
                        removeX3DOMBackendGraph(child);    // not really necessary...

                        var newNode = parent._nameSpace.setupTree(child);

                        parent.addChild(newNode, child.getAttribute("containerField"));
                        parent.nodeChanged();

                        var grandParentNode = parentNode.parentNode;
                        if (grandParentNode && grandParentNode._x3domNode)
                            grandParentNode._x3domNode.nodeChanged();

                        if (doc._viewarea && doc._viewarea._scene) {
                            doc._viewarea._scene.nodeChanged();
                            doc._viewarea._scene.updateVolume();
                            doc.needRender = true;
                        }
					}
					else {
						x3dom.debug.logWarning("No _nameSpace in onNodeInserted");
					}
				}
            }
        }
    };

    //sceneDoc.addEventListener('DOMCharacterDataModified', domEventListener.onAttrModified, true);
    sceneDoc.addEventListener('DOMNodeRemoved', domEventListener.onNodeRemoved, true);
    sceneDoc.addEventListener('DOMNodeInserted', domEventListener.onNodeInserted, true);
    if ( (x3dom.userAgentFeature.supportsDOMAttrModified === true ) ) {
        sceneDoc.addEventListener('DOMAttrModified', domEventListener.onAttrModified, true);
    }

    // sceneDoc is the X3D element here...
    var sceneElem = x3dom.findScene(sceneDoc);

    // create and add BindableBag that holds all bindable stacks
    this._bindableBag = new x3dom.BindableBag(this);

    // create and add the NodeNameSpace
    var nameSpace = new x3dom.NodeNameSpace("scene", doc);
    
    var scene = nameSpace.setupTree(sceneElem);

    // link scene
    this._scene = scene;
    this._bindableBag.setRefNode(scene);

    // create view
    this._viewarea = new x3dom.Viewarea (this, scene);

    this._viewarea._width = this.canvas.width;
    this._viewarea._height = this.canvas.height;
};

x3dom.X3DDocument.prototype.advanceTime = function (t) {
    var i = 0;

    if (this._nodeBag.timer.length) {
        for (i=0; i < this._nodeBag.timer.length; i++)
            { this.needRender |= this._nodeBag.timer[i].tick(t); }
    }
    if (this._nodeBag.followers.length) {
        for (i=0; i < this._nodeBag.followers.length; i++)
            { this.needRender |= this._nodeBag.followers[i].tick(t); }
    }
    // just a temporary tricker solution to update the CSS transforms
    if (this._nodeBag.trans.length) {
        for (i=0; i < this._nodeBag.trans.length; i++)
            { this.needRender |= this._nodeBag.trans[i].tick(t); }
    }
    if (this._nodeBag.viewarea.length) {
        for (i=0; i < this._nodeBag.viewarea.length; i++)
            { this.needRender |= this._nodeBag.viewarea[i].tick(t); }
    }
};

x3dom.X3DDocument.prototype.render = function (ctx) {
    if (!ctx || !this._viewarea) {
        return;
    }

    ctx.renderScene(this._viewarea);
};

x3dom.X3DDocument.prototype.onPick = function (ctx, x, y) {
    if (!ctx || !this._viewarea) {
        return;
    }
	
    ctx.pickValue(this._viewarea, x, y, 1);
};

x3dom.X3DDocument.prototype.onPickRect = function (ctx, x1, y1, x2, y2) {
    if (!ctx || !this._viewarea) {
        return [];
    }
	
    return ctx.pickRect(this._viewarea, x1, y1, x2, y2);
};

x3dom.X3DDocument.prototype.onMove = function (ctx, x, y, buttonState) {
    if (!ctx || !this._viewarea) {
        return;
    }

    if (this._viewarea._scene._vf.doPickPass)
        ctx.pickValue(this._viewarea, x, y, buttonState);
    this._viewarea.onMove(x, y, buttonState);
};

x3dom.X3DDocument.prototype.onMoveView = function (ctx, translation, rotation) {
    if (!ctx || !this._viewarea) {
        return;
    }

    this._viewarea.onMoveView(translation, rotation);
};

x3dom.X3DDocument.prototype.onDrag = function (ctx, x, y, buttonState) {
    if (!ctx || !this._viewarea) {
        return;
    }

    if (this._viewarea._scene._vf.doPickPass)
        ctx.pickValue(this._viewarea, x, y, buttonState);
    this._viewarea.onDrag(x, y, buttonState);
};

x3dom.X3DDocument.prototype.onMousePress = function (ctx, x, y, buttonState) {
    if (!ctx || !this._viewarea) {
        return;
    }

    // update volume only on click since expensive!
    this._viewarea._scene.updateVolume();

    ctx.pickValue(this._viewarea, x, y, buttonState);
    this._viewarea.onMousePress(x, y, buttonState);
};

x3dom.X3DDocument.prototype.onMouseRelease = function (ctx, x, y, buttonState, prevButton) {
    if (!ctx || !this._viewarea) {
        return;
    }

    var button = (prevButton << 8) | buttonState;   // for shadowObjectIdChanged
    ctx.pickValue(this._viewarea, x, y, button);
    this._viewarea.onMouseRelease(x, y, buttonState, prevButton);
};

x3dom.X3DDocument.prototype.onMouseOver = function (ctx, x, y, buttonState) {
    if (!ctx || !this._viewarea) {
        return;
    }

    ctx.pickValue(this._viewarea, x, y, buttonState);
    this._viewarea.onMouseOver(x, y, buttonState);
};

x3dom.X3DDocument.prototype.onMouseOut = function (ctx, x, y, buttonState) {
    if (!ctx || !this._viewarea) {
        return;
    }

    ctx.pickValue(this._viewarea, x, y, buttonState);
    this._viewarea.onMouseOut(x, y, buttonState);
};

x3dom.X3DDocument.prototype.onDoubleClick = function (ctx, x, y) {
    if (!ctx || !this._viewarea) {
        return;
    }

    this._viewarea.onDoubleClick(x, y);
};


x3dom.X3DDocument.prototype.onKeyDown = function(keyCode)
{
    //x3dom.debug.logInfo("pressed key " + keyCode);
    switch (keyCode) {
        case 37: /* left */
            this._viewarea.strafeLeft();
            break;
        case 38: /* up */
            this._viewarea.moveFwd();
            break;
        case 39: /* right */
            this._viewarea.strafeRight();
            break;
        case 40: /* down */
            this._viewarea.moveBwd();
            break;
        default:
    }
};

x3dom.X3DDocument.prototype.onKeyUp = function(keyCode)
{
    //x3dom.debug.logInfo("released key " + keyCode);
    var stack = null;

    switch (keyCode) {
        case 13: /* return */
            x3dom.toggleFullScreen();
            break;
        case 27: /* ESC */
            window.history.back(); // emulate good old ESC key
            break;
        case 33: /* page up */
            stack = this._scene.getViewpoint()._stack;

            if (stack) {
                stack.switchTo('next');
            }
            else {
                x3dom.debug.logError ('No valid ViewBindable stack.');
            }
            break;
        case 34: /* page down */
            stack = this._scene.getViewpoint()._stack;

            if (stack) {
                stack.switchTo('prev');
            }
            else {
                x3dom.debug.logError ('No valid ViewBindable stack.');
            }
            break;
        case 37: /* left */
            break;
        case 38: /* up */
            break;
        case 39: /* right */
            break;
        case 40: /* down */
            break;
        default:
    }
};

x3dom.X3DDocument.prototype.onKeyPress = function(charCode)
{
    //x3dom.debug.logInfo("pressed key " + charCode);
    var nav = this._scene.getNavigationInfo();
    var env = this._scene.getEnvironment();

    switch (charCode)
    {
        case  32: /* space */
            var states = this.canvas.parent.stateViewer;
			if (states) {
				states.display();
			}
            x3dom.debug.logInfo("a: show all | d: show helper buffers | s: small feature culling | t: light view | " +
                                "m: toggle render mode | c: frustum culling | p: intersect type | r: reset view | " +
                                "e: examine mode | f: fly mode | y: freefly mode | w: walk mode | h: helicopter mode | " +
                                "l: lookAt mode | o: lookaround | g: game mode | u: upright position | v: print viewpoint info | " +
                                "pageUp: next view | pageDown: prev. view | +: increase speed | -: decrease speed ");
            break;
        case  43: /* + (incr. speed) */
            nav._vf.speed = 2 * nav._vf.speed;
            x3dom.debug.logInfo("Changed navigation speed to " + nav._vf.speed);
            break;
        case  45: /* - (decr. speed) */
            nav._vf.speed = 0.5 * nav._vf.speed;
            x3dom.debug.logInfo("Changed navigation speed to " + nav._vf.speed);
            break;
        case  51: /* 3 (decr pg error tol) */
            x3dom.nodeTypes.PopGeometry.ErrorToleranceFactor += 0.5;
            x3dom.debug.logInfo("Changed POP error tolerance to " + x3dom.nodeTypes.PopGeometry.ErrorToleranceFactor);
            break;
        case  52: /* 4 (incr pg error tol) */
            x3dom.nodeTypes.PopGeometry.ErrorToleranceFactor -= 0.5;
            x3dom.debug.logInfo("Changed POP error tolerance to " + x3dom.nodeTypes.PopGeometry.ErrorToleranceFactor);
            break;
        case  54: /* 6 (incr height) */
            nav._vf.typeParams[1] += 1.0;
            nav._heliUpdated = false;
            x3dom.debug.logInfo("Changed helicopter height to " + nav._vf.typeParams[1]);
            break;
        case  55: /* 7 (decr height) */
            nav._vf.typeParams[1] -= 1.0;
            nav._heliUpdated = false;
            x3dom.debug.logInfo("Changed helicopter height to " + nav._vf.typeParams[1]);
            break;
        case  56: /* 8 (decr height) */
            nav._vf.typeParams[0] -= 0.02;
            nav._heliUpdated = false;
            x3dom.debug.logInfo("Changed helicopter angle to " + nav._vf.typeParams[0]);
            break;
        case  57: /* 9 (incr angle) */
            nav._vf.typeParams[0] += 0.02;
            nav._heliUpdated = false;
            x3dom.debug.logInfo("Changed helicopter angle to " + nav._vf.typeParams[0]);
            break;
        case  97: /* a, view all */
            this._viewarea.showAll();
            break;
        case  99: /* c, toggle frustum culling */
            env._vf.frustumCulling = !env._vf.frustumCulling;
            x3dom.debug.logInfo("Viewfrustum culling " + (env._vf.frustumCulling ? "on" : "off"));
            break;
        case  100: /* d, switch on/off buffer view for dbg */
            if (this._viewarea._visDbgBuf === undefined) {
                this._viewarea._visDbgBuf = (this._x3dElem.getAttribute("showLog") === 'true');
            }
            this._viewarea._visDbgBuf = !this._viewarea._visDbgBuf;
            x3dom.debug.logContainer.style.display = (this._viewarea._visDbgBuf == true) ? "block" : "none";
            break;
        case 101: /* e, examine mode */
            nav.setType("examine", this._viewarea);
            break;
        case 102: /* f, fly mode */
            nav.setType("fly", this._viewarea);
            break;
        case 103: /* g, game mode */
            nav.setType("game", this._viewarea);
            break;
        case 104: /* h, helicopter mode */
            nav.setType("helicopter", this._viewarea);
            break;
        case 108: /* l, lookAt mode */
            nav.setType("lookat", this._viewarea);
            break;
        case 109: /* m, toggle "points" attribute */
            this._viewarea._points = ++this._viewarea._points % 3;
            break;
        case 110: /* n, turntable */
            nav.setType("turntable", this._viewarea);
            break;
        case 111: /* o, look around like in fly, but don't move */
            nav.setType("lookaround", this._viewarea);
            break;
        case 112: /* p, switch intersect type */
            switch(this._scene._vf.pickMode.toLowerCase())
            {
                case "idbuf":
                    this._scene._vf.pickMode = "color";
                    break;
                case "color":
                    this._scene._vf.pickMode = "texCoord";
                    break;
                case "texcoord":
                    this._scene._vf.pickMode = "box";
                    break;
                default:
                    this._scene._vf.pickMode = "idBuf";
                    break;
            }
            x3dom.debug.logInfo("Switch pickMode to '" + this._scene._vf.pickMode + "'.");
            break;
        case 114: /* r, reset view */
            this._viewarea.resetView();
            break;
        case 115: /* s, toggle small feature culling */
            env._vf.smallFeatureCulling = !env._vf.smallFeatureCulling;
            x3dom.debug.logInfo("Small feature culling " + (env._vf.smallFeatureCulling ? "on" : "off"));
            break;
        case 116: /* t, light view */
            if (this._nodeBag.lights.length > 0) {
                this._viewarea.animateTo(this._viewarea.getLightMatrix()[0], this._scene.getViewpoint());
            }
            break;
        case 117: /* u, upright position */
            this._viewarea.uprightView();
            break;
        case 118: /* v, print viewpoint position/orientation */
            var that = this;
            (function() {
                var viewpoint = that._viewarea._scene.getViewpoint();
                var mat_view = that._viewarea.getViewMatrix().inverse();
    			
    			var rotation = new x3dom.fields.Quaternion(0, 0, 1, 0);
    			rotation.setValue(mat_view);
    			var rot = rotation.toAxisAngle();
    			var translation = mat_view.e3();
    			
    			x3dom.debug.logInfo('\n&lt;Viewpoint position="' + translation.x.toFixed(5) + ' '
    			                    + translation.y.toFixed(5) + ' ' + translation.z.toFixed(5) + '" ' +
    								'orientation="' + rot[0].x.toFixed(5) + ' ' + rot[0].y.toFixed(5) + ' ' 
    								+ rot[0].z.toFixed(5) + ' ' + rot[1].toFixed(5) + '" \n\t' +
                                    'zNear="' + viewpoint.getNear().toFixed(5) + '" ' +
    								'zFar="' + viewpoint.getFar().toFixed(5) + '" ' +
    								'description="' + viewpoint._vf.description + '"&gt;' +
                                    '&lt;/Viewpoint&gt;');
            })();
            break;
        case 119: /* w, walk mode */
            nav.setType("walk", this._viewarea);
            break;
        case 121: /* y, freefly mode */
            nav.setType("freefly", this._viewarea);
            break;
        default:
    }
};

x3dom.X3DDocument.prototype.shutdown = function(ctx)
{
    if (!ctx) {
        return;
    }
    ctx.shutdown(this._viewarea);
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

x3dom.MatrixMixer = function(beginTime, endTime) {
    if (arguments.length === 0) {
        this._beginTime = 0;
        this._endTime = 1;
    }
    else {
        this._beginTime = beginTime;
        this._endTime = endTime;
    }

    this._beginMat = x3dom.fields.SFMatrix4f.identity();
    this._beginInvMat = x3dom.fields.SFMatrix4f.identity();
    this._beginLogMat = x3dom.fields.SFMatrix4f.identity();
    this._endMat = x3dom.fields.SFMatrix4f.identity();
    this._endLogMat = x3dom.fields.SFMatrix4f.identity();
};

x3dom.MatrixMixer.prototype.calcFraction = function(time) {
    var fraction = (time - this._beginTime) / (this._endTime - this._beginTime);
    return (Math.sin((fraction * Math.PI) - (Math.PI / 2)) + 1) / 2.0;
};

x3dom.MatrixMixer.prototype.setBeginMatrix = function(mat) {
    this._beginMat.setValues(mat);
    this._beginInvMat = mat.inverse();
    this._beginLogMat = x3dom.fields.SFMatrix4f.zeroMatrix();  // mat.log();
};

x3dom.MatrixMixer.prototype.setEndMatrix = function(mat) {
    this._endMat.setValues(mat);
    this._endLogMat = mat.mult(this._beginInvMat).log();
    this._logDiffMat = this._endLogMat.addScaled(this._beginLogMat, -1);
};

x3dom.MatrixMixer.prototype.mix = function(time) {
    var mat = null;

    if (time <= this._beginTime)
    {
        mat = x3dom.fields.SFMatrix4f.copy(this._beginLogMat);
    }
    else
    {
        if (time >= this._endTime)
        {
            mat = x3dom.fields.SFMatrix4f.copy(this._endLogMat);
        }
        else
        {
            var fraction = this.calcFraction(time);
            mat = this._logDiffMat.multiply(fraction).add(this._beginLogMat);
        }
    }

    return mat.exp().mult(this._beginMat);
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

// ### Viewarea ###
x3dom.Viewarea = function (document, scene) {
    this._doc = document; // x3ddocument
    this._scene = scene; // FIXME: updates ?!

    document._nodeBag.viewarea.push(this);

    this._pickingInfo = {
        pickPos: new x3dom.fields.SFVec3f(0, 0, 0),
        pickNorm: new x3dom.fields.SFVec3f(0, 0, 1),
        pickObj: null,
        firstObj: null,
        lastObj: null,
        lastClickObj: null,
        shadowObjectId: -1
    };

    this._rotMat = x3dom.fields.SFMatrix4f.identity();
    this._transMat = x3dom.fields.SFMatrix4f.identity();
    this._movement = new x3dom.fields.SFVec3f(0, 0, 0);

    this._needNavigationMatrixUpdate = true;
    this._deltaT = 0;

    this._pitch = 0;
    this._yaw = 0;
    this._eyePos = new x3dom.fields.SFVec3f(0, 0, 0);

    this._width = 400;
    this._height = 300;
    
    this._dx = 0;
    this._dy = 0;
    this._lastX = -1;
    this._lastY = -1;
    this._pressX = -1;
    this._pressY = -1;
    this._lastButton = 0;

    this._points = 0;   // old render mode flag (but think of better name!)
    this._numRenderedNodes = 0;
    
    this._pick = new x3dom.fields.SFVec3f(0, 0, 0);
    this._pickNorm = new x3dom.fields.SFVec3f(0, 0, 1);
    
    this._isAnimating = false;
    this._isMoving = false;
    this._lastTS = 0;
    this._mixer = new x3dom.MatrixMixer();

    this.arc = null;
};

x3dom.Viewarea.prototype.tick = function(timeStamp)
{
    var needMixAnim = false;
    var env = this._scene.getEnvironment();

    if (env._vf.enableARC && this.arc == null)
    {
        this.arc = new x3dom.arc.AdaptiveRenderControl(this._scene);
    }

    if (this._mixer._beginTime > 0)
    {
        needMixAnim = true;

        if (timeStamp >= this._mixer._beginTime)
        {
            if (timeStamp <= this._mixer._endTime)
            {
                var mat = this._mixer.mix(timeStamp);

                this._scene.getViewpoint().setView(mat);
            }
            else {
                this._mixer._beginTime = 0;
                this._mixer._endTime = 0;

                this._scene.getViewpoint().setView(this._mixer._endMat);
            }
        }
        else {
            this._mixer._beginTime = 0;
            this._mixer._endTime = 0;
            
            this._scene.getViewpoint().setView(this._mixer._beginMat);
        }
    }

    var needNavAnim = this.navigateTo(timeStamp);
    var lastIsAnimating = this._isAnimating;

    this._lastTS = timeStamp;
    this._isAnimating = (needMixAnim || needNavAnim);

    if (this.arc != null )
    {
        this.arc.update(this.isMovingOrAnimating() ? 1 : 0, this._doc._x3dElem.runtime.getFPS());
    }

    return (this._isAnimating || lastIsAnimating);
};

x3dom.Viewarea.prototype.isMoving = function()
{
    return this._isMoving;
};

x3dom.Viewarea.prototype.isAnimating = function()
{
    return this._isAnimating;
};

x3dom.Viewarea.prototype.isMovingOrAnimating = function()
{
    return (this._isMoving || this._isAnimating);
};

x3dom.Viewarea.prototype.navigateTo = function(timeStamp)
{
    var navi = this._scene.getNavigationInfo();
    var navType = navi.getType();
    
    var needNavAnim = ( navType === "game" ||
                        (this._lastButton > 0 &&
                        (navType.indexOf("fly") >= 0 ||
                         navType === "walk" ||
                         navType === "helicopter" ||
                         navType.substr(0, 5) === "looka")) );
    
    this._deltaT = timeStamp - this._lastTS;

    if (needNavAnim)
    {
        var avatarRadius = 0.25;
        var avatarHeight = 1.6;
        var avatarKnee = 0.75;  // TODO; check max. step size

        if (navi._vf.avatarSize.length > 2) {
            avatarRadius = navi._vf.avatarSize[0];
            avatarHeight = navi._vf.avatarSize[1];
            avatarKnee = navi._vf.avatarSize[2];
        }

        // get current view matrix
        var currViewMat = this.getViewMatrix();
        var dist = 0;

        // check if forwards or backwards (on right button)
        var step = (this._lastButton & 2) ? -1 : 1;
        step *= (this._deltaT * navi._vf.speed);

        var phi = Math.PI * this._deltaT * (this._pressX - this._lastX) / this._width;
        var theta = Math.PI * this._deltaT * (this._pressY - this._lastY) / this._height;

        if (this._needNavigationMatrixUpdate === true)
        {
            this._needNavigationMatrixUpdate = false;
          
            // reset examine matrices to identity
            this._rotMat = x3dom.fields.SFMatrix4f.identity();
            this._transMat = x3dom.fields.SFMatrix4f.identity();
            this._movement = new x3dom.fields.SFVec3f(0, 0, 0);

            var angleX = 0;
            var angleY = Math.asin(currViewMat._02);
            var C = Math.cos(angleY);
            
            if (Math.abs(C) > 0.0001) {
                angleX = Math.atan2(-currViewMat._12 / C, currViewMat._22 / C);
            }

            // too many inversions here can lead to distortions
            this._flyMat = currViewMat.inverse();
            
            this._from = this._flyMat.e3();
            this._at = this._from.subtract(this._flyMat.e2());

            if (navType === "helicopter")
                this._at.y = this._from.y;
            
            if (navType.substr(0, 5) !== "looka")
                this._up = new x3dom.fields.SFVec3f(0, 1, 0);
            else
                this._up = this._flyMat.e1();

            this._pitch = angleX * 180 / Math.PI;
            this._yaw = angleY * 180 / Math.PI;
            this._eyePos = this._from.negate();
        }

        var tmpAt = null, tmpUp = null, tmpMat = null;
        var q, temp, fin;
        var lv, sv, up;

        if (navType === "game")
        {
            this._pitch += this._dy;
            this._yaw   += this._dx;

            if (this._pitch >=  89) this._pitch = 89;
            if (this._pitch <= -89) this._pitch = -89;
            if (this._yaw >=  360) this._yaw -= 360;
            if (this._yaw < 0) this._yaw = 360 + this._yaw;
            
            this._dx = 0;
            this._dy = 0;

            var xMat = x3dom.fields.SFMatrix4f.rotationX(this._pitch / 180 * Math.PI);
            var yMat = x3dom.fields.SFMatrix4f.rotationY(this._yaw / 180 * Math.PI);

            var fPos = x3dom.fields.SFMatrix4f.translation(this._eyePos);

            this._flyMat = xMat.mult(yMat).mult(fPos);

            // Finally check floor for terrain following (TODO: optimize!)
            var flyMat = this._flyMat.inverse();

            var tmpFrom = flyMat.e3();
            tmpUp = new x3dom.fields.SFVec3f(0, -1, 0);

            tmpAt = tmpFrom.add(tmpUp);
            tmpUp = flyMat.e0().cross(tmpUp).normalize();

            tmpMat = x3dom.fields.SFMatrix4f.lookAt(tmpFrom, tmpAt, tmpUp);
            tmpMat = tmpMat.inverse();

            this._scene._nameSpace.doc.ctx.pickValue(this, this._width/2, this._height/2,
                        this._lastButton, tmpMat, this.getProjectionMatrix().mult(tmpMat));

            if (this._pickingInfo.pickObj)
            {
                dist = this._pickingInfo.pickPos.subtract(tmpFrom).length();
                //x3dom.debug.logWarning("Floor collision at dist=" + dist.toFixed(4));

                tmpFrom.y += (avatarHeight - dist);
                flyMat.setTranslate(tmpFrom);

                this._eyePos = flyMat.e3().negate();
                this._flyMat = flyMat.inverse();

                this._pickingInfo.pickObj = null;
            }

            this._scene.getViewpoint().setView(this._flyMat);

            return needNavAnim;
        }   // game
        else if (navType === "helicopter")
        {
            var typeParams = navi.getTypeParams();

            if (this._lastButton & 2)
            {
                var stepUp = this._deltaT * this._deltaT * navi._vf.speed;
                stepUp *= 0.1 * (this._pressY - this._lastY) * Math.abs(this._pressY - this._lastY);
                typeParams[1] += stepUp;

                navi.setTypeParams(typeParams);
            }

            if (this._lastButton & 1) {
                step *= 0.01 * (this._pressY - this._lastY) * Math.abs(this._pressY - this._lastY);
            }
            else {
                step = 0;
            }

            theta = typeParams[0];
            this._from.y = typeParams[1];
            this._at.y = this._from.y;

            // rotate around the up vector
            q = x3dom.fields.Quaternion.axisAngle(this._up, phi);
            temp = q.toMatrix();

            fin = x3dom.fields.SFMatrix4f.translation(this._from);
            fin = fin.mult(temp);

            temp = x3dom.fields.SFMatrix4f.translation(this._from.negate());
            fin = fin.mult(temp);

            this._at = fin.multMatrixPnt(this._at);

            // rotate around the side vector
            lv = this._at.subtract(this._from).normalize();
            sv = lv.cross(this._up).normalize();
            up = sv.cross(lv).normalize();

            lv = lv.multiply(step);

            this._from = this._from.add(lv);
            this._at = this._at.add(lv);

            // rotate around the side vector
            q = x3dom.fields.Quaternion.axisAngle(sv, theta);
            temp = q.toMatrix();

            fin = x3dom.fields.SFMatrix4f.translation(this._from);
            fin = fin.mult(temp);

            temp = x3dom.fields.SFMatrix4f.translation(this._from.negate());
            fin = fin.mult(temp);

            var at = fin.multMatrixPnt(this._at);

            this._flyMat = x3dom.fields.SFMatrix4f.lookAt(this._from, at, up);

            this._scene.getViewpoint().setView(this._flyMat.inverse());

            return needNavAnim;
        }   // helicopter

        // rotate around the up vector
        q = x3dom.fields.Quaternion.axisAngle(this._up, phi);
        temp = q.toMatrix();

        fin = x3dom.fields.SFMatrix4f.translation(this._from);
        fin = fin.mult(temp);

        temp = x3dom.fields.SFMatrix4f.translation(this._from.negate());
        fin = fin.mult(temp);

        this._at = fin.multMatrixPnt(this._at);

        // rotate around the side vector
        lv = this._at.subtract(this._from).normalize();
        sv = lv.cross(this._up).normalize();
        up = sv.cross(lv).normalize();
        //this._up = up;

        q = x3dom.fields.Quaternion.axisAngle(sv, theta);
        temp = q.toMatrix();

        fin = x3dom.fields.SFMatrix4f.translation(this._from);
        fin = fin.mult(temp);

        temp = x3dom.fields.SFMatrix4f.translation(this._from.negate());
        fin = fin.mult(temp);

        this._at = fin.multMatrixPnt(this._at);

        // forward along view vector
        if (navType.substr(0, 5) !== "looka")
        {
            var currProjMat = this.getProjectionMatrix();

            if (navType !== "freefly") {
                if (step < 0) {
                    // backwards: negate viewing direction
                    tmpMat = new x3dom.fields.SFMatrix4f();
                    tmpMat.setValue(this._last_mat_view.e0(), this._last_mat_view.e1(),
                                    this._last_mat_view.e2().negate(), this._last_mat_view.e3());

                    this._scene._nameSpace.doc.ctx.pickValue(this, this._width/2, this._height/2,
                                this._lastButton, tmpMat, currProjMat.mult(tmpMat));
                }
                else {
                    this._scene._nameSpace.doc.ctx.pickValue(this, this._width/2, this._height/2, this._lastButton);
                }

                if (this._pickingInfo.pickObj)
                {
                    dist = this._pickingInfo.pickPos.subtract(this._from).length();

                    if (dist <= avatarRadius) {
                        step = 0;
                    }
                }
            }

            lv = this._at.subtract(this._from).normalize().multiply(step);

            this._at = this._at.add(lv);
            this._from = this._from.add(lv);

            // finally attach to ground when walking
            if (navType === "walk")
            {
                tmpAt = this._from.addScaled(up, -1.0);
                tmpUp = sv.cross(up.negate()).normalize();  // lv

                tmpMat = x3dom.fields.SFMatrix4f.lookAt(this._from, tmpAt, tmpUp);
                tmpMat = tmpMat.inverse();

                this._scene._nameSpace.doc.ctx.pickValue(this, this._width/2, this._height/2,
                            this._lastButton, tmpMat, currProjMat.mult(tmpMat));

                if (this._pickingInfo.pickObj)
                {
                    dist = this._pickingInfo.pickPos.subtract(this._from).length();

                    this._at = this._at.add(up.multiply(avatarHeight - dist));
                    this._from = this._from.add(up.multiply(avatarHeight - dist));
                }
            }
            this._pickingInfo.pickObj = null;
        }
        
        this._flyMat = x3dom.fields.SFMatrix4f.lookAt(this._from, this._at, up);

        this._scene.getViewpoint().setView(this._flyMat.inverse());
    }

    return needNavAnim;
};

x3dom.Viewarea.prototype.moveFwd = function()
{
    var navi = this._scene.getNavigationInfo();

    if (navi.getType() === "game")
    {
        var avatarRadius = 0.25;
        var avatarHeight = 1.6;

        if (navi._vf.avatarSize.length > 2) {
            avatarRadius = navi._vf.avatarSize[0];
            avatarHeight = navi._vf.avatarSize[1];
        }

        var speed = 5 * this._deltaT * navi._vf.speed;
        var yRotRad = (this._yaw / 180 * Math.PI);
        var xRotRad = (this._pitch / 180 * Math.PI);

        var dist = 0;
        var fMat = this._flyMat.inverse();

        // check front for collisions
        this._scene._nameSpace.doc.ctx.pickValue(this, this._width/2, this._height/2, this._lastButton);

        if (this._pickingInfo.pickObj)
        {
            dist = this._pickingInfo.pickPos.subtract(fMat.e3()).length();

            if (dist <= 2 * avatarRadius) {
                //x3dom.debug.logWarning("Collision at dist=" + dist.toFixed(4));
            }
            else {
                this._eyePos.x -= Math.sin(yRotRad) * speed;
                this._eyePos.z += Math.cos(yRotRad) * speed;
                this._eyePos.y += Math.sin(xRotRad) * speed;
            }
        }
    }
};

x3dom.Viewarea.prototype.moveBwd = function()
{
    var navi = this._scene.getNavigationInfo();

    if (navi.getType() === "game")
    {
        var speed = 5 * this._deltaT * navi._vf.speed;
        var yRotRad = (this._yaw / 180 * Math.PI);
        var xRotRad = (this._pitch / 180 * Math.PI);

        this._eyePos.x += Math.sin(yRotRad) * speed;
        this._eyePos.z -= Math.cos(yRotRad) * speed;
        this._eyePos.y -= Math.sin(xRotRad) * speed;
    }
};

x3dom.Viewarea.prototype.strafeRight = function()
{
    var navi = this._scene.getNavigationInfo();

    if (navi.getType() === "game")
    {
        var speed = 5 * this._deltaT * navi._vf.speed;
        var yRotRad = (this._yaw / 180 * Math.PI);

        this._eyePos.x -= Math.cos(yRotRad) * speed;
        this._eyePos.z -= Math.sin(yRotRad) * speed;
    }
};

x3dom.Viewarea.prototype.strafeLeft = function()
{
    var navi = this._scene.getNavigationInfo();

    if (navi.getType() === "game")
    {
        var speed = 5 * this._deltaT * navi._vf.speed;
        var yRotRad = (this._yaw / 180 * Math.PI);

        this._eyePos.x += Math.cos(yRotRad) * speed;
        this._eyePos.z += Math.sin(yRotRad) * speed;
    }
};

x3dom.Viewarea.prototype.animateTo = function(target, prev, dur)
{
    var navi = this._scene.getNavigationInfo();

    if (x3dom.isa(target, x3dom.nodeTypes.X3DViewpointNode)) {
        target = target.getViewMatrix().mult(target.getCurrentTransform().inverse());
    }

    if (navi._vf.transitionType[0].toLowerCase() !== "teleport" && navi.getType() !== "game")
    {
        if (prev && x3dom.isa(prev, x3dom.nodeTypes.X3DViewpointNode)) {
            prev = prev.getViewMatrix().mult(prev.getCurrentTransform().inverse()).
                         mult(this._transMat).mult(this._rotMat);

            this._mixer._beginTime = this._lastTS;

            if (arguments.length >= 3) {
                // for lookAt to assure travel speed of 1 m/s
                this._mixer._endTime = this._lastTS + dur;
            }
            else {
                this._mixer._endTime = this._lastTS + navi._vf.transitionTime;
            }

            this._mixer.setBeginMatrix (prev);
            this._mixer.setEndMatrix (target);
            
            this._scene.getViewpoint().setView(prev);
        }
        else {
            this._scene.getViewpoint().setView(target);
        }
    }
    else
    {
        this._scene.getViewpoint().setView(target);
    }

    this._rotMat = x3dom.fields.SFMatrix4f.identity();
    this._transMat = x3dom.fields.SFMatrix4f.identity();
    this._movement = new x3dom.fields.SFVec3f(0, 0, 0);
    this._needNavigationMatrixUpdate = true;
};

x3dom.Viewarea.prototype.getLights = function () {
    var enabledLights = [];
    for (var i=0; i<this._doc._nodeBag.lights.length; i++)
    {
        if (this._doc._nodeBag.lights[i]._vf.on == true)
        {
            enabledLights.push(this._doc._nodeBag.lights[i]);
        }
    }
    return enabledLights;
};

x3dom.Viewarea.prototype.getLightsShadow = function () {
	var lights = this._doc._nodeBag.lights;
	for(var l=0; l<lights.length; l++) {
		if(lights[l]._vf.shadowIntensity > 0.0){
            return true;
        }
	}
    return false;
};

x3dom.Viewarea.prototype.updateSpecialNavigation = function (viewpoint, mat_viewpoint) {
    var navi = this._scene.getNavigationInfo();
    var navType = navi.getType();
    
    // helicopter mode needs to manipulate view matrix specially
    if (navType == "helicopter" && !navi._heliUpdated)
    {
        var typeParams = navi.getTypeParams();
        var theta = typeParams[0];
        var currViewMat = viewpoint.getViewMatrix().mult(mat_viewpoint.inverse()).inverse();

        this._from = currViewMat.e3();
        this._at = this._from.subtract(currViewMat.e2());
        this._up = new x3dom.fields.SFVec3f(0, 1, 0);

        this._from.y = typeParams[1];
        this._at.y = this._from.y;

        var sv = currViewMat.e0();
        var q = x3dom.fields.Quaternion.axisAngle(sv, theta);
        var temp = q.toMatrix();

        var fin = x3dom.fields.SFMatrix4f.translation(this._from);
        fin = fin.mult(temp);

        temp = x3dom.fields.SFMatrix4f.translation(this._from.negate());
        fin = fin.mult(temp);

        this._at = fin.multMatrixPnt(this._at);

        this._flyMat = x3dom.fields.SFMatrix4f.lookAt(this._from, this._at, this._up);
        this._scene.getViewpoint().setView(this._flyMat.inverse());

        navi._heliUpdated = true;
    }
};

x3dom.Viewarea.prototype.getViewpointMatrix = function ()
{
    var viewpoint = this._scene.getViewpoint();
    var mat_viewpoint = viewpoint.getCurrentTransform();
    
    this.updateSpecialNavigation(viewpoint, mat_viewpoint);
    
    return viewpoint.getViewMatrix().mult(mat_viewpoint.inverse());
};

x3dom.Viewarea.prototype.getViewMatrix = function ()
{
    return this.getViewpointMatrix().mult(this._transMat).mult(this._rotMat);
};

x3dom.Viewarea.prototype.getLightMatrix = function ()
{
    var lights = this._doc._nodeBag.lights;
    var i, n = lights.length;

    if (n > 0)
    {
        var vol = this._scene.getVolume();

        if (vol.isValid())
        {
            var min = x3dom.fields.SFVec3f.MAX();
            var max = x3dom.fields.SFVec3f.MIN();
            vol.getBounds(min, max);

            var l_arr = [];
            var viewpoint = this._scene.getViewpoint();
            var fov = viewpoint.getFieldOfView();

            var dia = max.subtract(min);
            var dist1 = (dia.y/2.0) / Math.tan(fov/2.0) + (dia.z/2.0);
            var dist2 = (dia.x/2.0) / Math.tan(fov/2.0) + (dia.z/2.0);

            dia = min.add(dia.multiply(0.5));

            for (i=0; i<n; i++)
            {
                if (x3dom.isa(lights[i], x3dom.nodeTypes.PointLight)) {
                    var wcLoc = lights[i].getCurrentTransform().multMatrixPnt(lights[i]._vf.location);
                    dia = dia.subtract(wcLoc).normalize();
                }
                else {
                    var dir = lights[i].getCurrentTransform().multMatrixVec(lights[i]._vf.direction);
                    dir = dir.normalize().negate();
                    dia = dia.add(dir.multiply(1.2 * (dist1 > dist2 ? dist1 : dist2)));
                }

                l_arr[i] = lights[i].getViewMatrix(dia);
            }

            return l_arr;
        }
    }

    //TODO, this is only for testing
    return [ this.getViewMatrix() ];
};

x3dom.Viewarea.prototype.getWCtoLCMatrix = function(lMat)
{
    var proj = this.getProjectionMatrix();
    var view;

    if (arguments.length === 0) {
        view = this.getLightMatrix()[0];
    }
    else {
        view = lMat;
    }

    return proj.mult(view);
};

/*
 * get six WCtoLCMatrices for point light
 */
x3dom.Viewarea.prototype.getWCtoLCMatricesPointLight = function(view, lightNode, mat_proj)
{	 
	var zNear = lightNode._vf.zNear;
	var zFar = lightNode._vf.zFar;
	
	var proj = this.getLightProjectionMatrix(view, zNear, zFar, false, mat_proj);
	
	//set projection matrix to 90 degrees FOV (vertical and horizontal)
	proj._00 = 1;
	proj._11 = 1;
	
	var matrices = [];
	
	//create six matrices to cover all directions of point light
	matrices[0] = proj.mult(view);
		
	var rotationMatrix;
	
	//y-rotation
	for (var i=1; i<=3; i++){	
		rotationMatrix = x3dom.fields.SFMatrix4f.rotationY(i*Math.PI/2);
		matrices[i] = proj.mult(rotationMatrix.mult(view));
	}
	
	//x-rotation
	rotationMatrix = x3dom.fields.SFMatrix4f.rotationX(Math.PI/2);
	matrices[4] = proj.mult(rotationMatrix.mult(view));
	
	rotationMatrix = x3dom.fields.SFMatrix4f.rotationX(3*Math.PI/2);
	matrices[5] = proj.mult(rotationMatrix.mult(view));
	
    return matrices;
};

/*
 * Get WCToLCMatrices for cascaded light
 */
x3dom.Viewarea.prototype.getWCtoLCMatricesCascaded = function(view, lightNode, mat_proj)
{
	var numCascades = Math.max(1, Math.min(lightNode._vf.shadowCascades, 6));
	var splitFactor = Math.max(0, Math.min(lightNode._vf.shadowSplitFactor, 1));
	var splitOffset = Math.max(0, Math.min(lightNode._vf.shadowSplitOffset, 1));

	var isSpotLight = x3dom.isa(lightNode, x3dom.nodeTypes.SpotLight);
	var zNear = lightNode._vf.zNear;
	var zFar = lightNode._vf.zFar;
	
	var proj = this.getLightProjectionMatrix(view, zNear, zFar, true, mat_proj);
	
	if (isSpotLight){
		//set FOV to 90 degrees
		proj._00 = 1;
		proj._11 = 1;
	}	
	
	//get view projection matrix
	var viewProj = proj.mult(view);	
	
	var matrices = [];

	if (numCascades == 1){
		//return if only one cascade
		matrices[0] = viewProj;
		return matrices;
	}
	
	//compute split positions of view frustum
	var cascadeSplits = this.getShadowSplitDepths(numCascades, splitFactor, splitOffset, true, mat_proj);
	
	//calculate fitting matrices and multiply with view projection
	for (var i=0; i<numCascades; i++){
		var fittingMat = this.getLightFittingMatrix(viewProj, cascadeSplits[i], cascadeSplits[i+1], mat_proj);
		matrices[i] = fittingMat.mult(viewProj);
	}	
	
	return matrices;
};

x3dom.Viewarea.prototype.getLightProjectionMatrix = function(lMat, zNear, zFar, highPrecision, mat_proj)
{
    var proj = x3dom.fields.SFMatrix4f.copy(mat_proj);
	
	if (!highPrecision || zNear > 0 || zFar > 0) {
		//replace near and far plane of projection matrix
		//by values adapted to the light position
		
		var lightPos = lMat.inverse().e3();
		
		var nearScale = 0.8;
		var farScale = 1.2;
		
		var min = x3dom.fields.SFVec3f.copy(this._scene._lastMin);
		var max = x3dom.fields.SFVec3f.copy(this._scene._lastMax); 

		var dia = max.subtract(min);
		var sRad = dia.length() / 2;
		
		var sCenter = min.add(dia.multiply(0.5));
		var vDist = (lightPos.subtract(sCenter)).length();
		
		var near, far;
		
		if (sRad) {
			if (vDist > sRad)
				near = (vDist - sRad) * nearScale; 
			else
				near = 1;                           
			far = (vDist + sRad) * farScale;
		}
		if (zNear > 0) near = zNear;
		if (zFar > 0) far = zFar;

		proj._22 = -(far+near)/(far-near);
		proj._23 = -2.0*far*near / (far-near);
		
		return proj;
	}
    else {
		//should be more accurate, but also more expensive
		var cropMatrix = this.getLightCropMatrix(proj.mult(lMat));
		
		return cropMatrix.mult(proj);
	}
};

x3dom.Viewarea.prototype.getProjectionMatrix = function()
{
    var viewpoint = this._scene.getViewpoint();

    return viewpoint.getProjectionMatrix(this._width/this._height);
};

x3dom.Viewarea.prototype.getViewfrustum = function(clipMat)
{
    var env = this._scene.getEnvironment();

    if (env._vf.frustumCulling == true)
    {
        if (arguments.length == 0) {
            var proj = this.getProjectionMatrix();
            var view = this.getViewMatrix();
    
            return new x3dom.fields.FrustumVolume(proj.mult(view));
        }
        else {
            return new x3dom.fields.FrustumVolume(clipMat);
        }
    }

    return null;
};

x3dom.Viewarea.prototype.getWCtoCCMatrix = function()
{
    var view = this.getViewMatrix();
    var proj = this.getProjectionMatrix();

    return proj.mult(view);
};

x3dom.Viewarea.prototype.getCCtoWCMatrix = function()
{
    var mat = this.getWCtoCCMatrix();

    return mat.inverse();
};

x3dom.Viewarea.prototype.calcViewRay = function(x, y, mat)
{
    var cctowc = mat ? mat : this.getCCtoWCMatrix();

    var rx = x / (this._width - 1.0) * 2.0 - 1.0;
    var ry = (this._height - 1.0 - y) / (this._height - 1.0) * 2.0 - 1.0;

    var from = cctowc.multFullMatrixPnt(new x3dom.fields.SFVec3f(rx, ry, -1));
    var at = cctowc.multFullMatrixPnt(new x3dom.fields.SFVec3f(rx, ry,  1));
    var dir = at.subtract(from);

    return new x3dom.fields.Line(from, dir);
};

x3dom.Viewarea.prototype.showAll = function(axis)
{
    if (axis === undefined)
        axis = "negZ";

    var scene = this._scene;
    scene.updateVolume();

    var min = x3dom.fields.SFVec3f.copy(scene._lastMin);
    var max = x3dom.fields.SFVec3f.copy(scene._lastMax);

    var x = "x", y = "y", z = "z";
    var sign = 1;
    var to, from = new x3dom.fields.SFVec3f(0, 0, -1);

    switch (axis) {
        case "posX":
        sign = -1;
        case "negX":
        z = "x"; x = "y"; y = "z";
        to = new x3dom.fields.SFVec3f(sign, 0, 0);
        break;
        case "posY":
        sign = -1;
        case "negY":
        z = "y"; x = "z"; y = "x";
        to = new x3dom.fields.SFVec3f(0, sign, 0);
        break;
        case "posZ":
        sign = -1;
        case "negZ":
        default:
        to = new x3dom.fields.SFVec3f(0, 0, -sign);
        break;
    }

    var viewpoint = scene.getViewpoint();
    var fov = viewpoint.getFieldOfView();

    var dia = max.subtract(min);

    var diaz2 = dia[z] / 2.0, tanfov2 = Math.tan(fov / 2.0);

    var dist1 = (dia[y] / 2.0) / tanfov2 + diaz2;
    var dist2 = (dia[x] / 2.0) / tanfov2 + diaz2;

    dia = min.add(dia.multiply(0.5));

    dia[z] += sign * (dist1 > dist2 ? dist1 : dist2) * 1.01;

    var quat = x3dom.fields.Quaternion.rotateFromTo(from, to);

    var viewmat = quat.toMatrix();
    viewmat = viewmat.mult(x3dom.fields.SFMatrix4f.translation(dia.negate()));

    this.animateTo(viewmat, viewpoint);
};

x3dom.Viewarea.prototype.fit = function(min, max, updateCenterOfRotation)
{
    if (updateCenterOfRotation === undefined) {
        updateCenterOfRotation = true;
    }

    var scene = this._scene;

    var dia2 = max.subtract(min).multiply(0.5);    // half diameter
    var center = min.add(dia2);                    // center in wc
    var bsr = min.subtract(center).length();       // bounding sphere radius

    var viewpoint = scene.getViewpoint();
    var fov = viewpoint.getFieldOfView();

    var tanfov2 = Math.tan(fov / 2.0);

    var viewmat = x3dom.fields.SFMatrix4f.copy(this.getViewMatrix());

    var rightDir = new x3dom.fields.SFVec3f(viewmat._00, viewmat._01, viewmat._02);
    var upDir = new x3dom.fields.SFVec3f(viewmat._10, viewmat._11, viewmat._12);
    var viewDir = new x3dom.fields.SFVec3f(viewmat._20, viewmat._21, viewmat._22);

    var dist = (bsr / tanfov2);
    var lookAt = center;
    var eyePos = lookAt.add(viewDir.multiply(dist));

    viewmat._03 = -rightDir.dot(eyePos);
    viewmat._13 = -upDir.dot(eyePos);
    viewmat._23 = -viewDir.dot(eyePos);

    if (updateCenterOfRotation) {
        viewpoint._vf.centerOfRotation = center;
    }

    this.animateTo(viewmat, viewpoint);
};

x3dom.Viewarea.prototype.resetView = function()
{
    var navi = this._scene.getNavigationInfo();

    if (navi._vf.transitionType[0].toLowerCase() !== "teleport" && navi.getType() !== "game")
    {
        this._mixer._beginTime = this._lastTS;
        this._mixer._endTime = this._lastTS + navi._vf.transitionTime;

        this._mixer.setBeginMatrix(this.getViewMatrix());

        var target = this._scene.getViewpoint();
        target.resetView();

        target = target.getViewMatrix().mult(target.getCurrentTransform().inverse());

        this._mixer.setEndMatrix(target);
    }
    else
    {
        this._scene.getViewpoint().resetView();
    }

    this._rotMat = x3dom.fields.SFMatrix4f.identity();
    this._transMat = x3dom.fields.SFMatrix4f.identity();
    this._movement = new x3dom.fields.SFVec3f(0, 0, 0);
    this._needNavigationMatrixUpdate = true;
    navi._heliUpdated = false;
};

x3dom.Viewarea.prototype.uprightView = function()
{
    var mat = this.getViewMatrix().inverse();

    var from = mat.e3();
    var at = from.subtract(mat.e2());
    var up = new x3dom.fields.SFVec3f(0, 1, 0);

    var s = mat.e2().cross(up).normalize();
    var v = s.cross(up).normalize();
    at = from.add(v);

    mat = x3dom.fields.SFMatrix4f.lookAt(from, at, up);
    mat = mat.inverse();

    this.animateTo(mat, this._scene.getViewpoint());
};

x3dom.Viewarea.prototype.callEvtHandler = function (node, eventType, event)
{
    if (!node || !node._xmlNode)
        return null;
        
    event.target = node._xmlNode;
    var attrib = node._xmlNode[eventType];

    try {
        if (typeof(attrib) === "function") {
            attrib.call(node._xmlNode, event);
        }
        else {
            var funcStr = node._xmlNode.getAttribute(eventType);
            var func = new Function('event', funcStr);
            func.call(node._xmlNode, event);
        }

        var list = node._listeners[event.type];
        if (list) {
            for (var it=0; it<list.length; it++) {
                list[it].call(node._xmlNode, event);
            }
        }
    }
    catch(e) {
        x3dom.debug.logException(e);
    }

    return event.cancelBubble;
};

x3dom.Viewarea.prototype.checkEvents = function (obj, x, y, buttonState, eventType)
{
    var that = this;
    var needRecurse = true;

    var event = {
        target: {},
        type: eventType.substr(2, eventType.length-2),
        button: buttonState,
        layerX: x,
        layerY: y,
        worldX: that._pick.x,
        worldY: that._pick.y,
        worldZ: that._pick.z,
        normalX: that._pickNorm.x,
        normalY: that._pickNorm.y,
        normalZ: that._pickNorm.z,
        hitPnt: that._pick.toGL(), // for convenience
        hitObject: (obj && obj._xmlNode) ? obj._xmlNode : null,
        shadowObjectId: that._pickingInfo.shadowObjectId,
        cancelBubble: false,
        stopPropagation: function() { this.cancelBubble = true; },
		preventDefault: function() { this.cancelBubble = true; }
    };

    try {
        var anObj = obj;
        
        if ( anObj && anObj._xmlNode && anObj._cf.geometry &&
             !anObj._xmlNode[eventType] &&
             !anObj._xmlNode.hasAttribute(eventType) &&
             !anObj._listeners[event.type]) {
            anObj = anObj._cf.geometry.node;
        }
        
        if (anObj && that.callEvtHandler(anObj, eventType, event) === true) {
            needRecurse = false;
        }
    }
    catch(e) {
        x3dom.debug.logException(e);
    }

    var recurse = function(obj) {
        Array.forEach(obj._parentNodes, function (node) {
            if ( node._xmlNode && (node._xmlNode[eventType] ||
                 node._xmlNode.hasAttribute(eventType) ||
                 node._listeners[event.type]) )
            {
                if (that.callEvtHandler(node, eventType, event) === true) {
                    needRecurse = false;
                }
            }
            if (x3dom.isa(node, x3dom.nodeTypes.Anchor) && eventType === 'onclick') {
                node.handleTouch();
                needRecurse = false;
            }
            else if (needRecurse) {
                recurse(node);
            }
        });
    };

    if (needRecurse && obj) {
        recurse(obj);
    }
	
	return needRecurse;
};

x3dom.Viewarea.prototype.initMouseState = function()
{
    this._deltaT = 0;
    this._dx = 0;
    this._dy = 0;
    this._lastX = -1;
    this._lastY = -1;
    this._pressX = -1;
    this._pressY = -1;
    this._lastButton = 0;
    this._isMoving = false;
    this._needNavigationMatrixUpdate = true;
};

x3dom.Viewarea.prototype.onMousePress = function (x, y, buttonState)
{
    this._needNavigationMatrixUpdate = true;

    this.prepareEvents(x, y, buttonState, "onmousedown");
    this._pickingInfo.lastClickObj = this._pickingInfo.pickObj;
    this._pickingInfo.firstObj = this._pickingInfo.pickObj;

    this._dx = 0;
    this._dy = 0;
    this._lastX = x;
    this._lastY = y;
    this._pressX = x;
    this._pressY = y;
    this._lastButton = buttonState;
    this._isMoving = false;

    var navi = this._scene.getNavigationInfo();
    var navType = navi.getType();

    if (navType === "turntable")
    {
        var currViewMat = this.getViewMatrix();

        var viewpoint = this._scene.getViewpoint();
        var center = x3dom.fields.SFVec3f.copy(viewpoint.getCenterOfRotation());

        this._flyMat = currViewMat.inverse();

        this._from = this._flyMat.e3();
        //this._at = this._from.subtract(this._flyMat.e2());
        this._at = center;
        this._up = this._flyMat.e1();

        this._flyMat = x3dom.fields.SFMatrix4f.lookAt(this._from, this._at, this._up);

        var dur = 0.2 / navi._vf.speed;   // fly to pivot point
        this.animateTo(this._flyMat.inverse(), viewpoint, dur);
    }
};

x3dom.Viewarea.prototype.onMouseRelease = function (x, y, buttonState, prevButton)
{
    var tDist = 3.0;  // distance modifier for lookat, could be param
    var dir;
    var navi = this._scene.getNavigationInfo();
    var navType = navi.getType();

    if (this._scene._vf.pickMode.toLowerCase() !== "box") {
        this.prepareEvents(x, y, prevButton, "onmouseup");

        // click means that mousedown _and_ mouseup were detected on same element
        if (this._pickingInfo.pickObj &&
            this._pickingInfo.pickObj === this._pickingInfo.lastClickObj)
        {
            this.prepareEvents(x, y, prevButton, "onclick");
        }
        else if (!this._pickingInfo.pickObj && !this._pickingInfo.lastClickObj &&
                 !this._pickingInfo.firstObj)   // press and release outside object
        {
            var eventType = "backgroundClicked";
            try {
                if ( this._scene._xmlNode &&
                    (this._scene._xmlNode["on" + eventType] ||
                        this._scene._xmlNode.hasAttribute("on" + eventType) ||
                        this._scene._listeners[eventType]) ) {
                    var event = {
                        target: {}, type: eventType,
                        button: prevButton, layerX: x, layerY: y,
                        cancelBubble: false,
                        stopPropagation: function () { this.cancelBubble = true; },
                        preventDefault:  function () { this.cancelBubble = true; }
                    };
                    this._scene.callEvtHandler(("on" + eventType), event);
                }
            }
            catch (e) { x3dom.debug.logException("backgroundClicked: " + e); }
        }
    }
    else {
        var t0 = new Date().getTime();
        var line = this.calcViewRay(x, y);
        var isect = this._scene.doIntersect(line);
        var obj = line.hitObject;

        if (isect && obj)
        {
            this._pick.setValues(line.hitPoint);

            this.checkEvents(obj, x, y, buttonState, "onclick");

            x3dom.debug.logInfo("Hit '" + obj._xmlNode.localName + "/ " +
                                obj._DEF + "' at dist=" + line.dist.toFixed(4));
            x3dom.debug.logInfo("Ray hit at position " + this._pick);
        }

        var t1 = new Date().getTime() - t0;
        x3dom.debug.logInfo("Picking time (box): " + t1 + "ms");

        if (!isect) {
            dir = this.getViewMatrix().e2().negate();
            var u = dir.dot(line.pos.negate()) / dir.dot(line.dir);
            this._pick = line.pos.add(line.dir.multiply(u));
            //x3dom.debug.logInfo("No hit at position " + this._pick);
        }
    }
    this._pickingInfo.firstObj = null;

    if ((this._pickingInfo.pickObj || this._pickingInfo.shadowObjectId >= 0) &&
        navType === "lookat" && this._pressX === x && this._pressY === y)
    {
        var step = (this._lastButton & 2) ? -1 : 1;
        var dist = this._pickingInfo.pickPos.subtract(this._from).length() / tDist;

        var laMat = new x3dom.fields.SFMatrix4f();
        laMat.setValues(this.getViewMatrix());
        laMat = laMat.inverse();

        var from = laMat.e3();
        var at = from.subtract(laMat.e2());
        var up = laMat.e1();

        dir = this._pickingInfo.pickPos.subtract(from);
        var len = dir.length();
        dir = dir.normalize();

        //var newUp = new x3dom.fields.SFVec3f(0, 1, 0);
        var newAt = from.addScaled(dir, len);

        var s = dir.cross(up).normalize();
        dir = s.cross(up).normalize();

        if (step < 0) {
            dist = (0.5 + len + dist) * 2;
        }
        var newFrom = newAt.addScaled(dir, dist);

        laMat = x3dom.fields.SFMatrix4f.lookAt(newFrom, newAt, up);
        laMat = laMat.inverse();

        dist = newFrom.subtract(from).length();
        var dur = Math.max(0.5, Math.log((1 + dist) / navi._vf.speed));

        this.animateTo(laMat, this._scene.getViewpoint(), dur);
    }

    this._dx = 0;
    this._dy = 0;
    this._lastX = x;
    this._lastY = y;
    this._lastButton = buttonState;
    this._isMoving = false;
};

x3dom.Viewarea.prototype.onMouseOver = function (x, y, buttonState)
{
    this._dx = 0;
    this._dy = 0;
    this._lastButton = 0;
    this._isMoving = false;
    this._lastX = x;
    this._lastY = y;
    this._deltaT = 0;
};

x3dom.Viewarea.prototype.onMouseOut = function (x, y, buttonState)
{
    this._dx = 0;
    this._dy = 0;
    this._lastButton = 0;
    this._isMoving = false;
    this._lastX = x;
    this._lastY = y;
    this._deltaT = 0;
};

x3dom.Viewarea.prototype.onDoubleClick = function (x, y)
{
    if (this._doc.properties.getProperty('disableDoubleClick', 'false') === 'true') {
        return;
    }
    
    var navi = this._scene.getNavigationInfo();
    
    if (navi.getType() == "none") {
        return;
    }

    var pickMode = this._scene._vf.pickMode.toLowerCase();

    if ((pickMode == "color" || pickMode == "texcoord")) {
         return;
    }

    var viewpoint = this._scene.getViewpoint();

    if (viewpoint._vf.centerOfRotation) {
        viewpoint._vf.centerOfRotation.setValues(this._pick);
    }
    else {
        viewpoint._centerOfRotation.setValues(this._pick);  // Viewfrustum
    }
    x3dom.debug.logInfo("New center of Rotation:  " + this._pick);

    var mat = this.getViewMatrix().inverse();

    var from = mat.e3();
    var at = this._pick;
    var up = mat.e1();

    var norm = mat.e0().cross(up).normalize();
    // get distance between look-at point and viewing plane
    var dist = norm.dot(this._pick.subtract(from));
    
    from = at.addScaled(norm, -dist);
    mat = x3dom.fields.SFMatrix4f.lookAt(from, at, up);
    
    x3dom.debug.logInfo("New camera position:  " + from);
    this.animateTo(mat.inverse(), viewpoint);
};

x3dom.Viewarea.prototype.handleMoveEvt = function (x, y, buttonState)
{
    this.prepareEvents(x, y, buttonState, "onmousemove");

    if (this._pickingInfo.pickObj !== this._pickingInfo.lastObj)
    {
        if (this._pickingInfo.lastObj) {
            var obj = this._pickingInfo.pickObj;
            this._pickingInfo.pickObj = this._pickingInfo.lastObj;

            // call event for lastObj
            this.prepareEvents(x, y, buttonState, "onmouseout");
            this._pickingInfo.pickObj = obj;
        }

        if (this._pickingInfo.pickObj) {
            // call event for pickObj
            this.prepareEvents(x, y, buttonState, "onmouseover");
        }

        this._pickingInfo.lastObj = this._pickingInfo.pickObj;
    }
};

x3dom.Viewarea.prototype.onMove = function (x, y, buttonState)
{
    this.handleMoveEvt(x, y, buttonState);

    if (this._lastX < 0 || this._lastY < 0) {
        this._lastX = x;
        this._lastY = y;
    }
    this._dx = x - this._lastX;
    this._dy = y - this._lastY;
    this._lastX = x;
    this._lastY = y;
};

// multi-touch version of examine mode, called from X3DCanvas.js
x3dom.Viewarea.prototype.onMoveView = function (translation, rotation)
{
	var navi = this._scene.getNavigationInfo();
	var viewpoint = this._scene.getViewpoint();

	if (navi.getType() === "examine")
	{
		if (translation)
		{
			var distance = (this._scene._lastMax.subtract(this._scene._lastMin)).length();
			distance = ((distance < x3dom.fields.Eps) ? 1 : distance) * navi._vf.speed;
			
			translation = translation.multiply(distance);
            this._movement = this._movement.add(translation);

            this._transMat = viewpoint.getViewMatrix().inverse().
                mult(x3dom.fields.SFMatrix4f.translation(this._movement)).
                mult(viewpoint.getViewMatrix());
		}
		
		if (rotation)
        {            
            var center = viewpoint.getCenterOfRotation();
            var mat = this.getViewMatrix();
            mat.setTranslate(new x3dom.fields.SFVec3f(0,0,0));

            this._rotMat = this._rotMat.
                           mult(x3dom.fields.SFMatrix4f.translation(center)).
                           mult(mat.inverse()).mult(rotation).mult(mat).
                           mult(x3dom.fields.SFMatrix4f.translation(center.negate()));
		}

        this._isMoving = true;
	}
};

x3dom.Viewarea.prototype.onDrag = function (x, y, buttonState)
{
    // should onmouseover/-out be handled on drag?
    this.handleMoveEvt(x, y, buttonState);

    var navi = this._scene.getNavigationInfo();

    var navType = navi.getType();
    var navRestrict = navi.getExplorationMode();
    
    if (navType === "none" || navRestrict == 0) {
        return;
    }

    var viewpoint = this._scene.getViewpoint();

    var dx = x - this._lastX;
    var dy = y - this._lastY;
    var d, vec, mat = null;
    var alpha, beta;

    buttonState = ((navRestrict & buttonState) != buttonState) ? navRestrict : buttonState;

    if (navType === "examine")
    {
        if (buttonState & 1) //left
        {
            alpha = (dy * 2 * Math.PI) / this._width;
            beta = (dx * 2 * Math.PI) / this._height;
            mat = this.getViewMatrix();

            var mx = x3dom.fields.SFMatrix4f.rotationX(alpha);
            var my = x3dom.fields.SFMatrix4f.rotationY(beta);

            var center = viewpoint.getCenterOfRotation();
            mat.setTranslate(new x3dom.fields.SFVec3f(0,0,0));

            this._rotMat = this._rotMat.
                           mult(x3dom.fields.SFMatrix4f.translation(center)).
                           mult(mat.inverse()).mult(mx).mult(my).mult(mat).
                           mult(x3dom.fields.SFMatrix4f.translation(center.negate()));
        }
        if (buttonState & 4) //middle
        {
			d = (this._scene._lastMax.subtract(this._scene._lastMin)).length();
			d = ((d < x3dom.fields.Eps) ? 1 : d) * navi._vf.speed;

            vec = new x3dom.fields.SFVec3f(d*dx/this._width, d*(-dy)/this._height, 0);
            this._movement = this._movement.add(vec);

            mat = this.getViewpointMatrix().mult(this._transMat);
            //TODO; move real distance along viewing plane
            this._transMat = mat.inverse().
                             mult(x3dom.fields.SFMatrix4f.translation(this._movement)).
                             mult(mat);
        }
        if (buttonState & 2) //right
        {
			d = (this._scene._lastMax.subtract(this._scene._lastMin)).length();
			d = ((d < x3dom.fields.Eps) ? 1 : d) * navi._vf.speed;

            vec = new x3dom.fields.SFVec3f(0, 0, d*(dx+dy)/this._height);
            this._movement = this._movement.add(vec);

            mat = this.getViewpointMatrix().mult(this._transMat);
            //TODO; move real distance along viewing ray
            this._transMat = mat.inverse().
                             mult(x3dom.fields.SFMatrix4f.translation(this._movement)).
                             mult(mat);
        }

        this._isMoving = true;
    }
    else if (navType === "turntable")   // requires that y is up vector in world coords
    {
        if (buttonState & 1) //left
        {
            alpha = (dy * 2 * Math.PI) / this._height;
            beta = (dx * 2 * Math.PI) / this._width;

            this._up   = this._flyMat.e1();
            this._from = this._flyMat.e3();

            var offset = this._from.subtract(this._at);

            // angle in xz-plane
            var phi = Math.atan2(offset.x, offset.z);

            // angle from y-axis
            var theta = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);

            phi -= Math.min(beta, 0.1);
            theta -= Math.min(alpha, 0.1);

            // clamp theta
            var typeParams = navi.getTypeParams();
            theta = Math.max(typeParams[2], Math.min(typeParams[3], theta));

            var radius = offset.length();

            // calc new cam position
            var rSinPhi = radius * Math.sin(theta);

            offset.x = rSinPhi * Math.sin(phi);
            offset.y = radius  * Math.cos(theta);
            offset.z = rSinPhi * Math.cos(phi);

            offset = this._at.add(offset);

            // calc new up vector
            theta -= Math.PI / 2;

            var sinPhi = Math.sin(theta);
            var cosPhi = Math.cos(theta);
            var up = new x3dom.fields.SFVec3f(sinPhi * Math.sin(phi), cosPhi, sinPhi * Math.cos(phi));

            if (up.y < 0)
                up = up.negate();

            this._flyMat = x3dom.fields.SFMatrix4f.lookAt(offset, this._at, up);
            viewpoint.setView(this._flyMat.inverse());
        }
        else if (buttonState & 2) //right
        {
            d = (this._scene._lastMax.subtract(this._scene._lastMin)).length();
            d = ((d < x3dom.fields.Eps) ? 1 : d) * navi._vf.speed;

            this._up   = this._flyMat.e1();
            this._from = this._flyMat.e3();

            // zoom in/out
            var lastDir  = this._from.subtract(this._at);
            var lastDirL = lastDir.length();

            var zoomAmount = -d*(dx+dy) / this._height;

            //maintain minimum distance to prevent orientation flips
            var newDist = Math.max(lastDirL + zoomAmount, 1.0);

            this._from = this._at.addScaled(lastDir.normalize(), newDist);

            this._flyMat = x3dom.fields.SFMatrix4f.lookAt(this._from, this._at, this._up);
            viewpoint.setView(this._flyMat.inverse());
        }

        this._isMoving = true;
    }

    this._dx = dx;
    this._dy = dy;

    this._lastX = x;
    this._lastY = y;
};

x3dom.Viewarea.prototype.prepareEvents = function (x, y, buttonState, eventType)
{
    var pickMode = this._scene._vf.pickMode.toLowerCase();
    var avoidTraversal = (pickMode.indexOf("idbuf") == 0 ||
                          pickMode == "color" || pickMode == "texcoord");

    if (avoidTraversal) {
        var obj = this._pickingInfo.pickObj;

        if (obj) {
            this._pick.setValues(this._pickingInfo.pickPos);
            this._pickNorm.setValues(this._pickingInfo.pickNorm);

            this.checkEvents(obj, x, y, buttonState, eventType);

            if (eventType === "onclick") {  // debug
                if (obj._xmlNode)
                    x3dom.debug.logInfo("Hit \"" + obj._xmlNode.localName + "/ " + obj._DEF + "\"");
                x3dom.debug.logInfo("Ray hit at position " + this._pick);
            }
        }
    }
};


x3dom.Viewarea.prototype.getRenderMode = function()
{
    // this._points == 0 ? TRIANGLES or TRIANGLE_STRIP
    // this._points == 1 ? gl.POINTS
    // this._points == 2 ? gl.LINES
    // TODO: 3 :== surface with additional wireframe render mode
    return this._points;
};


x3dom.Viewarea.prototype.getShadowedLights = function()
{	
	var shadowedLights = [];
	var shadowIndex = 0;
	var slights = this.getLights();
	for (var i=0; i<slights.length; i++){
		if (slights[i]._vf.shadowIntensity > 0.0){
			shadowedLights[shadowIndex] = slights[i];
			shadowIndex++;
		}
	}
	return shadowedLights;
};


/*
 * Calculate view frustum split positions for the given number of cascades
 */
x3dom.Viewarea.prototype.getShadowSplitDepths = function(numCascades, splitFactor, splitOffset, postProject, mat_proj)
{
	var logSplit;
	var practSplit = [];
	
	var viewPoint = this._scene.getViewpoint();
	
	var zNear = viewPoint.getNear();
	var zFar = viewPoint.getFar();

	practSplit[0] = zNear;
	
	//pseudo near plane for bigger cascades near camera
	zNear = zNear + splitOffset*(zFar-zNear)/10;
	
	//calculate split depths according to "practical split scheme"
	for (var i=1;i<numCascades;i++){
		logSplit = zNear * Math.pow((zFar / zNear), i / numCascades);
		practSplit[i] = splitFactor * logSplit + (1 - splitFactor) * (zNear + i / (numCascades * (zNear-zFar)));
	}
	practSplit[numCascades] = zFar;
	
	//return in view coords
	if (!postProject)
        return practSplit;
	
	//return in post projective coords
	var postProj = [];
	
	for (var j=0; j<=numCascades; j++){
		postProj[j] = mat_proj.multFullMatrixPnt(new x3dom.fields.SFVec3f(0,0,-practSplit[j])).z;
	}
	
	return postProj;
};


/*
 * calculate a matrix to enhance the placement of 
 * the near and far planes of the light projection matrix
*/
x3dom.Viewarea.prototype.getLightCropMatrix = function(WCToLCMatrix)
{	
	//get corner points of scene bounds
	var sceneMin = x3dom.fields.SFVec3f.copy(this._scene._lastMin);
	var sceneMax = x3dom.fields.SFVec3f.copy(this._scene._lastMax);
	
	var sceneCorners = [];
	sceneCorners[0] = new x3dom.fields.SFVec3f(sceneMin.x, sceneMin.y, sceneMin.z);
	sceneCorners[1] = new x3dom.fields.SFVec3f(sceneMin.x, sceneMin.y, sceneMax.z);
	sceneCorners[2] = new x3dom.fields.SFVec3f(sceneMin.x, sceneMax.y, sceneMin.z);
	sceneCorners[3] = new x3dom.fields.SFVec3f(sceneMin.x, sceneMax.y, sceneMax.z);
	sceneCorners[4] = new x3dom.fields.SFVec3f(sceneMax.x, sceneMin.y, sceneMin.z);
	sceneCorners[5] = new x3dom.fields.SFVec3f(sceneMax.x, sceneMin.y, sceneMax.z);
	sceneCorners[6] = new x3dom.fields.SFVec3f(sceneMax.x, sceneMax.y, sceneMin.z);
	sceneCorners[7] = new x3dom.fields.SFVec3f(sceneMax.x, sceneMax.y, sceneMax.z);
	
	//transform scene bounds into light space
    var i;
	for (i=0; i<8; i++){
		sceneCorners[i] = WCToLCMatrix.multFullMatrixPnt(sceneCorners[i]);
	}
	
	//determine min and max values in light space
	var minScene = x3dom.fields.SFVec3f.copy(sceneCorners[0]);
	var maxScene = x3dom.fields.SFVec3f.copy(sceneCorners[0]);
	
	for (i=1; i<8; i++){
		minScene.z = Math.min(sceneCorners[i].z, minScene.z); 
		maxScene.z = Math.max(sceneCorners[i].z, maxScene.z); 
	}

	var scaleZ = 2.0 / (maxScene.z - minScene.z);
	var offsetZ = -(scaleZ * (maxScene.z + minScene.z)) / 2.0;	
		
	//var scaleZ = 1.0 / (maxScene.z - minScene.z);
	//var offsetZ = -minScene.z * scaleZ;

	var cropMatrix = x3dom.fields.SFMatrix4f.identity();
	
	cropMatrix._22 = scaleZ;
	cropMatrix._23 = offsetZ;	
	
	return cropMatrix;	
};
	

/*
 * Calculate a matrix to fit the given wctolc-matrix to the split boundaries
 */
x3dom.Viewarea.prototype.getLightFittingMatrix = function(WCToLCMatrix, zNear, zFar, mat_proj)
{
	var mat_view = this.getViewMatrix();
	var mat_view_proj = mat_proj.mult(mat_view);
	var mat_view_proj_inverse = mat_view_proj.inverse();
	
	//define view frustum corner points in post perspective view space
	var frustumCorners = [];
	frustumCorners[0] = new x3dom.fields.SFVec3f(-1, -1, zFar);
	frustumCorners[1] = new x3dom.fields.SFVec3f(-1, -1, zNear);
	frustumCorners[2] = new x3dom.fields.SFVec3f(-1,  1, zFar);
	frustumCorners[3] = new x3dom.fields.SFVec3f(-1,  1, zNear);
	frustumCorners[4] = new x3dom.fields.SFVec3f( 1, -1, zFar);
	frustumCorners[5] = new x3dom.fields.SFVec3f( 1, -1, zNear);
	frustumCorners[6] = new x3dom.fields.SFVec3f( 1,  1, zFar);
	frustumCorners[7] = new x3dom.fields.SFVec3f( 1,  1, zNear);
	

	//transform corner points into post perspective light space
    var i;
	for (i=0; i<8; i++){
		frustumCorners[i] = mat_view_proj_inverse.multFullMatrixPnt(frustumCorners[i]);
		frustumCorners[i] = WCToLCMatrix.multFullMatrixPnt(frustumCorners[i]);
	}
	
	//calculate minimum and maximum values
	var minFrustum = x3dom.fields.SFVec3f.copy(frustumCorners[0]);
	var maxFrustum = x3dom.fields.SFVec3f.copy(frustumCorners[0]);

	for (i=1; i<8; i++){
		minFrustum.x = Math.min(frustumCorners[i].x, minFrustum.x); 
		minFrustum.y = Math.min(frustumCorners[i].y, minFrustum.y);
		minFrustum.z = Math.min(frustumCorners[i].z, minFrustum.z); 
		
		maxFrustum.x = Math.max(frustumCorners[i].x, maxFrustum.x); 
		maxFrustum.y = Math.max(frustumCorners[i].y, maxFrustum.y); 
		maxFrustum.z = Math.max(frustumCorners[i].z, maxFrustum.z); 
	}
	
	
	//clip values to box (-1,-1,-1),(1,1,1)
	function clip(min,max)
    {
		var xMin = min.x;
		var yMin = min.y;
		var zMin = min.z;
		var xMax = max.x;
		var yMax = max.y;
		var zMax = max.z;
		
		if (xMin > 1.0 || xMax < -1.0) {
			xMin = -1.0;
			xMax =  1.0;
		} else {
			xMin = Math.max(xMin,-1.0);
			xMax = Math.min(xMax, 1.0);
		}
		
		if (yMin > 1.0 || yMax < -1.0) {
			yMin = -1.0;
			yMax =  1.0;
		} else {
			yMin = Math.max(yMin,-1.0);
			yMax = Math.min(yMax, 1.0);
		}
					   
		if (zMin > 1.0 || zMax < -1.0){
			zMin = -1.0;
			zMax = 1.0;
		} else {
			zMin = Math.max(zMin,-1.0);
			zMax = Math.min(zMax, 1.0);
		}
		var minValues = new x3dom.fields.SFVec3f(xMin,yMin,zMin);
		var maxValues = new x3dom.fields.SFVec3f(xMax,yMax,zMax);

		return new x3dom.fields.BoxVolume(minValues,maxValues);
	}
	
	var frustumBB = clip(minFrustum, maxFrustum);

	//define fitting matrix
	var scaleX = 2.0 / (frustumBB.max.x - frustumBB.min.x);
	var scaleY = 2.0 / (frustumBB.max.y - frustumBB.min.y);
	var offsetX = -(scaleX * (frustumBB.max.x + frustumBB.min.x)) / 2.0;
	var offsetY = -(scaleY * (frustumBB.max.y + frustumBB.min.y)) / 2.0;
	
	var fittingMatrix = x3dom.fields.SFMatrix4f.identity();
	
	fittingMatrix._00 = scaleX;
	fittingMatrix._11 = scaleY;
	fittingMatrix._03 = offsetX;
	fittingMatrix._13 = offsetY;

	return fittingMatrix;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/** @class x3dom.Mesh
*/
x3dom.Mesh = function(parent) 
{
    this._parent = parent;

    this._vol = new x3dom.fields.BoxVolume();

    this._invalidate = true;
    this._numFaces = 0;
    this._numCoords = 0;

    // cp. x3dom.Utils.primTypeDic for type list
	this._primType = 'TRIANGLES';
    
    this._positions = [];
    this._normals   = [];
    this._texCoords = [];
    this._colors    = [];
    this._indices   = [];
    
    this._positions[0] = [];
    this._normals[0]   = [];
    this._texCoords[0] = [];
    this._colors[0]    = [];
    this._indices[0]   = [];
};

x3dom.Mesh.prototype._dynamicFields = {};   // can hold X3DVertexAttributeNodes
/*x3dom.Mesh.prototype._positions = [];
x3dom.Mesh.prototype._normals   = [];
x3dom.Mesh.prototype._texCoords = [];
x3dom.Mesh.prototype._colors    = [];
x3dom.Mesh.prototype._indices   = [];*/

x3dom.Mesh.prototype._numPosComponents = 3;
x3dom.Mesh.prototype._numTexComponents = 2;
x3dom.Mesh.prototype._numColComponents = 3;
x3dom.Mesh.prototype._numNormComponents = 3;
x3dom.Mesh.prototype._lit = true;

x3dom.Mesh.prototype._vol = null;
x3dom.Mesh.prototype._invalidate = true;
x3dom.Mesh.prototype._numFaces = 0;
x3dom.Mesh.prototype._numCoords = 0;

x3dom.Mesh.prototype.setMeshData = function(positions, normals, texCoords, colors, indices)
{
    this._positions[0] = positions;
    this._normals[0]   = normals;
    this._texCoords[0] = texCoords;
    this._colors[0]    = colors;
    this._indices[0]   = indices;
    
    this._invalidate = true;
    this._numFaces = this._indices[0].length / 3;
    this._numCoords = this._positions[0].length / 3;
};

x3dom.Mesh.prototype.getVolume = function()
{
    if (this._invalidate == true && !this._vol.isValid())
    {
        var coords = this._positions[0];
        var n = coords.length;

        if (n > 3)
        {
            var initVal = new x3dom.fields.SFVec3f(coords[0],coords[1],coords[2]);
            this._vol.setBounds(initVal, initVal);

            for (var i=3; i<n; i+=3)
            {
                if (this._vol.min.x > coords[i  ]) { this._vol.min.x = coords[i  ]; }
                if (this._vol.min.y > coords[i+1]) { this._vol.min.y = coords[i+1]; }
                if (this._vol.min.z > coords[i+2]) { this._vol.min.z = coords[i+2]; }

                if (this._vol.max.x < coords[i  ]) { this._vol.max.x = coords[i  ]; }
                if (this._vol.max.y < coords[i+1]) { this._vol.max.y = coords[i+1]; }
                if (this._vol.max.z < coords[i+2]) { this._vol.max.z = coords[i+2]; }
            }
            this._invalidate = false;
        }
    }

    return this._vol;
};

x3dom.Mesh.prototype.invalidate = function()
{
    this._invalidate = true;
    this._vol.invalidate();
};

x3dom.Mesh.prototype.isValid = function()
{
    return this._vol.isValid();
};

x3dom.Mesh.prototype.getCenter = function() 
{
    return this.getVolume().getCenter();
};

x3dom.Mesh.prototype.getDiameter = function() 
{
    return this.getVolume().getDiameter();
};

x3dom.Mesh.prototype.doIntersect = function(line)
{
    var vol = this.getVolume();
    var isect = line.intersect(vol.min, vol.max);
    
    //TODO: iterate over all faces!
    if (isect && line.enter < line.dist)
    {
        //x3dom.debug.logInfo("Hit \"" + this._parent._xmlNode.localName + "/ " + 
        //                    this._parent._DEF + "\" at dist=" + line.enter.toFixed(4));
        
        line.dist = line.enter;
        line.hitObject = this._parent;
        line.hitPoint = line.pos.add(line.dir.multiply(line.enter));
    }
    
    return isect;
};

x3dom.Mesh.prototype.calcNormals = function(creaseAngle, ccw)
{
    if (ccw === undefined)
        ccw = true;

    var multInd = this._multiIndIndices && this._multiIndIndices.length;
    var idxs = multInd ? this._multiIndIndices : this._indices[0];
    var coords = this._positions[0];

    var vertNormals = [];
    var vertFaceNormals = [];

    var i, j, m = coords.length;
    var a, b, n = null;

    var num = (this._posSize !== undefined && this._posSize > m) ? this._posSize / 3 : m / 3;
    num = 3 * ((num - Math.floor(num) > 0) ? Math.floor(num + 1) : num);
    
    for (i = 0; i < num; ++i) {
        vertFaceNormals[i] = [];
    }
    
    num = idxs.length;
        
    for (i = 0; i < num; i += 3) {
        var ind_i0, ind_i1, ind_i2;
        var t;

        if (!multInd) {
            ind_i0 = idxs[i  ] * 3;
            ind_i1 = idxs[i+1] * 3;
            ind_i2 = idxs[i+2] * 3;

            t = new x3dom.fields.SFVec3f(coords[ind_i1], coords[ind_i1+1], coords[ind_i1+2]);
            a = new x3dom.fields.SFVec3f(coords[ind_i0], coords[ind_i0+1], coords[ind_i0+2]).subtract(t);
            b = t.subtract(new x3dom.fields.SFVec3f(coords[ind_i2], coords[ind_i2+1], coords[ind_i2+2]));

            // this is needed a few lines below
            ind_i0 =  i    * 3;
            ind_i1 = (i+1) * 3;
            ind_i2 = (i+2) * 3;
        }
        else {
            ind_i0 =  i    * 3;
            ind_i1 = (i+1) * 3;
            ind_i2 = (i+2) * 3;

            t = new x3dom.fields.SFVec3f(coords[ind_i1], coords[ind_i1+1], coords[ind_i1+2]);
            a = new x3dom.fields.SFVec3f(coords[ind_i0], coords[ind_i0+1], coords[ind_i0+2]).subtract(t);
            b = t.subtract(new x3dom.fields.SFVec3f(coords[ind_i2], coords[ind_i2+1], coords[ind_i2+2]));
        }
        
        n = a.cross(b).normalize();
        if (!ccw)
            n = n.negate();

        if (creaseAngle <= x3dom.fields.Eps) {
            vertNormals[ind_i0  ] = vertNormals[ind_i1  ] = vertNormals[ind_i2  ] = n.x;
            vertNormals[ind_i0+1] = vertNormals[ind_i1+1] = vertNormals[ind_i2+1] = n.y;
            vertNormals[ind_i0+2] = vertNormals[ind_i1+2] = vertNormals[ind_i2+2] = n.z;
        }
        else {
            vertFaceNormals[idxs[i  ]].push(n);
            vertFaceNormals[idxs[i+1]].push(n);
            vertFaceNormals[idxs[i+2]].push(n);
        }
    }

    // TODO: allow generic creaseAngle
    if (creaseAngle > x3dom.fields.Eps) 
    {
        for (i = 0; i < m; i += 3) {
            var iThird = i / 3;
            var arr;

            if (!multInd) {
                arr = vertFaceNormals[iThird];
            }
            else {
                arr = vertFaceNormals[idxs[iThird]];
            }
            num = arr.length;

            n = new x3dom.fields.SFVec3f(0, 0, 0);

            for (j = 0; j < num; ++j) {
                n = n.add(arr[j]);
            }
            n = n.normalize();

            vertNormals[i  ] = n.x;
            vertNormals[i+1] = n.y;
            vertNormals[i+2] = n.z;
        }
    }
    
    this._normals[0] = vertNormals;
};

/** @param primStride Number of index entries per primitive, for example 3 for TRIANGLES
 */
x3dom.Mesh.prototype.splitMesh = function(primStride, checkMultiIndIndices)
{
    var pStride;
    var isMultiInd;

    if (typeof primStride === undefined) {
        pStride = 3;
    } else {
        pStride = primStride;
    }

    if (typeof checkMultiIndIndices === undefined) {
        checkMultiIndIndices = false;
    }

    var MAX = x3dom.Utils.maxIndexableCoords;

    //adapt MAX to match the primitive stride
    MAX = Math.floor(MAX / pStride) * pStride;

    if (this._positions[0].length / 3 <= MAX && !checkMultiIndIndices) {
        return;
    }

    if (checkMultiIndIndices) {
        isMultiInd = this._multiIndIndices && this._multiIndIndices.length;
    } else {
        isMultiInd = false;
    }
    
    var positions = this._positions[0];
    var normals = this._normals[0];
    var texCoords = this._texCoords[0];
    var colors = this._colors[0];
    var indices = isMultiInd ? this._multiIndIndices : this._indices[0];

    var i = 0;
    
    do
    {
        this._positions[i] = [];
        this._normals[i]   = [];
        this._texCoords[i] = [];
        this._colors[i]    = [];
        this._indices[i]   = [];
        
        var k = (indices.length - ((i + 1) * MAX) >= 0);
        
        if (k) {
            this._indices[i] = indices.slice(i * MAX, (i + 1) * MAX);
        } else { 
            this._indices[i] = indices.slice(i * MAX);
        }

        if(!isMultiInd) {
            if (i) {
                var m = i * MAX;
                for (var j=0, l=this._indices[i].length; j<l; j++) {
                    this._indices[i][j] -= m;
                }
            }
        } else {
            for (var j=0, l=this._indices[i].length; j<l; j++) {
                this._indices[i][j] = j;
            }
        }

        if (k) { 
            this._positions[i] = positions.slice(i * MAX * 3, 3 * (i + 1) * MAX);
        } else { 
            this._positions[i] = positions.slice(i * MAX * 3);
        }
        
        if (normals.length) {
            if (k) { 
                this._normals[i] = normals.slice(i * MAX * 3, 3 * (i + 1) * MAX);
            } else { 
                this._normals[i] = normals.slice(i * MAX * 3);
            }
        }
        if (texCoords.length) {
            if (k) { 
                this._texCoords[i] = texCoords.slice(i * MAX * this._numTexComponents, 
                                                        this._numTexComponents * (i + 1) * MAX);
            } else {
                this._texCoords[i] = texCoords.slice(i * MAX * this._numTexComponents);
            }
        }
        if (colors.length) {
            if (k) { 
                this._colors[i] = colors.slice(i * MAX * this._numColComponents, 
                                                  this._numColComponents * (i + 1) * MAX);
            } else { 
                this._colors[i] = colors.slice(i * MAX * this._numColComponents);
            }
        }
    }
    while (positions.length > ++i * MAX * 3);
};

x3dom.Mesh.prototype.calcTexCoords = function(mode)
{
    this._texCoords[0] = [];
    
    // TODO; impl. all modes that aren't handled in shader!
    // FIXME; WebKit requires valid texCoords for texturing
    if (mode.toLowerCase() === "sphere-local")
    {
        for (var i=0, j=0, n=this._normals[0].length; i<n; i+=3)
        {
            this._texCoords[0][j++] = 0.5 + this._normals[0][i  ] / 2.0;
            this._texCoords[0][j++] = 0.5 + this._normals[0][i+1] / 2.0;
        }
    }
    else    // "plane" is x3d default mapping
    {
        var min = new x3dom.fields.SFVec3f(0, 0, 0),
            max = new x3dom.fields.SFVec3f(0, 0, 0);
        var vol = this.getVolume();

        vol.getBounds(min, max);
        var dia = max.subtract(min);
        
        var S = 0, T = 1;
        
        if (dia.x >= dia.y)
        {
            if (dia.x >= dia.z)
            {
                S = 0;
                T = dia.y >= dia.z ? 1 : 2;
            }
            else // dia.x < dia.z
            {
                S = 2;
                T = 0;
            }
        }
        else // dia.x < dia.y
        {
            if (dia.y >= dia.z)
            {
                S = 1;
                T = dia.x >= dia.z ? 0 : 2;
            }
            else // dia.y < dia.z
            {
                S = 2;
                T = 1;
            }
        }
        
        var sDenom = 1, tDenom = 1;
        var sMin = 0, tMin = 0;
        
        switch(S) {
            case 0: sDenom = dia.x; sMin = min.x; break;
            case 1: sDenom = dia.y; sMin = min.y; break;
            case 2: sDenom = dia.z; sMin = min.z; break;
        }
        
        switch(T) {
            case 0: tDenom = dia.x; tMin = min.x; break;
            case 1: tDenom = dia.y; tMin = min.y; break;
            case 2: tDenom = dia.z; tMin = min.z; break;
        }
        
        for (var k=0, l=0, m=this._positions[0].length; k<m; k+=3)
        {
            this._texCoords[0][l++] = (this._positions[0][k+S] - sMin) / sDenom;
            this._texCoords[0][l++] = (this._positions[0][k+T] - tMin) / tDenom;
        }
    }
};


/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/** If used as standalone lib, define some basics first. */
if (typeof x3dom === "undefined")
{
    x3dom = {
        extend: function(f) {
            function g() {}
            g.prototype = f.prototype || f;
            return new g();
        },

        debug: {
            logInfo:    function(msg) { console.log(msg); },
            logWarning: function(msg) { console.warn(msg); },
            logError:   function(msg) { console.error(msg); }
        }
    };

    if (!Array.map) {
        Array.map = function(array, fun, thisp) {
            var len = array.length;
            var res = [];
            for (var i = 0; i < len; i++) {
                if (i in array) {
                    res[i] = fun.call(thisp, array[i], i, array);
                }
            }
            return res;
        };
    }

    console.log("Using x3dom fields.js as standalone math and/or base types library.");
}


/** @namespace The x3dom.fields namespace. */
x3dom.fields = {};

x3dom.fields.Eps = 0.000001;


///////////////////////////////////////////////////////////////////////////////
// Single-Field Definitions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/** SFMatrix4f constructor. 
    @class Represents a SFMatrix4f
    THINKABOUTME: use 2-dim array instead of _xx?
  */
x3dom.fields.SFMatrix4f = function(	_00, _01, _02, _03, 
									_10, _11, _12, _13, 
									_20, _21, _22, _23, 
									_30, _31, _32, _33) 
{
    if (arguments.length === 0) {
        this._00 = 1; this._01 = 0; this._02 = 0; this._03 = 0;
        this._10 = 0; this._11 = 1; this._12 = 0; this._13 = 0;
        this._20 = 0; this._21 = 0; this._22 = 1; this._23 = 0;
        this._30 = 0; this._31 = 0; this._32 = 0; this._33 = 1;
    }
    else {
        this._00 = _00; this._01 = _01; this._02 = _02; this._03 = _03;
        this._10 = _10; this._11 = _11; this._12 = _12; this._13 = _13;
        this._20 = _20; this._21 = _21; this._22 = _22; this._23 = _23;
        this._30 = _30; this._31 = _31; this._32 = _32; this._33 = _33;
    }
};

/** returns 1st base vector (right) */
x3dom.fields.SFMatrix4f.prototype.e0 = function () {
    var baseVec = new x3dom.fields.SFVec3f(this._00, this._10, this._20);
    return baseVec.normalize();
};

/** returns 2nd base vector (up) */
x3dom.fields.SFMatrix4f.prototype.e1 = function () {
    var baseVec = new x3dom.fields.SFVec3f(this._01, this._11, this._21);
    return baseVec.normalize();
};

/** returns 3rd base vector (fwd) */
x3dom.fields.SFMatrix4f.prototype.e2 = function () {
    var baseVec = new x3dom.fields.SFVec3f(this._02, this._12, this._22);
    return baseVec.normalize();
};

/** returns 4th base vector (pos) */
x3dom.fields.SFMatrix4f.prototype.e3 = function () {
    return new x3dom.fields.SFVec3f(this._03, this._13, this._23);
};

/** Returns a copy of the argument matrix */
x3dom.fields.SFMatrix4f.copy = function(that) {
    return new x3dom.fields.SFMatrix4f(
        that._00, that._01, that._02, that._03,
        that._10, that._11, that._12, that._13,
        that._20, that._21, that._22, that._23,
        that._30, that._31, that._32, that._33
    );
};

/** Returns a SFMatrix4f identity matrix. */
x3dom.fields.SFMatrix4f.identity = function () {
    return new x3dom.fields.SFMatrix4f(
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    );
};

/** Returns a new null matrix */
x3dom.fields.SFMatrix4f.zeroMatrix = function () {
    return new x3dom.fields.SFMatrix4f(
        0, 0, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, 0
    );
};

x3dom.fields.SFMatrix4f.translation = function (vec) {
    return new x3dom.fields.SFMatrix4f(
        1, 0, 0, vec.x,
        0, 1, 0, vec.y,
        0, 0, 1, vec.z,
        0, 0, 0, 1
    );
};

x3dom.fields.SFMatrix4f.rotationX = function (a) {
    var c = Math.cos(a);
    var s = Math.sin(a);
    return new x3dom.fields.SFMatrix4f(
        1, 0, 0, 0,
        0, c, -s, 0,
        0, s, c, 0,
        0, 0, 0, 1
    );
};

x3dom.fields.SFMatrix4f.rotationY = function (a) {
    var c = Math.cos(a);
    var s = Math.sin(a);
    return new x3dom.fields.SFMatrix4f(
        c, 0, s, 0,
        0, 1, 0, 0,
        -s, 0, c, 0,
        0, 0, 0, 1
    );
};

x3dom.fields.SFMatrix4f.rotationZ = function (a) {
    var c = Math.cos(a);
    var s = Math.sin(a);
    return new x3dom.fields.SFMatrix4f(
        c, -s, 0, 0,
        s, c, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    );
};

x3dom.fields.SFMatrix4f.scale = function (vec) {
    return new x3dom.fields.SFMatrix4f(
        vec.x, 0, 0, 0,
        0, vec.y, 0, 0,
        0, 0, vec.z, 0,
        0, 0, 0, 1
    );
};

//! Calculates look-at/camera matrix
x3dom.fields.SFMatrix4f.lookAt = function (from, at, up)
{
    var view = from.subtract(at).normalize();
    var right = up.normalize().cross(view);

    // check if zero vector, i.e. linearly dependent
    if (right.dot(right) < x3dom.fields.Eps) {
        x3dom.debug.logWarning("View matrix is linearly dependent.");
        return x3dom.fields.SFMatrix4f.translation(from);
    }

    var newUp = view.cross(right.normalize()).normalize();

    var tmp = x3dom.fields.SFMatrix4f.identity();
    tmp.setValue(right, newUp, view, from);

    return tmp;
};

//! Calculates perspective projection matrix
x3dom.fields.SFMatrix4f.perspective = function(fov, aspect, near, far)
{
    var f = 1 / Math.tan(fov / 2);

    return new x3dom.fields.SFMatrix4f(
        f/aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (near+far)/(near-far), 2*near*far/(near-far),
        0, 0, -1, 0
    );
};

//! Calculates orthogonal projection matrix
x3dom.fields.SFMatrix4f.ortho = function(left, right, bottom, top, near, far, aspect)
{
    var rl = (right - left) / 2;    // hs
    var tb = (top - bottom) / 2;    // vs
    var fn = far - near;

    if (aspect === undefined)
        aspect = 1.0;

    if (aspect < (rl / tb))
        tb = rl / aspect;
    else
        rl = tb * aspect;

    left = -rl;
    right = rl;
    bottom = -tb;
    top = tb;

    rl *= 2;
    tb *= 2;

    return new x3dom.fields.SFMatrix4f(
        2 / rl, 0, 0,  -(right+left) / rl,
        0, 2 / tb, 0,  -(top+bottom) / tb,
        0, 0, -2 / fn, -(far+near) / fn,
        0, 0, 0, 1
    );
};

x3dom.fields.SFMatrix4f.prototype.setTranslate = function (vec) {
    this._03 = vec.x;
    this._13 = vec.y;
    this._23 = vec.z;
};

x3dom.fields.SFMatrix4f.prototype.setScale = function (vec) {
    this._00 = vec.x;
    this._11 = vec.y;
    this._22 = vec.z;
};

x3dom.fields.SFMatrix4f.prototype.setRotate = function (quat) {
    var xx = quat.x * quat.x;
    var xy = quat.x * quat.y;
    var xz = quat.x * quat.z;
    var yy = quat.y * quat.y;
    var yz = quat.y * quat.z;
    var zz = quat.z * quat.z;
    var wx = quat.w * quat.x;
    var wy = quat.w * quat.y;
    var wz = quat.w * quat.z;

    this._00 = 1 - 2 * (yy + zz); this._01 = 2 * (xy - wz); this._02 = 2 * (xz + wy);
    this._10 = 2 * (xy + wz); this._11 = 1 - 2 * (xx + zz); this._12 = 2 * (yz - wx);
    this._20 = 2 * (xz - wy); this._21 = 2 * (yz + wx); this._22 = 1 - 2 * (xx + yy);
};

x3dom.fields.SFMatrix4f.parseRotation = function (str) {
    var m = /^([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)$/.exec(str);
    var x = +m[1], y = +m[2], z = +m[3], a = +m[4];
    
    var d = Math.sqrt(x*x + y*y + z*z);
    if (d === 0) {
        x = 1; y = z = 0;
    } else {
        x /= d; y /= d; z /= d;
    }
    
    var c = Math.cos(a);
    var s = Math.sin(a);
    var t = 1 - c;

    return new x3dom.fields.SFMatrix4f(
        t*x*x+c,   t*x*y+s*z, t*x*z-s*y, 0,
        t*x*y-s*z, t*y*y+c,   t*y*z+s*x, 0,
        t*x*z+s*y, t*y*z-s*x, t*z*z+c,   0,
        0,         0,         0,         1
    ).transpose();
};

x3dom.fields.SFMatrix4f.parse = function (str) {
    var needTranspose = false;
    var val = /matrix.*\((.+)\)/;
    if (val.exec(str)) {
        str = RegExp.$1;
        needTranspose = true;
    }
    var arr = Array.map(str.split(/[,\s]+/), function (n) { return +n; });
    if (arr.length >= 16)
    {
        if (!needTranspose) {
            return new x3dom.fields.SFMatrix4f(
                arr[0],  arr[1],  arr[2],  arr[3], 
                arr[4],  arr[5],  arr[6],  arr[7], 
                arr[8],  arr[9],  arr[10], arr[11], 
                arr[12], arr[13], arr[14], arr[15]
            );
        }
        else {
            return new x3dom.fields.SFMatrix4f(
                arr[0],  arr[4],  arr[8],  arr[12], 
                arr[1],  arr[5],  arr[9],  arr[13], 
                arr[2],  arr[6],  arr[10], arr[14], 
                arr[3],  arr[7],  arr[11], arr[15]
            );
        }
    }
    else if (arr.length === 6) {
        return new x3dom.fields.SFMatrix4f(
            arr[0],  arr[1],  0,  arr[4], 
            arr[2],  arr[3],  0,  arr[5], 
                 0,       0,  1,  0, 
                 0,       0,  0,  1
        );
    }
    else {
        x3dom.debug.logWarning("SFMatrix4f - can't parse string: " + str);
        return x3dom.fields.SFMatrix4f.identity();
    }
};

//! Performs matrix multiplication
x3dom.fields.SFMatrix4f.prototype.mult = function (that)  {
    return new x3dom.fields.SFMatrix4f(
        this._00*that._00+this._01*that._10+this._02*that._20+this._03*that._30, 
        this._00*that._01+this._01*that._11+this._02*that._21+this._03*that._31, 
        this._00*that._02+this._01*that._12+this._02*that._22+this._03*that._32, 
        this._00*that._03+this._01*that._13+this._02*that._23+this._03*that._33,
        this._10*that._00+this._11*that._10+this._12*that._20+this._13*that._30, 
        this._10*that._01+this._11*that._11+this._12*that._21+this._13*that._31, 
        this._10*that._02+this._11*that._12+this._12*that._22+this._13*that._32, 
        this._10*that._03+this._11*that._13+this._12*that._23+this._13*that._33,
        this._20*that._00+this._21*that._10+this._22*that._20+this._23*that._30, 
        this._20*that._01+this._21*that._11+this._22*that._21+this._23*that._31, 
        this._20*that._02+this._21*that._12+this._22*that._22+this._23*that._32, 
        this._20*that._03+this._21*that._13+this._22*that._23+this._23*that._33,
        this._30*that._00+this._31*that._10+this._32*that._20+this._33*that._30, 
        this._30*that._01+this._31*that._11+this._32*that._21+this._33*that._31, 
        this._30*that._02+this._31*that._12+this._32*that._22+this._33*that._32, 
        this._30*that._03+this._31*that._13+this._32*that._23+this._33*that._33
    );
};

x3dom.fields.SFMatrix4f.prototype.multMatrixPnt = function (vec) {
    return new x3dom.fields.SFVec3f(
        this._00*vec.x + this._01*vec.y + this._02*vec.z + this._03,
        this._10*vec.x + this._11*vec.y + this._12*vec.z + this._13,
        this._20*vec.x + this._21*vec.y + this._22*vec.z + this._23
    );
};

x3dom.fields.SFMatrix4f.prototype.multMatrixVec = function (vec) {
    return new x3dom.fields.SFVec3f(
        this._00*vec.x + this._01*vec.y + this._02*vec.z,
        this._10*vec.x + this._11*vec.y + this._12*vec.z,
        this._20*vec.x + this._21*vec.y + this._22*vec.z
    );
};

x3dom.fields.SFMatrix4f.prototype.multFullMatrixPnt = function (vec) {
    var w = this._30*vec.x + this._31*vec.y + this._32*vec.z + this._33;
    if (w) { w = 1.0 / w; }
    return new x3dom.fields.SFVec3f(
        (this._00*vec.x + this._01*vec.y + this._02*vec.z + this._03) * w,
        (this._10*vec.x + this._11*vec.y + this._12*vec.z + this._13) * w,
        (this._20*vec.x + this._21*vec.y + this._22*vec.z + this._23) * w
    );
};

x3dom.fields.SFMatrix4f.prototype.transpose = function () {
    return new x3dom.fields.SFMatrix4f(
        this._00, this._10, this._20, this._30,
        this._01, this._11, this._21, this._31,
        this._02, this._12, this._22, this._32,
        this._03, this._13, this._23, this._33
    );
};

x3dom.fields.SFMatrix4f.prototype.negate = function () {
    return new x3dom.fields.SFMatrix4f(
        -this._00, -this._01, -this._02, -this._03,
        -this._10, -this._11, -this._12, -this._13,
        -this._20, -this._21, -this._22, -this._23,
        -this._30, -this._31, -this._32, -this._33
    );
};

// scales matrix with factor s
x3dom.fields.SFMatrix4f.prototype.multiply = function (s) {
    return new x3dom.fields.SFMatrix4f(
        s*this._00, s*this._01, s*this._02, s*this._03,
        s*this._10, s*this._11, s*this._12, s*this._13,
        s*this._20, s*this._21, s*this._22, s*this._23,
        s*this._30, s*this._31, s*this._32, s*this._33
    );
};

x3dom.fields.SFMatrix4f.prototype.add = function (that) {
    return new x3dom.fields.SFMatrix4f(
        this._00+that._00, this._01+that._01, this._02+that._02, this._03+that._03,
        this._10+that._10, this._11+that._11, this._12+that._12, this._13+that._13,
        this._20+that._20, this._21+that._21, this._22+that._22, this._23+that._23,
        this._30+that._30, this._31+that._31, this._32+that._32, this._33+that._33
    );
};

x3dom.fields.SFMatrix4f.prototype.addScaled = function (that, s) {
    return new x3dom.fields.SFMatrix4f(
        this._00+s*that._00, this._01+s*that._01, this._02+s*that._02, this._03+s*that._03,
        this._10+s*that._10, this._11+s*that._11, this._12+s*that._12, this._13+s*that._13,
        this._20+s*that._20, this._21+s*that._21, this._22+s*that._22, this._23+s*that._23,
        this._30+s*that._30, this._31+s*that._31, this._32+s*that._32, this._33+s*that._33
    );
};

x3dom.fields.SFMatrix4f.prototype.setValues = function (that) {
    this._00 = that._00; this._01 = that._01; this._02 = that._02; this._03 = that._03;
    this._10 = that._10; this._11 = that._11; this._12 = that._12; this._13 = that._13;
    this._20 = that._20; this._21 = that._21; this._22 = that._22; this._23 = that._23;
    this._30 = that._30; this._31 = that._31; this._32 = that._32; this._33 = that._33;
};

x3dom.fields.SFMatrix4f.prototype.setValue = function (v1, v2, v3, v4) {
    this._00 = v1.x; this._01 = v2.x; this._02 = v3.x;
    this._10 = v1.y; this._11 = v2.y; this._12 = v3.y;
    this._20 = v1.z; this._21 = v2.z; this._22 = v3.z;
    this._30 = 0;    this._31 = 0;    this._32 = 0;
    
    if (arguments.length > 3) {
        this._03 = v4.x;
        this._13 = v4.y;
        this._23 = v4.z;
        this._33 = 1;
    }
};

x3dom.fields.SFMatrix4f.prototype.setFromArray = function (a) {
    this._00 = a[0]; this._01 = a[4]; this._02 = a[ 8]; this._03 = a[12];
    this._10 = a[1]; this._11 = a[5]; this._12 = a[ 9]; this._13 = a[13];
    this._20 = a[2]; this._21 = a[6]; this._22 = a[10]; this._23 = a[14];
    this._30 = a[3]; this._31 = a[7]; this._32 = a[11]; this._33 = a[15];
};

x3dom.fields.SFMatrix4f.prototype.toGL = function () {
    return [
        this._00, this._10, this._20, this._30,
        this._01, this._11, this._21, this._31,
        this._02, this._12, this._22, this._32,
        this._03, this._13, this._23, this._33
    ];
};

x3dom.fields.SFMatrix4f.prototype.at = function (i, j) {
	var field = "_" + i + j;
	return this[field];
};

/** Computes the square root of the matrix, assumes det > 0 */
x3dom.fields.SFMatrix4f.prototype.sqrt = function () {
    var Y = x3dom.fields.SFMatrix4f.identity();
    var result = x3dom.fields.SFMatrix4f.copy(this);
    
    for (var i=0; i<6; i++)
    {
        var iX = result.inverse();
        var iY = (i == 0) ? x3dom.fields.SFMatrix4f.identity() : Y.inverse();
        
        var rd = result.det(), yd = Y.det();
        
        var g = Math.abs( Math.pow(rd * yd, -0.125) );
        var ig = 1.0 / g;
        
        result = result.multiply(g);
        result = result.addScaled(iY, ig);
        result = result.multiply(0.5);
        
        Y = Y.multiply(g);
        Y = Y.addScaled(iX, ig);
        Y = Y.multiply(0.5);
    }
    
    return result;
};

/** Returns the largest absolute value of all entries in the matrix */
x3dom.fields.SFMatrix4f.prototype.normInfinity = function () {
    var t = 0, m = 0;

    if ((t = Math.abs(this._00)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._01)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._02)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._03)) > m) {
        m = t;
    }
        
    if ((t = Math.abs(this._10)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._11)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._12)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._13)) > m) {
        m = t;
    }
    
    if ((t = Math.abs(this._20)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._21)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._22)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._23)) > m) {
        m = t;
    }
        
    if ((t = Math.abs(this._30)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._31)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._32)) > m) {
        m = t;
    }
    if ((t = Math.abs(this._33)) > m) {
        m = t;
    }

    return m;
};

/** Returns the 1-norm of the upper left 3x3 part of this matrix.
    The 1-norm is also known as maximum absolute column sum norm.
 */
x3dom.fields.SFMatrix4f.prototype.norm1_3x3 = function() {
    var max = Math.abs(this._00) + 
              Math.abs(this._10) +
              Math.abs(this._20);
    var t = 0;
    
    if ((t = Math.abs(this._01) +
             Math.abs(this._11) +
             Math.abs(this._21)) > max) {
        max = t;
    }
    
    if ((t = Math.abs(this._02) +
             Math.abs(this._12) +
             Math.abs(this._22)) > max) {
        max = t;
    }
    
    return max;
};

/** Returns the infinity-norm of the upper left 3x3 part of this matrix.
    The infinity-norm is also known as maximum absolute row sum norm.
 */
x3dom.fields.SFMatrix4f.prototype.normInf_3x3 = function() {
    var max = Math.abs(this._00) + 
              Math.abs(this._01) +
              Math.abs(this._02);
    var t = 0;
    
    if ((t = Math.abs(this._10) +
             Math.abs(this._11) +
             Math.abs(this._12)) > max) {
        max = t;
    }
    
    if ((t = Math.abs(this._20) +
             Math.abs(this._21) +
             Math.abs(this._22)) > max) {
        max = t;
    }
    
    return max;
};

x3dom.fields.SFMatrix4f.prototype.adjointT_3x3 = function () {
	var result = x3dom.fields.SFMatrix4f.identity();
	
    result._00 = this._11 * this._22 - this._12 * this._21;
    result._01 = this._12 * this._20 - this._10 * this._22;
    result._02 = this._10 * this._21 - this._11 * this._20;
    
    result._10 = this._21 * this._02 - this._22 * this._01;
    result._11 = this._22 * this._00 - this._20 * this._02;
    result._12 = this._20 * this._01 - this._21 * this._00;
    
    result._20 = this._01 * this._12 - this._02 * this._11;
    result._21 = this._02 * this._10 - this._00 * this._12;
    result._22 = this._00 * this._11 - this._01 * this._10;
	
	return result;
};

x3dom.fields.SFMatrix4f.prototype.equals = function (that) {
    var eps = 0.000000000001;
    return Math.abs(this._00-that._00) < eps && Math.abs(this._01-that._01) < eps && 
           Math.abs(this._02-that._02) < eps && Math.abs(this._03-that._03) < eps &&
           Math.abs(this._10-that._10) < eps && Math.abs(this._11-that._11) < eps && 
           Math.abs(this._12-that._12) < eps && Math.abs(this._13-that._13) < eps &&
           Math.abs(this._20-that._20) < eps && Math.abs(this._21-that._21) < eps && 
           Math.abs(this._22-that._22) < eps && Math.abs(this._23-that._23) < eps &&
           Math.abs(this._30-that._30) < eps && Math.abs(this._31-that._31) < eps && 
           Math.abs(this._32-that._32) < eps && Math.abs(this._33-that._33) < eps;
};

/** Decomposes the matrix into a translation, rotation, scale,
 *  and scale orientation. Any projection information is discarded.
 *  The decomposition depends upon choice of center point for
 *  rotation and scaling, which is optional as the last parameter.
 *  (Note that quaternions need to be converted via .toAxisAngle()
 *  to an axis/angle pair for being used in the x3d dom tree.)
 */
x3dom.fields.SFMatrix4f.prototype.getTransform = function(
				        translation, rotation, scaleFactor, scaleOrientation, center) 
{
	var m = null;
	
	if (arguments.length > 4) {
		m = x3dom.fields.SFMatrix4f.translation(center.negate());
		m = m.mult(this);
		
		var c = x3dom.fields.SFMatrix4f.translation(center);
		m = m.mult(c);
	}
	else {
	    m = x3dom.fields.SFMatrix4f.copy(this);
	}
	
	var flip = m.decompose(translation, rotation, scaleFactor, scaleOrientation);
	
	scaleFactor.setValues(scaleFactor.multiply(flip));
};

x3dom.fields.SFMatrix4f.prototype.decompose = function(t, r, s, so) 
{
	var A = x3dom.fields.SFMatrix4f.copy(this);
	
    var Q  = x3dom.fields.SFMatrix4f.identity(),
		S  = x3dom.fields.SFMatrix4f.identity(),
		SO = x3dom.fields.SFMatrix4f.identity();
	
	t.x = A._03;
    t.y = A._13;
    t.z = A._23;
    
    A._03 = 0.0;
    A._13 = 0.0;
    A._23 = 0.0;
    
    A._30 = 0.0;
    A._31 = 0.0;
    A._32 = 0.0;
	
	var det = A.polarDecompose(Q, S);
    var f = 1.0;

    if (det < 0.0) {
        Q = Q.negate();
        f = -1.0;
    }
    
    r.setValue(Q);
    
    S.spectralDecompose(SO, s);
    
    so.setValue(SO);
	
	return f;
};

x3dom.fields.SFMatrix4f.prototype.polarDecompose = function(Q, S)
{
    var TOL = 0.000000000001;
	
    var Mk = this.transpose();
    var Ek = x3dom.fields.SFMatrix4f.identity();
	
    var Mk_one = Mk.norm1_3x3();
    var Mk_inf = Mk.normInf_3x3();
    
	var MkAdjT;
    var MkAdjT_one, MkAdjT_inf;
    var Ek_one, Mk_det;
       
    do
    {
        // compute transpose of adjoint
		MkAdjT = Mk.adjointT_3x3();
        
        // Mk_det = det(Mk) -- computed from the adjoint        
        Mk_det = Mk._00 * MkAdjT._00 + 
                 Mk._01 * MkAdjT._01 +
                 Mk._02 * MkAdjT._02;
        
        // should this be a close to zero test ?
        if (Mk_det == 0.0)
        {
            x3dom.debug.logWarning("polarDecompose: Mk_det == 0.0");
            break;
        }
        
        MkAdjT_one = MkAdjT.norm1_3x3();
        MkAdjT_inf = MkAdjT.normInf_3x3();
        
        // compute update factors
        var gamma = Math.sqrt( Math.sqrt((MkAdjT_one * MkAdjT_inf) / 
							  (Mk_one * Mk_inf)) / Math.abs(Mk_det) );
        
        var g1 = 0.5 * gamma;
        var g2 = 0.5 / (gamma * Mk_det);
        
        Ek.setValues(Mk);
        
        Mk = Mk.multiply (g1);         // this does:
        Mk = Mk.addScaled(MkAdjT, g2); // Mk = g1 * Mk + g2 * MkAdjT
        Ek = Ek.addScaled(Mk, -1.0);   // Ek -= Mk;
        
        Ek_one = Ek.norm1_3x3();
        Mk_one = Mk.norm1_3x3();
        Mk_inf = Mk.normInf_3x3();
        
    } while (Ek_one > (Mk_one * TOL));
    
    Q.setValues(Mk.transpose());
    S.setValues(Mk.mult(this));

    for (var i = 0; i < 3; ++i)
    {
        for (var j = i; j < 3; ++j)
        {
            S['_'+j+i] = 0.5 * (S['_'+j+i] + S['_'+i+j]);
			S['_'+i+j] = 0.5 * (S['_'+j+i] + S['_'+i+j]);
        }
    }
    
    return Mk_det;
};

x3dom.fields.SFMatrix4f.prototype.spectralDecompose = function(SO, k)
{
    var next = [1, 2, 0];
    var maxIterations = 20;
    var diag = [this._00, this._11, this._22];
    var offDiag = [this._12, this._20, this._01];
    
    for (var iter = 0; iter < maxIterations; ++iter)
    {
        var sm = Math.abs(offDiag[0]) + Math.abs(offDiag[1]) + Math.abs(offDiag[2]);
        
        if (sm == 0) {        
            break;
        }
        
        for (var i = 2; i >= 0; --i)
        {
            var p = next[i];
            var q = next[p];
            
            var absOffDiag = Math.abs(offDiag[i]);
            var g          = 100.0 * absOffDiag; 
            
            if (absOffDiag > 0.0)
            {
                var t = 0, h = diag[q] - diag[p];
                var absh = Math.abs(h);
                
                if (absh + g == absh)
                {
                    t = offDiag[i] / h;
                }
                else
                {
                    var theta = 0.5 * h / offDiag[i];
                    t = 1.0 / (Math.abs(theta) + Math.sqrt(theta * theta + 1.0));
                    
                    t = theta < 0.0 ? -t : t;
                }
            
                var c = 1.0 / Math.sqrt(t * t + 1.0);
                var s = t * c;
                
                var tau = s / (c + 1.0);
                var ta  = t * offDiag[i];
                
                offDiag[i] = 0.0;
                
                diag[p] -= ta;
                diag[q] += ta;
                
                var offDiagq = offDiag[q];
                
                offDiag[q] -= s * (offDiag[p] + tau * offDiagq);
                offDiag[p] += s * (offDiagq - tau * offDiag[p]);
                
                for (var j = 2; j >= 0; --j)
                {
                    var a = SO['_'+j+p];
                    var b = SO['_'+j+q];
                    
                    SO['_'+j+p] -= s * (b + tau * a);
                    SO['_'+j+q] += s * (a - tau * b);
                }
            }
        }
    }
    
    k.x = diag[0];
    k.y = diag[1];
    k.z = diag[2];
};

/** Computes the logarithm of this matrix, assumes det > 0 */
x3dom.fields.SFMatrix4f.prototype.log = function () {
    var maxiter = 12;
    var eps = 1e-12;
    
    var A = x3dom.fields.SFMatrix4f.copy(this),
        Z = x3dom.fields.SFMatrix4f.copy(this);

    // Take repeated square roots to reduce spectral radius
    Z._00 -= 1;
    Z._11 -= 1;
    Z._22 -= 1;
    Z._33 -= 1;
    
    var k = 0;

    while (Z.normInfinity() > 0.5)
    {
        A = A.sqrt();
        Z.setValues(A);

        Z._00 -= 1;
        Z._11 -= 1;
        Z._22 -= 1;
        Z._33 -= 1;

        k++;
    }

    A._00 -= 1;
    A._11 -= 1;
    A._22 -= 1;
    A._33 -= 1;

    A = A.negate();
    Z.setValues(A);
    
    var result = x3dom.fields.SFMatrix4f.copy(A);
    var i = 1;

    while (Z.normInfinity() > eps && i < maxiter)
    {
        Z = Z.mult(A);
        i++;

        result = result.addScaled(Z, 1.0 / i);
    }
    
    return result.multiply( -(1 << k) );
};

/** Computes the exponential of this matrix */
x3dom.fields.SFMatrix4f.prototype.exp = function () {
    var q = 6;
    var A = x3dom.fields.SFMatrix4f.copy(this), 
        D = x3dom.fields.SFMatrix4f.identity(), 
        N = x3dom.fields.SFMatrix4f.identity(), 
        result = x3dom.fields.SFMatrix4f.identity();
    var k = 0, c = 1.0;

    var j = 1.0 + parseInt(Math.log(A.normInfinity() / 0.693));
    //var j = 1.0 + (Math.log(A.normInfinity() / 0.693) | 0);
    
    if (j < 0) {
        j = 0;
    }

    A = A.multiply(1.0 / (1 << j));

    for (k = 1; k <= q; k++)
    {
        c *= (q - k + 1) / (k * (2 * q - k + 1));

        result = A.mult(result);

        N = N.addScaled(result, c);

        if (k % 2) {
            D = D.addScaled(result, -c);
        }
        else {
            D = D.addScaled(result, c);
        }
    }
    
    result = D.inverse().mult(N);

    for (k = 0; k < j; k++)
    {
        result = result.mult(result);
    }
    
    return result;
};

//! helper to calculate a 3x3 determinant
x3dom.fields.SFMatrix4f.prototype.det3 = function (a1, a2, a3, b1, b2, b3, c1, c2, c3) {
    return ((a1 * b2 * c3) + (a2 * b3 * c1) + (a3 * b1 * c2) -
            (a1 * b3 * c2) - (a2 * b1 * c3) - (a3 * b2 * c1));
};

//! Returns the determinant of the whole 4x4 matrix
x3dom.fields.SFMatrix4f.prototype.det = function () {
    var a1 = this._00;
    var b1 = this._10;
    var c1 = this._20;
    var d1 = this._30;

    var a2 = this._01;
    var b2 = this._11;
    var c2 = this._21;
    var d2 = this._31;

    var a3 = this._02;
    var b3 = this._12;
    var c3 = this._22;
    var d3 = this._32;

    var a4 = this._03;
    var b4 = this._13;
    var c4 = this._23;
    var d4 = this._33;
    
    return (a1 * this.det3(b2, b3, b4, c2, c3, c4, d2, d3, d4) - 
            b1 * this.det3(a2, a3, a4, c2, c3, c4, d2, d3, d4) + 
            c1 * this.det3(a2, a3, a4, b2, b3, b4, d2, d3, d4) - 
            d1 * this.det3(a2, a3, a4, b2, b3, b4, c2, c3, c4));
};

/** Method to invert the matrix, given that matrix is not singular */
x3dom.fields.SFMatrix4f.prototype.inverse = function () {
    var a1 = this._00;
    var b1 = this._10;
    var c1 = this._20;
    var d1 = this._30;

    var a2 = this._01;
    var b2 = this._11;
    var c2 = this._21;
    var d2 = this._31;

    var a3 = this._02;
    var b3 = this._12;
    var c3 = this._22;
    var d3 = this._32;

    var a4 = this._03;
    var b4 = this._13;
    var c4 = this._23;
    var d4 = this._33;

    var rDet = this.det();

    //if (Math.abs(rDet) < 1e-30)
    if (rDet == 0)
    {
        x3dom.debug.logWarning("Invert matrix: singular matrix, no inverse!");
        return x3dom.fields.SFMatrix4f.identity();
    }

    rDet = 1.0 / rDet;

    return new x3dom.fields.SFMatrix4f(
                +this.det3(b2, b3, b4, c2, c3, c4, d2, d3, d4) * rDet,
                -this.det3(a2, a3, a4, c2, c3, c4, d2, d3, d4) * rDet,
                +this.det3(a2, a3, a4, b2, b3, b4, d2, d3, d4) * rDet,
                -this.det3(a2, a3, a4, b2, b3, b4, c2, c3, c4) * rDet,
                -this.det3(b1, b3, b4, c1, c3, c4, d1, d3, d4) * rDet,
                +this.det3(a1, a3, a4, c1, c3, c4, d1, d3, d4) * rDet,
                -this.det3(a1, a3, a4, b1, b3, b4, d1, d3, d4) * rDet,
                +this.det3(a1, a3, a4, b1, b3, b4, c1, c3, c4) * rDet,
                +this.det3(b1, b2, b4, c1, c2, c4, d1, d2, d4) * rDet,
                -this.det3(a1, a2, a4, c1, c2, c4, d1, d2, d4) * rDet,
                +this.det3(a1, a2, a4, b1, b2, b4, d1, d2, d4) * rDet,
                -this.det3(a1, a2, a4, b1, b2, b4, c1, c2, c4) * rDet,
                -this.det3(b1, b2, b3, c1, c2, c3, d1, d2, d3) * rDet,
                +this.det3(a1, a2, a3, c1, c2, c3, d1, d2, d3) * rDet,
                -this.det3(a1, a2, a3, b1, b2, b3, d1, d2, d3) * rDet,
                +this.det3(a1, a2, a3, b1, b2, b3, c1, c2, c3) * rDet
            );
};

/**
 * Returns an array of euler angles (in radians) - this must be a rotation matrix!
 */
x3dom.fields.SFMatrix4f.prototype.getEulerAngles = function() {
    var theta_1, theta_2, theta;
    var phi_1, phi_2, phi;
    var psi_1, psi_2, psi;
    var cos_theta_1, cos_theta_2;

    if (Math.abs(this._20) != 1.0) {
        theta_1 = -Math.asin(this._20);
        theta_2 = Math.PI - theta_1;

        cos_theta_1 = Math.cos(theta_1);
        cos_theta_2 = Math.cos(theta_2);

        psi_1   = Math.atan2(this._21 / cos_theta_1, this._22 / cos_theta_1);
        psi_2   = Math.atan2(this._21 / cos_theta_2, this._22 / cos_theta_2);

        phi_1   = Math.atan2(this._10 / cos_theta_1, this._00 / cos_theta_1);
        phi_2   = Math.atan2(this._10 / cos_theta_2, this._00 / cos_theta_2);

        return [psi_1, theta_1, phi_1,
                psi_2, theta_2, phi_2];
    }
    else {
        phi = 0;

        if (this._20 == -1.0) {
            theta = Math.PI / 2.0;
            psi   = phi + Math.atan2(this._01, this._02);
        }
        else {
            theta = -(Math.PI / 2.0);
            psi   = -phi + Math.atan2(-this._01, -this._02);
        }

        return [psi, theta, phi,
                psi, theta, phi];
    }
};

x3dom.fields.SFMatrix4f.prototype.toString = function () {
    return '\n' +
		this._00.toFixed(6)+', '+this._01.toFixed(6)+', '+
		this._02.toFixed(6)+', '+this._03.toFixed(6)+', \n'+
        this._10.toFixed(6)+', '+this._11.toFixed(6)+', '+
		this._12.toFixed(6)+', '+this._13.toFixed(6)+', \n'+
        this._20.toFixed(6)+', '+this._21.toFixed(6)+', '+
		this._22.toFixed(6)+', '+this._23.toFixed(6)+', \n'+
        this._30.toFixed(6)+', '+this._31.toFixed(6)+', '+
		this._32.toFixed(6)+', '+this._33.toFixed(6);
};

x3dom.fields.SFMatrix4f.prototype.setValueByStr = function(str) {
    var needTranspose = false;
    var val = /matrix.*\((.+)\)/;
    if (val.exec(str)) {
        str = RegExp.$1;
        needTranspose = true;
    }
    var arr = Array.map(str.split(/[,\s]+/), function (n) { return +n; });
    if (arr.length >= 16)
    {
        if (!needTranspose) {
            this._00 = arr[0];  this._01 = arr[1];  this._02 = arr[2];  this._03 = arr[3];
            this._10 = arr[4];  this._11 = arr[5];  this._12 = arr[6];  this._13 = arr[7];
            this._20 = arr[8];  this._21 = arr[9];  this._22 = arr[10]; this._23 = arr[11];
            this._30 = arr[12]; this._31 = arr[13]; this._32 = arr[14]; this._33 = arr[15];
        }
        else {
            this._00 = arr[0];  this._01 = arr[4];  this._02 = arr[8];  this._03 = arr[12];
            this._10 = arr[1];  this._11 = arr[5];  this._12 = arr[9];  this._13 = arr[13];
            this._20 = arr[2];  this._21 = arr[6];  this._22 = arr[10]; this._23 = arr[14];
            this._30 = arr[3];  this._31 = arr[7];  this._32 = arr[11]; this._33 = arr[15];
        }
    }
    else if (arr.length === 6) {
        this._00 = arr[0]; this._01 = arr[1]; this._02 = 0; this._03 = arr[4];
        this._10 = arr[2]; this._11 = arr[3]; this._12 = 0; this._13 = arr[5];
        this._20 = 0; this._21 = 0; this._22 = 1; this._23 = 0;
        this._30 = 0; this._31 = 0; this._32 = 0; this._33 = 1;
    }
    else {
        x3dom.debug.logWarning("SFMatrix4f - can't parse string: " + str);
    }
    return this;
};


///////////////////////////////////////////////////////////////////////////////
/** SFVec2f constructor.
    @class Represents a SFVec2f
  */
x3dom.fields.SFVec2f = function(x, y) {
    if (arguments.length === 0) {
        this.x = 0;
        this.y = 0;
    }
    else {
        this.x = x;
        this.y = y;
    }
};

x3dom.fields.SFVec2f.copy = function(v) {
    return new x3dom.fields.SFVec2f(v.x, v.y);
};

x3dom.fields.SFVec2f.parse = function (str) {
    var m = /^\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*$/.exec(str);
    return new x3dom.fields.SFVec2f(+m[1], +m[2]);
};

x3dom.fields.SFVec2f.prototype.setValues = function (that) {
    this.x = that.x;
    this.y = that.y;
};

x3dom.fields.SFVec2f.prototype.at = function (i) {
	switch(i) {
	    case 0:  return this.x;
	    case 1:  return this.y;
	    default: return this.x;
	}
};

x3dom.fields.SFVec2f.prototype.add = function (that) {
    return new x3dom.fields.SFVec2f(this.x+that.x, this.y+that.y);
};

x3dom.fields.SFVec2f.prototype.subtract = function (that) {
    return new x3dom.fields.SFVec2f(this.x-that.x, this.y-that.y);
};

x3dom.fields.SFVec2f.prototype.negate = function () {
    return new x3dom.fields.SFVec2f(-this.x, -this.y);
};

x3dom.fields.SFVec2f.prototype.dot = function (that) {
    return this.x * that.x + this.y * that.y;
};

x3dom.fields.SFVec2f.prototype.reflect = function (n) {
    var d2 = this.dot(n)*2;
    return new x3dom.fields.SFVec2f(this.x-d2*n.x, this.y-d2*n.y);
};

x3dom.fields.SFVec2f.prototype.normalize = function() {
    var n = this.length();
    if (n) { n = 1.0 / n; }
    return new x3dom.fields.SFVec2f(this.x*n, this.y*n);
};

x3dom.fields.SFVec2f.prototype.multComponents = function (that) {
    return new x3dom.fields.SFVec2f(this.x*that.x, this.y*that.y);
};

x3dom.fields.SFVec2f.prototype.multiply = function (n) {
    return new x3dom.fields.SFVec2f(this.x*n, this.y*n);
};

x3dom.fields.SFVec2f.prototype.divide = function (n) {
    var denom = n ? (1.0 / n) : 1.0;
    return new x3dom.fields.SFVec2f(this.x*denom, this.y*denom);
};

x3dom.fields.SFVec2f.prototype.equals = function (that, eps) {
    return Math.abs(this.x - that.x) < eps && 
           Math.abs(this.y - that.y) < eps;
};

x3dom.fields.SFVec2f.prototype.length = function() {
    return Math.sqrt((this.x*this.x) + (this.y*this.y));
};

x3dom.fields.SFVec2f.prototype.toGL = function () {
    return [ this.x, this.y ];
};

x3dom.fields.SFVec2f.prototype.toString = function () {
    return this.x + " " + this.y;
};

x3dom.fields.SFVec2f.prototype.setValueByStr = function(str) {
    var m = /^\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*$/.exec(str);
    this.x = +m[1];
    this.y = +m[2];
    return this;
};


///////////////////////////////////////////////////////////////////////////////
/** SFVec3f constructor.
    @class Represents a SFVec3f
  */
x3dom.fields.SFVec3f = function(x, y, z) {
    if (arguments.length === 0) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }
    else {
        this.x = x;
        this.y = y;
        this.z = z;
    }
};

x3dom.fields.SFVec3f.NullVector = new x3dom.fields.SFVec3f(0, 0, 0);
x3dom.fields.SFVec3f.OneVector  = new x3dom.fields.SFVec3f(1, 1, 1);

x3dom.fields.SFVec3f.copy = function(v) {
    return new x3dom.fields.SFVec3f(v.x, v.y, v.z);
};

x3dom.fields.SFVec3f.MIN = function() {
    return new x3dom.fields.SFVec3f(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
};

x3dom.fields.SFVec3f.MAX = function() {
    return new x3dom.fields.SFVec3f(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
};

x3dom.fields.SFVec3f.parse = function (str) {
    try {
        var m = /^\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*$/.exec(str);
        return new x3dom.fields.SFVec3f(+m[1], +m[2], +m[3]);
    }
    catch (e) {
        // allow automatic type conversion as is convenient for shaders
        var c = x3dom.fields.SFColor.colorParse(str);
        return new x3dom.fields.SFVec3f(c.r, c.g, c.b);
    }
};

x3dom.fields.SFVec3f.prototype.setValues = function (that) {
    this.x = that.x;
    this.y = that.y;
    this.z = that.z;   
};

x3dom.fields.SFVec3f.prototype.at = function (i) {
	switch(i) {
	    case 0:  return this.x;
	    case 1:  return this.y;
	    case 2:  return this.z;
	    default: return this.x;
	}
};

x3dom.fields.SFVec3f.prototype.add = function (that) {
    return new x3dom.fields.SFVec3f(this.x + that.x, this.y + that.y, this.z + that.z);
};

x3dom.fields.SFVec3f.prototype.addScaled = function (that, s) {
    return new x3dom.fields.SFVec3f(this.x + s*that.x, this.y + s*that.y, this.z + s*that.z);
};

x3dom.fields.SFVec3f.prototype.subtract = function (that) {
    return new x3dom.fields.SFVec3f(this.x - that.x, this.y - that.y, this.z - that.z);
};

x3dom.fields.SFVec3f.prototype.negate = function () {
    return new x3dom.fields.SFVec3f(-this.x, -this.y, -this.z);
};

x3dom.fields.SFVec3f.prototype.dot = function (that) {
    return (this.x*that.x + this.y*that.y + this.z*that.z);
};

x3dom.fields.SFVec3f.prototype.cross = function (that) {
    return new x3dom.fields.SFVec3f( this.y*that.z - this.z*that.y, 
                                     this.z*that.x - this.x*that.z,
                                     this.x*that.y - this.y*that.x );
};

x3dom.fields.SFVec3f.prototype.reflect = function (n) {
    var d2 = this.dot(n)*2;
    return new x3dom.fields.SFVec3f(this.x - d2*n.x, this.y - d2*n.y, this.z - d2*n.z);
};

x3dom.fields.SFVec3f.prototype.length = function() {
    return Math.sqrt((this.x*this.x) + (this.y*this.y) + (this.z*this.z));
};

x3dom.fields.SFVec3f.prototype.normalize = function() {
    var n = this.length();
    if (n) { n = 1.0 / n; }
    return new x3dom.fields.SFVec3f(this.x*n, this.y*n, this.z*n);
};

x3dom.fields.SFVec3f.prototype.multComponents = function (that) {
    return new x3dom.fields.SFVec3f(this.x*that.x, this.y*that.y, this.z*that.z);
};

x3dom.fields.SFVec3f.prototype.multiply = function (n) {
    return new x3dom.fields.SFVec3f(this.x*n, this.y*n, this.z*n);
};

x3dom.fields.SFVec3f.prototype.divide = function (n) {
    var denom = n ? (1.0 / n) : 1.0;
    return new x3dom.fields.SFVec3f(this.x*denom, this.y*denom, this.z*denom);
};

x3dom.fields.SFVec3f.prototype.equals = function (that, eps) {
    return Math.abs(this.x - that.x) < eps && 
           Math.abs(this.y - that.y) < eps &&
           Math.abs(this.z - that.z) < eps;
};

x3dom.fields.SFVec3f.prototype.toGL = function () {
    return [ this.x, this.y, this.z ];
};

x3dom.fields.SFVec3f.prototype.toString = function () {
    return this.x + " " + this.y + " " + this.z;
};

x3dom.fields.SFVec3f.prototype.setValueByStr = function(str) {
    try {
        var m = /^\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*$/.exec(str);
        this.x = +m[1];
        this.y = +m[2];
        this.z = +m[3];
    }
    catch (e) {
        // allow automatic type conversion as is convenient for shaders
        var c = x3dom.fields.SFColor.colorParse(str);
        this.x = c.r;
        this.y = c.g;
        this.z = c.b;
    }
    return this;
};


///////////////////////////////////////////////////////////////////////////////
/** SFVec4f constructor.
    @class Represents a SFVec4f
  */
x3dom.fields.SFVec4f = function(x, y, z, w) {
    if (arguments.length === 0) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
    }
    else {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
};

x3dom.fields.SFVec4f.copy = function(v) {
    return new x3dom.fields.SFVec4f(v.x, v.y, v.z, v.w);
};

x3dom.fields.SFVec4f.parse = function (str) {
    var m = /^\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*$/.exec(str);
    return new x3dom.fields.SFVec4f(+m[1], +m[2], +m[3], +m[4]);
};

x3dom.fields.SFVec4f.prototype.setValueByStr = function(str) {
    var m = /^\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*$/.exec(str);
    this.x = +m[1];
    this.y = +m[2];
    this.z = +m[3];
    this.w = +m[4];
    return this;
};

x3dom.fields.SFVec4f.prototype.toGL = function () {
    return [ this.x, this.y, this.z, this.w ];
};

x3dom.fields.SFVec4f.prototype.toString = function () {
    return this.x + " " + this.y + " " + this.z + " " + this.w;
};


///////////////////////////////////////////////////////////////////////////////
/** Quaternion constructor.
    @class Represents a Quaternion
  */
x3dom.fields.Quaternion = function(x, y, z, w) {
    if (arguments.length === 0) {
        this.x = 0;
        this.y = 0;
        this.z = 1;
        this.w = 0;
    }
    else {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
};

x3dom.fields.Quaternion.copy = function(v) {
    return new x3dom.fields.Quaternion(v.x, v.y, v.z, v.w);
};

x3dom.fields.Quaternion.prototype.multiply = function (that) {
    return new x3dom.fields.Quaternion(
        this.w*that.x + this.x*that.w + this.y*that.z - this.z*that.y,
        this.w*that.y + this.y*that.w + this.z*that.x - this.x*that.z,
        this.w*that.z + this.z*that.w + this.x*that.y - this.y*that.x,
        this.w*that.w - this.x*that.x - this.y*that.y - this.z*that.z
    );
};

x3dom.fields.Quaternion.parseAxisAngle = function (str) {
    var m = /^\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*$/.exec(str);
    return x3dom.fields.Quaternion.axisAngle(new x3dom.fields.SFVec3f(+m[1], +m[2], +m[3]), +m[4]);
};

x3dom.fields.Quaternion.axisAngle = function (axis, a) {
    var t = axis.length();
    
    if (t > x3dom.fields.Eps)
    {
        var s = Math.sin(a/2) / t;
        var c = Math.cos(a/2);
        return new x3dom.fields.Quaternion(axis.x*s, axis.y*s, axis.z*s, c);
    }
    else
    {
        return new x3dom.fields.Quaternion(0, 0, 0, 1);
    }
};

x3dom.fields.Quaternion.prototype.toMatrix = function () {
    var xx = this.x * this.x;
    var xy = this.x * this.y;
    var xz = this.x * this.z;
    var yy = this.y * this.y;
    var yz = this.y * this.z;
    var zz = this.z * this.z;
    var wx = this.w * this.x;
    var wy = this.w * this.y;
    var wz = this.w * this.z;

    return new x3dom.fields.SFMatrix4f(
        1 - 2 * (yy + zz), 2 * (xy - wz), 2 * (xz + wy), 0,
        2 * (xy + wz), 1 - 2 * (xx + zz), 2 * (yz - wx), 0,
        2 * (xz - wy), 2 * (yz + wx), 1 - 2 * (xx + yy), 0,
        0, 0, 0, 1
    );
};

x3dom.fields.Quaternion.prototype.toAxisAngle = function()
{
    var x = 0, y = 0, z = 0;
    var s = 0, a = 0;
    var that = this;
    
    if ( this.w > 1 )
    {
        that = x3dom.fields.Quaternion.normalize( this );
    }
    
    a = 2 * Math.acos( that.w );
    s = Math.sqrt( 1 - that.w * that.w );
    
    if ( s == 0 ) //< x3dom.fields.Eps )
    {
        x = that.x;
        y = that.y;
        z = that.z;
    }
    else
    {
        x = that.x / s;
        y = that.y / s;
        z = that.z / s;
    }
    
    return [ new x3dom.fields.SFVec3f(x,y,z), a ];
};

x3dom.fields.Quaternion.prototype.angle = function()
{
    return 2 * Math.acos(this.w);
};

x3dom.fields.Quaternion.prototype.setValue = function(matrix)
{
    var tr, s = 1;
    var qt = [0, 0, 0];

    var i = 0, j = 0, k = 0;
    var nxt = [1, 2, 0];

    tr = matrix._00 + matrix._11 + matrix._22;
	
    if (tr > 0.0)
    {
        s = Math.sqrt(tr + 1.0);

        this.w = s * 0.5;

        s = 0.5 / s;

        this.x = (matrix._21 - matrix._12) * s;
        this.y = (matrix._02 - matrix._20) * s;
        this.z = (matrix._10 - matrix._01) * s;
    }
    else
    {
        if (matrix._11 > matrix._00) {
            i = 1;
		}
        else {
            i = 0;
		}

        if (matrix._22 > matrix.at(i, i)) {
            i = 2;
		}

        j = nxt[i];
        k = nxt[j];

        s = Math.sqrt(matrix.at(i, i) - (matrix.at(j, j) + matrix.at(k, k)) + 1.0);

        qt[i] = s * 0.5;
        s     = 0.5 / s;

        this.w = (matrix.at(k, j) - matrix.at(j, k)) * s;

        qt[j] = (matrix.at(j, i) + matrix.at(i, j)) * s;
        qt[k] = (matrix.at(k, i) + matrix.at(i, k)) * s;

        this.x = qt[0];
        this.y = qt[1];
        this.z = qt[2];
    }

    if (this.w > 1.0 || this.w < -1.0)
    {
        var errThreshold = 1 + (x3dom.fields.Eps * 100);

        if (this.w > errThreshold || this.w < -errThreshold)
        {
			// When copying, then everything, incl. the famous OpenSG MatToQuat bug
            x3dom.debug.logInfo("MatToQuat: BUG: |quat[4]| (" + this.w +") >> 1.0 !");
        }

        if (this.w > 1.0) {
            this.w = 1.0;
        }
        else {
            this.w = -1.0;
        }
    }
};

x3dom.fields.Quaternion.prototype.dot = function (that) {
    return this.x*that.x + this.y*that.y + this.z*that.z + this.w*that.w;
};

x3dom.fields.Quaternion.prototype.add = function (that) {
    return new x3dom.fields.Quaternion(this.x + that.x, this.y + that.y, this.z + that.z, this.w + that.w);
};

x3dom.fields.Quaternion.prototype.subtract = function (that) {
    return new x3dom.fields.Quaternion(this.x - that.x, this.y - that.y, this.z - that.z, this.w - that.w);
};

x3dom.fields.Quaternion.prototype.setValues = function (that) { 
    this.x = that.x;
    this.y = that.y;
    this.z = that.z;
    this.w = that.w;
};

x3dom.fields.Quaternion.prototype.equals = function (that, eps) {
    return (this.dot(that) >= 1.0 - eps);
};

x3dom.fields.Quaternion.prototype.multScalar = function (s) {
    return new x3dom.fields.Quaternion(this.x*s, this.y*s, this.z*s, this.w*s);
};

x3dom.fields.Quaternion.prototype.normalize = function (that) {
    var d2 = this.dot(that);
    var id = 1.0;
    if (d2) { id = 1.0 / Math.sqrt(d2); }
    return new x3dom.fields.Quaternion(this.x*id, this.y*id, this.z*id, this.w*id);
};

x3dom.fields.Quaternion.prototype.negate = function() {
    return new x3dom.fields.Quaternion(-this.x, -this.y, -this.z, -this.w);
};

x3dom.fields.Quaternion.prototype.inverse = function () {
    return new x3dom.fields.Quaternion(-this.x, -this.y, -this.z, this.w);
};

x3dom.fields.Quaternion.prototype.slerp = function (that, t) {
    // calculate the cosine
    var cosom = this.dot(that);
    var rot1;

    // adjust signs if necessary
    if (cosom < 0.0)
    {
        cosom = -cosom;
        rot1 = that.negate();
    }
    else
    {
        rot1 = new x3dom.fields.Quaternion(that.x, that.y, that.z, that.w);
    }

    // calculate interpolating coeffs
    var scalerot0, scalerot1;
    
    if ((1.0 - cosom) > 0.00001)
    {
        // standard case
        var omega = Math.acos(cosom);
        var sinom = Math.sin(omega);
        scalerot0 = Math.sin((1.0 - t) * omega) / sinom;
        scalerot1 = Math.sin(t * omega) / sinom;
    }
    else
    {
        // rot0 and rot1 very close - just do linear interp.
        scalerot0 = 1.0 - t;
        scalerot1 = t;
    }

    // build the new quaternion
    return this.multScalar(scalerot0).add(rot1.multScalar(scalerot1));
};

x3dom.fields.Quaternion.rotateFromTo = function (fromVec, toVec) {
    var from = fromVec.normalize();
    var to   = toVec.normalize();
    var cost = from.dot(to);

    // check for degeneracies
    if (cost > 0.99999)
    {
        // vectors are parallel
        return new x3dom.fields.Quaternion(0, 0, 0, 1);
    }
    else if (cost < -0.99999)
    {
        // vectors are opposite
        // find an axis to rotate around, which should be
        // perpendicular to the original axis
        // Try cross product with (1,0,0) first, if that's one of our
        // original vectors then try  (0,1,0).
        var cAxis = new x3dom.fields.SFVec3f(1, 0, 0);

        var tmp = from.cross(cAxis);

        if (tmp.length() < 0.00001)
        {
            cAxis.x = 0;
            cAxis.y = 1;
            cAxis.z = 0;

            tmp = from.cross(cAxis);
        }
        tmp = tmp.normalize();

        return x3dom.fields.Quaternion.axisAngle(tmp, Math.PI);
    }

    var axis = fromVec.cross(toVec);
    axis = axis.normalize();

    // use half-angle formulae
    // sin^2 t = ( 1 - cos (2t) ) / 2
    var s = Math.sqrt(0.5 * (1.0 - cost));
    axis = axis.multiply(s);

    // scale the axis by the sine of half the rotation angle to get
    // the normalized quaternion
    // cos^2 t = ( 1 + cos (2t) ) / 2
    // w part is cosine of half the rotation angle
    s = Math.sqrt(0.5 * (1.0 + cost));
    
    return new x3dom.fields.Quaternion(axis.x, axis.y, axis.z, s);
};

x3dom.fields.Quaternion.prototype.toGL = function () {
    var val = this.toAxisAngle();
    return [ val[0].x, val[0].y, val[0].z, val[1] ];
};

x3dom.fields.Quaternion.prototype.toString = function () {
    return this.x + " " + this.y + " " + this.z + ", " + this.w;
};

x3dom.fields.Quaternion.prototype.setValueByStr = function(str) {
    var m = /^\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*$/.exec(str);
    var quat = x3dom.fields.Quaternion.axisAngle(new x3dom.fields.SFVec3f(+m[1], +m[2], +m[3]), +m[4]);
    this.x = quat.x;
    this.y = quat.y;
    this.z = quat.z;
    this.w = quat.w;
    return this;
};


///////////////////////////////////////////////////////////////////////////////
/** SFColor constructor.
    @class Represents a SFColor
  */
x3dom.fields.SFColor = function(r, g, b) {
    if (arguments.length === 0) {
        this.r = 0;
        this.g = 0;
        this.b = 0;
    }
    else {
        this.r = r;
        this.g = g;
        this.b = b;
    }
};

x3dom.fields.SFColor.parse = function(str) {
    try {
        var m = /^\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*$/.exec(str);
        return new x3dom.fields.SFColor( +m[1], +m[2], +m[3] );
    }
    catch (e) {
        return x3dom.fields.SFColor.colorParse(str);
    }
};

x3dom.fields.SFColor.prototype.setHSV = function (h, s, v) {
    x3dom.debug.logWarning("SFColor.setHSV() NYI");
};

x3dom.fields.SFColor.prototype.getHSV = function () {
    var h = 0, s = 0, v = 0;
    x3dom.debug.logWarning("SFColor.getHSV() NYI");
    return [ h, s, v ];
};

x3dom.fields.SFColor.prototype.setValues = function (color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;   
};

x3dom.fields.SFColor.prototype.equals = function (that, eps) {
    return Math.abs(this.r - that.r) < eps && 
           Math.abs(this.g - that.g) < eps &&
           Math.abs(this.b - that.b) < eps;
};

x3dom.fields.SFColor.prototype.add = function (that) {
    return new x3dom.fields.SFColor(this.r + that.r, this.g + that.g, this.b + that.b);
};

x3dom.fields.SFColor.prototype.subtract = function (that) {
    return new x3dom.fields.SFColor(this.r - that.r, this.g - that.g, this.b - that.b);
};

x3dom.fields.SFColor.prototype.multiply = function (n) {
    return new x3dom.fields.SFColor(this.r*n, this.g*n, this.b*n);
};

x3dom.fields.SFColor.prototype.toGL = function () {
    return [ this.r, this.g, this.b ];
};

x3dom.fields.SFColor.prototype.toString = function() {
    return this.r + " " + this.g + " " + this.b;
};

x3dom.fields.SFColor.prototype.setValueByStr = function(str) {
    try {
        var m = /^\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*$/.exec(str);
        this.r = +m[1];
        this.g = +m[2];
        this.b = +m[3];
    }
    catch (e) {
        var c = x3dom.fields.SFColor.colorParse(str);
        this.r = c.r;
        this.g = c.g;
        this.b = c.b;
    }
    return this;
};

x3dom.fields.SFColor.colorParse = function(color) {
    var red = 0, green = 0, blue = 0;
    
    // definition of css color names
    var color_names = {
        aliceblue: 'f0f8ff',    antiquewhite: 'faebd7', aqua: '00ffff',
        aquamarine: '7fffd4',   azure: 'f0ffff',        beige: 'f5f5dc',
        bisque: 'ffe4c4',       black: '000000',        blanchedalmond: 'ffebcd',
        blue: '0000ff',         blueviolet: '8a2be2',   brown: 'a52a2a',
        burlywood: 'deb887',    cadetblue: '5f9ea0',    chartreuse: '7fff00',
        chocolate: 'd2691e',    coral: 'ff7f50',        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',     crimson: 'dc143c',      cyan: '00ffff',
        darkblue: '00008b',     darkcyan: '008b8b',     darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',     darkgreen: '006400',    darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',  darkolivegreen: '556b2f',darkorange: 'ff8c00',
        darkorchid: '9932cc',   darkred: '8b0000',      darksalmon: 'e9967a',
        darkseagreen: '8fbc8f', darkslateblue: '483d8b',darkslategray: '2f4f4f',
        darkturquoise: '00ced1',darkviolet: '9400d3',   deeppink: 'ff1493',
        deepskyblue: '00bfff',  dimgray: '696969',      dodgerblue: '1e90ff',
        feldspar: 'd19275',     firebrick: 'b22222',    floralwhite: 'fffaf0',
        forestgreen: '228b22',  fuchsia: 'ff00ff',      gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',   gold: 'ffd700',         goldenrod: 'daa520',
        gray: '808080',         green: '008000',        greenyellow: 'adff2f',
        honeydew: 'f0fff0',     hotpink: 'ff69b4',      indianred : 'cd5c5c',
        indigo : '4b0082',      ivory: 'fffff0',        khaki: 'f0e68c',
        lavender: 'e6e6fa',     lavenderblush: 'fff0f5',lawngreen: '7cfc00',
        lemonchiffon: 'fffacd', lightblue: 'add8e6',    lightcoral: 'f08080',
        lightcyan: 'e0ffff',    lightgoldenrodyellow: 'fafad2', lightgrey: 'd3d3d3',
        lightgreen: '90ee90',   lightpink: 'ffb6c1',    lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',lightskyblue: '87cefa', lightslateblue: '8470ff',
        lightslategray: '778899',lightsteelblue: 'b0c4de',lightyellow: 'ffffe0',
        lime: '00ff00',         limegreen: '32cd32',    linen: 'faf0e6',
        magenta: 'ff00ff',      maroon: '800000',       mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',   mediumorchid: 'ba55d3', mediumpurple: '9370d8',
        mediumseagreen: '3cb371',mediumslateblue: '7b68ee', mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',mediumvioletred: 'c71585',midnightblue: '191970',
        mintcream: 'f5fffa',    mistyrose: 'ffe4e1',    moccasin: 'ffe4b5',
        navajowhite: 'ffdead',  navy: '000080',         oldlace: 'fdf5e6',
        olive: '808000',        olivedrab: '6b8e23',    orange: 'ffa500',
        orangered: 'ff4500',    orchid: 'da70d6',       palegoldenrod: 'eee8aa',
        palegreen: '98fb98',    paleturquoise: 'afeeee',palevioletred: 'd87093',
        papayawhip: 'ffefd5',   peachpuff: 'ffdab9',    peru: 'cd853f',
        pink: 'ffc0cb',         plum: 'dda0dd',         powderblue: 'b0e0e6',
        purple: '800080',       red: 'ff0000',          rosybrown: 'bc8f8f',
        royalblue: '4169e1',    saddlebrown: '8b4513',  salmon: 'fa8072',
        sandybrown: 'f4a460',   seagreen: '2e8b57',     seashell: 'fff5ee',
        sienna: 'a0522d',       silver: 'c0c0c0',       skyblue: '87ceeb',
        slateblue: '6a5acd',    slategray: '708090',    snow: 'fffafa',
        springgreen: '00ff7f',  steelblue: '4682b4',    tan: 'd2b48c',
        teal: '008080',         thistle: 'd8bfd8',      tomato: 'ff6347',
        turquoise: '40e0d0',    violet: 'ee82ee',       violetred: 'd02090',
        wheat: 'f5deb3',        white: 'ffffff',        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',       yellowgreen: '9acd32'
    };
    
    if (color_names[color]) {
        // first check if color is given as colorname
        color = "#" + color_names[color];
    }
    
    if (color.substr && color.substr(0,1) === "#") {
        color = color.substr(1);
        var len = color.length;
        
        if (len === 6) {
            red   = parseInt("0x"+color.substr(0,2), 16) / 255.0;
            green = parseInt("0x"+color.substr(2,2), 16) / 255.0;
            blue  = parseInt("0x"+color.substr(4,2), 16) / 255.0;
        }
        else if (len === 3) {
            red   = parseInt("0x"+color.substr(0,1), 16) / 15.0;
            green = parseInt("0x"+color.substr(1,1), 16) / 15.0;
            blue  = parseInt("0x"+color.substr(2,1), 16) / 15.0;
        }
    }
    
    return new x3dom.fields.SFColor( red, green, blue );
};


///////////////////////////////////////////////////////////////////////////////
/** SFColorRGBA constructor.
    @class Represents a SFColorRGBA
  */
x3dom.fields.SFColorRGBA = function(r, g, b, a) {
    if (arguments.length === 0) {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 1;
    }
    else {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }    
};

x3dom.fields.SFColorRGBA.parse = function(str) {
    try {
        var m = /^([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)$/.exec(str);
        return new x3dom.fields.SFColorRGBA( +m[1], +m[2], +m[3], +m[4] );
    }
    catch (e) {
        return x3dom.fields.SFColorRGBA.colorParse(str);
    }
};

x3dom.fields.SFColorRGBA.prototype.setValues = function (color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;   
    this.a = color.a;   
};

x3dom.fields.SFColorRGBA.prototype.equals = function (that, eps) {
    return Math.abs(this.r - that.r) < eps && 
           Math.abs(this.g - that.g) < eps &&
           Math.abs(this.b - that.b) < eps &&
           Math.abs(this.a - that.a) < eps;
};

x3dom.fields.SFColorRGBA.prototype.toGL = function () {
    return [ this.r, this.g, this.b, this.a ];
};

x3dom.fields.SFColorRGBA.prototype.toString = function() {
    return this.r + " " + this.g + " " + this.b + " " + this.a;
};

x3dom.fields.SFColorRGBA.prototype.setValueByStr = function(str) {
    try {
        var m = /^([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)\s*,?\s*([+\-]?\d*\.*\d*[eE]?[+\-]?\d*?)$/.exec(str);
        this.r = +m[1];
        this.g = +m[2];
        this.b = +m[3];
        this.a = +m[4];
    }
    catch (e) {
        var c = x3dom.fields.SFColorRGBA.colorParse(str);
        this.r = c.r;
        this.g = c.g;
        this.b = c.b;
        this.a = c.a;
    }
    return this;
};


///////////////////////////////////////////////////////////////////////////////
/** SFImage constructor.
    @class Represents an SFImage
  */
x3dom.fields.SFImage = function(w, h, c, arr) {
    if (arguments.length === 0 || !(arr && arr.map)) {
        this.width = 0;
        this.height = 0;
        this.comp = 0;
        this.array = [];
    }
    else {
        this.width = w;
        this.height = h;
        this.comp = c;
        var that = this.array;
        arr.map( function(v) { that.push(v); }, this.array );
    }
};

x3dom.fields.SFImage.parse = function(str) {
    var img = new x3dom.fields.SFImage();
    img.setValueByStr(str);
    return img;
};

x3dom.fields.SFImage.prototype.setValueByStr = function(str) {
    var mc = str.match(/(\w+)/g);
    var n = mc.length;
    var c2 = 0;
    var hex = "0123456789ABCDEF";
    
    this.array = [];
    
    if (n > 2) {
        this.width = +mc[0];
        this.height = +mc[1];
        this.comp = +mc[2];
        c2 = 2 * this.comp;
    } else {
        this.width = 0;
        this.height = 0;
        this.comp = 0;
        return;
    }
    
    var len, i;
    for (i=3; i<n; i++) {
        if (!mc[i].substr) {
            continue;
        }
        
        if (mc[i].substr(1,1).toLowerCase() !== "x") {
            // Maybe optimize by directly parsing value!
            var out = "";
            var inp = parseInt(mc[i], 10);
            
            while (inp !== 0) {
              out = hex.charAt(inp%16) + out;
              inp = inp >> 4;
            }
            len = out.length;
            while (out.length < c2) {
                out = "0" + out;
            }
            mc[i] = "0x" + out;
        }
        
        if (mc[i].substr(1,1).toLowerCase() === "x") {
            mc[i] = mc[i].substr(2);
            len = mc[i].length;
            var r, g, b, a;
            
            if (len === c2) {
                if (this.comp === 1) {
                    r = parseInt("0x"+mc[i].substr(0,2), 16);
                    this.array.push( r );
                }
                else if (this.comp === 2) {
                    r = parseInt("0x"+mc[i].substr(0,2), 16);
                    g = parseInt("0x"+mc[i].substr(2,2), 16);
                    this.array.push( r, g );
                }
                else if (this.comp === 3) {
                    r = parseInt("0x"+mc[i].substr(0,2), 16);
                    g = parseInt("0x"+mc[i].substr(2,2), 16);
                    b = parseInt("0x"+mc[i].substr(4,2), 16);
                    this.array.push( r, g, b );
                }
                else if (this.comp === 4) {
                    r = parseInt("0x"+mc[i].substr(0,2), 16);
                    g = parseInt("0x"+mc[i].substr(2,2), 16);
                    b = parseInt("0x"+mc[i].substr(4,2), 16);
                    a = parseInt("0x"+mc[i].substr(6,2), 16);
                    this.array.push( r, g, b, a );
                }
            }
        }
    }
};

x3dom.fields.SFImage.prototype.toGL = function() {
    var a = [];

    Array.map( this.array, function(c) {
        a.push(c);       
    });

    return a;
};



///////////////////////////////////////////////////////////////////////////////
// Multi-Field Definitions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/** MFColor constructor.
    @class Represents a MFColor
  */
x3dom.fields.MFColor = function(colorArray) {

    if (arguments.length === 0) {
    }
    else {
        var that = this;
        colorArray.map( function(c) { that.push(c); }, this );
    }
};

x3dom.fields.MFColor.prototype = x3dom.extend([]);

x3dom.fields.MFColor.parse = function(str) {
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    var colors = [];
    for (var i=0, n=mc?mc.length:0; i<n; i+=3) {
        colors.push( new x3dom.fields.SFColor(+mc[i+0], +mc[i+1], +mc[i+2]) );
    }
    
    return new x3dom.fields.MFColor( colors );
};

x3dom.fields.MFColor.prototype.setValueByStr = function(str) {
    while (this.length) {
        this.pop();
    }
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    for (var i=0, n=mc?mc.length:0; i<n; i+=3) {
        this.push( new x3dom.fields.SFColor(+mc[i+0], +mc[i+1], +mc[i+2]) );
    }
};

x3dom.fields.MFColor.prototype.toGL = function() {
    var a = [];

    Array.map( this, function(c) {
        a.push(c.r);
        a.push(c.g);
        a.push(c.b);        
    });

    return a;
};


///////////////////////////////////////////////////////////////////////////////
/** MFColorRGBA constructor.
    @class Represents a MFColorRGBA
  */
x3dom.fields.MFColorRGBA = function(colorArray) {
    if (arguments.length === 0) {
    }
    else {
        var that = this;
        colorArray.map( function(c) { that.push(c); }, this );
    }
};

x3dom.fields.MFColorRGBA.prototype = x3dom.extend([]);

x3dom.fields.MFColorRGBA.parse = function(str) {
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    var colors = [];
    for (var i=0, n=mc?mc.length:0; i<n; i+=4) {
        colors.push( new x3dom.fields.SFColorRGBA(+mc[i+0], +mc[i+1], +mc[i+2], +mc[i+3]) );
    }
    
    return new x3dom.fields.MFColorRGBA( colors );
};

x3dom.fields.MFColorRGBA.prototype.setValueByStr = function(str) {
    while (this.length) {
        this.pop();
    }
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    for (var i=0, n=mc?mc.length:0; i<n; i+=4) {
        this.push( new x3dom.fields.SFColor(+mc[i+0], +mc[i+1], +mc[i+2], +mc[i+3]) );
    }
};

x3dom.fields.MFColorRGBA.prototype.toGL = function() {
    var a = [];

    Array.map( this, function(c) {
        a.push(c.r);
        a.push(c.g);
        a.push(c.b);
        a.push(c.a);    
    });

    return a;
};


///////////////////////////////////////////////////////////////////////////////
/** MFRotation constructor.
    @class Represents a MFRotation
  */
x3dom.fields.MFRotation = function(rotArray) {
    if (arguments.length === 0) {        
    }
    else {
        var that = this;
        rotArray.map( function(v) { that.push(v); }, this );
    }
};

x3dom.fields.MFRotation.prototype = x3dom.extend([]);

x3dom.fields.MFRotation.parse = function(str) {
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    var vecs = [];
    for (var i=0, n=mc?mc.length:0; i<n; i+=4) {
        vecs.push( x3dom.fields.Quaternion.axisAngle(new x3dom.fields.SFVec3f(+mc[i+0], +mc[i+1], +mc[i+2]), +mc[i+3]) );
    }
    
    // holds the quaternion representation as needed by interpolators etc.
    return new x3dom.fields.MFRotation( vecs );    
};

x3dom.fields.MFRotation.prototype.setValueByStr = function(str) {
    while (this.length) {
        this.pop();
    }
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    for (var i=0, n=mc?mc.length:0; i<n; i+=4) {
        this.push( x3dom.fields.Quaternion.axisAngle(new x3dom.fields.SFVec3f(+mc[i+0], +mc[i+1], +mc[i+2]), +mc[i+3]) );
    }
};

x3dom.fields.MFRotation.prototype.toGL = function() {
    var a = [];

    Array.map( this, function(c) {
        var val = c.toAxisAngle();
        a.push(val[0].x);
        a.push(val[0].y);
        a.push(val[0].z);
        a.push(val[1]);
    });

    return a;
};


///////////////////////////////////////////////////////////////////////////////
/** MFVec3f constructor.
    @class Represents a MFVec3f
  */
x3dom.fields.MFVec3f = function(vec3Array) {
    if (arguments.length === 0) {        
    }
    else {
        var that = this;
        vec3Array.map( function(v) { that.push(v); }, this );
    }
};

x3dom.fields.MFVec3f.copy = function(vec3Array) {
    var destination = new x3dom.fields.MFVec3f();
    vec3Array.map( function(v) { destination.push(x3dom.fields.SFVec3f.copy(v)); }, this );
    return destination;
};

x3dom.fields.MFVec3f.prototype = x3dom.extend([]);

x3dom.fields.MFVec3f.parse = function(str) {
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    var vecs = [];
    for (var i=0, n=mc?mc.length:0; i<n; i+=3) {
        vecs.push( new x3dom.fields.SFVec3f(+mc[i+0], +mc[i+1], +mc[i+2]) );
    }
    
    return new x3dom.fields.MFVec3f( vecs );    
};

x3dom.fields.MFVec3f.prototype.setValueByStr = function(str) {
    while (this.length) {
        this.pop();
    }
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    for (var i=0, n=mc?mc.length:0; i<n; i+=3) {
        this.push( new x3dom.fields.SFVec3f(+mc[i+0], +mc[i+1], +mc[i+2]) );
    }
};

x3dom.fields.MFVec3f.prototype.toGL = function() {
    var a = [];

    Array.map( this, function(c) {
        a.push(c.x);
        a.push(c.y);
        a.push(c.z);        
    });

    return a;
};


///////////////////////////////////////////////////////////////////////////////
/** MFVec2f constructor.
    @class Represents a MFVec2f
  */
x3dom.fields.MFVec2f = function(vec2Array) {
    if (arguments.length === 0) {        
    }
    else {
        var that = this;
        vec2Array.map( function(v) { that.push(v); }, this );
    }
};

x3dom.fields.MFVec2f.prototype = x3dom.extend([]);

x3dom.fields.MFVec2f.parse = function(str) {
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    var vecs = [];
    for (var i=0, n=mc?mc.length:0; i<n; i+=2) {
        vecs.push( new x3dom.fields.SFVec2f(+mc[i+0], +mc[i+1]) );
    }

    return new x3dom.fields.MFVec2f( vecs );    
};

x3dom.fields.MFVec2f.prototype.setValueByStr = function(str) {
    while (this.length) {
        this.pop();
    }
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    for (var i=0, n=mc?mc.length:0; i<n; i+=2) {
        this.push( new x3dom.fields.SFVec2f(+mc[i+0], +mc[i+1]) );
    }
};

x3dom.fields.MFVec2f.prototype.toGL = function() {
    var a = [];

    Array.map( this, function(v) {
        a.push(v.x);
        a.push(v.y);    
    });

    return a;
};


///////////////////////////////////////////////////////////////////////////////
/** MFInt32 constructor.
    @class Represents a MFInt32
  */
x3dom.fields.MFInt32 = function(array) {
    if (arguments.length === 0) {
    }
    else if (array && array.map) {
        var that = this;
        array.map( function(v) { that.push(v); }, this );
    }
};

x3dom.fields.MFInt32.prototype = x3dom.extend([]);

x3dom.fields.MFInt32.parse = function(str) {
    var mc = str.match(/([+\-]?\d+\s*){1},?\s*/g);
    var vals = [];
    for (var i=0, n=mc?mc.length:0; i<n; ++i) {
        vals.push( parseInt(mc[i], 10) );
    }
    
    return new x3dom.fields.MFInt32( vals );
};

x3dom.fields.MFInt32.prototype.setValueByStr = function(str) {
    while (this.length) {
        this.pop();
    }
    var mc = str.match(/([+\-]?\d+\s*){1},?\s*/g);
    for (var i=0, n=mc?mc.length:0; i<n; ++i) {
        this.push( parseInt(mc[i], 10) );
    }
};

x3dom.fields.MFInt32.prototype.toGL = function() {
    var a = [];

    Array.map( this, function(v) {
        a.push(v);
    });

    return a;
};


///////////////////////////////////////////////////////////////////////////////
/** MFFloat constructor.
    @class Represents a MFFloat
  */
x3dom.fields.MFFloat = function(array) {
    if (arguments.length === 0) {
    }
    else if (array && array.map) {
        var that = this;
        array.map( function(v) { that.push(v); }, this );
    }
};

x3dom.fields.MFFloat.prototype = x3dom.extend([]);

x3dom.fields.MFFloat.parse = function(str) {
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    var vals = [];
    for (var i=0, n=mc?mc.length:0; i<n; i++) {
        vals.push( +mc[i] );
    }
    
    return new x3dom.fields.MFFloat( vals );    
};

x3dom.fields.MFFloat.prototype.setValueByStr = function(str) {
    while (this.length) {
        this.pop();
    }
    var mc = str.match(/([+\-0-9eE\.]+)/g);
    for (var i=0, n=mc?mc.length:0; i<n; i++) {
        this.push( +mc[i] );
    }
};

x3dom.fields.MFFloat.prototype.toGL = function() {
    var a = [];

    Array.map( this, function(v) {
        a.push(v);
    });

    return a;
};


///////////////////////////////////////////////////////////////////////////////
/** MFBoolean constructor.
 @class Represents a MFBoolean
 */
x3dom.fields.MFBoolean = function(array) {
    if (arguments.length === 0) {
    }
    else if (array && array.map) {
        var that = this;
        array.map( function(v) { that.push(v); }, this );
    }
};

x3dom.fields.MFBoolean.prototype = x3dom.extend([]);

x3dom.fields.MFBoolean.parse = function(str) {
    var vals = [];
    // TODO; parse!!!

    return new x3dom.fields.MFBoolean( vals );
};

x3dom.fields.MFBoolean.prototype.setValueByStr = function(str) {
    while (this.length) {
        this.pop();
    }
    // TODO; parse!!!
};

x3dom.fields.MFBoolean.prototype.toGL = function() {
    var a = [];

    Array.map( this, function(v) {
        a.push(v);
    });

    return a;
};


///////////////////////////////////////////////////////////////////////////////
/** MFString constructor.
    @class Represents a MFString
  */
x3dom.fields.MFString = function(strArray) {
    if (arguments.length === 0) {
    }
    else if (strArray && strArray.map) {
        var that = this;
        strArray.map( function(v) { that.push(v); }, this );
    }
};

x3dom.fields.MFString.parse = function(str) {
    var arr = [];
    // ignore leading whitespace?
    if (str.length && str[0] == '"') {
        var m, re = /"((?:[^\\"]|\\\\|\\")*)"/g;
        while ((m = re.exec(str))) {
            var s = m[1].replace(/\\([\\"])/, "$1");
            if (s !== undefined) {
                arr.push(s);
            }
        }
    }
    else {
        arr.push(str);
    }
    return new x3dom.fields.MFString( arr );
};

x3dom.fields.MFString.prototype = x3dom.extend([]);

x3dom.fields.MFString.prototype.setValueByStr = function(str) {
    var arr = this;
    while (arr.length) {
        arr.pop();
    }
    // ignore leading whitespace?
    if (str.length && str[0] == '"') {
        var m, re = /"((?:[^\\"]|\\\\|\\")*)"/g;
        while ((m = re.exec(str))) {
            var s = m[1].replace(/\\([\\"])/, "$1");
            if (s !== undefined) {
                arr.push(s);
            }
        }
    }
    else {
        arr.push(str);
    }
    return this;
};

x3dom.fields.MFString.prototype.toString = function () {
    var str = "";
    for (var i=0; i<this.length; i++) {
		 str = str + this[i] + " ";
    }
    return str;
};



///////////////////////////////////////////////////////////////////////////////
// Single-/Multi-Field Node Definitions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/** SFNode constructor.
    @class Represents a SFNode
  */
x3dom.fields.SFNode = function(type) {
    this.type = type;
    this.node = null;
};

x3dom.fields.SFNode.prototype.hasLink = function(node) {
    return (node ? (this.node === node) : this.node);
};

x3dom.fields.SFNode.prototype.addLink = function(node) {
    this.node = node;
    return true;
};

x3dom.fields.SFNode.prototype.rmLink = function(node) {
    if (this.node === node) {
        this.node = null;
        return true;
    }
    else {
        return false;
    }
};


///////////////////////////////////////////////////////////////////////////////
/** MFNode constructor.
    @class Represents a MFNode
  */
x3dom.fields.MFNode = function(type) {
    this.type = type;
    this.nodes = [];
};

x3dom.fields.MFNode.prototype.hasLink = function(node) {
    if (node) {
        for (var i = 0, n = this.nodes.length; i < n; i++) {
            if (this.nodes[i] === node) {
                return true;
            }
        }
    }
    else {
        return (this.length > 0);
    }
    return false;
};

x3dom.fields.MFNode.prototype.addLink = function(node) {
    this.nodes.push (node);
    return true;
};

x3dom.fields.MFNode.prototype.rmLink = function(node) {
    for (var i = 0, n = this.nodes.length; i < n; i++) {
        if (this.nodes[i] === node) {
            this.nodes.splice(i,1);
            return true;
        }
    }
    return false;
};

x3dom.fields.MFNode.prototype.length = function() {
    return this.nodes.length;
};



///////////////////////////////////////////////////////////////////////////////
// Math Helper Node Definitions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/** Line constructor.
    @class Represents a Line (as internal helper).
  */
x3dom.fields.Line = function(pos, dir) 
{
    if (arguments.length === 0) 
    {
        this.pos = new x3dom.fields.SFVec3f(0, 0, 0);
        this.dir = new x3dom.fields.SFVec3f(0, 0, 1);
    } 
    else 
    {
        this.pos = new x3dom.fields.SFVec3f(pos.x, pos.y, pos.z);
        
        var n = dir.length();
        if (n) { n = 1.0 / n; }
        
        this.dir = new x3dom.fields.SFVec3f(dir.x*n, dir.y*n, dir.z*n);
    }
    
    this.enter = 0;
    this.exit  = 0;
    this.hitObject = null;
    this.hitPoint  = {};
    this.dist = Number.MAX_VALUE;
};

x3dom.fields.Line.prototype.toString = function () {
    return 'Line: [' + this.pos.toString() + '; ' + this.dir.toString() + ']';
};

/** intersect line with box volume given by low and high */
x3dom.fields.Line.prototype.intersect = function(low, high)
{
    var isect = 0.0;
    var out = Number.MAX_VALUE;
    var r, te, tl;
    
    if (this.dir.x > x3dom.fields.Eps)
    {
        r = 1.0 / this.dir.x;
    
        te = (low.x - this.pos.x) * r;
        tl = (high.x - this.pos.x) * r;
    
        if (tl < out){ 
            out = tl;
        }
    
        if (te > isect){ 
            isect  = te;
        }
    }
    else if (this.dir.x < -x3dom.fields.Eps)
    {
        r = 1.0 / this.dir.x;
    
        te = (high.x - this.pos.x) * r;
        tl = (low.x - this.pos.x) * r;
    
        if (tl < out){
            out = tl;
        }
    
        if (te > isect)   {
            isect = te;
        }
    }
    else if (this.pos.x < low.x || this.pos.x > high.x)
    {
        return false;
    }
    
    if (this.dir.y > x3dom.fields.Eps)
    {
        r = 1.0 / this.dir.y;
    
        te = (low.y - this.pos.y) * r;
        tl = (high.y - this.pos.y) * r;
    
        if (tl < out){ 
            out = tl;
        }
    
        if (te > isect) {
            isect = te;
        }
    
        if (isect-out >= x3dom.fields.Eps) {
            return false;
        }
    }
    else if (this.dir.y < -x3dom.fields.Eps)
    {
        r = 1.0 / this.dir.y;
    
        te = (high.y - this.pos.y) * r;
        tl = (low.y - this.pos.y) * r;
    
        if (tl < out){ 
            out = tl;
        }
    
        if (te > isect) {
            isect = te;
        }
    
        if (isect-out >= x3dom.fields.Eps) {
            return false;
        }
    }
    else if (this.pos.y < low.y || this.pos.y > high.y)
    {
        return false;
    }
    
    if (this.dir.z > x3dom.fields.Eps)
    {
        r = 1.0 / this.dir.z;
    
        te = (low.z - this.pos.z) * r;
        tl = (high.z - this.pos.z) * r;
    
        if (tl < out) {
            out = tl;
        }
    
        if (te > isect) {
            isect = te;
        }
    }
    else if (this.dir.z < -x3dom.fields.Eps)
    {
        r = 1.0 / this.dir.z;
    
        te = (high.z - this.pos.z) * r;
        tl = (low.z - this.pos.z) * r;
    
        if (tl < out) {
            out = tl;
        }
    
        if (te > isect) {
            isect = te;
        }
    }
    else if (this.pos.z < low.z || this.pos.z > high.z)
    {
        return false;
    }
    
    this.enter = isect;
    this.exit  = out;

    return (isect-out < x3dom.fields.Eps);
};


///////////////////////////////////////////////////////////////////////////////
/** BoxVolume constructor.
    @class Represents a box volume (as internal helper).
  */
x3dom.fields.BoxVolume = function(min, max)
{
    if (arguments.length < 2) {
        this.min = new x3dom.fields.SFVec3f(0, 0, 0);
        this.max = new x3dom.fields.SFVec3f(0, 0, 0);
        this.valid = false;
    }
    else {
        // compiler enforced type check for min/max would be nice
        this.min = x3dom.fields.SFVec3f.copy(min);
        this.max = x3dom.fields.SFVec3f.copy(max);
        this.valid = true;
    }

    this.updateInternals();
};

x3dom.fields.BoxVolume.copy = function(other)
{
    return new x3dom.fields.BoxVolume(other.min, other.max);
};

x3dom.fields.BoxVolume.prototype.updateInternals = function()
{
    this.radialVec = this.max.subtract(this.min).multiply(0.5);
    this.center    = this.min.add(this.radialVec);
    this.diameter  = 2 * this.radialVec.length();
};

x3dom.fields.BoxVolume.prototype.setBounds = function(min, max)
{
    this.min.setValues(min);
    this.max.setValues(max);

    this.updateInternals();
    this.valid = true;
};

x3dom.fields.BoxVolume.prototype.setBoundsByCenterSize = function(center, size)
{
    var halfSize = size.multiply(0.5);
    this.min = center.subtract(halfSize);
    this.max = center.add(halfSize);

    this.updateInternals();
    this.valid = true;
};

x3dom.fields.BoxVolume.prototype.extendBounds = function(min, max)
{
    if (this.valid)
    {
        if (this.min.x > min.x) { this.min.x = min.x; }
        if (this.min.y > min.y) { this.min.y = min.y; }
        if (this.min.z > min.z) { this.min.z = min.z; }

        if (this.max.x < max.x) { this.max.x = max.x; }
        if (this.max.y < max.y) { this.max.y = max.y; }
        if (this.max.z < max.z) { this.max.z = max.z; }

        this.updateInternals();
    }
    else
    {
        this.setBounds(min, max);
    }
};

x3dom.fields.BoxVolume.prototype.getBounds = function(min, max)
{
    min.setValues(this.min);
    max.setValues(this.max);
};

x3dom.fields.BoxVolume.prototype.getRadialVec = function()
{
    return this.radialVec;
};

x3dom.fields.BoxVolume.prototype.invalidate = function()
{
    this.valid = false;
};

x3dom.fields.BoxVolume.prototype.isValid = function()
{
    return this.valid;
};

x3dom.fields.BoxVolume.prototype.getCenter = function()
{
    return this.center;
};

x3dom.fields.BoxVolume.prototype.getDiameter = function()
{
    return this.diameter;
};

x3dom.fields.BoxVolume.prototype.transform = function(m)
{
    var xmin, ymin, zmin;
    var xmax, ymax, zmax;

    xmin = xmax = m._03;
    ymin = ymax = m._13;
    zmin = zmax = m._23;

    // calculate xmin and xmax of new transformed BBox
    var a = this.max.x * m._00;
    var b = this.min.x * m._00;

    if (a >= b) {
        xmax += a;
        xmin += b;
    }
    else {
        xmax += b;
        xmin += a;
    }

    a = this.max.y * m._01;
    b = this.min.y * m._01;

    if (a >= b) {
        xmax += a;
        xmin += b;
    }
    else {
        xmax += b;
        xmin += a;
    }
    
    a = this.max.z * m._02;
    b = this.min.z * m._02;

    if (a >= b) {
        xmax += a;
        xmin += b;
    }
    else {
        xmax += b;
        xmin += a;
    }

    // calculate ymin and ymax of new transformed BBox
    a = this.max.x * m._10;
    b = this.min.x * m._10;

    if (a >= b) {
        ymax += a;
        ymin += b;
    }
    else {
        ymax += b;
        ymin += a;
    }

    a = this.max.y * m._11;
    b = this.min.y * m._11;

    if (a >= b) {
        ymax += a;
        ymin += b;
    }
    else {
        ymax += b;
        ymin += a;
    }

    a = this.max.z * m._12;
    b = this.min.z * m._12;

    if (a >= b) {
        ymax += a;
        ymin += b;
    }
    else {
        ymax += b;
        ymin += a;
    }

    // calculate zmin and zmax of new transformed BBox
    a = this.max.x * m._20;
    b = this.min.x * m._20;

    if (a >= b) {
        zmax += a;
        zmin += b;
    }
    else {
        zmax += b;
        zmin += a;
    }

    a = this.max.y * m._21;
    b = this.min.y * m._21;

    if (a >= b) {
        zmax += a;
        zmin += b;
    }
    else {
        zmax += b;
        zmin += a;
    }

    a = this.max.z * m._22;
    b = this.min.z * m._22;

    if (a >= b) {
        zmax += a;
        zmin += b;
    }
    else {
        zmax += b;
        zmin += a;
    }

    this.min.x = xmin;
    this.min.y = ymin;
    this.min.z = zmin;
    
    this.max.x = xmax;
    this.max.y = ymax;
    this.max.z = zmax;

    this.updateInternals();
};

x3dom.fields.BoxVolume.prototype.transformFrom = function(m, other)
{
    var xmin, ymin, zmin;
    var xmax, ymax, zmax;

    xmin = xmax = m._03;
    ymin = ymax = m._13;
    zmin = zmax = m._23;

    // calculate xmin and xmax of new transformed BBox
    var a = other.max.x * m._00;
    var b = other.min.x * m._00;

    if (a >= b) {
        xmax += a;
        xmin += b;
    }
    else {
        xmax += b;
        xmin += a;
    }

    a = other.max.y * m._01;
    b = other.min.y * m._01;

    if (a >= b) {
        xmax += a;
        xmin += b;
    }
    else {
        xmax += b;
        xmin += a;
    }

    a = other.max.z * m._02;
    b = other.min.z * m._02;

    if (a >= b) {
        xmax += a;
        xmin += b;
    }
    else {
        xmax += b;
        xmin += a;
    }

    // calculate ymin and ymax of new transformed BBox
    a = other.max.x * m._10;
    b = other.min.x * m._10;

    if (a >= b) {
        ymax += a;
        ymin += b;
    }
    else {
        ymax += b;
        ymin += a;
    }

    a = other.max.y * m._11;
    b = other.min.y * m._11;

    if (a >= b) {
        ymax += a;
        ymin += b;
    }
    else {
        ymax += b;
        ymin += a;
    }

    a = other.max.z * m._12;
    b = other.min.z * m._12;

    if (a >= b) {
        ymax += a;
        ymin += b;
    }
    else {
        ymax += b;
        ymin += a;
    }

    // calculate zmin and zmax of new transformed BBox
    a = other.max.x * m._20;
    b = other.min.x * m._20;

    if (a >= b) {
        zmax += a;
        zmin += b;
    }
    else {
        zmax += b;
        zmin += a;
    }

    a = other.max.y * m._21;
    b = other.min.y * m._21;

    if (a >= b) {
        zmax += a;
        zmin += b;
    }
    else {
        zmax += b;
        zmin += a;
    }

    a = other.max.z * m._22;
    b = other.min.z * m._22;

    if (a >= b) {
        zmax += a;
        zmin += b;
    }
    else {
        zmax += b;
        zmin += a;
    }

    this.min.x = xmin;
    this.min.y = ymin;
    this.min.z = zmin;

    this.max.x = xmax;
    this.max.y = ymax;
    this.max.z = zmax;

    this.updateInternals();
    this.valid = true;
};


///////////////////////////////////////////////////////////////////////////////
/** FrustumVolume constructor.
    @class Represents a frustum (as internal helper).
  */
x3dom.fields.FrustumVolume = function(clipMat)
{
    this.planeNormals = [];
    this.planeDistances = [];
    this.directionIndex = [];
    
    if (arguments.length === 0) {
        return;
    }
    
    var planeEquation = [];
    
    for (var i=0; i<6; i++) {
        this.planeNormals[i] = new x3dom.fields.SFVec3f(0, 0, 0);
        this.planeDistances[i] = 0;
        this.directionIndex[i] = 0;
        
        planeEquation[i] = new x3dom.fields.SFVec4f(0, 0, 0, 0);
    }
    
    planeEquation[0].x = clipMat._30 - clipMat._00;
    planeEquation[0].y = clipMat._31 - clipMat._01;
    planeEquation[0].z = clipMat._32 - clipMat._02;
    planeEquation[0].w = clipMat._33 - clipMat._03;

    planeEquation[1].x = clipMat._30 + clipMat._00;
    planeEquation[1].y = clipMat._31 + clipMat._01;
    planeEquation[1].z = clipMat._32 + clipMat._02;
    planeEquation[1].w = clipMat._33 + clipMat._03;

    planeEquation[2].x = clipMat._30 + clipMat._10;
    planeEquation[2].y = clipMat._31 + clipMat._11;
    planeEquation[2].z = clipMat._32 + clipMat._12;
    planeEquation[2].w = clipMat._33 + clipMat._13;

    planeEquation[3].x = clipMat._30 - clipMat._10;
    planeEquation[3].y = clipMat._31 - clipMat._11;
    planeEquation[3].z = clipMat._32 - clipMat._12;
    planeEquation[3].w = clipMat._33 - clipMat._13;

    planeEquation[4].x = clipMat._30 + clipMat._20;
    planeEquation[4].y = clipMat._31 + clipMat._21;
    planeEquation[4].z = clipMat._32 + clipMat._22;
    planeEquation[4].w = clipMat._33 + clipMat._23;

    planeEquation[5].x = clipMat._30 - clipMat._20;
    planeEquation[5].y = clipMat._31 - clipMat._21;
    planeEquation[5].z = clipMat._32 - clipMat._22;
    planeEquation[5].w = clipMat._33 - clipMat._23;
    
    for (i=0; i<6; i++) {
        var vectorLength = Math.sqrt(planeEquation[i].x * planeEquation[i].x +
                                     planeEquation[i].y * planeEquation[i].y +
                                     planeEquation[i].z * planeEquation[i].z);
        
        planeEquation[i].x /=  vectorLength;
        planeEquation[i].y /=  vectorLength;
        planeEquation[i].z /=  vectorLength;
        planeEquation[i].w /= -vectorLength;
    }
    
    var updateDirectionIndex = function(normalVec) {
        var ind = 0;
        if (normalVec.x > 0) ind |= 1;
        if (normalVec.y > 0) ind |= 2;
        if (normalVec.z > 0) ind |= 4;
        return ind;
    };
    
    // right
    this.planeNormals[3].setValues(planeEquation[0]);
    this.planeDistances[3] = planeEquation[0].w;
    this.directionIndex[3] = updateDirectionIndex(this.planeNormals[3]);

    // left
    this.planeNormals[2].setValues(planeEquation[1]);
    this.planeDistances[2] = planeEquation[1].w;
    this.directionIndex[2] = updateDirectionIndex(this.planeNormals[2]);

    // bottom
    this.planeNormals[5].setValues(planeEquation[2]);
    this.planeDistances[5] = planeEquation[2].w;
    this.directionIndex[5] = updateDirectionIndex(this.planeNormals[5]);

    // top
    this.planeNormals[4].setValues(planeEquation[3]);
    this.planeDistances[4] = planeEquation[3].w;
    this.directionIndex[4] = updateDirectionIndex(this.planeNormals[4]);

    // near
    this.planeNormals[0].setValues(planeEquation[4]);
    this.planeDistances[0] = planeEquation[4].w;
    this.directionIndex[0] = updateDirectionIndex(this.planeNormals[0]);

    // far
    this.planeNormals[1].setValues(planeEquation[5]);
    this.planeDistances[1] = planeEquation[5].w;
    this.directionIndex[1] = updateDirectionIndex(this.planeNormals[1]);
};

/** Check the volume against the frustum. */
x3dom.fields.FrustumVolume.prototype.intersect = function(vol, planeMask)
{
    if (this.planeNormals.length < 6) {
        x3dom.debug.logWarning("FrustumVolume not initialized!");
        return false;
    }
    
    var that = this;
    var min = vol.min, max = vol.max;
    
    var setDirectionIndexPoint = function(index) {
        var pnt = new x3dom.fields.SFVec3f(0, 0, 0);
        if (index & 1) { pnt.x = min.x; }
        else           { pnt.x = max.x; }
        if (index & 2) { pnt.y = min.y; }
        else           { pnt.y = max.y; }
        if (index & 4) { pnt.z = min.z; }
        else           { pnt.z = max.z; }
        return pnt;
    };
    
    //Check if the point is in the halfspace
    var pntIsInHalfSpace = function(i, pnt) {
        var s = that.planeNormals[i].dot(pnt) - that.planeDistances[i];
        return (s >= 0);
    };

    //Check if the box formed by min/max is fully inside the halfspace
    var isInHalfSpace = function(i) {
        var p = setDirectionIndexPoint(that.directionIndex[i]);
        return pntIsInHalfSpace(i, p);
    };

    //Check if the box formed by min/max is fully outside the halfspace
    var isOutHalfSpace = function(i) {
        var p = setDirectionIndexPoint(that.directionIndex[i] ^ 7);
        return !pntIsInHalfSpace(i, p);
    };
    
    //Check each point of the box to the 6 planes
    var mask = 1;
    if (planeMask < 0) planeMask = 0;

    for (var i=0; i<6; i++, mask<<=1) {
        if ((planeMask & mask) != 0)
            continue;

        if (isOutHalfSpace(i))
            return -1;

        if (isInHalfSpace(i))
            planeMask |= mask;
    }

    return planeMask;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/// NodeNameSpace constructor
x3dom.NodeNameSpace = function (name, document) {
    this.name = name;
    this.doc = document;
    this.baseURL = "";
    this.defMap = {};
    this.parent = null;
    this.childSpaces = [];
};

x3dom.NodeNameSpace.prototype.addNode = function (node, name) {
    this.defMap[name] = node;
    node._nameSpace = this;
};

x3dom.NodeNameSpace.prototype.removeNode = function (name) {
    var node = name ? this.defMap[name] : null;
    if (node) {
        delete this.defMap[name];
        node._nameSpace = null;
    }
};

x3dom.NodeNameSpace.prototype.getNamedNode = function (name) {
    return this.defMap[name];
};

x3dom.NodeNameSpace.prototype.getNamedElement = function (name) {
    var node = this.defMap[name];
    return (node ? node._xmlNode : null);
};

x3dom.NodeNameSpace.prototype.addSpace = function (space) {
    this.childSpaces.push(space);
    space.parent = this;
};

x3dom.NodeNameSpace.prototype.removeSpace = function (space) {
    space.parent = null;
    for (var it=0; it<this.childSpaces.length; it++) {
        if (this.childSpaces[it] == space) {
            this.childSpaces.splice(it, 1);
        }
    }
};

x3dom.NodeNameSpace.prototype.setBaseURL = function (url) {
    var i = url.lastIndexOf ("/");
    this.baseURL = (i >= 0) ? url.substr(0,i+1) : "";

    x3dom.debug.logInfo("setBaseURL: " + this.baseURL);
};

x3dom.NodeNameSpace.prototype.getURL = function (url) {
    if (url === undefined || !url.length) {
        return "";
    }
    else {
        return ((url[0] === '/') || (url.indexOf(":") >= 0)) ? url : (this.baseURL + url);
    }
};

// helper to check an element's attribute
x3dom.hasElementAttribute = function(attrName)
{
    var ok = this.__hasAttribute(attrName);
    if (!ok && attrName) {
        ok = this.__hasAttribute(attrName.toLowerCase());
    }
    return ok;
};

// helper to get an element's attribute
x3dom.getElementAttribute = function(attrName)
{
    var attrib = this.__getAttribute(attrName);
    if (!attrib && attrName) {
        attrib = this.__getAttribute(attrName.toLowerCase());
    }

    if (attrib || !this._x3domNode) {
        return attrib;
    }
    else {
        return this._x3domNode._vf[attrName];
    }
};

// helper to set an element's attribute
x3dom.setElementAttribute = function(attrName, newVal)
{
    //var prevVal = this.getAttribute(attrName);
    this.__setAttribute(attrName, newVal);
    //newVal = this.getAttribute(attrName);

    var x3dNode = this._x3domNode;
    if (x3dNode) {
        x3dNode.updateField(attrName, newVal);
        x3dNode._nameSpace.doc.needRender = true;
    }
};

x3dom.NodeNameSpace.prototype.setupTree = function (domNode) {
    var n = null;

    if (x3dom.isX3DElement(domNode)) {

        // return if it is already initialized
        if (domNode._x3domNode) {
            x3dom.debug.logWarning('Tree is already initialized');
            return null;
        }
        
        // workaround since one cannot find out which handlers are registered
        if ( (domNode.tagName !== undefined) &&
            (!domNode.__addEventListener) && (!domNode.__removeEventListener) )
        {
            // helper to track an element's listeners
            domNode.__addEventListener = domNode.addEventListener;
            domNode.addEventListener = function(type, func, phase) {
                if (!this._x3domNode._listeners[type]) {
                    this._x3domNode._listeners[type] = [];
                }
                this._x3domNode._listeners[type].push(func);

                //x3dom.debug.logInfo('addEventListener for ' + this.tagName + ".on" + type);
                this.__addEventListener(type, func, phase);
            };

            domNode.__removeEventListener = domNode.removeEventListener;
            domNode.removeEventListener = function(type, func, phase) {
                var list = this._x3domNode._listeners[type];
                if (list) {
                    for (var it=0; it<list.length; it++) {
                        if (list[it] == func) {
                            list.splice(it, 1);
                            //x3dom.debug.logInfo('removeEventListener for ' +
                            //                    this.tagName + ".on" + type);
                        }
                    }
                }
                this.__removeEventListener(type, func, phase);
            };
        }

        // TODO (?): dynamic update of USE attribute during runtime
        if (domNode.hasAttribute('USE')) {
            n = this.defMap[domNode.getAttribute('USE')];
            if (!n) {
                var nsName = domNode.getAttribute('USE').split('__');

                if (nsName.length >= 2) {
                    var otherNS = this;
                    while (otherNS) {
                        if (otherNS.name == nsName[0])
                            n = otherNS.defMap[nsName[1]];
                        if (n)
                            otherNS = null;
                        else
                            otherNS = otherNS.parent;
                    }
                    if (!n) {
                        n = null;
                        x3dom.debug.logWarning('Could not USE: ' + domNode.getAttribute('USE'));
                    }
                }
            }
            if (n) {
                domNode._x3domNode = n;
            }
            return n;
        }
        else {
            // check and create ROUTEs
            if (domNode.localName.toLowerCase() === 'route') {
                var route = domNode;
                var fromNode = this.defMap[route.getAttribute('fromNode')];
                var toNode = this.defMap[route.getAttribute('toNode')];
                //x3dom.debug.logInfo("ROUTE: from=" + fromNode._DEF + ", to=" + toNode._DEF);
                if (! (fromNode && toNode)) {
                    x3dom.debug.logWarning("Broken route - can't find all DEFs for " +
                                route.getAttribute('fromNode')+" -> "+ route.getAttribute('toNode'));
                    return null;
                }
                fromNode.setupRoute(route.getAttribute('fromField'), toNode, route.getAttribute('toField'));
                // Store reference to namespace for being able to remove route later on
                route._nodeNameSpace = this;
                return null;
            }

            // find the NodeType for the given dom-node
            var nodeType = x3dom.nodeTypesLC[domNode.localName.toLowerCase()];
            if (nodeType === undefined) {
                x3dom.debug.logWarning("Unrecognised X3D element &lt;" + domNode.localName + "&gt;.");
            }
            else {
                //active workaround for missing DOMAttrModified support
                if ( (x3dom.userAgentFeature.supportsDOMAttrModified === false)
                      && (domNode instanceof Element) ) {
                    if (domNode.setAttribute && !domNode.__setAttribute) {
                        domNode.__setAttribute = domNode.setAttribute;
                        domNode.setAttribute = x3dom.setElementAttribute;
                    }

                    if (domNode.getAttribute && !domNode.__getAttribute) {
                        domNode.__getAttribute = domNode.getAttribute;
                        domNode.getAttribute = x3dom.getElementAttribute;
                    }

                    if (domNode.hasAttribute && !domNode.__hasAttribute) {
                        domNode.__hasAttribute = domNode.hasAttribute;
                        domNode.hasAttribute = x3dom.hasElementAttribute;
                    }
                }

                // create x3domNode
                var ctx = {
                    doc: this.doc,
                    xmlNode: domNode,
                    nameSpace: this
                };
                n = new nodeType(ctx);

                // find and store/link _DEF name
                if (domNode.hasAttribute('DEF')) {
                    n._DEF = domNode.getAttribute('DEF');
                    this.defMap[n._DEF] = n;
                }
                else {
                    if (domNode.hasAttribute('id')) {
                        n._DEF = domNode.getAttribute('id');
                        this.defMap[n._DEF] = n;
                    }
                }
                
                // add experimental highlighting functionality
                if (domNode.highlight === undefined) 
                {
                    domNode.highlight = function(enable, colorStr) {
                        var color = x3dom.fields.SFColor.parse(colorStr);
                        this._x3domNode.highlight(enable, color);
                        this._x3domNode._nameSpace.doc.needRender = true;
                    };
                }

                // link both DOM-Node and Scene-graph-Node
                n._xmlNode = domNode;
                domNode._x3domNode = n;

                // call children
                var that = this;
                Array.forEach ( domNode.childNodes, function (childDomNode) {
                    var c = that.setupTree(childDomNode);
                    if (c) {
                        n.addChild(c, childDomNode.getAttribute("containerField"));
                    }
                } );

                n.nodeChanged();
                return n;
            }
        }
    }
    else if (domNode.localName) {
        // be nice to users who use nodes not (yet) known to the system
        x3dom.debug.logWarning("Unrecognised X3D element &lt;" + domNode.localName + "&gt;.");
        n = null;
    }

    return n;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

// ### X3DNode ###
x3dom.registerNodeType(
    "X3DNode",
    "Core",
    defineClass(null, function (ctx) {
        // reference to DOM element
        this._xmlNode = null;

        // holds a link to the node name
        this._DEF = null;

        // links the nameSpace
        this._nameSpace = (ctx && ctx.nameSpace) ? ctx.nameSpace : null;

        // holds all value fields (e.g. SFFloat, MFVec3f, ...)
        this._vf = {};
        this._vfFieldTypes = {};
        
        // holds all child fields ( SFNode and MFNode )
        this._cf = {};
        this._cfFieldTypes = {};

        this._fieldWatchers = {};
        this._routes = {};

        this._listeners = {};

        this._parentNodes = [];

        // FIXME; should be removed and handled by _cf methods
        this._childNodes = [];

        this.addField_SFNode('metadata', x3dom.nodeTypes.X3DMetadataObject);
    },
    {
        type: function () {
            return this.constructor;
        },
        
        typeName: function () {
            return this.constructor._typeName;
        },

        addChild: function (node, containerFieldName) {
            if (node) {
                var field = null;
                if (containerFieldName) {
                    field = this._cf[containerFieldName];
                }
                else {
                    for (var fieldName in this._cf) {
                        if (this._cf.hasOwnProperty(fieldName)) {
                            var testField = this._cf[fieldName];
                            if (x3dom.isa(node,testField.type)) {
                                field = testField;
                                break;
                            }
                        }
                    }
                }
                if (field && field.addLink(node)) {
                    node._parentNodes.push(this);
                    this._childNodes.push(node);
                    node.parentAdded(this);
                    return true;
                }
            }
            return false;
        },

        removeChild: function (node) {
            if (node) {
                for (var fieldName in this._cf) {
                    if (this._cf.hasOwnProperty(fieldName)) {
                        var field = this._cf[fieldName];
                        if (field.rmLink(node)) {
                            for (var i = node._parentNodes.length - 1; i >= 0; i--) {
                                if (node._parentNodes[i] === this) {
                                    node._parentNodes.splice(i, 1);
                                    node.parentRemoved(this);
                                }
                            }
                            for (var j = this._childNodes.length - 1; j >= 0; j--) {
                                if (this._childNodes[j] === node) {
                                    this._childNodes.splice(j, 1);
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        },

        parentAdded: function(parent) {
            // to be overwritten by concrete classes
        },

        parentRemoved: function(parent) {
            // attention: overwritten by concrete classes
            for (var i=0, n=this._childNodes.length; i<n; i++) {
                if (this._childNodes[i]) {
                    this._childNodes[i].parentRemoved(this);
                }
            }
        },

        getCurrentTransform: function () {
            if (this._parentNodes.length >= 1) {
                return this.transformMatrix(this._parentNodes[0].getCurrentTransform());
            }
            else {
                return x3dom.fields.SFMatrix4f.identity();
            }
        },

        transformMatrix: function (transform) {
            return transform;
        },

        getVolume: function () {
            //x3dom.debug.logWarning("Called getVolume for unbounded node!");
            return null;
        },

        invalidateVolume: function() {
            // overwritten
        },

        invalidateCache: function() {
            // overwritten
        },

        volumeValid: function() {
            return false;
        },

        // Collects all objects to be drawn
        collectDrawableObjects: function (transform, drawableCollection, singlePath, invalidateCache, planeMask) {
            // explicitly do nothing on collect traversal for (most) nodes
        },
        
        highlight: function(enable, color)
        {
            if (this._vf.hasOwnProperty("diffuseColor")) 
            {
                if (enable) {
                    if (this._actDiffuseColor === undefined) {
                        this._actDiffuseColor = new x3dom.fields.SFColor();
                        this._highlightOn = false;
                    }
                    
                    if (!this._highlightOn) {
                        this._actDiffuseColor.setValues(this._vf.diffuseColor);
                        this._highlightOn = true;
                    }
                    this._vf.diffuseColor.setValues(color);
                }
                else {
                    if (this._actDiffuseColor !== undefined) {
                        this._vf.diffuseColor.setValues(this._actDiffuseColor);
                        this._highlightOn = false;
                        // new/delete every frame can be very slow
                        // but prevent from copying if called not only on change
                        delete this._actDiffuseColor;
                    }
                }
            }

            for (var i=0, n=this._childNodes.length; i<n; i++)
            {
                if (this._childNodes[i])
                    this._childNodes[i].highlight(enable, color);
            }
        },

        findX3DDoc: function () {
            return this._nameSpace.doc;
        },

        doIntersect: function(line) {
            var isect = false;
            for (var i=0; i<this._childNodes.length; i++) {
                if (this._childNodes[i]) {
                    isect = this._childNodes[i].doIntersect(line) || isect;
                }
            }
            return isect;
        },

        postMessage: function (field, msg) {
            // TODO: timestamps and stuff
            this._vf[field] = msg;  // FIXME; _cf!!!
            var listeners = this._fieldWatchers[field];
            var thisp = this;
            if (listeners) {
                Array.forEach(listeners, function (l) { l.call(thisp, msg); });
            }
        },

        // method for handling field updates
        updateField: function (field, msg) {
            var f = this._vf[field];

            if (f === undefined) {
                var pre = "set_";
                if (field.indexOf(pre) == 0) {
                    var fieldName = field.substr(pre.length, field.length - 1);
                    if (this._vf[fieldName] !== undefined) {
                        field = fieldName;
                        f = this._vf[field];
                    }
                }
                if (f === undefined) {
                    f = {};
                    this._vf[field] = f;
                }
            }

            if (f !== null) {
                try {
                    this._vf[field].setValueByStr(msg);
                }
                catch (exc1) {
                    try {
                        switch ((typeof(this._vf[field])).toString()) {
                            case "number":
                                if (typeof(msg) == "number")
                                    this._vf[field] = msg;
                                else
                                    this._vf[field] = +msg;
                                break;
                            case "boolean":
                                if (typeof(msg) == "boolean")
                                    this._vf[field] = msg;
                                else
                                    this._vf[field] = (msg.toLowerCase() == "true");
                                break;
                            case "string":
                                this._vf[field] = msg;
                                break;
                        }
                    }
                    catch (exc2) {
                        x3dom.debug.logError("updateField: setValueByStr() NYI for " + typeof(f));
                    }
                }

                // TODO: eval fieldChanged for all nodes!
                this.fieldChanged(field);
            }
        },

        setupRoute: function (fromField, toNode, toField) {
            var pos;
            var fieldName;
            var pre = "set_", post = "_changed";

            // build correct fromField
            if (!this._vf[fromField]) {
                pos = fromField.indexOf(pre);
                if (pos === 0) {
                    fieldName = fromField.substr(pre.length, fromField.length - 1);
                    if (this._vf[fieldName]) {
                        fromField = fieldName;
                    }
                } else {
                    pos = fromField.indexOf(post);
                    if (pos > 0) {
                        fieldName = fromField.substr(0, fromField.length - post.length);
                        if (this._vf[fieldName]) {
                            fromField = fieldName;
                        }
                    }
                }
            }

            // build correct toField
            if (!toNode._vf[toField]) {
                pos = toField.indexOf(pre);
                if (pos === 0) {
                    fieldName = toField.substr(pre.length, toField.length - 1);
                    if (toNode._vf[fieldName]) {
                        toField = fieldName;
                    }
                }
                else {
                    pos = toField.indexOf(post);
                    if (pos > 0) {
                        fieldName = toField.substr(0, toField.length - post.length);
                        if (toNode._vf[fieldName]) {
                            toField = fieldName;
                        }
                    }
                }
            }

            var where = this._DEF + "&" + fromField + "&" + toNode._DEF + "&" + toField;

            if (!this._routes[where]) {
                if (!this._fieldWatchers[fromField]) {
                    this._fieldWatchers[fromField] = [];
                }
                this._fieldWatchers[fromField].push(
                    function (msg) {
                        toNode.postMessage(toField, msg);
                    }
                );

                if (!toNode._fieldWatchers[toField]) {
                    toNode._fieldWatchers[toField] = [];
                }
                toNode._fieldWatchers[toField].push(
                    // FIXME: THIS DOESN'T WORK FOR NODE (_cf) FIELDS
                    function (msg) {
                        toNode._vf[toField] = msg;
                        toNode.fieldChanged(toField);
                    }
                );

                // store this route to be able to delete it
                this._routes[where] = {
                    from: this._fieldWatchers[fromField].length - 1,
                    to: toNode._fieldWatchers[toField].length - 1
                };
            }
        },

        removeRoute: function (fromField, toNode, toField) {
            var pos;
            var fieldName;
            var pre = "set_", post = "_changed";

            // again, build correct fromField
            if (!this._vf[fromField]) {
                pos = fromField.indexOf(pre);
                if (pos === 0) {
                    fieldName = fromField.substr(pre.length, fromField.length - 1);
                    if (this._vf[fieldName]) {
                        fromField = fieldName;
                    }
                } else {
                    pos = fromField.indexOf(post);
                    if (pos > 0) {
                        fieldName = fromField.substr(0, fromField.length - post.length);
                        if (this._vf[fieldName]) {
                            fromField = fieldName;
                        }
                    }
                }
            }

            // again, build correct toField
            if (!toNode._vf[toField]) {
                pos = toField.indexOf(pre);
                if (pos === 0) {
                    fieldName = toField.substr(pre.length, toField.length - 1);
                    if (toNode._vf[fieldName]) {
                        toField = fieldName;
                    }
                }
                else {
                    pos = toField.indexOf(post);
                    if (pos > 0) {
                        fieldName = toField.substr(0, toField.length - post.length);
                        if (toNode._vf[fieldName]) {
                            toField = fieldName;
                        }
                    }
                }
            }

            // finally, delete route
            var where = this._DEF + "&" + fromField + "&" + toNode._DEF + "&" + toField;

            if (this._routes[where]) {
                this._fieldWatchers[fromField].splice(this._routes[where].from, 1);
                toNode._fieldWatchers[toField].splice(this._routes[where].to, 1);

                delete this._routes[where];
            }
        },

        fieldChanged: function (fieldName) {
            // to be overwritten by concrete classes
        },

        nodeChanged: function () {
            // to be overwritten by concrete classes
        },
        
		callEvtHandler: function(eventType, event) {
			var node = this;

            if (!node._xmlNode) {
                return event.cancelBubble;
            }

			try {
				var attrib = node._xmlNode[eventType];
				event.target = node._xmlNode;
				
				if (typeof(attrib) === "function") {
					attrib.call(node._xmlNode, event);
				}
				else {
					var funcStr = node._xmlNode.getAttribute(eventType);
					var func = new Function('event', funcStr);
					func.call(node._xmlNode, event);
				}
				
				var list = node._listeners[event.type];
				if (list) {
					for (var it=0; it<list.length; it++) {
						list[it].call(node._xmlNode, event);
					}
				}
			}
			catch(ex) {
				x3dom.debug.logException(ex);
			}
			
			return event.cancelBubble;
		},
        
        initSetter: function (xmlNode, name) {
            if (xmlNode.__defineSetter__ && xmlNode.__defineGetter__) {
                xmlNode.__defineSetter__(name, function(value) {
                    xmlNode.setAttribute(name, value);
                });
                xmlNode.__defineGetter__(name, function() {
                    return xmlNode.getAttribute(name);
                });
            }
            else {
                // IE has no __define[G|S]etter__ !!!
                Object.defineProperty(xmlNode, name, {
                    set: function(value) {
                        xmlNode.setAttribute(name, value);
                    },
                    get: function() {
                        return xmlNode.getAttribute(name);
                    },
                    configurable: true,
                    enumerable: true
                });
            }

            if (this._vf[name] &&
                !xmlNode.attributes[name] && !xmlNode.attributes[name.toLowerCase()]) {
                var str = "";
                try {
                    if (this._vf[name].toGL)
                        str = this._vf[name].toGL().toString();
                    else
                        str = this._vf[name].toString();
                }
                catch (e) {
                    str = this._vf[name].toString();
                }
                if (!str) {
                    str = "";
                }
                xmlNode.setAttribute(name, str);
            }
        },

        // single fields
        addField_SFInt32: function (ctx, name, n) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                parseInt(ctx.xmlNode.getAttribute(name),10) : n;
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFInt32";
        },
        
        addField_SFFloat: function (ctx, name, n) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                +ctx.xmlNode.getAttribute(name) : n;
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFFloat";
        },
        
        addField_SFDouble: function (ctx, name, n) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                +ctx.xmlNode.getAttribute(name) : n;
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFDouble";
        },
        
        addField_SFTime: function (ctx, name, n) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                +ctx.xmlNode.getAttribute(name) : n;
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFTime";
        },
        
        addField_SFBool: function (ctx, name, n) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                ctx.xmlNode.getAttribute(name).toLowerCase() === "true" : n;
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFBool";
        },
        
        addField_SFString: function (ctx, name, n) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                ctx.xmlNode.getAttribute(name) : n;
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFString";
        },
        
        addField_SFColor: function (ctx, name, r, g, b) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.SFColor.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.SFColor(r, g, b);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFColor";
        },
        
        addField_SFColorRGBA: function (ctx, name, r, g, b, a) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.SFColorRGBA.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.SFColorRGBA(r, g, b, a);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFColorRGBA";
        },
        
        addField_SFVec2f: function (ctx, name, x, y) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.SFVec2f.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.SFVec2f(x, y);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFVec2f";
        },
        
        addField_SFVec3f: function (ctx, name, x, y, z) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.SFVec3f.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.SFVec3f(x, y, z);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFVec3f";
        },
        
        addField_SFVec3d: function(ctx, name, x, y, z) {
            this.addField_SFVec3f(ctx, name, x, y, z);
            this._vfFieldTypes[name] = "SFVec3d";
        },
        
        addField_SFRotation: function (ctx, name, x, y, z, a) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.Quaternion.parseAxisAngle(ctx.xmlNode.getAttribute(name)) :
                x3dom.fields.Quaternion.axisAngle(new x3dom.fields.SFVec3f(x, y, z), a);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFRotation";
        },
        
        addField_SFMatrix4f: function (ctx, name, _00, _01, _02, _03,
                                                  _10, _11, _12, _13,
                                                  _20, _21, _22, _23,
                                                  _30, _31, _32, _33) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.SFMatrix4f.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.SFMatrix4f(_00, _01, _02, _03,
                                            _10, _11, _12, _13,
                                            _20, _21, _22, _23,
                                            _30, _31, _32, _33);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFMatrix4f";
        },
        
        addField_SFImage: function (ctx, name, def) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.SFImage.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.SFImage(def);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "SFImage";
        },

        // multi fields
        addField_MFString: function (ctx, name, def) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.MFString.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.MFString(def);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "MFString";
        },

        addField_MFBoolean: function (ctx, name, def) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.MFBoolean.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.MFBoolean(def);

            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "MFBoolean";
        },

        addField_MFInt32: function (ctx, name, def) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.MFInt32.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.MFInt32(def);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "MFInt32";
        },
        
        addField_MFFloat: function (ctx, name, def) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.MFFloat.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.MFFloat(def);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "MFFloat";
        },
        
        addField_MFDouble: function (ctx, name, def) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.MFFloat.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.MFFloat(def);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "MFDouble";
        },
        
        addField_MFColor: function (ctx, name, def) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.MFColor.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.MFColor(def);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "MFColor";
        },
        
        addField_MFColorRGBA: function (ctx, name, def) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.MFColorRGBA.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.MFColorRGBA(def);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "MFColorRGBA";
        },
        
        addField_MFVec2f: function (ctx, name, def) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.MFVec2f.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.MFVec2f(def);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "MFVec2f";
        },
        
        addField_MFVec3f: function (ctx, name, def) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.MFVec3f.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.MFVec3f(def);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "MFVec3f";
        },
        
        addField_MFVec3d: function (ctx, name, def) {
            this.addField_MFVec3f(ctx, name, def);
            this._vfFieldTypes[name] = "MFVec3d";
        },
        
        addField_MFRotation: function (ctx, name, def) {
            this._vf[name] = ctx && ctx.xmlNode && ctx.xmlNode.hasAttribute(name) ?
                x3dom.fields.MFRotation.parse(ctx.xmlNode.getAttribute(name)) :
                new x3dom.fields.MFRotation(def);
                
            if (ctx && ctx.xmlNode) { this.initSetter(ctx.xmlNode, name); }
            this._vfFieldTypes[name] = "MFRotation";
        },
        
        // child node fields
        addField_SFNode: function (name, type) {
            this._cf[name] = new x3dom.fields.SFNode(type);
            this._cfFieldTypes[name] = "SFNode";
        },
        addField_MFNode: function (name, type) {
            this._cf[name] = new x3dom.fields.MFNode(type);
            this._cfFieldTypes[name] = "MFNode";
        }
    }
));

/* ### X3DMetadataObject ### */
x3dom.registerNodeType(
    "X3DMetadataObject",
    "Core",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.X3DMetadataObject.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'name', "");
            this.addField_SFString(ctx, 'reference', "");
        }
    )
);

/* ### MetadataBoolean ### */
x3dom.registerNodeType(
    "MetadataBoolean",
    "Core",
    defineClass(x3dom.nodeTypes.X3DMetadataObject,
        function (ctx) {
            x3dom.nodeTypes.MetadataBoolean.superClass.call(this, ctx);

            // TODO: implement parsing of MFBoolean in fields.js!
            this.addField_MFBoolean(ctx, 'value', []);
        }
    )
);

/* ### MetadataDouble ### */
x3dom.registerNodeType(
    "MetadataDouble",
    "Core",
    defineClass(x3dom.nodeTypes.X3DMetadataObject,
        function (ctx) {
            x3dom.nodeTypes.MetadataDouble.superClass.call(this, ctx);

            this.addField_MFDouble(ctx, 'value', []);
        }
    )
);

/* ### MetadataFloat ### */
x3dom.registerNodeType(
    "MetadataFloat",
    "Core",
    defineClass(x3dom.nodeTypes.X3DMetadataObject,
        function (ctx) {
            x3dom.nodeTypes.MetadataFloat.superClass.call(this, ctx);

            this.addField_MFFloat(ctx, 'value', []);
        }
    )
);

/* ### MetadataInteger ### */
x3dom.registerNodeType(
    "MetadataInteger",
    "Core",
    defineClass(x3dom.nodeTypes.X3DMetadataObject,
        function (ctx) {
            x3dom.nodeTypes.MetadataInteger.superClass.call(this, ctx);

            this.addField_MFInt32(ctx, 'value', []);
        }
    )
);

/* ### MetadataSet ### */
x3dom.registerNodeType(
    "MetadataSet",
    "Core",
    defineClass(x3dom.nodeTypes.X3DMetadataObject,
        function (ctx) {
            x3dom.nodeTypes.MetadataSet.superClass.call(this, ctx);

            this.addField_MFNode('value', x3dom.nodeTypes.X3DMetadataObject);
        }
    )
);

/* ### MetadataString ### */
x3dom.registerNodeType(
    "MetadataString",
    "Core",
    defineClass(x3dom.nodeTypes.X3DMetadataObject,
        function (ctx) {
            x3dom.nodeTypes.MetadataString.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'value', []);
        }
    )
);

/* ### Field ### */
x3dom.registerNodeType(
    "Field",
    "Core",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.Field.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'name', "");
            this.addField_SFString(ctx, 'type', "");
            this.addField_SFString(ctx, 'value', "");
        },
        {
            fieldChanged: function(fieldName) {
                var that = this;
                if (fieldName === 'value') {
                    Array.forEach(this._parentNodes, function (node) {
                        node.fieldChanged(that._vf.name);
                    });
                }
            }
        }
    )
);


/* ### X3DChildNode ### */
x3dom.registerNodeType(
    "X3DChildNode",
    "Core",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.X3DChildNode.superClass.call(this, ctx);
        }
    )
);

/* ### X3DBindableNode ### */
x3dom.registerNodeType(
    "X3DBindableNode",
    "Core",
    defineClass(x3dom.nodeTypes.X3DChildNode,
        function (ctx) {
          x3dom.nodeTypes.X3DBindableNode.superClass.call(this, ctx);

          this.addField_SFBool(ctx, 'bind', false);
          this.addField_SFString(ctx, 'description', "");
          this.addField_SFBool(ctx, 'isActive', false);

          this._autoGen = (ctx && ctx.autoGen ? true : false);
          if (this._autoGen)
              this._vf.description = "default" + this.constructor.superClass._typeName;
          
          // Bindable stack to register node later on 
          this._stack = null;
        },
        {
            bind: function (value) {
                if (this._stack) {
                    if (value) {
                        this._stack.push (this);
                    }
                    else {
                        this._stack.pop  (this);
                    }
                }
                else {
                    x3dom.debug.logError ('No BindStack in ' + this.typeName() + 'Bindable');
                }
            },

            activate: function (prev) {
                this.postMessage('isActive', true);
                x3dom.debug.logInfo('activate ' + this.typeName() + 'Bindable ' + 
                                    this._DEF + '/' + this._vf.description);
            },

            deactivate: function (prev) {
                this.postMessage('isActive', false);
                x3dom.debug.logInfo('deactivate ' + this.typeName() + 'Bindable ' + 
                                    this._DEF + '/' + this._vf.description);
            },

            fieldChanged: function(fieldName) {
                if (fieldName.indexOf("bind") >= 0) {
                    this.bind(this._vf.bind);
                }
            },

            nodeChanged: function() {
                this._stack = this._nameSpace.doc._bindableBag.addBindable(this);
            }
        }
    )
);


/* ### X3DInfoNode ### */
x3dom.registerNodeType(
    "X3DInfoNode",
    "Core",
    defineClass(x3dom.nodeTypes.X3DChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DInfoNode.superClass.call(this, ctx);
        }
    )
);

/* ### WorldInfo ### */
x3dom.registerNodeType(
    "WorldInfo",
    "Core",
    defineClass(x3dom.nodeTypes.X3DInfoNode,
        function (ctx) {
            x3dom.nodeTypes.WorldInfo.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'info', []);
            this.addField_SFString(ctx, 'title', "");

            x3dom.debug.logInfo(this._vf.info);
            x3dom.debug.logInfo(this._vf.title);
        }
    )
);

/* ### X3DBoundedNode ### */
x3dom.registerNodeType(
    "X3DBoundedNode",
    "Core",
    defineClass(x3dom.nodeTypes.X3DChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DBoundedNode.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'render', true);
            this.addField_SFVec3f(ctx, 'bboxCenter', 0, 0, 0);
            this.addField_SFVec3f(ctx, 'bboxSize', -1, -1, -1);

            this._graph = {
                boundedNode:  this,    // backref to node object
                localMatrix:  x3dom.fields.SFMatrix4f.identity(),   // usually identity
                globalMatrix: null,    // new x3dom.fields.SFMatrix4f();
                volume:       new x3dom.fields.BoxVolume(),     // local bbox
                worldVolume:  new x3dom.fields.BoxVolume(),     // global bbox
                center:       new x3dom.fields.SFVec3f(0,0,0),  // center in eye coords
                coverage:     -1       // currently approx. number of pixels on screen
            };
        },
        {
            fieldChanged: function (fieldName) {
                // TODO; wait for sync traversal to invalidate en block
                if (this._vf.hasOwnProperty(fieldName)) {
                    this.invalidateVolume();
                    //this.invalidateCache();
                }
            },

            nodeChanged: function () {
                // TODO; wait for sync traversal to invalidate en block
                this.invalidateVolume();
                //this.invalidateCache();
            },

            parentAdded: function(parent) {
                // some default behavior if not overwitten
                this.invalidateVolume();
                //this.invalidateCache();
            },

            getVolume: function()
            {
                var vol = this._graph.volume;

                if (!this.volumeValid() && this._vf.render)
                {
                    for (var i=0, n=this._childNodes.length; i<n; i++)
                    {
                        var child = this._childNodes[i];
                        // render could be undefined, but undefined != true
                        if (!child || child._vf.render !== true)
                            continue;

                        var childVol = child.getVolume();

                        if (childVol && childVol.isValid())
                            vol.extendBounds(childVol.min, childVol.max);
                    }
                }

                return vol;
            },

            invalidateVolume: function()
            {
                var graph = this._graph;

                graph.volume.invalidate();

                // also clear cache
                graph.worldVolume.invalidate();
                graph.globalMatrix = null;

                // set parent volumes invalid, too
                for (var i=0, n=this._parentNodes.length; i<n; i++) {
                    var node = this._parentNodes[i];
                    if (node && node.volumeValid())
                        node.invalidateVolume();
                }
            },

            invalidateCache: function()
            {
                var graph = this._graph;

                //if (graph.volume.isValid() &&
                //    graph.globalMatrix == null && !graph.worldVolume.isValid())
                //    return;     // stop here, we're already done

                graph.worldVolume.invalidate();
                graph.globalMatrix = null;

                // clear children's cache, too
                //for (var i=0, n=this._childNodes.length; i<n; i++) {
                //    var node = this._childNodes[i];
                //    if (node)
                //        node.invalidateCache();
                //}
            },

            cacheInvalid: function()
            {
                return ( this._graph.globalMatrix == null ||
                        !this._graph.worldVolume.isValid() );
            },

            volumeValid: function()
            {
                return this._graph.volume.isValid();
            },

            graphState: function()
            {
                return this._graph;
            },

            forceUpdateCoverage: function()
            {
                return false;
            }
        }
    )
);

// ### X3DSensorNode ###
x3dom.registerNodeType(
    "X3DSensorNode",
    "Core",
    defineClass(x3dom.nodeTypes.X3DChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DSensorNode.superClass.call(this, ctx);
        }
    )
);

// deprecated, will be removed in 1.5
// ### Param ###
x3dom.registerNodeType(
    "Param",
    "Core",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.Param.superClass.call(this, ctx);
            
            x3dom.debug.logWarning('DEPRECATED: Param element needs to be child of X3D element '
                      + '[<a href="http://x3dom.org/docs/latest/configuration.html">DOCS</a>]');
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

// ### X3DGroupingNode ###
x3dom.registerNodeType(
    "X3DGroupingNode",
    "Grouping",
    defineClass(x3dom.nodeTypes.X3DBoundedNode,
        function (ctx) {
            x3dom.nodeTypes.X3DGroupingNode.superClass.call(this, ctx);

            this.addField_MFNode('children', x3dom.nodeTypes.X3DChildNode);
            // FIXME; add addChild and removeChild slots ?
        },
        {
            collectDrawableObjects: function (transform, drawableCollection, singlePath, invalidateCache, planeMask)
            {
                // check if multi parent sub-graph, don't cache in that case
                if (singlePath && (this._parentNodes.length > 1))
                    singlePath = false;

                // an invalid world matrix or volume needs to be invalidated down the hierarchy
                if (singlePath && (invalidateCache = invalidateCache || this.cacheInvalid()))
                    this.invalidateCache();

                // check if sub-graph can be culled away or render flag was set to false
                planeMask = drawableCollection.cull(transform, this.graphState(), singlePath, planeMask);
                if (planeMask <= 0) {
                    return;
                }

                var cnode, childTransform;

                if (singlePath) {
                    // rebuild cache on change and reuse world transform
                    if (!this._graph.globalMatrix) {
                        this._graph.globalMatrix = this.transformMatrix(transform);
                    }
                    childTransform = this._graph.globalMatrix;
                }
                else {
                    childTransform = this.transformMatrix(transform);
                }

                for (var i=0, n=this._childNodes.length; i<n; i++) {
                    if ( (cnode = this._childNodes[i]) ) {
                        cnode.collectDrawableObjects(childTransform, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                }
            }
        }
    )
);

// ### Switch ###
x3dom.registerNodeType(
    "Switch",
    "Grouping",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.Switch.superClass.call(this, ctx);

            this.addField_SFInt32(ctx, 'whichChoice', -1);
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "whichChoice") {
                    this.invalidateVolume();
                    //this.invalidateCache();
                }
            },

            getVolume: function()
            {
                var vol = this._graph.volume;

                if (!this.volumeValid() && this._vf.render)
                {
                    if (this._vf.whichChoice >= 0 &&
                        this._vf.whichChoice < this._childNodes.length)
                    {
                        var child = this._childNodes[this._vf.whichChoice];

                        var childVol = (child && child._vf.render === true) ? child.getVolume() : null;

                        if (childVol && childVol.isValid())
                            vol.extendBounds(childVol.min, childVol.max);
                    }
                }

                return vol;
            },

            collectDrawableObjects: function (transform, drawableCollection, singlePath, invalidateCache, planeMask)
            {
                if (singlePath && (this._parentNodes.length > 1))
                    singlePath = false;

                if (singlePath && (invalidateCache = invalidateCache || this.cacheInvalid()))
                    this.invalidateCache();

                if (this._vf.whichChoice < 0 || this._vf.whichChoice >= this._childNodes.length ||
                    (planeMask = drawableCollection.cull(transform, this.graphState(), singlePath, planeMask)) <= 0) {
                    return;
                }

                var cnode, childTransform;

                if (singlePath) {
                    if (!this._graph.globalMatrix) {
                        this._graph.globalMatrix = this.transformMatrix(transform);
                    }
                    childTransform = this._graph.globalMatrix;
                }
                else {
                    childTransform = this.transformMatrix(transform);
                }

                if ( (cnode = this._childNodes[this._vf.whichChoice]) ) {
                    cnode.collectDrawableObjects(childTransform, drawableCollection, singlePath, invalidateCache, planeMask);
                }
            },

            doIntersect: function(line)
            {
                if (this._vf.whichChoice < 0 ||
                    this._vf.whichChoice >= this._childNodes.length) {
                    return false;
                }

                var child = this._childNodes[this._vf.whichChoice];
                if (child) {
                    return child.doIntersect(line);
                }

                return false;
            }
        }
    )
);

// ### X3DTransformNode ###
x3dom.registerNodeType(
    "X3DTransformNode",
    "Grouping",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.X3DTransformNode.superClass.call(this, ctx);

            if (ctx)
                ctx.doc._nodeBag.trans.push(this);
            else
                x3dom.debug.logWarning("X3DTransformNode: No runtime context found!");

            // holds the current matrix (local space transform)
            this._trafo = null;

            // workaround, only check on init if getStyle is necessary, since expensive
            this._needCssStyleUpdates = true;
        },
        {
            tick: function (t)
            {
                if (this._xmlNode && (this._xmlNode['ontransform'] ||
                         this._xmlNode.hasAttribute('ontransform') ||
                         this._listeners['transform'])) {
                    var transMatrix = this.getCurrentTransform();

                    var event = {
                        target: this._xmlNode,
                        type: 'transform',
                        worldX: transMatrix._03,
                        worldY: transMatrix._13,
                        worldZ: transMatrix._23,
                        cancelBubble: false,
                        stopPropagation: function () {
                            this.cancelBubble = true;
                        }
                    };

                    this.callEvtHandler("ontransform", event);
                }

                // temporary per frame update method for CSS-Transform
                if (this._needCssStyleUpdates) {
                    var trans = x3dom.getStyle(this._xmlNode, "-webkit-transform") ||
                                x3dom.getStyle(this._xmlNode, "-moz-transform");

                    if (trans && (trans != 'none')) {
                        this._trafo.setValueByStr(trans);

                        this.invalidateVolume();
                        //this.invalidateCache();

                        return true;
                    }
                    this._needCssStyleUpdates = false;    // no special CSS set
                }

                return false;
            },

            transformMatrix: function(transform) {
                return transform.mult(this._trafo);
            },

            getVolume: function()
            {
                var vol = this._graph.volume;

                if (!this.volumeValid() && this._vf.render)
                {
                    this._graph.localMatrix = this._trafo;

                    for (var i=0, n=this._childNodes.length; i<n; i++)
                    {
                        var child = this._childNodes[i];
                        if (!child || child._vf.render !== true)
                            continue;

                        var childVol = child.getVolume();

                        if (childVol && childVol.isValid())
                            vol.extendBounds(childVol.min, childVol.max);
                    }

                    if (vol.isValid())
                        vol.transform(this._trafo);
                }

                return vol;
            },

            doIntersect: function(line)
            {
                var isect = false;
                var mat = this._trafo.inverse();

                var tmpPos = new x3dom.fields.SFVec3f(line.pos.x, line.pos.y, line.pos.z);
                var tmpDir = new x3dom.fields.SFVec3f(line.dir.x, line.dir.y, line.dir.z);

                line.pos = mat.multMatrixPnt(line.pos);
                line.dir = mat.multMatrixVec(line.dir);

                if (line.hitObject) {
                    line.dist *= line.dir.length();
                }

                // check for _nearest_ hit object and don't stop on first!
                for (var i=0; i<this._childNodes.length; i++)
                {
                    if (this._childNodes[i]) {
                        isect = this._childNodes[i].doIntersect(line) || isect;
                    }
                }

                line.pos.setValues(tmpPos);
                line.dir.setValues(tmpDir);

                if (isect) {
                    line.hitPoint = this._trafo.multMatrixPnt(line.hitPoint);
                    line.dist *= line.dir.length();
                }

                return isect;
            },

            parentRemoved: function(parent)
            {
                var i, n;
                
                if (this._parentNodes.length == 0) {
                    var doc = this.findX3DDoc();

                    for (i=0, n=doc._nodeBag.trans.length; i<n; i++) {
                        if (doc._nodeBag.trans[i] === this) {
                            doc._nodeBag.trans.splice(i, 1);
                        }
                    }
                }

                for (i=0, n=this._childNodes.length; i<n; i++) {
                    if (this._childNodes[i]) {
                        this._childNodes[i].parentRemoved(this);
                    }
                }
            }
        }
    )
);

// ### Transform ###
x3dom.registerNodeType(
    "Transform",
    "Grouping",
    defineClass(x3dom.nodeTypes.X3DTransformNode,
        function (ctx) {
            x3dom.nodeTypes.Transform.superClass.call(this, ctx);

            this.addField_SFVec3f(ctx, 'center', 0, 0, 0);
            this.addField_SFVec3f(ctx, 'translation', 0, 0, 0);
            this.addField_SFRotation(ctx, 'rotation', 0, 0, 1, 0);
            this.addField_SFVec3f(ctx, 'scale', 1, 1, 1);
            this.addField_SFRotation(ctx, 'scaleOrientation', 0, 0, 1, 0);

            // P' = T * C * R * SR * S * -SR * -C * P
            this._trafo = x3dom.fields.SFMatrix4f.translation(
                    this._vf.translation.add(this._vf.center)).
                mult(this._vf.rotation.toMatrix()).
                mult(this._vf.scaleOrientation.toMatrix()).
                mult(x3dom.fields.SFMatrix4f.scale(this._vf.scale)).
                mult(this._vf.scaleOrientation.toMatrix().inverse()).
                mult(x3dom.fields.SFMatrix4f.translation(this._vf.center.negate()));
        },
        {
            fieldChanged: function (fieldName)
            {
                if (fieldName == "center" || fieldName == "translation" ||
                    fieldName == "rotation" || fieldName == "scale" ||
                    fieldName == "scaleOrientation")
                {
                    // P' = T * C * R * SR * S * -SR * -C * P
                    this._trafo = x3dom.fields.SFMatrix4f.translation(
                                 this._vf.translation.add(this._vf.center)).
                            mult(this._vf.rotation.toMatrix()).
                            mult(this._vf.scaleOrientation.toMatrix()).
                            mult(x3dom.fields.SFMatrix4f.scale(this._vf.scale)).
                            mult(this._vf.scaleOrientation.toMatrix().inverse()).
                            mult(x3dom.fields.SFMatrix4f.translation(this._vf.center.negate()));

                    this.invalidateVolume();
                    //this.invalidateCache();
                }
                else if (fieldName == "render") {
                    this.invalidateVolume();
                    //this.invalidateCache();
                }
            }
        }
    )
);

// ### MatrixTransform ###
x3dom.registerNodeType(
    "MatrixTransform",
    "Grouping",
    defineClass(x3dom.nodeTypes.X3DTransformNode,
        function (ctx) {
            x3dom.nodeTypes.MatrixTransform.superClass.call(this, ctx);

            this.addField_SFMatrix4f(ctx, 'matrix', 1, 0, 0, 0,
                                                    0, 1, 0, 0,
                                                    0, 0, 1, 0,
                                                    0, 0, 0, 1);
            this._trafo = this._vf.matrix.transpose();
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "matrix") {
                    this._trafo = this._vf.matrix.transpose();

                    this.invalidateVolume();
                    //this.invalidateCache();
                }
                else if (fieldName == "render") {
                    this.invalidateVolume();
                    //this.invalidateCache();
                }
            }
        }
    )
);

// ### Group ###
x3dom.registerNodeType(
    "Group",
    "Grouping",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.Group.superClass.call(this, ctx);
        }
    )
);

// ### Block ###
x3dom.registerNodeType(
    "Block",
    "Grouping",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.Block.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'nameSpaceName', []);
        }
    )
);

// ### StaticGroup ###
x3dom.registerNodeType(
    "StaticGroup",
    "Grouping",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.StaticGroup.superClass.call(this, ctx);

            // Node implements optimizations; no need to maintain the children node's
            // X3D representations, as they cannot be accessed after creation time
            this.addField_SFBool(ctx, 'debug', false);
            this.addField_SFBool(ctx, 'showDebugBoxVolumes', false);

            // type of bvh to use, supported are 'jsBIH', 'BIH' and 'OCTREE'
            this.addField_SFString(ctx, 'bvhType', 'jsBIH');
            this.addField_SFInt32(ctx, 'maxObjectsPerNode', 1);
            // -1 sets default values, other values forces maxDepth
            this.addField_SFInt32(ctx, 'maxDepth', -1);
            this.addField_SFFloat(ctx, 'minRelativeBBoxSize', 0.01);

            this.needBvhRebuild = true;
            this.drawableCollection = null;
            this.bvh = null;
        },
        {
            getMaxDepth : function()
            {
                if(this._vf.maxDepth == -1 )
                {
                    return (this._vf.bvhType == ('jsBIH' || 'BIH')) ? 50 : 4;
                }
                return this._vf.maxDepth;
            },

            collectDrawableObjects: function (transform, drawableCollection, singlePath, invalidateCache, planeMask)
            {
                // check if multi parent sub-graph, don't cache in that case
                if (singlePath && (this._parentNodes.length > 1))
                    singlePath = false;

                // an invalid world matrix or volume needs to be invalidated down the hierarchy
                if (singlePath && (invalidateCache = invalidateCache || this.cacheInvalid()))
                    this.invalidateCache();

                // check if sub-graph can be culled away or render flag was set to false
                planeMask = drawableCollection.cull(transform, this.graphState(), singlePath, planeMask);
                if (planeMask <= 0) {
                    return;
                }

                var cnode, childTransform;

                if (singlePath) {
                    // rebuild cache on change and reuse world transform
                    if (!this._graph.globalMatrix) {
                        this._graph.globalMatrix = this.transformMatrix(transform);
                    }
                    childTransform = this._graph.globalMatrix;
                }
                else {
                    childTransform = this.transformMatrix(transform);
                }

                if (this.needBvhRebuild)
                {
                    var drawableCollectionConfig = {
                        viewArea: drawableCollection.viewarea,
                        sortTrans: drawableCollection.sortTrans,
                        viewMatrix: drawableCollection.viewMatrix,
                        projMatrix: drawableCollection.projMatrix,
                        sceneMatrix: drawableCollection.sceneMatrix,
                        frustumCulling: false,
                        smallFeatureThreshold: 0,//1,    // THINKABOUTME
                        context: drawableCollection.context
                    };

                    this.drawableCollection = new x3dom.DrawableCollection(drawableCollectionConfig);

                    var i, n = this._childNodes.length;
                    for (i=0; i<n; i++) {
                        if ( (cnode = this._childNodes[i]) ) {
                            //this is only used to collect all drawables once
                            cnode.collectDrawableObjects(childTransform, this.drawableCollection, singlePath, invalidateCache, planeMask);
                        }
                    }
                    this.drawableCollection.concat();

                    var scene = this._nameSpace.doc._scene;

                    //create settings
                    var bvhSettings = new x3dom.bvh.Settings(
                        this._vf.debug,
                        this._vf.showDebugBoxVolumes,
                        this._vf.bvhType,
                        this._vf.maxObjectsPerNode,
                        this.getMaxDepth(),
                        this._vf.minRelativeBBoxSize
                    );
                    //create bvh type
                    this.bvh = (this._vf.bvhType == 'jsBIH' ) ?
                        new x3dom.bvh.BIH(scene, bvhSettings) :
                        new x3dom.bvh.Culler(this.drawableCollection,scene, bvhSettings);

                    //add decorator for debug shapes
                    if(this._vf.debug || this._vf.showDebugBoxVolumes)
                        this.bvh = new x3dom.bvh.DebugDecorator(this.bvh, scene, bvhSettings);

                    //add drawables
                    n = this.drawableCollection.length;
                    for (i = 0; i < n; i++)
                    {
                        this.bvh.addDrawable(this.drawableCollection.get(i))
                    }

                    //compile bvh
                    this.bvh.compile();

                    if(this._vf.debug)
                        this.bvh.showCompileStats();

                    this.needBvhRebuild = false;    // TODO: re-evaluate if Inline node is child node
                }

                x3dom.Utils.startMeasure('bvhTraverse');
                //collect drawables
                this.bvh.collectDrawables(drawableCollection);
                var dt = x3dom.Utils.stopMeasure('bvhTraverse');
                this._nameSpace.doc.ctx.x3dElem.runtime.addMeasurement('BVH', dt);

                //show stats
                this.bvh.showTraverseStats(this._nameSpace.doc.ctx.x3dElem.runtime);
            }
        }
    )
);

// ### RemoteSelectionGroup ###
x3dom.registerNodeType(
    "RemoteSelectionGroup",
    "Grouping",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.RemoteSelectionGroup.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'url', ["ws://localhost:35668/cstreams/0"]);  // address for WebSocket connection
            this.addField_MFString(ctx, 'label', []);           // list for subsequent id/object pairs
            this.addField_SFInt32(ctx, 'maxRenderedIds', -1);   // max number of items to be rendered
            this.addField_SFBool(ctx, 'reconnect', true);       // if true, the node tries to reconnect
            this.addField_SFFloat(ctx, 'scaleRenderedIdsOnMove', 1.0);  // scaling factor to reduce render calls during navigation (between 0 and 1)
            this.addField_SFBool(ctx, 'enableCulling', true);   // if false, RSG works like normal group
            this.addField_MFString(ctx, 'invisibleNodes', []);  // allows disabling nodes with given label name (incl. prefix*)

            this._idList = [];          // to be updated by socket connection
            this._websocket = null;     // pointer to socket

            this._nameObjMap = {};
            this._createTime = [];
            this._visibleList = [];

            if (ctx)
                this.initializeSocket();    // init socket connection
            else
                x3dom.debug.logWarning("RemoteSelectionGroup: No runtime context found!");
        },
        {
            initializeSocket: function() 
            {
                var that = this;
                
                if ("WebSocket" in window)
                {
                    var wsUrl = "ws://localhost:35668/cstreams/0";
                    
                    if (this._vf.url.length && this._vf.url[0].length)
                        wsUrl = this._vf.url[0];

                    this._websocket = new WebSocket(wsUrl);

                    this._websocket._lastMsg = null;
                    this._websocket._lastData = "";

                    this._websocket.onopen = function(evt)
                    {
                        x3dom.debug.logInfo("WS Connected");
                        
                        var view = that._nameSpace.doc._viewarea.getViewMatrix();
                        this._lastMsg = view.toGL().toString();

                        view = that._nameSpace.doc._viewarea.getProjectionMatrix();
                        this._lastMsg += ("," + view.toGL().toString());

                        this.send(this._lastMsg);
                        x3dom.debug.logInfo("WS Sent: " + this._lastMsg);
                        
                        this._lastMsg = "";     // triggers first update
                        this._lastData = "";
                    };

                    this._websocket.onclose = function(evt) 
                    {
                        x3dom.debug.logInfo("WS Disconnected");

                        if (that._vf.reconnect)
                        {
                            window.setTimeout(function() { 
        						that.initializeSocket();
        					}, 2000);
					    }
                    };

                    this._websocket.onmessage = function(evt) 
                    {
                        if (that._vf.maxRenderedIds < 0)
                        {
                            // render all sent items
                            that._idList = x3dom.fields.MFString.parse(evt.data);
                        }
                        else if (that._vf.maxRenderedIds > 0) 
                        {
                            // render #maxRenderedIds items
                            that._idList = [];
                            var arr = x3dom.fields.MFString.parse(evt.data);
                            var n = Math.min(arr.length, Math.abs(that._vf.maxRenderedIds));

                            for (var i=0; i<n; ++i) {
                                that._idList[i] = arr[i];
                            }
                        }
                        
                        if (that._vf.maxRenderedIds != 0 && this._lastData != evt.data)
                        {
                            this._lastData = evt.data;
                            that._nameSpace.doc.needRender = true;
                            //x3dom.debug.logInfo("WS Response: " + evt.data);

                            that.invalidateVolume();
                            //that.invalidateCache();
                        }
                    };

                    this._websocket.onerror = function(evt) 
                    {
                        x3dom.debug.logError(evt.data);
                    };

                    this._websocket.updateCamera = function()
                    {
                        // send again
                        var view = that._nameSpace.doc._viewarea.getViewMatrix();
                        var message = view.toGL().toString();

                        view = that._nameSpace.doc._viewarea.getProjectionMatrix();
                        message += ("," + view.toGL().toString());

                        if (this._lastMsg != null && this._lastMsg != message)
                        {
                            this._lastMsg = message;
                            this.send(message);
                            //x3dom.debug.logInfo("WS Sent: " + message);
                        }
                    };

                    // if there were a d'tor this would belong there
                    // this._websocket.close();
                }
                else
                {
                    x3dom.debug.logError("Browser has no WebSocket support!");
                }
            },

            nodeChanged: function ()
            {
                var n = this._vf.label.length;

                this._nameObjMap = {};
                this._createTime = new Array(n);
                this._visibleList = new Array(n);

                for (var i=0; i<n; ++i)
                {
                    var shape = this._childNodes[i];

                    if (shape && x3dom.isa(shape, x3dom.nodeTypes.X3DShapeNode))
                    {
                        this._nameObjMap[this._vf.label[i]] = { shape: shape, pos: i };
                        this._visibleList[i] = true;
                    }
					else {
						this._visibleList[i] = false;
						x3dom.debug.logError("Invalid children: " + this._vf.label[i]);
					}

					// init list that holds creation time of gl object
					this._createTime[i] = 0;
                }

                this.invalidateVolume();
                //this.invalidateCache();

                x3dom.debug.logInfo("RemoteSelectionGroup has " + n + " entries.");
            },

            fieldChanged: function(fieldName)
            {
                if (fieldName == "url")
                {
                    if (this._websocket) {
                        this._websocket.close();
                        this._websocket = null;
                    }
                    this.initializeSocket();
                }
                else if (fieldName == "invisibleNodes")
                {
                    for (var i=0, n=this._vf.label.length; i<n; ++i)
                    {
                        var shape = this._childNodes[i];
                        
                        if (shape && x3dom.isa(shape, x3dom.nodeTypes.X3DShapeNode)) 
                        {
                            this._visibleList[i] = true;
                            
                            for (var j=0, numInvis=this._vf.invisibleNodes.length; j<numInvis; ++j)
                            {
                                var nodeName = this._vf.invisibleNodes[j];
                                var starInd = nodeName.lastIndexOf('*');
                                var matchNameBegin = false;
                                
                                if (starInd > 0) {
                                    nodeName = nodeName.substring(0, starInd);
                                    matchNameBegin = true;
                                }
                                if (nodeName.length <= 1)
                                    continue;
                                
                                if ((matchNameBegin && this._vf.label[i].indexOf(nodeName) == 0) ||
                                    this._vf.label[i] == nodeName) {
                                    this._visibleList[i] = false;
                                    break;
                                }
                            }
                        }
                        else {
                            this._visibleList[i] = false;
                        }
                    }

                    this.invalidateVolume();
                    //this.invalidateCache();
                }
                else if (fieldName == "render") {
                    this.invalidateVolume();
                    //this.invalidateCache();
                }
            },
            
            getNumRenderedObjects: function(len, isMoving)
            {
                var n = len;
				
                if (this._vf.maxRenderedIds > 0)
                {
                    var num = Math.max(this._vf.maxRenderedIds, 16);  // set lower bound
                    
                    var scale = 1;  // scale down on move
                    if (isMoving)
                        scale = Math.min(this._vf.scaleRenderedIdsOnMove, 1);
                    
                    num = Math.max(Math.round(scale * num), 0);
                    n = Math.min(n, num);
                }
                
                return n;
            },

            collectDrawableObjects: function (transform, drawableCollection, singlePath, invalidateCache, planeMask)
            {
                if (singlePath && (this._parentNodes.length > 1))
                    singlePath = false;

                if (singlePath && (invalidateCache = invalidateCache || this.cacheInvalid()))
                    this.invalidateCache();

                planeMask = drawableCollection.cull(transform, this.graphState(), singlePath, planeMask);
                if (planeMask <= 0) {
                    return;
                }

                var viewarea = this._nameSpace.doc._viewarea;
                var isMoving = viewarea.isMovingOrAnimating();
                
                var ts = new Date().getTime();
                var maxLiveTime = 10000;
                var i, n, numChild = this._childNodes.length;
                
                if (!this._vf.enableCulling)
                {
                    n = this.getNumRenderedObjects(numChild, isMoving);

                    var cnt = 0;
                    for (i=0; i<numChild; i++)
                    {
                        var shape = this._childNodes[i];
                        
                        if (shape)
                        {
                            var needCleanup = true;
                            
                            if (this._visibleList[i] && cnt < n &&
                                shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask))
                            {
                                this._createTime[i] = ts;
                                cnt++;
                                needCleanup = false;
                            }
                            
                            if (needCleanup && !isMoving && this._createTime[i] > 0 && 
                                ts - this._createTime[i] > maxLiveTime && shape._cleanupGLObjects)
                            {
                                shape._cleanupGLObjects(true);
                                this._createTime[i] = 0;
                            }
                        }
                    }
                    
                    return;
                }

                if (this._websocket)
                    this._websocket.updateCamera();

                if (this._vf.label.length)
                {
                    n = this.getNumRenderedObjects(this._idList.length, isMoving);
                    
                    for (i=0; i<n; i++)
                    {
                        var obj = this._nameObjMap[this._idList[i]];
                        if (obj && obj.shape) {
                            obj.shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                            this._createTime[obj.pos] = ts;
                        }
						else
							x3dom.debug.logError("Invalid label: " + this._idList[i]);
                    }
                    
                    for (i=0; i<this._childNodes.length; i++)
                    {
                        if (this._childNodes[i] && !isMoving && this._createTime[i] > 0 && 
                            ts - this._createTime[i] > maxLiveTime && this._childNodes[i]._cleanupGLObjects)
                        {
                            this._childNodes[i]._cleanupGLObjects(true);
                            this._createTime[i] = 0;
                        }
                    }
                }
            }
        }
    )
);

// Not a real X3D node type
// ### Scene ###
x3dom.registerNodeType(
    "Scene",
    "Core",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.Scene.superClass.call(this, ctx);

            // define the experimental picking mode: box, idBuf, idBuf24, idBufId, color, texCoord
            this.addField_SFString(ctx, 'pickMode', "idBuf");
            // experimental field to switch off picking
            this.addField_SFBool(ctx, 'doPickPass', true);

            // another experimental field for shadow DOM remapping
            this.addField_SFString(ctx, 'shadowObjectIdMapping', "");

            this._lastMin = new x3dom.fields.SFVec3f(0, 0, 0);
            this._lastMax = new x3dom.fields.SFVec3f(1, 1, 1);
            
            this._shadowIdMap = null;
            this.loadMapping();
        },
        {
            /* Bindable getter (e.g. getViewpoint) are added automatically */
            
            fieldChanged: function(fieldName)
            {
                if (fieldName == "shadowObjectIdMapping")
                    this.loadMapping();
            },
            
            updateVolume: function()
            {
                var vol = this.getVolume();

                if (vol.isValid())
                {
                    this._lastMin = x3dom.fields.SFVec3f.copy(vol.min);
                    this._lastMax = x3dom.fields.SFVec3f.copy(vol.max);
                }
            },
            
            loadMapping: function()
            {
                this._shadowIdMap = null;
                
                if (this._vf.shadowObjectIdMapping.length == 0) {
                    return;
                }
                
                var that = this;
                var xhr = new XMLHttpRequest();
                
                xhr.open("GET", encodeURI(this._nameSpace.getURL(this._vf.shadowObjectIdMapping)), true);
                xhr.send();
                
                xhr.onload = function()
                {
                    that._shadowIdMap = eval("(" + xhr.response + ")");
                };
            }
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


///////////////////////////////////////////////////////////////////////////////
// BindableStack constructor
///////////////////////////////////////////////////////////////////////////////
x3dom.BindableStack = function (doc, type, defaultType, getter) {
    this._doc = doc;
    this._type = type;
    this._defaultType = defaultType;
    this._defaultRoot = null;
    this._getter = getter;
    this._bindBag = [];
    this._bindStack = [];
};

x3dom.BindableStack.prototype.top = function () {
    return ( (this._bindStack.length > 0) ? this._bindStack[this._bindStack.length - 1] : null );
};

x3dom.BindableStack.prototype.push = function (bindable) {
    var top = this.top();

    if (top === bindable) {
        return;
    }

    if (top) {
        top.deactivate();
    }

    this._bindStack.push(bindable);
    
    bindable.activate(top);
};

x3dom.BindableStack.prototype.replaceTop = function (bindable) {
    var top = this.top();

    if (top === bindable) {
        return;
    }

    if (top) {
        top.deactivate();

        this._bindStack[this._bindStack.length - 1] = bindable;
        
        bindable.activate(top);
    }
};

x3dom.BindableStack.prototype.pop = function (bindable) {
    var top;

    if (bindable) {
        top = this.top();
        if (bindable !== top) {
            return null;
        }
    }

    top = this._bindStack.pop();

    if (top) {
        top.deactivate();
    }

    return top;
};

x3dom.BindableStack.prototype.switchTo = function (target) {
    var last = this.getActive();
    var n = this._bindBag.length;
    var toBind = 0;
    var i = 0, lastIndex = -1;

    if (n <= 1) {
        return;
    }

    switch (target)
    {
        case 'first':
            toBind = this._bindBag[0];
            break;
        case 'last':
            toBind = this._bindBag[n-1];
            break;
        default:
            for (i = 0; i < n; i++) {
                if (this._bindBag[i] == last) {
                    lastIndex = i;
                    break;
                }
            }
            if (lastIndex >= 0) {
                i = lastIndex;
                while (!toBind) {
                    if (target == 'next') {
                        i = (i < (n-1)) ? (i+1) : 0;
                    } else { // prev
                        i = (i>0) ? (i-1) : (n-1);
                    }
                    if (i == lastIndex) {
                        break;
                    }
                    if (this._bindBag[i]._vf.description.length >= 0) {
                        toBind = this._bindBag[i];
                    }
                }
            }
            break;
    }
    
    if (toBind) {
        this.replaceTop(toBind);
    } else {
        x3dom.debug.logWarning ('Cannot switch bindable; no other bindable with description found.');
    }
};

// Get currently active bindable of given stack type, creates new if none exists
x3dom.BindableStack.prototype.getActive = function () {
    if (this._bindStack.length === 0) {
        if (this._bindBag.length === 0) {
            if (this._defaultRoot) {
                x3dom.debug.logInfo ('create new ' + this._defaultType._typeName +
                                     ' for ' + this._type._typeName + '-stack');
                var obj = new this._defaultType( 
                    { doc: this._doc, nameSpace: this._defaultRoot._nameSpace, autoGen: true } );
                
                this._defaultRoot.addChild(obj);
                obj.nodeChanged();
            }
            else {
                x3dom.debug.logError ('stack without defaultRoot');
            }
        }
        else {
            x3dom.debug.logInfo ('activate first ' + this._type._typeName +
                                 ' for ' + this._type._typeName + '-stack');
        }

        this._bindStack.push(this._bindBag[0]);
        this._bindBag[0].activate();
    }
    
    return this._bindStack[this._bindStack.length - 1];
};


///////////////////////////////////////////////////////////////////////////////
// BindableBag constructor
///////////////////////////////////////////////////////////////////////////////
x3dom.BindableBag = function (doc) {
    this._stacks = [];

    this.addType ("X3DViewpointNode", "Viewpoint", "getViewpoint", doc);
    this.addType ("X3DNavigationInfoNode", "NavigationInfo", "getNavigationInfo", doc);
    this.addType ("X3DBackgroundNode", "Background", "getBackground", doc);
    this.addType ("X3DFogNode", "Fog", "getFog", doc);
    this.addType ("X3DEnvironmentNode", "Environment", "getEnvironment", doc);
};

x3dom.BindableBag.prototype.addType = function(typeName, defaultTypeName, getter, doc) {
    var type = x3dom.nodeTypes[typeName];
    var defaultType = x3dom.nodeTypes[defaultTypeName];

    if (type && defaultType) {
        var stack = new x3dom.BindableStack (doc, type, defaultType, getter);
        this._stacks.push(stack);
    }
    else {
        x3dom.debug.logWarning('Invalid Bindable type/defaultType: ' + 
                                typeName + '/' + defaultType);
    }
};

x3dom.BindableBag.prototype.setRefNode = function (node) {
    Array.forEach ( this._stacks, function (stack) {
        // set reference to Scene
        stack._defaultRoot = node;
        node[stack._getter] = function () { return stack.getActive(); };
    } );
};

x3dom.BindableBag.prototype.addBindable = function(node) {
    for (var i = 0, n = this._stacks.length; i < n; i++) {
        var stack = this._stacks[i];
        
        if ( x3dom.isa (node, stack._type) ) {
            x3dom.debug.logInfo('register ' + node.typeName() + 'Bindable ' + 
                                node._DEF + '/' + node._vf.description);
            
            stack._bindBag.push(node);
            
            var top = stack.top();
            
            if (top && top._autoGen) {
                stack.replaceTop(node);
                
                // remove auto-generated default bindable
        		for (var j = 0, m = stack._bindBag.length; j < m; j++) {
                    if (stack._bindBag[j] === top) {
                        stack._bindBag.splice(j, 1);
                        break;
                    }
                }
        		stack._defaultRoot.removeChild(top);
            }
            
            return stack;
        }
    }
    
    x3dom.debug.logError (node.typeName() + ' is not a valid bindable');
    return null;
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### X3DGeometryNode ### */
x3dom.registerNodeType(
    "X3DGeometryNode",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.X3DGeometryNode.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'solid', true);
            this.addField_SFBool(ctx, 'ccw', true);
            // Most geo primitives use geo cache and others might later on,
            // but one should be able to disable cache per geometry node.
            this.addField_SFBool(ctx, 'useGeoCache', true);

            // mesh object also holds volume (_vol)
            this._mesh = new x3dom.Mesh(this);
        },
        {
            getVolume: function() {
                // geometry doesn't hold volume, but mesh does
                return this._mesh.getVolume();
            },

            invalidateVolume: function() {
                this._mesh.invalidate();
            },

            getCenter: function() {
                return this._mesh.getCenter();
            },
            
            getDiameter: function() {
                return this._mesh.getDiameter();
            },

            doIntersect: function(line) {
                return this._mesh.doIntersect(line);
            },

            forceUpdateCoverage: function() {
                return false;
            },

            hasIndexOffset: function() {
                return false;
            },

            getColorTexture: function() {
                return null;
            },

            getColorTextureURL: function() {
                return null;
            },

            parentAdded: function(parent) {
                if (x3dom.isa(parent, x3dom.nodeTypes.X3DShapeNode)) {
                    if (parent._cleanupGLObjects) {
                        parent._cleanupGLObjects(true);
                    }
                    parent.setAllDirty();
                    parent.invalidateVolume();
                }
            }
        }
    )
);

/* ### Mesh ### */
x3dom.registerNodeType(
    "Mesh",         // experimental WebSG geo node
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Mesh.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'primType', "triangle");
            this.addField_MFInt32(ctx, 'index', []);

            this.addField_MFNode('vertexAttributes', x3dom.nodeTypes.X3DVertexAttributeNode);
        },
        {
            nodeChanged: function()
            {
                var time0 = new Date().getTime();

                var i, n = this._cf.vertexAttributes.nodes.length;

                for (i=0; i<n; i++)
                {
                    var name = this._cf.vertexAttributes.nodes[i]._vf.name;

                    switch (name.toLowerCase())
                    {
                        case "position":
                            this._mesh._positions[0] = this._cf.vertexAttributes.nodes[i]._vf.value.toGL();
                            break;
                        case "normal":
                            this._mesh._normals[0] = this._cf.vertexAttributes.nodes[i]._vf.value.toGL();
                            break;
                        case "texcoord":
                            this._mesh._texCoords[0] = this._cf.vertexAttributes.nodes[i]._vf.value.toGL();
                            break;
                        case "color":
                            this._mesh._colors[0] = this._cf.vertexAttributes.nodes[i]._vf.value.toGL();
                            break;
                        default:
                            this._mesh._dynamicFields[name] = {};
                            this._mesh._dynamicFields[name].numComponents =
                                       this._cf.vertexAttributes.nodes[i]._vf.numComponents;
                            this._mesh._dynamicFields[name].value =
                                       this._cf.vertexAttributes.nodes[i]._vf.value.toGL();
                        break;
                    }
                }

                this._mesh._indices[0] = this._vf.index.toGL();

                this.invalidateVolume();

                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                var time1 = new Date().getTime() - time0;
                x3dom.debug.logWarning("Mesh load time: " + time1 + " ms");
            }
        }
    )
);

/* ### PointSet ### */
x3dom.registerNodeType(
    "PointSet",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.PointSet.superClass.call(this, ctx);

            this.addField_SFNode('coord', x3dom.nodeTypes.Coordinate);
            this.addField_SFNode('color', x3dom.nodeTypes.X3DColorNode);

            this._mesh._primType = 'POINTS';
        },
        {
            nodeChanged: function()
            {
                var time0 = new Date().getTime();

                var coordNode = this._cf.coord.node;
                x3dom.debug.assert(coordNode);
                var positions = coordNode._vf.point;

                var numColComponents = 3;
                var colorNode = this._cf.color.node;
                var colors = new x3dom.fields.MFColor();
                if (colorNode) {
                    colors = colorNode._vf.color;
                    x3dom.debug.assert(positions.length == colors.length);

                    if (x3dom.isa(colorNode, x3dom.nodeTypes.ColorRGBA)) {
                        numColComponents = 4;
                    }
                }

                this._mesh._numColComponents = numColComponents;
                this._mesh._lit = false;

                this._mesh._indices[0] = [];
                this._mesh._positions[0] = positions.toGL();
                this._mesh._colors[0] = colors.toGL();
                this._mesh._normals[0] = [];
                this._mesh._texCoords[0] = [];

                this.invalidateVolume();
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                var time1 = new Date().getTime() - time0;
                //x3dom.debug.logInfo("Mesh load time: " + time1 + " ms");
            },

            fieldChanged: function(fieldName)
            {
                var pnts = null;
                
                if (fieldName == "coord")
                {
                    pnts = this._cf.coord.node._vf.point;
                    
                    this._mesh._positions[0] = pnts.toGL();

                    this.invalidateVolume();

                    Array.forEach(this._parentNodes, function (node) {					
                        node._dirty.positions = true;
                        node.invalidateVolume();
                    });
                }
                else if (fieldName == "color")
                {
                    pnts = this._cf.color.node._vf.color;
                    
                    this._mesh._colors[0] = pnts.toGL();

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.colors = true;
                    });
                }
            }
        }
    )
);

/* ### X3DComposedGeometryNode ### */
x3dom.registerNodeType(
    "X3DComposedGeometryNode",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.X3DComposedGeometryNode.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'colorPerVertex', true);
            this.addField_SFBool(ctx, 'normalPerVertex', true);
            this.addField_SFString(ctx, 'normalUpdateMode', 'fast');  // none; fast; nice

            this.addField_MFNode('attrib', x3dom.nodeTypes.X3DVertexAttributeNode);

            this.addField_SFNode('coord', x3dom.nodeTypes.X3DCoordinateNode);
            this.addField_SFNode('normal', x3dom.nodeTypes.Normal);
            this.addField_SFNode('color', x3dom.nodeTypes.X3DColorNode);
            this.addField_SFNode('texCoord', x3dom.nodeTypes.X3DTextureCoordinateNode);
        },
        {
            handleAttribs: function()
            {
                //var time0 = new Date().getTime();

                // TODO; handle case that more than 2^16-1 attributes are to be referenced
                var i, n = this._cf.attrib.nodes.length;

                for (i=0; i<n; i++)
                {
                    var name = this._cf.attrib.nodes[i]._vf.name;

                    switch (name.toLowerCase())
                    {
                        case "position":
                            this._mesh._positions[0] = this._cf.attrib.nodes[i]._vf.value.toGL();
                            break;
                        case "normal":
                            this._mesh._normals[0] = this._cf.attrib.nodes[i]._vf.value.toGL();
                            break;
                        case "texcoord":
                            this._mesh._texCoords[0] = this._cf.attrib.nodes[i]._vf.value.toGL();
                            break;
                        case "color":
                            this._mesh._colors[0] = this._cf.attrib.nodes[i]._vf.value.toGL();
                            break;
                        default:
                            this._mesh._dynamicFields[name] = {};
                            this._mesh._dynamicFields[name].numComponents =
                                       this._cf.attrib.nodes[i]._vf.numComponents;
                            this._mesh._dynamicFields[name].value =
                                       this._cf.attrib.nodes[i]._vf.value.toGL();
                        break;
                    }
                }

                //var time1 = new Date().getTime() - time0;
                //x3dom.debug.logInfo("Mesh load time: " + time1 + " ms");
            }
        }
    )
);

/* ### LineSet ### */
x3dom.registerNodeType(
    "LineSet",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.LineSet.superClass.call(this, ctx);

            this.addField_MFInt32(ctx, 'vertexCount', []);

            this.addField_MFNode('attrib', x3dom.nodeTypes.X3DVertexAttributeNode);
            this.addField_SFNode('coord', x3dom.nodeTypes.X3DCoordinateNode);
            this.addField_SFNode('color', x3dom.nodeTypes.X3DColorNode);

            this._mesh._primType = "LINES";
        },
        {
            nodeChanged: function() {
                var coordNode = this._cf.coord.node;
                x3dom.debug.assert(coordNode);
                var positions = coordNode.getPoints();

                this._mesh._positions[0] = positions.toGL();

                var colorNode = this._cf.color.node;
                if (colorNode) {
                    var colors = colorNode._vf.color;

                    this._mesh._colors[0] = colors.toGL();

                    var numColComponents = 3;
                    if (x3dom.isa(colorNode, x3dom.nodeTypes.ColorRGBA)) {
                        numColComponents = 4;
                    }
                }

                var cnt = 0;
                this._mesh._indices[0] = [];

                for (var i=0, n=this._vf.vertexCount.length; i<n; i++) {
                    var vc = this._vf.vertexCount[i];
                    if (vc < 2) {
                        x3dom.debug.logError("LineSet.vertexCount must not be smaller than 2!");
                        break;
                    }
                    for (var j=vc-2; j>=0; j--) {
                        this._mesh._indices[0].push(cnt++, cnt);
                        if (j == 0) cnt++;
                    }
                }
            },

            fieldChanged: function(fieldName) {
                if (fieldName == "coord") {
                    var pnts = this._cf.coord.node.getPoints();
                    this._mesh._positions[0] = pnts.toGL();

                    this.invalidateVolume();
                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.positions = true;
                        node.invalidateVolume();
                    });
                }
                else if (fieldName == "color") {
                    var cols = this._cf.color.node._vf.color;
                    this._mesh._colors[0] = cols.toGL();

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.colors = true;
                    });
                }
            }
        }
    )
);


/* ### IndexedLineSet ### */
x3dom.registerNodeType(
    "IndexedLineSet",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.IndexedLineSet.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'colorPerVertex', true);  // TODO

            this.addField_MFNode('attrib', x3dom.nodeTypes.X3DVertexAttributeNode);
            this.addField_SFNode('coord', x3dom.nodeTypes.X3DCoordinateNode);
            this.addField_SFNode('color', x3dom.nodeTypes.X3DColorNode);

            this.addField_MFInt32(ctx, 'coordIndex', []);
            this.addField_MFInt32(ctx, 'colorIndex', []);

            this._mesh._primType = 'LINES';
        },
        {
            nodeChanged: function()
            {
                var time0 = new Date().getTime();

                // this.handleAttribs();

                var indexes = this._vf.coordIndex;
                var colorInd = this._vf.colorIndex;

                var hasColor = false, hasColorInd = false;

                // TODO; implement colorPerVertex also for single index
                var colPerVert = this._vf.colorPerVertex;

                if (colorInd.length > 0)
                {
                    hasColorInd = true;
                }

                var positions, colors;

                var coordNode = this._cf.coord.node;
                x3dom.debug.assert(coordNode);
                
                positions = coordNode.getPoints();

                var numColComponents = 3;
                var colorNode = this._cf.color.node;
                if (colorNode)
                {
                    hasColor = true;
                    colors = colorNode._vf.color;

                    if (x3dom.isa(colorNode, x3dom.nodeTypes.ColorRGBA)) {
                        numColComponents = 4;
                    }
                }
                else {
                    hasColor = false;
                }

                this._mesh._indices[0] = [];
                this._mesh._positions[0] = [];
                this._mesh._colors[0] = [];

                var i, t, cnt, lineCnt;
                var p0, p1, c0, c1;

                // Found MultiIndex Mesh OR LineSet with too many vertices for 16 bit
                if ( (hasColor && hasColorInd) || positions.length > x3dom.Utils.maxIndexableCoords )
                {
                    t = 0;
                    cnt = 0;
                    lineCnt = 0;

                    for (i=0; i < indexes.length; ++i)
                    {
                        if (indexes[i] === -1) {
                            t = 0;
                            continue;
                        }

                        if (hasColorInd) {
                            x3dom.debug.assert(colorInd[i] != -1);
                        }

                        switch (t)
                        {
                            case 0:
                                p0 = +indexes[i];
                                if (hasColorInd && colPerVert) { c0 = +colorInd[i]; }
                                else { c0 = p0; }
                                t = 1;
                                break;
                            case 1:
                                p1 = +indexes[i];
                                if (hasColorInd && colPerVert) { c1 = +colorInd[i]; }
                                else if (hasColorInd && !colPerVert) { c1 = +colorInd[lineCnt]; }
                                else { c1 = p1; }

                                this._mesh._indices[0].push(cnt++, cnt++);

                                this._mesh._positions[0].push(positions[p0].x);
                                this._mesh._positions[0].push(positions[p0].y);
                                this._mesh._positions[0].push(positions[p0].z);
                                this._mesh._positions[0].push(positions[p1].x);
                                this._mesh._positions[0].push(positions[p1].y);
                                this._mesh._positions[0].push(positions[p1].z);

                                if (hasColor) {
                                    if (!colPerVert) {
                                        c0 = c1;
                                    }
                                    this._mesh._colors[0].push(colors[c0].r);
                                    this._mesh._colors[0].push(colors[c0].g);
                                    this._mesh._colors[0].push(colors[c0].b);
                                    this._mesh._colors[0].push(colors[c1].r);
                                    this._mesh._colors[0].push(colors[c1].g);
                                    this._mesh._colors[0].push(colors[c1].b);
                                }

                                t = 2;
                                lineCnt++;
                                break;
                            case 2:
                                p0 = p1;
                                c0 = c1;
                                p1 = +indexes[i];
                                if (hasColorInd && colPerVert) { c1 = +colorInd[i]; }
                                else if (hasColorInd && !colPerVert) { c1 = +colorInd[lineCnt]; }
                                else { c1 = p1; }

                                this._mesh._indices[0].push(cnt++, cnt++);

                                this._mesh._positions[0].push(positions[p0].x);
                                this._mesh._positions[0].push(positions[p0].y);
                                this._mesh._positions[0].push(positions[p0].z);
                                this._mesh._positions[0].push(positions[p1].x);
                                this._mesh._positions[0].push(positions[p1].y);
                                this._mesh._positions[0].push(positions[p1].z);

                                if (hasColor) {
                                    if (!colPerVert) {
                                        c0 = c1;
                                    }
                                    this._mesh._colors[0].push(colors[c0].r);
                                    this._mesh._colors[0].push(colors[c0].g);
                                    this._mesh._colors[0].push(colors[c0].b);
                                    this._mesh._colors[0].push(colors[c1].r);
                                    this._mesh._colors[0].push(colors[c1].g);
                                    this._mesh._colors[0].push(colors[c1].b);
                                }

                                lineCnt++;
                                break;
                            default:
                        }
                    }

                    //if the LineSet is too large for 16 bit indices, split it!
                    if (positions.length > x3dom.Utils.maxIndexableCoords)
                        this._mesh.splitMesh(2);
                } // if isMulti
                else
                {
                    var n = indexes.length;
                    t = 0;

                    for (i=0; i < n; ++i)
                    {
                        if (indexes[i] == -1) {
                            t = 0;
                            continue;
                        }

                        switch (t) {
                        case 0: p0 = +indexes[i]; t = 1; break;
                        case 1: p1 = +indexes[i]; t = 2; this._mesh._indices[0].push(p0, p1); break;
                        case 2: p0 = p1; p1 = +indexes[i]; this._mesh._indices[0].push(p0, p1); break;
                        }
                    }

                    this._mesh._positions[0] = positions.toGL();

                    if (hasColor) {
                        this._mesh._colors[0] = colors.toGL();
                        this._mesh._numColComponents = numColComponents;
                    }
                }

                this.invalidateVolume();
                this._mesh._numCoords = 0;

                for (i=0; i<this._mesh._indices.length; i++) {
                    this._mesh._numCoords += this._mesh._positions[i].length / 3;
                }

                var time1 = new Date().getTime() - time0;
                //x3dom.debug.logInfo("Mesh load time: " + time1 + " ms");
            },

            fieldChanged: function(fieldName)
            {
                var pnts = null;
                
                if (fieldName == "coord")
                {
                    pnts = this._cf.coord.node._vf.point;
                    
                    this._mesh._positions[0] = pnts.toGL();

                    this.invalidateVolume();

                    Array.forEach(this._parentNodes, function (node) {					
                        node._dirty.positions = true;
                        node.invalidateVolume();
                    });
                }
                else if (fieldName == "color")
                {
                    pnts = this._cf.color.node._vf.color;
                    
                    this._mesh._colors[0] = pnts.toGL();

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.colors = true;
                    });
                }
                else if (fieldName == "coordIndex") {
                    this._mesh._indices[0] = [];

                    var indexes = this._vf.coordIndex;
                    var p0, p1, t = 0;

                    for (var i=0, n=indexes.length; i < n; ++i) {
                        if (indexes[i] == -1) {
                            t = 0;
                        }
                        else {
                            switch (t) {
                                case 0: p0 = +indexes[i]; t = 1; break;
                                case 1: p1 = +indexes[i]; t = 2; this._mesh._indices[0].push(p0, p1); break;
                                case 2: p0 = p1; p1 = +indexes[i]; this._mesh._indices[0].push(p0, p1); break;
                            }
                        }
                    }

                    this.invalidateVolume();

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.indexes = true;
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);


/* ### IndexedTriangleSet ### */
x3dom.registerNodeType(
    "IndexedTriangleSet",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DComposedGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.IndexedTriangleSet.superClass.call(this, ctx);

            this.addField_MFInt32(ctx, 'index', []);
        },
        {
            nodeChanged: function()
            {
                var time0 = new Date().getTime();

                this.handleAttribs();

				var colPerVert = this._vf.colorPerVertex;
                var normPerVert = this._vf.normalPerVertex;

                var indexes = this._vf.index;

                var hasNormal = false, hasTexCoord = false, hasColor = false;
                var positions, normals, texCoords, colors;

                var coordNode = this._cf.coord.node;
                x3dom.debug.assert(coordNode);
                positions = coordNode._vf.point;

                var normalNode = this._cf.normal.node;
                if (normalNode) {
                    hasNormal = true;
                    normals = normalNode._vf.vector;
                }
                else {
                    hasNormal = false;
                }

                var texMode = "", numTexComponents = 2;
                var texCoordNode = this._cf.texCoord.node;
                if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                    if (texCoordNode._cf.texCoord.nodes.length)
                        texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                }
                if (texCoordNode) {
                    if (texCoordNode._vf.point) {
                        hasTexCoord = true;
                        texCoords = texCoordNode._vf.point;

                        if (x3dom.isa(texCoordNode, x3dom.nodeTypes.TextureCoordinate3D)) {
                            numTexComponents = 3;
                        }
                    }
                    else if (texCoordNode._vf.mode) {
                        texMode = texCoordNode._vf.mode;
                    }
                }
                else {
                    hasTexCoord = false;
                }

                var numColComponents = 3;
                var colorNode = this._cf.color.node;
                if (colorNode) {
                    hasColor = true;
                    colors = colorNode._vf.color;

                    if (x3dom.isa(colorNode, x3dom.nodeTypes.ColorRGBA)) {
                        numColComponents = 4;
                    }
                }
                else {
                    hasColor = false;
                }

                this._mesh._indices[0] = [];
                this._mesh._positions[0] = [];
                this._mesh._normals[0] = [];
                this._mesh._texCoords[0] = [];
                this._mesh._colors[0] = [];

                var i, t, cnt, faceCnt, posMax;
                var p0, p1, p2, n0, n1, n2, t0, t1, t2, c0, c1, c2;

                // if positions array too short add degenerate triangle
                while (positions.length % 3 > 0) {
                    positions.push(positions.length-1);
                }
                posMax = positions.length;

                if (!normPerVert || posMax > x3dom.Utils.maxIndexableCoords)
                {
                    t = 0;
                    cnt = 0;
                    faceCnt = 0;
                    this._mesh._multiIndIndices = [];
                    this._mesh._posSize = positions.length;

                    for (i=0; i < indexes.length; ++i)
                    {
                        // Convert non-triangular polygons to a triangle fan
                        // (TODO: this assumes polygons are convex)
                        
                        if ((i > 0) && (i % 3 === 0 )) {
                            t = 0; 
							faceCnt++;							
                        }					

                        //TODO: OPTIMIZE but think about cache coherence regarding arrays!!!
                        switch (t)
                        {
                            case 0:
                                p0 = +indexes[i];
								if (normPerVert) { 
									 n0 = p0;
								} else if (!normPerVert) {
									n0 = faceCnt;
								}
                                t0 = p0;
                                if (colPerVert) { 
									 c0 = p0;
								} else if (!colPerVert) {
									c0 = faceCnt;
								}
                                t = 1;
                            break;
                            case 1:
                                p1 = +indexes[i];
								if (normPerVert) { 
									 n1 = p1;
								} else if (!normPerVert) {
									n1 = faceCnt;
								}
                                t1 = p1;
                                if (colPerVert) { 
									 c1 = p1;
								} else if (!colPerVert) {
									c1 = faceCnt;
								}
                                t = 2;
                            break;
                            case 2:
                                p2 = +indexes[i];
                                if (normPerVert) { 
									 n2 = p2;
								} else if (!normPerVert) {
									n2 = faceCnt;
								}
                                t2 = p2;
                                if (colPerVert) { 
									 c2 = p2;
								} else if (!colPerVert) {
									c2 = faceCnt;
								}
                                t = 3;

                                this._mesh._indices[0].push(cnt++, cnt++, cnt++);

                                this._mesh._positions[0].push(positions[p0].x);
                                this._mesh._positions[0].push(positions[p0].y);
                                this._mesh._positions[0].push(positions[p0].z);
                                this._mesh._positions[0].push(positions[p1].x);
                                this._mesh._positions[0].push(positions[p1].y);
                                this._mesh._positions[0].push(positions[p1].z);
                                this._mesh._positions[0].push(positions[p2].x);
                                this._mesh._positions[0].push(positions[p2].y);
                                this._mesh._positions[0].push(positions[p2].z);

                                if (hasNormal) {
                                    this._mesh._normals[0].push(normals[n0].x);
                                    this._mesh._normals[0].push(normals[n0].y);
                                    this._mesh._normals[0].push(normals[n0].z);
                                    this._mesh._normals[0].push(normals[n1].x);
                                    this._mesh._normals[0].push(normals[n1].y);
                                    this._mesh._normals[0].push(normals[n1].z);
                                    this._mesh._normals[0].push(normals[n2].x);
                                    this._mesh._normals[0].push(normals[n2].y);
                                    this._mesh._normals[0].push(normals[n2].z);
                                }
                                else {
                                    this._mesh._multiIndIndices.push(p0, p1, p2);
                                    //this._mesh._multiIndIndices.push(cnt-3, cnt-2, cnt-1);
                                }

                                if (hasColor) {
                                    this._mesh._colors[0].push(colors[c0].r);
                                    this._mesh._colors[0].push(colors[c0].g);
                                    this._mesh._colors[0].push(colors[c0].b);
                                    if (numColComponents === 4) {
                                        this._mesh._colors[0].push(colors[c0].a);
                                    }
                                    this._mesh._colors[0].push(colors[c1].r);
                                    this._mesh._colors[0].push(colors[c1].g);
                                    this._mesh._colors[0].push(colors[c1].b);
                                    if (numColComponents === 4) {
                                        this._mesh._colors[0].push(colors[c1].a);
                                    }
                                    this._mesh._colors[0].push(colors[c2].r);
                                    this._mesh._colors[0].push(colors[c2].g);
                                    this._mesh._colors[0].push(colors[c2].b);
                                    if (numColComponents === 4) {
                                        this._mesh._colors[0].push(colors[c2].a);
                                    }
                                }

                                if (hasTexCoord) {
                                    this._mesh._texCoords[0].push(texCoords[t0].x);
                                    this._mesh._texCoords[0].push(texCoords[t0].y);
                                    if (numTexComponents === 3) {
                                        this._mesh._texCoords[0].push(texCoords[t0].z);
                                    }
                                    this._mesh._texCoords[0].push(texCoords[t1].x);
                                    this._mesh._texCoords[0].push(texCoords[t1].y);
                                    if (numTexComponents === 3) {
                                        this._mesh._texCoords[0].push(texCoords[t1].z);
                                    }
                                    this._mesh._texCoords[0].push(texCoords[t2].x);
                                    this._mesh._texCoords[0].push(texCoords[t2].y);
                                    if (numTexComponents === 3) {
                                        this._mesh._texCoords[0].push(texCoords[t2].z);
                                    }
                                }

                                //faceCnt++;
                            break;
                            default:
                        }
                    }

                    if (!hasNormal) {
                        this._mesh.calcNormals(normPerVert ? Math.PI : 0);
                    }
                    if (!hasTexCoord) {
                        this._mesh.calcTexCoords(texMode);
                    }

                    this._mesh.splitMesh();

                    //x3dom.debug.logInfo(this._mesh._indices.length);
                } // if isMulti
                else
                {
					faceCnt = 0;
					for (i=0; i<indexes.length; i++)
					{
						if ((i > 0) && (i % 3 === 0 )) {                   
							faceCnt++;							
                        }	
						
						this._mesh._indices[0].push(indexes[i]);
							
						if(!normPerVert && hasNormal) {
							this._mesh._normals[0].push(normals[faceCnt].x);
							this._mesh._normals[0].push(normals[faceCnt].y);
							this._mesh._normals[0].push(normals[faceCnt].z);
						}
						if(!colPerVert && hasColor) {								
							this._mesh._colors[0].push(colors[faceCnt].r);
							this._mesh._colors[0].push(colors[faceCnt].g);
							this._mesh._colors[0].push(colors[faceCnt].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(colors[faceCnt].a);
							}   
						}  				
					}
               
                    this._mesh._positions[0] = positions.toGL();
                    
                    if (hasNormal) {
                        this._mesh._normals[0] = normals.toGL();
                    }
                    else {
                        this._mesh.calcNormals(normPerVert ? Math.PI : 0);
                    }
                    
                    if (hasTexCoord) {
                        this._mesh._texCoords[0] = texCoords.toGL();
                        this._mesh._numTexComponents = numTexComponents;
                    }
                    else {
                        this._mesh.calcTexCoords(texMode);
                    }
                    
                    if (hasColor && colPerVert) {
                        this._mesh._colors[0] = colors.toGL();
                        this._mesh._numColComponents = numColComponents;
                    }
                }

                this.invalidateVolume();

                this._mesh._numFaces = 0;
                this._mesh._numCoords = 0;
                for (i=0; i<this._mesh._indices.length; i++) {
                    this._mesh._numFaces += this._mesh._indices[i].length / 3;
                    this._mesh._numCoords += this._mesh._positions[i].length / 3;
                }

                var time1 = new Date().getTime() - time0;
                //x3dom.debug.logInfo("Mesh load time: " + time1 + " ms");
            },

            fieldChanged: function(fieldName)
            {
                var pnts = this._cf.coord.node._vf.point;
                
                if ( pnts.length > x3dom.Utils.maxIndexableCoords )  // are there other problematic cases?
                {
					// TODO; implement
                    x3dom.debug.logWarning("IndexedTriangleSet: fieldChanged with " + 
                                           "too many coordinates not yet implemented!");
                    return;
                }
                
                if (fieldName == "coord")
                {
                    this._mesh._positions[0] = pnts.toGL();
                    
                    // tells the mesh that its bbox requires update
                    this.invalidateVolume();

                    Array.forEach(this._parentNodes, function (node) {					
                        node._dirty.positions = true;
                        node.invalidateVolume();
                    });
                }
                else if (fieldName == "color")
                {                                      
					pnts = this._cf.color.node._vf.color;
						
					if (this._vf.colorPerVertex) { 
				
						this._mesh._colors[0] = pnts.toGL();	
							
					} else if (!this._vf.colorPerVertex) {
						
						var faceCnt = 0;
						var numColComponents = 3;	
                   		if (x3dom.isa(this._cf.color.node, x3dom.nodeTypes.ColorRGBA)) {
							numColComponents = 4;
						}
							
						this._mesh._colors[0] = [];
							
						var indexes = this._vf.index;
						for (var i=0; i < indexes.length; ++i)
						{
							if ((i > 0) && (i % 3 === 0 )) {                   
								faceCnt++;							
							}	
								
							this._mesh._colors[0].push(pnts[faceCnt].r);
							this._mesh._colors[0].push(pnts[faceCnt].g);
							this._mesh._colors[0].push(pnts[faceCnt].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(pnts[faceCnt].a);
							}  
						}
					}
					Array.forEach(this._parentNodes, function (node) {
						node._dirty.colors = true;
					});
                }
				else if (fieldName == "normal")
                {                 
					pnts = this._cf.normal.node._vf.vector;
						
					if (this._vf.normalPerVertex) { 
						
						this._mesh._normals[0] = pnts.toGL();
							
					} else if (!this._vf.normalPerVertex) {
							
						var indexes = this._vf.index;
						this._mesh._normals[0] = [];
						
						var faceCnt = 0;
						for (var i=0; i < indexes.length; ++i)
						{
							if ((i > 0) && (i % 3 === 0 )) {                   
								faceCnt++;							
							}	
							
							this._mesh._normals[0].push(pnts[faceCnt].x);
							this._mesh._normals[0].push(pnts[faceCnt].y);
							this._mesh._normals[0].push(pnts[faceCnt].z);	
						}
					}

					Array.forEach(this._parentNodes, function (node) {
						 node._dirty.normals = true;
					});
                }
				else if (fieldName == "texCoord")
                {
                    var texCoordNode = this._cf.texCoord.node;
                    if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                        if (texCoordNode._cf.texCoord.nodes.length)
                            texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                    }
                    pnts = texCoordNode._vf.point;
                    
                    this._mesh._texCoords[0] = pnts.toGL();
                    
                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.texcoords = true;
                    });
                }
                // TODO: index
            }
        }
    )
);


/* ### IndexedTriangleStripSet ### */
x3dom.registerNodeType(
    "IndexedTriangleStripSet",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DComposedGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.IndexedTriangleStripSet.superClass.call(this, ctx);
			
            this.addField_MFInt32(ctx, 'index', []);

            this._hasIndexOffset = false;
            this._indexOffset = null;
        },
        {
            hasIndexOffset: function() {
                return this._hasIndexOffset;
            },

            nodeChanged: function() 
            {
                this.handleAttribs();   // check if method is still functional
	
                var hasNormal = false, hasTexCoord = false, hasColor = false;

                var colPerVert = this._vf.colorPerVertex;
                var normPerVert = this._vf.normalPerVertex;

                var indexes = this._vf.index;
				var positions, normals, texCoords, colors;

                var coordNode = this._cf.coord.node;
                x3dom.debug.assert(coordNode);
                positions = coordNode._vf.point;

                var normalNode = this._cf.normal.node;
                if (normalNode) {
                    hasNormal = true;
                    normals = normalNode._vf.vector;
                }
                else {
                    hasNormal = false;
                }

                var texMode = "", numTexComponents = 2;
                var texCoordNode = this._cf.texCoord.node;
                if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                    if (texCoordNode._cf.texCoord.nodes.length)
                        texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                }
                if (texCoordNode) {
                    if (texCoordNode._vf.point) {
                        hasTexCoord = true;
                        texCoords = texCoordNode._vf.point;

                        if (x3dom.isa(texCoordNode, x3dom.nodeTypes.TextureCoordinate3D)) {
                            numTexComponents = 3;
                        }
                    }
                    else if (texCoordNode._vf.mode) {
                        texMode = texCoordNode._vf.mode;
                    }
                }
                else {
                    hasTexCoord = false;
                }
				this._mesh._numTexComponents = numTexComponents;

                var numColComponents = 3;
                var colorNode = this._cf.color.node;
                if (colorNode) {
                    hasColor = true;
                    colors = colorNode._vf.color;

                    if (x3dom.isa(colorNode, x3dom.nodeTypes.ColorRGBA)) {
                        numColComponents = 4;
                    }
                }
                else {
                    hasColor = false;
                }
				this._mesh._numColComponents = numColComponents;
				
                this._mesh._indices[0] = [];
                this._mesh._positions[0] = [];
                this._mesh._normals[0] = [];
                this._mesh._texCoords[0] = [];
                this._mesh._colors[0] = [];

                this.invalidateVolume();
                this._mesh._numFaces = 0;
                this._mesh._numCoords = 0;
				
				var faceCnt = 0, cnt = 0;
				
				if (hasNormal && positions.length <= x3dom.Utils.maxIndexableCoords)
				{
                    this._hasIndexOffset = true;
                    this._indexOffset = [];
					this._mesh._primType = 'TRIANGLESTRIP';

                    var indexOffset = [ 0 ];
					
					for (i=0; i<indexes.length; i++)
					{
						if (indexes[i] == -1) {
							faceCnt++;
							indexOffset.push(this._mesh._indices[0].length);
						}
						else {
						    this._mesh._indices[0].push(+indexes[i]);
							
							if(!normPerVert) {
								this._mesh._normals[0].push(normals[faceCnt].x);
								this._mesh._normals[0].push(normals[faceCnt].y);
								this._mesh._normals[0].push(normals[faceCnt].z);
							}
							if(!colPerVert) {							
								this._mesh._colors[0].push(colors[faceCnt].r);
								this._mesh._colors[0].push(colors[faceCnt].g);
								this._mesh._colors[0].push(colors[faceCnt].b);
								if (numColComponents === 4) {
									this._mesh._colors[0].push(colors[faceCnt].a);
								}   
							}  
						}
					}
					
					this._mesh._positions[0] = positions.toGL();	
                    
					if(normPerVert) {
						this._mesh._normals[0] = normals.toGL();
					}
                    
                    if (hasTexCoord) {
                        this._mesh._texCoords[0] = texCoords.toGL();
                        this._mesh._numTexComponents = numTexComponents;
                    }
                    else {
                        x3dom.debug.logWarning("IndexedTriangleStripSet: no texCoords given and won't calculate!");
                    }
                    
                    if (hasColor) {
						if(colPerVert) {
							this._mesh._colors[0] = colors.toGL();        
						}     
						this._mesh._numColComponents = numColComponents;
                    }
                    
                    for (i=1; i<indexOffset.length; i++) {
                        var triCnt = indexOffset[i] - indexOffset[i-1];
                        this._indexOffset.push( {
                            count: triCnt,
                            offset: 2 * indexOffset[i-1]
                        } );

                        this._mesh._numFaces += (triCnt - 2);
                    }
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;
				} 
				else 
				{
                    this._hasIndexOffset = false;

				    var p1, p2 , p3, n1, n2, n3, t1, t2, t3, c1, c2, c3;
				    
				    var swapOrder = false;
				    
					for (var i=1; i < indexes.length-2; ++i)
					{
						if (indexes[i+1] == -1) {
							i = i+2;
							faceCnt++;
							continue;
						}
						
						// care for counterclockwise point order
						if (swapOrder) {
    						p1 = indexes[i];
    						p2 = indexes[i-1];
    						p3 = indexes[i+1];
						}
						else {
    						p1 = indexes[i-1];
    						p2 = indexes[i];
    						p3 = indexes[i+1];  
						}
						swapOrder = !swapOrder;
						
						if (normPerVert) { 
							n1 = p1;
							n2 = p2;
							n3 = p3;
						} else if (!normPerVert) {
							n1 = n2 = n3 = faceCnt;
						}
						 
						t1 = p1;
						t2 = p2;
						t3 = p3;

						if (colPerVert) {
							c1 = p1;
							c2 = p2;
							c3 = p3;
						} else if (!colPerVert) { 
							c1 = c2 = c3 = faceCnt;
						}
	
						this._mesh._indices[0].push(cnt++, cnt++, cnt++);				
						
						this._mesh._positions[0].push(positions[p1].x);
						this._mesh._positions[0].push(positions[p1].y);
						this._mesh._positions[0].push(positions[p1].z);
						this._mesh._positions[0].push(positions[p2].x);
						this._mesh._positions[0].push(positions[p2].y);
						this._mesh._positions[0].push(positions[p2].z);
						this._mesh._positions[0].push(positions[p3].x);
						this._mesh._positions[0].push(positions[p3].y);
						this._mesh._positions[0].push(positions[p3].z);
					   
						if (hasNormal) {
							this._mesh._normals[0].push(normals[n1].x);
							this._mesh._normals[0].push(normals[n1].y);
							this._mesh._normals[0].push(normals[n1].z);
							this._mesh._normals[0].push(normals[n2].x);
							this._mesh._normals[0].push(normals[n2].y);
							this._mesh._normals[0].push(normals[n2].z);
							this._mesh._normals[0].push(normals[n3].x);
							this._mesh._normals[0].push(normals[n3].y);
							this._mesh._normals[0].push(normals[n3].z);
						}
	
						if (hasColor) {
							this._mesh._colors[0].push(colors[c1].r);
							this._mesh._colors[0].push(colors[c1].g);
							this._mesh._colors[0].push(colors[c1].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(colors[c1].a);
							}    
							this._mesh._colors[0].push(colors[c2].r);
							this._mesh._colors[0].push(colors[c2].g);
							this._mesh._colors[0].push(colors[c2].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(colors[c2].a);
							}    
							this._mesh._colors[0].push(colors[c3].r);
							this._mesh._colors[0].push(colors[c3].g);
							this._mesh._colors[0].push(colors[c3].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(colors[c3].a);
							}    
						}
	
						if (hasTexCoord) {
							this._mesh._texCoords[0].push(texCoords[t1].x);
							this._mesh._texCoords[0].push(texCoords[t1].y);
							if (numTexComponents === 3) {
								this._mesh._texCoords[0].push(texCoords[t1].z);
							}
							this._mesh._texCoords[0].push(texCoords[t2].x);
							this._mesh._texCoords[0].push(texCoords[t2].y);
							if (numTexComponents === 3) {
								this._mesh._texCoords[0].push(texCoords[t2].z);
							}
							this._mesh._texCoords[0].push(texCoords[t3].x);
							this._mesh._texCoords[0].push(texCoords[t3].y);
							if (numTexComponents === 3) {
								this._mesh._texCoords[0].push(texCoords[t3].z);
							}
						}						
					}
					
					if (!hasNormal) {
						this._mesh.calcNormals(Math.PI);
					}
					
					if (!hasTexCoord) {
					  this._mesh.calcTexCoords(texMode);
					}
			
					this._mesh.splitMesh();

                    this.invalidateVolume();

                    for (i=0; i<this._mesh._indices.length; i++) {
                        this._mesh._numFaces += this._mesh._indices[i].length / 3;
                        this._mesh._numCoords += this._mesh._positions[i].length / 3;
                    }
				}
            },
            
            fieldChanged: function(fieldName)
            {
                if (fieldName != "coord" && fieldName != "normal" &&
    				fieldName != "texCoord" && fieldName != "color")
    			{
    			    x3dom.debug.logWarning("IndexedTriangleStripSet: fieldChanged for " +
    			                           fieldName + " not yet implemented!");
    			    return;
    			}
        		
                var pnts = this._cf.coord.node._vf.point;
                
				if ((this._cf.normal.node === null) || (pnts.length > x3dom.Utils.maxIndexableCoords))
                {
					if (fieldName == "coord") {
						this._mesh._positions[0] = [];
						this._mesh._indices[0] =[];
						this._mesh._normals[0] = [];
						this._mesh._texCoords[0] =[];
			
						var hasNormal = false, hasTexCoord = false, hasColor = false;
	
						var colPerVert = this._vf.colorPerVertex;
						var normPerVert = this._vf.normalPerVertex;
		
						var indexes = this._vf.index;
						var positions, normals, texCoords, colors;
		
						var coordNode = this._cf.coord.node;
						x3dom.debug.assert(coordNode);
						positions = coordNode._vf.point;
		
						var normalNode = this._cf.normal.node;
						if (normalNode) {
							hasNormal = true;
							normals = normalNode._vf.vector;
						}
						else {
							hasNormal = false;
						}
		
						var texMode = "", numTexComponents = 2;
                        var texCoordNode = this._cf.texCoord.node;
                        if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                            if (texCoordNode._cf.texCoord.nodes.length)
                                texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                        }
						if (texCoordNode) {
							if (texCoordNode._vf.point) {
								hasTexCoord = true;
								texCoords = texCoordNode._vf.point;
		
								if (x3dom.isa(texCoordNode, x3dom.nodeTypes.TextureCoordinate3D)) {
									numTexComponents = 3;
								}
							}
							else if (texCoordNode._vf.mode) {
								texMode = texCoordNode._vf.mode;
							}
						}
						else {
							hasTexCoord = false;
						}
						this._mesh._numTexComponents = numTexComponents;
		
						var numColComponents = 3;
						var colorNode = this._cf.color.node;
						if (colorNode) {
							hasColor = true;
							colors = colorNode._vf.color;
		
							if (x3dom.isa(colorNode, x3dom.nodeTypes.ColorRGBA)) {
								numColComponents = 4;
							}
						}
						else {
							hasColor = false;
						}
						this._mesh._numColComponents = numColComponents;
						
						this._mesh._indices[0] = [];
						this._mesh._positions[0] = [];
						this._mesh._normals[0] = [];
						this._mesh._texCoords[0] = [];
						this._mesh._colors[0] = [];
						
						var faceCnt = 0, cnt = 0;
						var p1, p2 , p3, n1, n2, n3, t1, t2, t3, c1, c2, c3;
						var swapOrder = false;
						 
						if ( hasNormal  || hasTexCoord || hasColor) {
							
							for (var i=1; i < indexes.length-2; ++i)
							{
								if (indexes[i+1] == -1) {
									i = i+2;
									faceCnt++;
									continue;
								}
								
								if (swapOrder) {
									p1 = indexes[i];
									p2 = indexes[i-1];
									p3 = indexes[i+1];
								}
								else {
									p1 = indexes[i-1];
									p2 = indexes[i];
									p3 = indexes[i+1];  
								}
								swapOrder = !swapOrder;
								
								if (normPerVert) { 
									n1 = p1;
									n2 = p2;
									n3 = p3;
								} else if (!normPerVert) {
									n1 = n2 = n3 = faceCnt;
								}
								 
								t1 = p1;
								t2 = p2;
								t3 = p3;
		
								if (colPerVert) {
									c1 = p1;
									c2 = p2;
									c3 = p3;
								} else if (!colPerVert) { 
									c1 = c2 = c3 = faceCnt;
								}
			
								this._mesh._indices[0].push(cnt++, cnt++, cnt++);				
								
								this._mesh._positions[0].push(positions[p1].x);
								this._mesh._positions[0].push(positions[p1].y);
								this._mesh._positions[0].push(positions[p1].z);
								this._mesh._positions[0].push(positions[p2].x);
								this._mesh._positions[0].push(positions[p2].y);
								this._mesh._positions[0].push(positions[p2].z);
								this._mesh._positions[0].push(positions[p3].x);
								this._mesh._positions[0].push(positions[p3].y);
								this._mesh._positions[0].push(positions[p3].z);
							   
								if (hasNormal) {
									this._mesh._normals[0].push(normals[n1].x);
									this._mesh._normals[0].push(normals[n1].y);
									this._mesh._normals[0].push(normals[n1].z);
									this._mesh._normals[0].push(normals[n2].x);
									this._mesh._normals[0].push(normals[n2].y);
									this._mesh._normals[0].push(normals[n2].z);
									this._mesh._normals[0].push(normals[n3].x);
									this._mesh._normals[0].push(normals[n3].y);
									this._mesh._normals[0].push(normals[n3].z);
								}
			
								if (hasColor) {
									this._mesh._colors[0].push(colors[c1].r);
									this._mesh._colors[0].push(colors[c1].g);
									this._mesh._colors[0].push(colors[c1].b);
									if (numColComponents === 4) {
										this._mesh._colors[0].push(colors[c1].a);
									}    
									this._mesh._colors[0].push(colors[c2].r);
									this._mesh._colors[0].push(colors[c2].g);
									this._mesh._colors[0].push(colors[c2].b);
									if (numColComponents === 4) {
										this._mesh._colors[0].push(colors[c2].a);
									}    
									this._mesh._colors[0].push(colors[c3].r);
									this._mesh._colors[0].push(colors[c3].g);
									this._mesh._colors[0].push(colors[c3].b);
									if (numColComponents === 4) {
										this._mesh._colors[0].push(colors[c3].a);
									}    
								}
			
								if (hasTexCoord) {
									this._mesh._texCoords[0].push(texCoords[t1].x);
									this._mesh._texCoords[0].push(texCoords[t1].y);
									if (numTexComponents === 3) {
										this._mesh._texCoords[0].push(texCoords[t1].z);
									}
									this._mesh._texCoords[0].push(texCoords[t2].x);
									this._mesh._texCoords[0].push(texCoords[t2].y);
									if (numTexComponents === 3) {
										this._mesh._texCoords[0].push(texCoords[t2].z);
									}
									this._mesh._texCoords[0].push(texCoords[t3].x);
									this._mesh._texCoords[0].push(texCoords[t3].y);
									if (numTexComponents === 3) {
										this._mesh._texCoords[0].push(texCoords[t3].z);
									}
								}						
							}
							
							if (!hasNormal) {
								this._mesh.calcNormals(Math.PI);
							}
							
							if (!hasTexCoord) {
							  this._mesh.calcTexCoords(texMode);
							}
					
							this._mesh.splitMesh();
			
						} else {
							var swapOrder = false;
							for (var i = 1; i < indexes.length; ++i)
							{
								if (indexes[i+1] == -1) {
									i = i+2;
									continue;
								}
								
								if (swapOrder) {
									this._mesh._indices[0].push(indexes[i]);
									this._mesh._indices[0].push(indexes[i-1]);
									this._mesh._indices[0].push(indexes[i+1]);
								}
								else {
									this._mesh._indices[0].push(indexes[i-1]);
									this._mesh._indices[0].push(indexes[i]);
									this._mesh._indices[0].push(indexes[i+1]);
								}
								swapOrder = !swapOrder;
							}
							
							this._mesh._positions[0] = positions.toGL();
			
							if (hasNormal) {
								this._mesh._normals[0] = normals.toGL();
							}
							else {
								this._mesh.calcNormals(Math.PI);
							}
							if (hasTexCoord) {
								this._mesh._texCoords[0] = texCoords.toGL();
								this._mesh._numTexComponents = numTexComponents;
							}
							else {
								this._mesh.calcTexCoords(texMode);
							}
							if (hasColor) {
								this._mesh._colors[0] = colors.toGL();
								this._mesh._numColComponents = numColComponents;
							}
							
						}

                        this.invalidateVolume();
						this._mesh._numFaces = 0;
						this._mesh._numCoords = 0;
						
						for (i=0; i<this._mesh._indices.length; i++) {
							this._mesh._numFaces += this._mesh._indices[i].length / 3;
							this._mesh._numCoords += this._mesh._positions[i].length / 3;
						}
		
						Array.forEach(this._parentNodes, function (node) {
							node.setAllDirty();
                            node.invalidateVolume();
						});
					}
					else if (fieldName == "color") {
						var col = this._cf.color.node._vf.color;
						var faceCnt = 0;
						var c1 = c2 = c3 = 0;
						
						var numColComponents = 3;	
					   
						if (x3dom.isa(this._cf.color.node, x3dom.nodeTypes.ColorRGBA)) {
							numColComponents = 4;
						}
						
						this._mesh._colors[0] = [];
						
						var indexes = this._vf.index;
						var swapOrder = false;
						
						for (i=1; i < indexes.length-2; ++i)
						{
							if (indexes[i+1] == -1) {
								i = i+2;
								faceCnt++;
								continue;
							}
								
							if (this._vf.colorPerVertex) { 
								if (swapOrder) {
									c1 = indexes[i];
									c2 = indexes[i-1];
									c3 = indexes[i+1];
								}
								else {
									c1 = indexes[i-1];
									c2 = indexes[i];
									c3 = indexes[i+1];	
								}
								swapOrder = !swapOrder;
							} else if (!this._vf.colorPerVertex) {
								c1 = c2 = c3 = faceCnt;
							}
							this._mesh._colors[0].push(col[c1].r);
							this._mesh._colors[0].push(col[c1].g);
							this._mesh._colors[0].push(col[c1].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(col[c1].a);
							}  
							this._mesh._colors[0].push(col[c2].r);
							this._mesh._colors[0].push(col[c2].g);
							this._mesh._colors[0].push(col[c2].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(col[c2].a);
							}  
							this._mesh._colors[0].push(col[c3].r);
							this._mesh._colors[0].push(col[c3].g);
							this._mesh._colors[0].push(col[c3].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(col[c3].a);
							}  
						}
						
						Array.forEach(this._parentNodes, function (node) {
							node._dirty.colors = true;
						}); 
					}  
					else if (fieldName == "normal") {
					    var nor = this._cf.normal.node._vf.vector;
					    var faceCnt = 0;
						var n1 = n2 = n3 = 0;
						
						this._mesh._normals[0] = [];
						
						var indexes = this._vf.index;
						var swapOrder = false;
							
						for (i=1; i < indexes.length-2; ++i)
						{
							if (indexes[i+1] == -1) {
								i = i+2;
								faceCnt++;
								continue;
							}
							
							if (this._vf.normalPerVertex) { 
								if (swapOrder) {
									n1 = indexes[i];
									n2 = indexes[i-1];
									n3 = indexes[i+1];
								}
								else {
									n1 = indexes[i-1];
									n2 = indexes[i];
									n3 = indexes[i+1];	
								}
								swapOrder = !swapOrder;
							} else if (!this._vf.normalPerVertex) {
								n1 = n2 = n3 = faceCnt;
							}
							this._mesh._normals[0].push(nor[n1].x);
							this._mesh._normals[0].push(nor[n1].y);
							this._mesh._normals[0].push(nor[n1].z);
							this._mesh._normals[0].push(nor[n2].x);
							this._mesh._normals[0].push(nor[n2].y);
							this._mesh._normals[0].push(nor[n2].z);
							this._mesh._normals[0].push(nor[n3].x);
							this._mesh._normals[0].push(nor[n3].y);
							this._mesh._normals[0].push(nor[n3].z);
						}
						
						Array.forEach(this._parentNodes, function (node) {
							node._dirty.normals = true;
						}); 
					}
					else if (fieldName == "texCoord") {
                        var texCoordNode = this._cf.texCoord.node;
                        if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                            if (texCoordNode._cf.texCoord.nodes.length)
                                texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                        }
						var tex = texCoordNode._vf.point;
						var t1 = t2 = t3 = 0;
						
						var numTexComponents = 2;	
					   
						if (x3dom.isa(texCoordNode, x3dom.nodeTypes.TextureCoordinate3D)) {
							numTexComponents = 3;
						}
						
						this._mesh._texCoords[0] = [];
						var indexes = this._vf.index;
						var swapOrder = false;
						
						for (i=1; i < indexes.length-2; ++i)
						{
							if (indexes[i+1] == -1) {
								i = i+2;
								continue;
							}
							
							if (swapOrder) {
								t1 = indexes[i];
								t2 = indexes[i-1];
								t3 = indexes[i+1];
							}
							else {
								t1 = indexes[i-1];
								t2 = indexes[i];
								t3 = indexes[i+1];	
							}
							swapOrder = !swapOrder;
							
							this._mesh._texCoords[0].push(tex[t1].x);
							this._mesh._texCoords[0].push(tex[t1].y);
							if (numTexComponents === 3) {
								this._mesh._texCoords[0].push(tex[t1].z);
							}  
							this._mesh._texCoords[0].push(tex[t2].x);
							this._mesh._texCoords[0].push(tex[t2].y);                       
							if (numTexComponents === 3) {
								this._mesh._texCoords[0].tex(col[t2].z);
							}  
							this._mesh._texCoords[0].push(tex[t3].x);
							this._mesh._texCoords[0].push(tex[t3].y);               
							if (numTexComponents === 3) {
								this._mesh._texCoords[0].push(tex[t3].z);
							}  
						}
						
						Array.forEach(this._parentNodes, function (node) {
							node._dirty.texcoords = true;
						}); 
					}
                }
				else
				{
					if (fieldName == "coord")
					{
						this._mesh._positions[0] = pnts.toGL();
						
						// tells the mesh that its bbox requires update
                        this.invalidateVolume();
	
						Array.forEach(this._parentNodes, function (node) {					
							node._dirty.positions = true;
                            node.invalidateVolume();
						});
					}
					else if (fieldName == "color")
					{ 
						pnts = this._cf.color.node._vf.color;
						
						if (this._vf.colorPerVertex) { 
						
							this._mesh._colors[0] = pnts.toGL();	
							
						} else if (!this._vf.colorPerVertex) {
							
							var faceCnt = 0;
							var numColComponents = 3;	
                   
							if (x3dom.isa(this._cf.color.node, x3dom.nodeTypes.ColorRGBA)) {
								numColComponents = 4;
							}
							
							this._mesh._colors[0] = [];
							
							var indexes = this._vf.index;
							for (i=0; i < indexes.length; ++i)
							{
								if (indexes[i] == -1) {	
									faceCnt++;
									continue;
								}
								
								this._mesh._colors[0].push(pnts[faceCnt].r);
								this._mesh._colors[0].push(pnts[faceCnt].g);
								this._mesh._colors[0].push(pnts[faceCnt].b);
								if (numColComponents === 4) {
									this._mesh._colors[0].push(pnts[faceCnt].a);
								}  
							}
						}

						Array.forEach(this._parentNodes, function (node) {
							node._dirty.colors = true;
						});
					}
					else if (fieldName == "normal")
					{
						pnts = this._cf.normal.node._vf.vector;
						
						if (this._vf.normalPerVertex) { 
						
							this._mesh._normals[0] = pnts.toGL();
							
						} else if (!this._vf.normalPerVertex) {
							
							var indexes = this._vf.index;
							this._mesh._normals[0] = [];
							
							var faceCnt = 0;
							for (i=0; i < indexes.length; ++i)
							{
								if (indexes[i] == -1) {					
									faceCnt++;
									continue;
								}
								
								this._mesh._normals[0].push(pnts[faceCnt].x);
								this._mesh._normals[0].push(pnts[faceCnt].y);
								this._mesh._normals[0].push(pnts[faceCnt].z);	
							}
						}

						Array.forEach(this._parentNodes, function (node) {
							 node._dirty.normals = true;
						});
					}
					else if (fieldName == "texCoord")
					{
                        var texCoordNode = this._cf.texCoord.node;
                        if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                            if (texCoordNode._cf.texCoord.nodes.length)
                                texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                        }
						pnts = texCoordNode._vf.point;
						
						this._mesh._texCoords[0] = pnts.toGL();
						
						Array.forEach(this._parentNodes, function (node) {
							node._dirty.texcoords = true;
						});
					}
				}
            }
        }
    )
);


/* ### X3DGeometricPropertyNode ### */
x3dom.registerNodeType(
    "X3DGeometricPropertyNode",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.X3DGeometricPropertyNode.superClass.call(this, ctx);
        }
    )
);

/* ### X3DCoordinateNode ### */
x3dom.registerNodeType(
    "X3DCoordinateNode",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DGeometricPropertyNode,
        function (ctx) {
            x3dom.nodeTypes.X3DCoordinateNode.superClass.call(this, ctx);
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName === "coord" || fieldName === "point") {
                    Array.forEach(this._parentNodes, function (node) {
                        node.fieldChanged("coord");
                    });
                }
            },

            parentAdded: function (parent) {
                if (parent._mesh && parent._cf.coord.node !== this) {
                    parent.fieldChanged("coord");
                }
            }
        }
      )
);


/* ### Coordinate ### */
x3dom.registerNodeType(
    "Coordinate",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DCoordinateNode,
        function (ctx) {
            x3dom.nodeTypes.Coordinate.superClass.call(this, ctx);

            this.addField_MFVec3f(ctx, 'point', []);
        },
        {
            getPoints: function() {
                return this._vf.point;
            }
        }
    )
);


/* ### Normal ### */
x3dom.registerNodeType(
    "Normal",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DGeometricPropertyNode,
        function (ctx) {
            x3dom.nodeTypes.Normal.superClass.call(this, ctx);

            this.addField_MFVec3f(ctx, 'vector', []);
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName === "normal" || fieldName === "vector") {
                    Array.forEach(this._parentNodes, function (node) {
                        node.fieldChanged("normal");
                    });
                }
            },

            parentAdded: function (parent) {
                if (parent._mesh && //parent._cf.coord.node &&
                    parent._cf.normal.node !== this) {
                    parent.fieldChanged("normal");
                }
            }
        }
    )
);

/* ### X3DColorNode ### */
x3dom.registerNodeType(
    "X3DColorNode",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DGeometricPropertyNode,
        function (ctx) {
            x3dom.nodeTypes.X3DColorNode.superClass.call(this, ctx);
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName === "color") {
                    Array.forEach(this._parentNodes, function (node) {
                        node.fieldChanged("color");
                    });
                }
            },

            parentAdded: function (parent) {
                if (parent._mesh && //parent._cf.coord.node &&
                    parent._cf.color.node !== this) {
                    parent.fieldChanged("color");
                }
            }
        }
    )
);

/* ### Color ### */
x3dom.registerNodeType(
    "Color",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DColorNode,
        function (ctx) {
            x3dom.nodeTypes.Color.superClass.call(this, ctx);

            this.addField_MFColor(ctx, 'color', []);
        }
    )
);

/* ### ColorRGBA ### */
x3dom.registerNodeType(
    "ColorRGBA",
    "Rendering",
    defineClass(x3dom.nodeTypes.X3DColorNode,
        function (ctx) {
            x3dom.nodeTypes.ColorRGBA.superClass.call(this, ctx);

            this.addField_MFColorRGBA(ctx, 'color', []);
        }
    )
);


/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/* ### X3DAppearanceNode ### */
x3dom.registerNodeType(
    "X3DAppearanceNode",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.X3DAppearanceNode.superClass.call(this, ctx);
        }
    )
);

/* ### Appearance ### */
x3dom.registerNodeType(
    "Appearance",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DAppearanceNode,
        function (ctx) {
            x3dom.nodeTypes.Appearance.superClass.call(this, ctx);

            this.addField_SFNode('material', x3dom.nodeTypes.X3DMaterialNode);
            this.addField_SFNode('texture',  x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('textureTransform', x3dom.nodeTypes.X3DTextureTransformNode);
            this.addField_SFNode('lineProperties', x3dom.nodeTypes.LineProperties);
            this.addField_SFNode('colorMaskMode', x3dom.nodeTypes.ColorMaskMode);
            this.addField_SFNode('blendMode', x3dom.nodeTypes.BlendMode);
            this.addField_SFNode('depthMode', x3dom.nodeTypes.DepthMode);
            this.addField_MFNode('shaders', x3dom.nodeTypes.X3DShaderNode);
			this.addField_SFString(ctx, 'sortType', 'auto');      // [auto, transparent, opaque]
            this.addField_SFInt32(ctx, 'sortKey', 0);             // Change render order manually

            // shortcut to shader program
            this._shader = null;
        },
        {
            nodeChanged: function() {
				//TODO delete this if all works fine
                if (!this._cf.material.node) {
					//Unlit
                    //this.addChild(x3dom.nodeTypes.Material.defaultNode());
                }

                if (this._cf.shaders.nodes.length) {
                    this._shader = this._cf.shaders.nodes[0];
                }
				
				this.checkSortType();
            },

            checkSortType: function() {
                if (this._vf.sortType == 'auto') {
                    if (this._cf.material.node && this._cf.material.node._vf.transparency > 0) {
                        this._vf.sortType = 'transparent';
                    }
                    else if (this._cf.texture.node && this._cf.texture.node._vf.url.length) {
                        // uhh, this is a rather coarse guess...
                        if (this._cf.texture.node._vf.url[0].toLowerCase().indexOf('.'+'png') >= 0) {
                            this._vf.sortType = 'transparent';
                        }
                        else {
                            this._vf.sortType = 'opaque';
                        }
                    }
                    else {
                        this._vf.sortType = 'opaque';
                    }
                }
            },

            texTransformMatrix: function() {
                if (this._cf.textureTransform.node === null) {
                    return x3dom.fields.SFMatrix4f.identity();
                }
                else {
                    return this._cf.textureTransform.node.texTransformMatrix();
                }
            },

            parentAdded: function(parent) {
                if (this != x3dom.nodeTypes.Appearance._defaultNode) {
                    /*if (parent._cleanupGLObjects) {
                        parent._cleanupGLObjects(true);
                    }*/
                    parent.setAppDirty();
                }
            }
        }
    )
);

x3dom.nodeTypes.Appearance.defaultNode = function() {
    if (!x3dom.nodeTypes.Appearance._defaultNode) {
        x3dom.nodeTypes.Appearance._defaultNode = new x3dom.nodeTypes.Appearance();
        x3dom.nodeTypes.Appearance._defaultNode.nodeChanged();
    }
    return x3dom.nodeTypes.Appearance._defaultNode;
};

/* ### X3DAppearanceChildNode ### */
x3dom.registerNodeType(
    "X3DAppearanceChildNode",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.X3DAppearanceChildNode.superClass.call(this, ctx);
        }
    )
);

/* ### BlendMode ### */
x3dom.registerNodeType(
    "BlendMode",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DAppearanceChildNode,
        function (ctx) {
            x3dom.nodeTypes.BlendMode.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'srcFactor', "src_alpha");
            this.addField_SFString(ctx, 'destFactor', "one_minus_src_alpha");
            this.addField_SFColor(ctx, 'color', 1, 1, 1);
            this.addField_SFFloat(ctx, 'colorTransparency', 0);
            this.addField_SFString(ctx, 'alphaFunc', "none");
            this.addField_SFFloat(ctx, 'alphaFuncValue', 0);
            this.addField_SFString(ctx, 'equation', "none");
        }
    )
);

/* ### DepthMode ### */
x3dom.registerNodeType(
    "DepthMode",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DAppearanceChildNode,
        function (ctx) {
            x3dom.nodeTypes.DepthMode.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'enableDepthTest', true);
            this.addField_SFString(ctx, 'depthFunc', "none");
            this.addField_SFBool(ctx, 'readOnly', false);
            this.addField_SFFloat(ctx, 'zNearRange', -1);
            this.addField_SFFloat(ctx, 'zFarRange', -1);
        }
    )
);

/* ### ColorMaskMode ### */
x3dom.registerNodeType(
    "ColorMaskMode",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DAppearanceChildNode,
        function (ctx) {
            x3dom.nodeTypes.ColorMaskMode.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'maskR', true);
            this.addField_SFBool(ctx, 'maskG', true);
            this.addField_SFBool(ctx, 'maskB', true);
            this.addField_SFBool(ctx, 'maskA', true);
        }
    )
);

/* ### LineProperties ### */
x3dom.registerNodeType(
    "LineProperties",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DAppearanceChildNode,
        function (ctx) {
            x3dom.nodeTypes.LineProperties.superClass.call(this, ctx);

            // http://www.web3d.org/files/specifications/19775-1/V3.2/Part01/components/shape.html#LineProperties
            // THINKABOUTME: to my mind, the only useful, but missing, field is linewidth (scaleFactor is overhead)
            this.addField_SFBool(ctx, 'applied', true);
            this.addField_SFInt32(ctx, 'linetype', 1);
            this.addField_SFFloat(ctx, 'linewidthScaleFactor', 0);
        }
    )
);


/* ### X3DMaterialNode ### */
x3dom.registerNodeType(
    "X3DMaterialNode",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DAppearanceChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DMaterialNode.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'ambientIntensity', 0.2);
            this.addField_SFColor(ctx, 'diffuseColor', 0.8, 0.8, 0.8);
            this.addField_SFColor(ctx, 'emissiveColor', 0, 0, 0);
            this.addField_SFFloat(ctx, 'shininess', 0.2);
            this.addField_SFColor(ctx, 'specularColor', 0, 0, 0);
            this.addField_SFFloat(ctx, 'transparency', 0);
        }
    )
);

/* ### Material ### */
x3dom.registerNodeType(
    "Material",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DMaterialNode,
        function (ctx) {
            x3dom.nodeTypes.Material.superClass.call(this, ctx);
        },
		{
			fieldChanged: function(fieldName) {
				if (fieldName == "ambientIntensity" || fieldName == "diffuseColor" ||
					fieldName == "emissiveColor" || fieldName == "shininess" ||
					fieldName == "specularColor" || fieldName == "transparency")
                {
                    Array.forEach(this._parentNodes, function (app) {
                        Array.forEach(app._parentNodes, function (shape) {
                            shape._dirty.material = true;
                        });
                        app.checkSortType();
                    });
                }
			}
		}
    )
);

x3dom.nodeTypes.Material.defaultNode = function() {
    if (!x3dom.nodeTypes.Material._defaultNode) {
        x3dom.nodeTypes.Material._defaultNode = new x3dom.nodeTypes.Material();
        x3dom.nodeTypes.Material._defaultNode.nodeChanged();
    }
    return x3dom.nodeTypes.Material._defaultNode;
};

/* ### TwoSidedMaterial ### */
x3dom.registerNodeType(
    "TwoSidedMaterial",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DMaterialNode,
        function (ctx) {
            x3dom.nodeTypes.TwoSidedMaterial.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'backAmbientIntensity', 0.2);
            this.addField_SFColor(ctx, 'backDiffuseColor', 0.8, 0.8, 0.8);
            this.addField_SFColor(ctx, 'backEmissiveColor', 0, 0, 0);
            this.addField_SFFloat(ctx, 'backShininess', 0.2);
            this.addField_SFColor(ctx, 'backSpecularColor', 0, 0, 0);
            this.addField_SFFloat(ctx, 'backTransparency', 0);
            this.addField_SFBool(ctx, 'separateBackColor', false);
        },
        {
            fieldChanged: function(fieldName) {
                if (fieldName == "ambientIntensity" || fieldName == "diffuseColor" ||
                    fieldName == "emissiveColor" || fieldName == "shininess" ||
                    fieldName == "specularColor" || fieldName == "transparency" ||
                    fieldName == "backAmbientIntensity" || fieldName == "backDiffuseColor" ||
                    fieldName == "backEmissiveColor" || fieldName == "backShininess" ||
                    fieldName == "backSpecularColor" || fieldName == "backTransparency" ||
                    fieldName == "separateBackColor")
                {
                    Array.forEach(this._parentNodes, function (app) {
                        Array.forEach(app._parentNodes, function (shape) {
                            shape._dirty.material = true;
                        });
                        app.checkSortType();
                    });
                }
            }
        }
    )
);


/* ### X3DShapeNode ### */
x3dom.registerNodeType(
    "X3DShapeNode",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DBoundedNode,
        function (ctx) {
            x3dom.nodeTypes.X3DShapeNode.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'isPickable', true);
            this.addField_SFNode('appearance', x3dom.nodeTypes.X3DAppearanceNode);
            this.addField_SFNode('geometry', x3dom.nodeTypes.X3DGeometryNode);

            this._objectID = 0;
            this._shaderProperties = null;
            
            // in WebGL-based renderer a clean-up function is attached
            this._cleanupGLObjects = null;

            this._dirty = {
                positions: true,
                normals: true,
                texcoords: true,
                colors: true,
                indexes: true,
                texture: true,
                material: true,
                text: true,
                shader: true
            };

            // FIXME; move somewhere else and allow generic values!!!
            this._coordStrideOffset = [0, 0];
            this._normalStrideOffset = [0, 0];
            this._texCoordStrideOffset = [0, 0];
            this._colorStrideOffset = [0, 0];

            this._tessellationProperties = [];
        },
        {
            collectDrawableObjects: function (transform, drawableCollection, singlePath, invalidateCache, planeMask)
            {
                // attention, in contrast to other collectDrawableObjects()
                // this one has boolean return type to better work with RSG
                var graphState = this.graphState();

                if (singlePath && (this._parentNodes.length > 1))
                    singlePath = false;

                if (singlePath && (invalidateCache = invalidateCache || this.cacheInvalid()))
                    this.invalidateCache();

                if (!this._cf.geometry.node ||
                    drawableCollection.cull(transform, graphState, singlePath, planeMask) <= 0) {
                    return false;
                }

                if (singlePath && !this._graph.globalMatrix)
                    this._graph.globalMatrix = transform;

                drawableCollection.addShape(this, transform, graphState);

                return true;
            },

            getVolume: function()
            {
                var vol = this._graph.volume;

                if (!this.volumeValid() && this._vf.render)
                {
                    var geo = this._cf.geometry.node;
                    var childVol = geo ? geo.getVolume() : null;

                    if (childVol && childVol.isValid())
                        vol.extendBounds(childVol.min, childVol.max);
                }

                return vol;
            },

            getCenter: function() {
                var geo = this._cf.geometry.node;
				return (geo ? geo.getCenter() : new x3dom.fields.SFVec3f(0,0,0));
            },

            getDiameter: function() {
                var geo = this._cf.geometry.node;
				return (geo ? geo.getDiameter() : 0);
            },

            doIntersect: function(line) {
                return this._cf.geometry.node.doIntersect(line);
            },

            forceUpdateCoverage: function()
            {
                var geo = this._cf.geometry.node;
                return (geo ? geo.forceUpdateCoverage() : false);
            },

            tessellationProperties: function()
            {
                // some geometries require offset and count into index array
                var geo = this._cf.geometry.node;
                if (geo && geo._indexOffset)
                    return geo._indexOffset;      // IndexedTriangleStripSet
                else
                    return this._tessellationProperties; // BVHRefiner-Patch
            },

            isSolid: function() {
                return this._cf.geometry.node._vf.solid;
            },

            isCCW: function() {
                return this._cf.geometry.node._vf.ccw;
            },

            parentRemoved: function(parent) {
                for (var i=0, n=this._childNodes.length; i<n; i++) {
                    var child = this._childNodes[i];
                    if (child) {
                        child.parentRemoved(this);
                    }
                }

                if (parent)
                    parent.invalidateVolume();
                if (this._parentNodes.length > 0)
                    this.invalidateVolume();

                // Cleans all GL objects for WebGL-based renderer
                if (this._cleanupGLObjects) {
                    this._cleanupGLObjects();
                }
            },
            
            unsetDirty: function () {
				// vertex attributes
				this._dirty.positions = false;
				this._dirty.normals = false;
				this._dirty.texcoords = false;
				this._dirty.colors =  false;
				// indices/topology
				this._dirty.indexes = false;
				// appearance properties
				this._dirty.texture = false;
				this._dirty.material = false;
				this._dirty.text = false;
				this._dirty.shader = false;
            },

            unsetGeoDirty: function () {
                this._dirty.positions = false;
                this._dirty.normals = false;
                this._dirty.texcoords = false;
                this._dirty.colors =  false;
                this._dirty.indexes = false;
            },
			
			setAllDirty: function () {
			    // vertex attributes
				this._dirty.positions = true;
				this._dirty.normals = true;
				this._dirty.texcoords = true;
				this._dirty.colors =  true;
				// indices/topology
				this._dirty.indexes = true;
				// appearance properties
				this._dirty.texture = true;
				this._dirty.material = true;
				this._dirty.text = true;
				this._dirty.shader = true;
                // finally invalidate volume
                this.invalidateVolume();
            },
            
            setAppDirty: function () {
				// appearance properties
				this._dirty.texture = true;
				this._dirty.material = true;
				//this._dirty.text = true;
				this._dirty.shader = true;
            },
            
            setGeoDirty: function () {
				this._dirty.positions = true;
				this._dirty.normals = true;
				this._dirty.texcoords = true;
				this._dirty.colors = true;
				this._dirty.indexes = true;
                // finally invalidate volume
                this.invalidateVolume();
            },

            getShaderProperties: function(viewarea) {
                if (this._shaderProperties == null || this._dirty.shader == true ||
                    (this._webgl !== undefined && this._webgl.dirtyLighting != x3dom.Utils.checkDirtyLighting(viewarea)))
                {
                    this._shaderProperties = x3dom.Utils.generateProperties(viewarea, this);
                    this._dirty.shader = false;
                    if (this._webgl !== undefined)
                    {
                        this._webgl.dirtyLighting = x3dom.Utils.checkDirtyLighting(viewarea);
                    }
                }

                return this._shaderProperties;
            },
			
			getTextures: function() {
				var textures = [];

                var appearance = this._cf.appearance.node;
                if (appearance) {
                    var tex = appearance._cf.texture.node;
                    if(tex) {
                        if(x3dom.isa(tex, x3dom.nodeTypes.MultiTexture)) {
                            textures = textures.concat(tex.getTextures());
                        }
                        else {
                            textures.push(tex);
                        }
                    }

                    var shader = appearance._cf.shaders.nodes[0];
                    if(shader) {
                        if(x3dom.isa(shader, x3dom.nodeTypes.CommonSurfaceShader)) {
                            textures = textures.concat(shader.getTextures());
                        }
                    }
                }

				var geometry = this._cf.geometry.node;
				if (geometry) {
					if(x3dom.isa(geometry, x3dom.nodeTypes.ImageGeometry)) {
						textures = textures.concat(geometry.getTextures());
					}
                    else if(x3dom.isa(geometry, x3dom.nodeTypes.Text)) {
						textures = textures.concat(geometry);
					}
				}
				
				return textures;
			}
        }
    )
);

/* ### Shape ### */
x3dom.registerNodeType(
    "Shape",
    "Shape",
    defineClass(x3dom.nodeTypes.X3DShapeNode,
        function (ctx) {
            x3dom.nodeTypes.Shape.superClass.call(this, ctx);
        },
        {
            nodeChanged: function () {
				//TODO delete this if all works fine
                if (!this._cf.appearance.node) {
					//Unlit
                    //this.addChild(x3dom.nodeTypes.Appearance.defaultNode());
                }
                if (!this._cf.geometry.node) {
                    if (this._DEF)
                        x3dom.debug.logError("No geometry given in Shape/" + this._DEF);
                }
                else if (!this._objectID) {
                    this._objectID = ++x3dom.nodeTypes.Shape.objectID;
                    x3dom.nodeTypes.Shape.idMap.nodeID[this._objectID] = this;
                }
                this.invalidateVolume();
            }
        }
    )
);

/** Static class ID counter (needed for picking) */
x3dom.nodeTypes.Shape.objectID = 0;

/** Map for Shape node IDs (needed for picking) */
x3dom.nodeTypes.Shape.idMap = {
    nodeID: {},
    remove: function(obj) {
        for (var prop in this.nodeID) {
            if (this.nodeID.hasOwnProperty(prop)) {
                var val = this.nodeID[prop];
                if (val._objectID  && obj._objectID &&
                    val._objectID === obj._objectID)
                {
                    delete this.nodeID[prop];
                    x3dom.debug.logInfo("Unreg " + val._objectID);
                    // FIXME; handle node removal to unreg from map,
                    // and put free'd ID back to ID pool for reuse
                }
            }
        }
    }
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### X3DLightNode ### */
x3dom.registerNodeType(
    "X3DLightNode",
    "Lighting",
    defineClass(x3dom.nodeTypes.X3DChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DLightNode.superClass.call(this, ctx);

            if (ctx)
                ctx.doc._nodeBag.lights.push(this);
            else
                x3dom.debug.logWarning("X3DLightNode: No runtime context found!");

			this._lightID = 0;
			this._dirty = true;
			
            this.addField_SFFloat(ctx, 'ambientIntensity', 0);
            this.addField_SFColor(ctx, 'color', 1, 1, 1);
            this.addField_SFFloat(ctx, 'intensity', 1);
            this.addField_SFBool(ctx, 'global', false);
            this.addField_SFBool(ctx, 'on', true);
            this.addField_SFFloat(ctx, 'shadowIntensity', 0);
			this.addField_SFInt32(ctx, 'shadowMapSize', 1024);
			this.addField_SFInt32(ctx, 'shadowFilterSize', 0);
            this.addField_SFFloat(ctx, 'shadowOffset', 0);
            this.addField_SFFloat(ctx, 'zNear', -1); 
            this.addField_SFFloat(ctx, 'zFar', -1);
        },
        {
            getViewMatrix: function(vec) {
                return x3dom.fields.SFMatrix4f.identity;
            },
			
			nodeChanged: function () {
				if(!this._lightID) {
					this._lightID = ++x3dom.nodeTypes.X3DLightNode.lightID;
				}
			},
			
			fieldChanged: function(fieldName)
            {
                if (this._vf.hasOwnProperty(fieldName)) {
				    this._dirty = true;
                }
			},

            parentRemoved: function(parent)
            {
                if (this._parentNodes.length === 0) {
                    var doc = this.findX3DDoc();

                    for (var i=0, n=doc._nodeBag.lights.length; i<n; i++) {
                        if (doc._nodeBag.lights[i] === this) {
                            doc._nodeBag.lights.splice(i, 1);
                        }
                    }
                }
            }
        }
    )
);

/** Static class ID counter (needed for flash performance up) */
x3dom.nodeTypes.X3DLightNode.lightID = 0;


/* ### DirectionalLight ### */
x3dom.registerNodeType(
    "DirectionalLight",
    "Lighting",
    defineClass(x3dom.nodeTypes.X3DLightNode,
        function (ctx) {
            x3dom.nodeTypes.DirectionalLight.superClass.call(this, ctx);

            this.addField_SFVec3f(ctx, 'direction', 0, 0, -1);
			this.addField_SFInt32(ctx, 'shadowCascades', 1);
			this.addField_SFFloat(ctx, 'shadowSplitFactor', 1);
			this.addField_SFFloat(ctx, 'shadowSplitOffset', 0.1);
        },
        {
            getViewMatrix: function(vec) {
                var dir = this.getCurrentTransform().multMatrixVec(this._vf.direction).normalize();
                var orientation = x3dom.fields.Quaternion.rotateFromTo(
                        new x3dom.fields.SFVec3f(0, 0, -1), dir);
                return orientation.toMatrix().transpose().
                        mult(x3dom.fields.SFMatrix4f.translation(vec.negate()));
            }
        }
    )
);

/* ### PointLight ### */
x3dom.registerNodeType(
    "PointLight",
    "Lighting",
    defineClass(x3dom.nodeTypes.X3DLightNode,
        function (ctx) {
            x3dom.nodeTypes.PointLight.superClass.call(this, ctx);

            this.addField_SFVec3f(ctx, 'attenuation', 1, 0, 0);
            this.addField_SFVec3f(ctx, 'location', 0, 0, 0);
            this.addField_SFFloat(ctx, 'radius', 100);

            this._vf.global = true;
        },
        {
            getViewMatrix: function(vec) {
                var pos = this.getCurrentTransform().multMatrixPnt(this._vf.location);
                var orientation = x3dom.fields.Quaternion.rotateFromTo(
                        new x3dom.fields.SFVec3f(0, 0, -1), vec);
                return orientation.toMatrix().transpose().
                        mult(x3dom.fields.SFMatrix4f.translation(pos.negate()));
            }
        }
    )
);

/* ### SpotLight ### */
x3dom.registerNodeType(
    "SpotLight",
    "Lighting",
    defineClass(x3dom.nodeTypes.X3DLightNode,
        function (ctx) {
            x3dom.nodeTypes.SpotLight.superClass.call(this, ctx);
            
            this.addField_SFVec3f(ctx, 'direction', 0, 0, -1);
            this.addField_SFVec3f(ctx, 'attenuation', 1, 0, 0);
            this.addField_SFVec3f(ctx, 'location', 0, 0, 0);
            this.addField_SFFloat(ctx, 'radius', 100);
            this.addField_SFFloat(ctx, 'beamWidth', 1.5707963);
            this.addField_SFFloat(ctx, 'cutOffAngle', 1.5707963);
			this.addField_SFInt32(ctx, 'shadowCascades', 1);	
			this.addField_SFFloat(ctx, 'shadowSplitFactor', 1);
			this.addField_SFFloat(ctx, 'shadowSplitOffset', 0.1);
			
            this._vf.global = true;
        },
        {
            getViewMatrix: function(vec) {
                var pos = this.getCurrentTransform().multMatrixPnt(this._vf.location);
                var dir = this.getCurrentTransform().multMatrixVec(this._vf.direction).normalize();
                var orientation = x3dom.fields.Quaternion.rotateFromTo(
                        new x3dom.fields.SFVec3f(0, 0, -1), dir);
                return orientation.toMatrix().transpose().
                        mult(x3dom.fields.SFMatrix4f.translation(pos.negate()));
            }
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### X3DFollowerNode ### */
x3dom.registerNodeType(
    "X3DFollowerNode",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DFollowerNode.superClass.call(this, ctx);
            
            if (ctx)
                ctx.doc._nodeBag.followers.push(this);
            else
                x3dom.debug.logWarning("X3DFollowerNode: No runtime context found!");
            
            this.addField_SFBool(ctx, 'isActive', false);

            // http://www.web3d.org/files/specifications/19775-1/V3.3/Part01/components/followers.html
            // [S|M]F<type> [in]     set_destination
            // [S|M]F<type> [in]     set_value
            // [S|M]F<type> [out]    value
            // SFBool       [out]    isActive
            // [S|M]F<type> []       initialDestination
            // [S|M]F<type> []       initialValue

            this._eps = x3dom.fields.Eps; //0.001;
        },
        {
            parentRemoved: function(parent)
            {
                if (this._parentNodes.length === 0) {
                    var doc = this.findX3DDoc();
                    
                    for (var i=0, n=doc._nodeBag.followers.length; i<n; i++) {
                        if (doc._nodeBag.followers[i] === this) {
                            doc._nodeBag.followers.splice(i, 1);
                        }
                    }
                }
            },
            
            tick: function(t) {
                return false;
            },
            
            stepResponse: function(t)
            {
                if (t <= 0) {
                    return 0;
                }

                if (t >= this._vf.duration) {
                    return 1;
                }

                // When optimizing for speed, the above two if(.) cases can be omitted,
                // as this function will not be called for values outside of 0..duration.
                return this.stepResponseCore(t / this._vf.duration);
            },
            
            // This function defines the shape of how the output responds to the initialDestination.
            // It must accept values for T in the range 0 <= T <= 1.
            // In this._vf.order to create a smooth animation, it should return 0 for T == 0,
            // 1 for T == 1 and be sufficient smooth in the range 0 <= T <= 1.
            //
            // It should be optimized for speed, in this._vf.order for high performance. It's
            // executed _buffer.length + 1 times each simulation tick.
            stepResponseCore: function(T)
            {
                return 0.5 - 0.5 * Math.cos(T * Math.PI);
            }
        }
    )
);

/* ### X3DChaserNode ### */
x3dom.registerNodeType(
    "X3DChaserNode",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DFollowerNode,
        function (ctx) {
            x3dom.nodeTypes.X3DChaserNode.superClass.call(this, ctx);

            this.addField_SFTime(ctx, 'duration', 1);
            
            this._initDone = false;
            this._stepTime = 0;
            this._currTime = 0;
            this._bufferEndTime = 0;
            this._numSupports = 60;
        }
    )
);

/* ### X3DDamperNode ### */
x3dom.registerNodeType(
    "X3DDamperNode",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DFollowerNode,
        function (ctx) {
            x3dom.nodeTypes.X3DDamperNode.superClass.call(this, ctx);

            this.addField_SFTime(ctx, 'tau', 0.3);
            this.addField_SFFloat(ctx, 'tolerance', -1);
            this.addField_SFInt32(ctx, 'order', 3);
            
            this._eps = this._vf.tolerance < 0 ? this._eps : this._vf.tolerance;
            this._lastTick = 0;
        }
    )
);

/* ### ColorChaser ### */
x3dom.registerNodeType(
    "ColorChaser",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DChaserNode,
        function (ctx) {
            x3dom.nodeTypes.ColorChaser.superClass.call(this, ctx);

            this.addField_SFColor(ctx, 'initialDestination', 0.8, 0.8, 0.8);
            this.addField_SFColor(ctx, 'initialValue', 0.8, 0.8, 0.8);

            this.addField_SFColor(ctx, 'value', 0, 0, 0);
            this.addField_SFColor(ctx, 'destination', 0, 0, 0);
            
            this._buffer = new x3dom.fields.MFColor();
            this._previousValue = new x3dom.fields.SFColor(0, 0, 0);
            this._value = new x3dom.fields.SFColor(0, 0, 0);

            this.initialize();
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName.indexOf("destination") >= 0)
                {
                    this.initialize();
                    this.updateBuffer(this._currTime);
                    
                    if (!this._vf.isActive) {
                        this.postMessage('isActive', true);
                    }
                }
                else if (fieldName.indexOf("value") >= 0)
                {
                    this.initialize();
                    
                    this._previousValue.setValues(this._vf.value);
                    for (var C=1; C<this._buffer.length; C++) {
                        this._buffer[C].setValues(this._vf.value);
                    }
                    
                    this.postMessage('value', this._vf.value);
                    
                    if (!this._vf.isActive) {
                        this.postMessage('isActive', true);
                    }
                }
            },
            
            /** The following handler code is copy & paste from PositionChaser
             */
            initialize: function()
            {
                if (!this._initDone)
                {
                    this._initDone = true;
                    
                    this._vf.destination = this._vf.initialDestination;

                    this._buffer.length = this._numSupports;

                    this._buffer[0] = this._vf.initialDestination;
                    for (var C=1; C<this._buffer.length; C++) {
                        this._buffer[C] = this._vf.initialValue;
                    }

                    this._previousValue = this._vf.initialValue;

                    this._stepTime = this._vf.duration / this._numSupports;
                    
                    var active = !this._buffer[0].equals(this._buffer[1], this._eps);
                    if (this._vf.isActive !== active) {
                        this.postMessage('isActive', active);
                    }
                }
            },

            tick: function(now)
            {
                this.initialize();
                this._currTime = now;
                
                //if (!this._vf.isActive)
                //    return false;
                
                if (!this._bufferEndTime)
                {
                    this._bufferEndTime = now;  // on init

                    this._value = this._vf.initialValue;
                    
                    this.postMessage('value', this._value);
                    
                    return true;
                }

                var Frac = this.updateBuffer(now);
                
                var Output = this._previousValue;

                var DeltaIn = this._buffer[this._buffer.length - 1].subtract(this._previousValue);

                var DeltaOut = DeltaIn.multiply(this.stepResponse((this._buffer.length - 1 + Frac) * this._stepTime));

                Output = Output.add(DeltaOut);

                for (var C=this._buffer.length - 2; C>=0; C--)
                {
                    DeltaIn = this._buffer[C].subtract(this._buffer[C + 1]);

                    DeltaOut = DeltaIn.multiply(this.stepResponse((C + Frac) * this._stepTime));

                    Output = Output.add(DeltaOut);
                }
                
                if ( !Output.equals(this._value, this._eps) ) {
                    this._value.setValues(Output);
                    
                    this.postMessage('value', this._value);
                }
                else {
                    this.postMessage('isActive', false);
                }
                
                return this._vf.isActive;
            },
            
            updateBuffer: function(now)
            {
                var Frac = (now - this._bufferEndTime) / this._stepTime;
                var C;
                var NumToShift;
                var Alpha;
                
                if (Frac >= 1)
                {
                    NumToShift = Math.floor(Frac);
                    Frac -= NumToShift;

                    if( NumToShift < this._buffer.length)
                    { 
                        this._previousValue = this._buffer[this._buffer.length - NumToShift];

                        for (C=this._buffer.length - 1; C>=NumToShift; C--) {
                            this._buffer[C] = this._buffer[C - NumToShift];
                        }

                        for (C=0; C<NumToShift; C++)
                        {
                            Alpha = C / NumToShift;

                            this._buffer[C] = this._buffer[NumToShift].multiply(Alpha).add(this._vf.destination.multiply((1 - Alpha)));
                        }
                    }
                    else
                    {
                        this._previousValue = (NumToShift == this._buffer.length) ? this._buffer[0] : this._vf.destination;

                        for (C= 0; C<this._buffer.length; C++) {
                            this._buffer[C] = this._vf.destination;
                        }
                    }
                    this._bufferEndTime += NumToShift * this._stepTime;
                }
                return Frac;
            }
        }
    )
);

/* ### ColorDamper ### */
x3dom.registerNodeType(
    "ColorDamper",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DDamperNode,
        function (ctx) {
            x3dom.nodeTypes.ColorDamper.superClass.call(this, ctx);

            this.addField_SFColor(ctx, 'initialDestination', 0.8, 0.8, 0.8);
            this.addField_SFColor(ctx, 'initialValue', 0.8, 0.8, 0.8);

            this.addField_SFColor(ctx, 'value', 0, 0, 0);
            this.addField_SFColor(ctx, 'destination', 0, 0, 0);
            
            this._value0 = new x3dom.fields.SFColor(0, 0, 0);
            this._value1 = new x3dom.fields.SFColor(0, 0, 0);
            this._value2 = new x3dom.fields.SFColor(0, 0, 0);
            this._value3 = new x3dom.fields.SFColor(0, 0, 0);
            this._value4 = new x3dom.fields.SFColor(0, 0, 0);
            this._value5 = new x3dom.fields.SFColor(0, 0, 0);
            
            this.initialize();
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName === "tolerance")
                {
                    this._eps = this._vf.tolerance < 0 ? 0.001 : this._vf.tolerance;
                }
                else if (fieldName.indexOf("destination") >= 0)
                {
                    if ( !this._value0.equals(this._vf.destination, this._eps) ) {
                        this._value0 = this._vf.destination;
                        
                        if (!this._vf.isActive) {
                            //this._lastTick = 0;
                            this.postMessage('isActive', true);
                        }
                    }
                }
                else if (fieldName.indexOf("value") >= 0)
                {
                    this._value1.setValues(this._vf.value);
                    this._value2.setValues(this._vf.value);
                    this._value3.setValues(this._vf.value);
                    this._value4.setValues(this._vf.value);
                    this._value5.setValues(this._vf.value);
                    this._lastTick = 0;
                    
                    this.postMessage('value', this._value5);
                    
                    if (!this._vf.isActive) {
                        this._lastTick = 0;
                        this.postMessage('isActive', true);
                    }
                }
            },
            
            initialize: function()
            {
                this._value0.setValues(this._vf.initialDestination);
                this._value1.setValues(this._vf.initialValue);
                this._value2.setValues(this._vf.initialValue);
                this._value3.setValues(this._vf.initialValue);
                this._value4.setValues(this._vf.initialValue);
                this._value5.setValues(this._vf.initialValue);
                this._lastTick = 0;
                
                var active = !this._value0.equals(this._value1, this._eps);
                if (this._vf.isActive !== active) {
                    this.postMessage('isActive', active);
                }
            },
            
            distance: function(a, b)
            {
                var diff = a.subtract(b);
                return Math.sqrt(diff.r*diff.r + diff.g*diff.g + diff.b*diff.b);
            },
            
            // The ColorDamper animates SFColor values not in HSV space
            // but as proposed in the original PROTO code in RGB space.
            tick: function(now)
            {
                //if (!this._vf.isActive)
                //    return false;
                
                if (!this._lastTick)
                {
                    this._lastTick = now;
                    return false;
                }

                var delta = now - this._lastTick;

                var alpha = Math.exp(-delta / this._vf.tau);

                this._value1 = this._vf.order > 0 && this._vf.tau ? 
                    this._value0.add(this._value1.subtract(this._value0).multiply(alpha)) : 
                    new x3dom.fields.SFColor(this._value0.r, this._value0.g, this._value0.b);

                this._value2 = this._vf.order > 1 && this._vf.tau ? 
                    this._value1.add(this._value2.subtract(this._value1).multiply(alpha)) : 
                    new x3dom.fields.SFColor(this._value1.r, this._value1.g, this._value1.b);

                this._value3 = this._vf.order > 2 && this._vf.tau ? 
                    this._value2.add(this._value3.subtract(this._value2).multiply(alpha)) : 
                    new x3dom.fields.SFColor(this._value2.r, this._value2.g, this._value2.b);

                this._value4 = this._vf.order > 3 && this._vf.tau ?
                    this._value3.add(this._value4.subtract(this._value3).multiply(alpha)) :
                    new x3dom.fields.SFColor(this._value3.r, this._value3.g, this._value3.b);

                this._value5 = this._vf.order > 4 && this._vf.tau ?
                    this._value4.add(this._value5.subtract(this._value4).multiply(alpha)) :
                    new x3dom.fields.SFColor(this._value4.r, this._value4.g, this._value4.b);

                var dist = this.distance(this._value1, this._value0);
                
                if (this._vf.order > 1)
                {
                    var dist2 = this.distance(this._value2, this._value1);
                    if (dist2 > dist) { dist = dist2; }
                }
                if (this._vf.order > 2)
                {
                    var dist3 = this.distance(this._value3, this._value2);
                    if (dist3 > dist) { dist = dist3; }
                }
                if (this._vf.order > 3)
                {
                    var dist4 = this.distance(this._value4, this._value3);
                    if (dist4 > dist) { dist = dist4; }
                }
                if (this._vf.order > 4)
                {
                    var dist5 = this.distance(this._value5, this._value4);
                    if (dist5 > dist) { dist = dist5; }
                }
                
                if (dist <= this._eps)
                {
                    this._value1.setValues(this._value0);
                    this._value2.setValues(this._value0);
                    this._value3.setValues(this._value0);
                    this._value4.setValues(this._value0);
                    this._value5.setValues(this._value0);
                    
                    this.postMessage('value', this._value0);
                    this.postMessage('isActive', false);
                    
                    this._lastTick = 0;
                    
                    return false;
                }
                
                this.postMessage('value', this._value5);

                this._lastTick = now;

                return true;
            }
        }
    )
);

/* ### OrientationChaser ### */
x3dom.registerNodeType(
    "OrientationChaser",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DChaserNode,
        function (ctx) {
            x3dom.nodeTypes.OrientationChaser.superClass.call(this, ctx);

            this.addField_SFRotation(ctx, 'initialDestination', 0, 1, 0, 0);
            this.addField_SFRotation(ctx, 'initialValue', 0, 1, 0, 0);

            this.addField_SFRotation(ctx, 'value', 0, 1, 0, 0);
            this.addField_SFRotation(ctx, 'destination', 0, 1, 0, 0);
            
            this._numSupports = 30;
            this._buffer = new x3dom.fields.MFRotation();
            this._previousValue = new x3dom.fields.Quaternion(0, 1, 0, 0);
            this._value = new x3dom.fields.Quaternion(0, 1, 0, 0);

            this.initialize();
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName.indexOf("destination") >= 0)
                {
                    this.initialize();
                    this.updateBuffer(this._currTime);
                    
                    if (!this._vf.isActive) {
                        this.postMessage('isActive', true);
                    }
                }
                else if (fieldName.indexOf("value") >= 0)
                {
                    this.initialize();
                    
                    this._previousValue.setValues(this._vf.value);
                    for (var C=1; C<this._buffer.length; C++) {
                        this._buffer[C].setValues(this._vf.value);
                    }
                    
                    this.postMessage('value', this._vf.value);
                    
                    if (!this._vf.isActive) {
                        this.postMessage('isActive', true);
                    }
                }
            },
            
            /** The following handler code was basically taken from 
             *  http://www.hersto.com/X3D/Followers
             */
            initialize: function()
            {
                if (!this._initDone)
                {
                    this._initDone = true;
                    
                    this._vf.destination = x3dom.fields.Quaternion.copy(this._vf.initialDestination);

                    this._buffer.length = this._numSupports;

                    this._buffer[0] = x3dom.fields.Quaternion.copy(this._vf.initialDestination);
                    for (var C=1; C<this._buffer.length; C++) {
                        this._buffer[C] = x3dom.fields.Quaternion.copy(this._vf.initialValue);
                    }

                    this._previousValue = x3dom.fields.Quaternion.copy(this._vf.initialValue);

                    this._stepTime = this._vf.duration / this._numSupports;
                    
                    var active = !this._buffer[0].equals(this._buffer[1], this._eps);
                    if (this._vf.isActive !== active) {
                        this.postMessage('isActive', active);
                    }
                }
            },

            tick: function(now)
            {
                this.initialize();
                this._currTime = now;
                
                //if (!this._vf.isActive)
                //    return false;
                
                if (!this._bufferEndTime)
                {
                    this._bufferEndTime = now; // first event we received, so we are in the initialization phase.

                    this._value = x3dom.fields.Quaternion.copy(this._vf.initialValue);
                    
                    this.postMessage('value', this._value);
                    
                    return true;
                }

                var Frac = this.updateBuffer(now);
                // Frac is a value in   0 <= Frac < 1.

                // now we can calculate the output.
                // This means we calculate the delta between each entry in _buffer and its previous
                // entries, calculate the step response of each such step and add it to form the output.

                // The oldest value _buffer[_buffer.length - 1] needs some extra thought, because it has
                // no previous value. More exactly, we haven't stored a previous value anymore.
                // However, the step response of that missing previous value has already reached its
                // destination, so we can - would we have that previous value - use this as a start point
                // for adding the step responses.
                // Actually updateBuffer(.) maintains this value in

                var Output = x3dom.fields.Quaternion.copy(this._previousValue);

                var DeltaIn = this._previousValue.inverse().multiply(this._buffer[this._buffer.length - 1]);
                
                Output = Output.slerp(Output.multiply(DeltaIn), this.stepResponse((this._buffer.length - 1 + Frac) * this._stepTime));
                
                for (var C=this._buffer.length - 2; C>=0; C--)
                {
                    DeltaIn = this._buffer[C + 1].inverse().multiply(this._buffer[C]);
                    
                    Output = Output.slerp(Output.multiply(DeltaIn), this.stepResponse((C + Frac) * this._stepTime));
                }

                if ( !Output.equals(this._value, this._eps) ) {
                    Output = Output.normalize(Output);
                    this._value.setValues(Output);

                    this.postMessage('value', this._value);
                }
                else {
                    this.postMessage('isActive', false);
                }
                
                return this._vf.isActive;
            },
            
            updateBuffer: function(now)
            {
                var Frac = (now - this._bufferEndTime) / this._stepTime;
                var C;
                var NumToShift;
                var Alpha;
                // is normally < 1. When it has grown to be larger than 1, we have to shift the array because the step response
                // of the oldest entry has already reached its destination, and it's time for a newer entry.
                // In the case of a very low frame rate, or a very short _stepTime we may need to shift by more than one entry.

                if (Frac >= 1)
                {
                    NumToShift = Math.floor(Frac);
                    Frac -= NumToShift;

                    if( NumToShift < this._buffer.length)
                    {   
                        // normal case
                        this._previousValue = x3dom.fields.Quaternion.copy(this._buffer[this._buffer.length - NumToShift]);

                        for (C=this._buffer.length - 1; C>=NumToShift; C--) {
                            this._buffer[C] = x3dom.fields.Quaternion.copy(this._buffer[C - NumToShift]);
                        }

                        for (C=0; C<NumToShift; C++)
                        {
                            // Hmm, we have a destination value, but don't know how it has
                            // reached the current state.
                            // Therefore we do a linear interpolation from the latest value in the buffer to destination.
                            Alpha = C / NumToShift;

                            this._buffer[C] = this._vf.destination.slerp(this._buffer[NumToShift], Alpha);
                        }
                    }
                    else
                    {
                        // degenerated case:
                        //
                        // We have a _VERY_ low frame rate...
                        // we can only guess how we should fill the array.
                        // Maybe we could write part of a linear interpolation
                        // from this._buffer[0] to destination, that goes from this._bufferEndTime to now
                        // (possibly only the end of the interpolation is to be written),
                        // but if we reach here we are in a very degenerate case...
                        // Thus we just write destination to the buffer.

                        this._previousValue = x3dom.fields.Quaternion.copy((NumToShift == this._buffer.length) ?
                                                                           this._buffer[0] : this._vf.destination);

                        for (C= 0; C<this._buffer.length; C++) {
                            this._buffer[C] = x3dom.fields.Quaternion.copy(this._vf.destination);
                        }
                    }

                    this._bufferEndTime += NumToShift * this._stepTime;
                }

                return Frac;
            }
        }
    )
);

/* ### OrientationDamper ### */
x3dom.registerNodeType(
    "OrientationDamper",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DDamperNode,
        function (ctx) {
            x3dom.nodeTypes.OrientationDamper.superClass.call(this, ctx);

            this.addField_SFRotation(ctx, 'initialDestination', 0, 1, 0, 0);
            this.addField_SFRotation(ctx, 'initialValue', 0, 1, 0, 0);

            this.addField_SFRotation(ctx, 'value', 0, 1, 0, 0);
            this.addField_SFRotation(ctx, 'destination', 0, 1, 0, 0);
            
            this._value0 = new x3dom.fields.Quaternion(0, 1, 0, 0);
            this._value1 = new x3dom.fields.Quaternion(0, 1, 0, 0);
            this._value2 = new x3dom.fields.Quaternion(0, 1, 0, 0);
            this._value3 = new x3dom.fields.Quaternion(0, 1, 0, 0);
            this._value4 = new x3dom.fields.Quaternion(0, 1, 0, 0);
            this._value5 = new x3dom.fields.Quaternion(0, 1, 0, 0);
            
            this.initialize();
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName === "tolerance")
                {
                    this._eps = this._vf.tolerance < 0 ? 0.001 : this._vf.tolerance;
                }
                else if (fieldName.indexOf("destination") >= 0)
                {
                    if ( !this._value0.equals(this._vf.destination, this._eps) ) {
                        this._value0 = this._vf.destination;
                        
                        if (!this._vf.isActive) {
                            //this._lastTick = 0;
                            this.postMessage('isActive', true);
                        }
                    }
                }
                else if (fieldName.indexOf("value") >= 0)
                {
                    this._value1.setValues(this._vf.value);
                    this._value2.setValues(this._vf.value);
                    this._value3.setValues(this._vf.value);
                    this._value4.setValues(this._vf.value);
                    this._value5.setValues(this._vf.value);
                    this._lastTick = 0;
                    
                    this.postMessage('value', this._value5);
                    
                    if (!this._vf.isActive) {
                        this._lastTick = 0;
                        this.postMessage('isActive', true);
                    }
                }
            },
            
            initialize: function()
            {
                this._value0.setValues(this._vf.initialDestination);
                this._value1.setValues(this._vf.initialValue);
                this._value2.setValues(this._vf.initialValue);
                this._value3.setValues(this._vf.initialValue);
                this._value4.setValues(this._vf.initialValue);
                this._value5.setValues(this._vf.initialValue);
                this._lastTick = 0;
                
                var active = !this._value0.equals(this._value1, this._eps);
                if (this._vf.isActive !== active) {
                    this.postMessage('isActive', active);
                }
            },
            
            tick: function(now)
            {
                //if (!this._vf.isActive)
                //    return false;
                
                if (!this._lastTick)
                {
                    this._lastTick = now;
                    return false;
                }

                var delta = now - this._lastTick;

                var alpha = Math.exp(-delta / this._vf.tau);

                this._value1 = this._vf.order > 0 && this._vf.tau ? 
                    this._value0.slerp(this._value1, alpha) :
                    new x3dom.fields.Quaternion(this._value0.x, this._value0.y, this._value0.z, this._value0.w);
                
                this._value2 = this._vf.order > 1 && this._vf.tau ? 
                this._value1.slerp(this._value2, alpha) : 
                new x3dom.fields.Quaternion(this._value1.x, this._value1.y, this._value1.z, this._value1.w);

                this._value3 = this._vf.order > 2 && this._vf.tau ?
                    this._value2.slerp(this._value3, alpha) :
                    new x3dom.fields.Quaternion(this._value2.x, this._value2.y, this._value2.z, this._value2.w);

                this._value4 = this._vf.order > 3 && this._vf.tau ?
                    this._value3.slerp(this._value4, alpha) :
                    new x3dom.fields.Quaternion(this._value3.x, this._value3.y, this._value3.z, this._value3.w);

                this._value5 = this._vf.order > 4 && this._vf.tau ?
                    this._value4.slerp(this._value5, alpha) :
                    new x3dom.fields.Quaternion(this._value4.x, this._value4.y, this._value4.z, this._value4.w);

                var dist = Math.abs(this._value1.inverse().multiply(this._value0).angle());
                
                if(this._vf.order > 1)
                {
                    var dist2 = Math.abs(this._value2.inverse().multiply(this._value1).angle());
                    if (dist2 > dist)  { dist = dist2; }
                }
                if(this._vf.order > 2)
                {
                    var dist3 = Math.abs(this._value3.inverse().multiply(this._value2).angle());
                    if (dist3 > dist) { dist = dist3; }
                }
                if(this._vf.order > 3)
                {
                    var dist4 = Math.abs(this._value4.inverse().multiply(this._value3).angle());
                    if (dist4 > dist)  { dist = dist4; }
                }
                if(this._vf.order > 4)
                {
                    var dist5 = Math.abs(this._value5.inverse().multiply(this._value4).angle());
                    if (dist5 > dist)  { dist = dist5; }
                }

                if (dist <= this._eps)
                {
                    this._value1.setValues(this._value0);
                    this._value2.setValues(this._value0);
                    this._value3.setValues(this._value0);
                    this._value4.setValues(this._value0);
                    this._value5.setValues(this._value0);
                    
                    this.postMessage('value', this._value0);
                    this.postMessage('isActive', false);
                    
                    this._lastTick = 0;
                    
                    return false;
                }
                
                this.postMessage('value', this._value5);

                this._lastTick = now;

                return true;
            }
        }
    )
);

/* ### PositionChaser ### */
x3dom.registerNodeType(
    "PositionChaser",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DChaserNode,
        function (ctx) {
            x3dom.nodeTypes.PositionChaser.superClass.call(this, ctx);
            
            this.addField_SFVec3f(ctx, 'initialDestination', 0, 0, 0);
            this.addField_SFVec3f(ctx, 'initialValue', 0, 0, 0);

            this.addField_SFVec3f(ctx, 'value', 0, 0, 0);
            this.addField_SFVec3f(ctx, 'destination', 0, 0, 0);
            
            this._buffer = new x3dom.fields.MFVec3f();
            this._previousValue = new x3dom.fields.SFVec3f(0, 0, 0);
            this._value = new x3dom.fields.SFVec3f(0, 0, 0);

            this.initialize();
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName.indexOf("destination") >= 0)
                {
                    this.initialize();
                    this.updateBuffer(this._currTime);
                    
                    if (!this._vf.isActive) {
                        this.postMessage('isActive', true);
                    }
                }
                else if (fieldName.indexOf("value") >= 0)
                {
                    this.initialize();
                    
                    this._previousValue.setValues(this._vf.value);
                    for (var C=1; C<this._buffer.length; C++) {
                        this._buffer[C].setValues(this._vf.value);
                    }
                    
                    this.postMessage('value', this._vf.value);
                    
                    if (!this._vf.isActive) {
                        this.postMessage('isActive', true);
                    }
                }
            },
            
            /** The following handler code was basically taken from 
             *  http://www.hersto.com/X3D/Followers
             */
            initialize: function()
            {
                if (!this._initDone)
                {
                    this._initDone = true;
                    
                    this._vf.destination = x3dom.fields.SFVec3f.copy(this._vf.initialDestination);

                    this._buffer.length = this._numSupports;

                    this._buffer[0] = x3dom.fields.SFVec3f.copy(this._vf.initialDestination);
                    for (var C=1; C<this._buffer.length; C++) {
                        this._buffer[C] = x3dom.fields.SFVec3f.copy(this._vf.initialValue);
                    }

                    this._previousValue = x3dom.fields.SFVec3f.copy(this._vf.initialValue);

                    this._stepTime = this._vf.duration / this._numSupports;
                    
                    var active = !this._buffer[0].equals(this._buffer[1], this._eps);
                    if (this._vf.isActive !== active) {
                        this.postMessage('isActive', active);
                    }
                }
            },

            tick: function(now)
            {
                this.initialize();
                this._currTime = now;
                
                //if (!this._vf.isActive)
                //    return false;
                
                if (!this._bufferEndTime)
                {
                    this._bufferEndTime = now; // first event we received, so we are in the initialization phase.

                    this._value = x3dom.fields.SFVec3f.copy(this._vf.initialValue);
                    
                    this.postMessage('value', this._value);
                    
                    return true;
                }

                var Frac = this.updateBuffer(now);
                // Frac is a value in   0 <= Frac < 1.

                // now we can calculate the output.
                // This means we calculate the delta between each entry in _buffer and its previous
                // entries, calculate the step response of each such step and add it to form the output.

                // The oldest value _buffer[_buffer.length - 1] needs some extra thought, because it has
                // no previous value. More exactly, we haven't stored a previous value anymore.
                // However, the step response of that missing previous value has already reached its
                // destination, so we can - would we have that previous value - use this as a start point
                // for adding the step responses.
                // Actually updateBuffer(.) maintains this value in

                var Output = x3dom.fields.SFVec3f.copy(this._previousValue);

                var DeltaIn = this._buffer[this._buffer.length - 1].subtract(this._previousValue);

                var DeltaOut = DeltaIn.multiply(this.stepResponse((this._buffer.length - 1 + Frac) * this._stepTime));

                Output = Output.add(DeltaOut);

                for (var C=this._buffer.length - 2; C>=0; C--)
                {
                    DeltaIn = this._buffer[C].subtract(this._buffer[C + 1]);

                    DeltaOut = DeltaIn.multiply(this.stepResponse((C + Frac) * this._stepTime));

                    Output = Output.add(DeltaOut);
                }
                
                if ( !Output.equals(this._value, this._eps) ) {
                    this._value.setValues(Output);
                    
                    this.postMessage('value', this._value);
                }
                else {
                    this.postMessage('isActive', false);
                }
                
                return this._vf.isActive;
            },
            
            updateBuffer: function(now)
            {
                var Frac = (now - this._bufferEndTime) / this._stepTime;
                var C;
                var NumToShift;
                var Alpha;
                // is normally < 1. When it has grown to be larger than 1, we have to shift the array because the step response
                // of the oldest entry has already reached its destination, and it's time for a newer entry.
                // In the case of a very low frame rate, or a very short _stepTime we may need to shift by more than one entry.

                if (Frac >= 1)
                {
                    NumToShift = Math.floor(Frac);
                    Frac -= NumToShift;

                    if( NumToShift < this._buffer.length)
                    {   
                        // normal case
                        this._previousValue = x3dom.fields.SFVec3f.copy(this._buffer[this._buffer.length - NumToShift]);

                        for (C=this._buffer.length - 1; C>=NumToShift; C--) {
                            this._buffer[C] = x3dom.fields.SFVec3f.copy(this._buffer[C - NumToShift]);
                        }

                        for (C=0; C<NumToShift; C++)
                        {
                            // Hmm, we have a destination value, but don't know how it has
                            // reached the current state.
                            // Therefore we do a linear interpolation from the latest value in the buffer to destination.
                            Alpha = C / NumToShift;

                            this._buffer[C] = this._buffer[NumToShift].multiply(Alpha).add(this._vf.destination.multiply((1 - Alpha)));
                        }
                    }
                    else
                    {
                        // degenerated case:
                        //
                        // We have a _VERY_ low frame rate...
                        // we can only guess how we should fill the array.
                        // Maybe we could write part of a linear interpolation
                        // from this._buffer[0] to destination, that goes from this._bufferEndTime to now
                        // (possibly only the end of the interpolation is to be written),
                        // but if we reach here we are in a very degenerate case...
                        // Thus we just write destination to the buffer.

                        this._previousValue = x3dom.fields.SFVec3f.copy((NumToShift == this._buffer.length) ?
                                                                        this._buffer[0] : this._vf.destination);

                        for (C= 0; C<this._buffer.length; C++) {
                            this._buffer[C] = x3dom.fields.SFVec3f.copy(this._vf.destination);
                        }
                    }

                    this._bufferEndTime += NumToShift * this._stepTime;
                }

                return Frac;
            }
        }
    )
);

/* ### PositionChaser2D ### */
x3dom.registerNodeType(
    "PositionChaser2D",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DChaserNode,
        function (ctx) {
            x3dom.nodeTypes.PositionChaser2D.superClass.call(this, ctx);

            this.addField_SFVec2f(ctx, 'initialDestination', 0, 0);
            this.addField_SFVec2f(ctx, 'initialValue', 0, 0);

            this.addField_SFVec2f(ctx, 'value', 0, 0);
            this.addField_SFVec2f(ctx, 'destination', 0, 0);
            
            this._buffer = new x3dom.fields.MFVec2f();
            this._previousValue = new x3dom.fields.SFVec2f(0, 0);
            this._value = new x3dom.fields.SFVec2f(0, 0);

            this.initialize();
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName.indexOf("destination") >= 0)
                {
                    this.initialize();
                    this.updateBuffer(this._currTime);
                    
                    if (!this._vf.isActive) {
                        this.postMessage('isActive', true);
                    }
                }
                else if (fieldName.indexOf("value") >= 0)
                {
                    this.initialize();
                    
                    this._previousValue.setValues(this._vf.value);
                    for (var C=1; C<this._buffer.length; C++) {
                        this._buffer[C].setValues(this._vf.value);
                    }
                    
                    this.postMessage('value', this._vf.value);
                    
                    if (!this._vf.isActive) {
                        this.postMessage('isActive', true);
                    }
                }
            },
            
            /** The following handler code is copy & paste from PositionChaser
             */
            initialize: function()
            {
                if (!this._initDone)
                {
                    this._initDone = true;
                    
                    this._vf.destination = x3dom.fields.SFVec2f.copy(this._vf.initialDestination);

                    this._buffer.length = this._numSupports;

                    this._buffer[0] = x3dom.fields.SFVec2f.copy(this._vf.initialDestination);
                    for (var C=1; C<this._buffer.length; C++) {
                        this._buffer[C] = x3dom.fields.SFVec2f.copy(this._vf.initialValue);
                    }

                    this._previousValue = x3dom.fields.SFVec2f.copy(this._vf.initialValue);

                    this._stepTime = this._vf.duration / this._numSupports;
                    
                    var active = !this._buffer[0].equals(this._buffer[1], this._eps);
                    if (this._vf.isActive !== active) {
                        this.postMessage('isActive', active);
                    }
                }
            },

            tick: function(now)
            {
                this.initialize();
                this._currTime = now;
                
                //if (!this._vf.isActive)
                //    return false;
                
                if (!this._bufferEndTime)
                {
                    this._bufferEndTime = now;

                    this._value = x3dom.fields.SFVec2f.copy(this._vf.initialValue);
                    
                    this.postMessage('value', this._value);
                    
                    return true;
                }

                var Frac = this.updateBuffer(now);
                
                var Output = x3dom.fields.SFVec2f.copy(this._previousValue);

                var DeltaIn = this._buffer[this._buffer.length - 1].subtract(this._previousValue);

                var DeltaOut = DeltaIn.multiply(this.stepResponse((this._buffer.length - 1 + Frac) * this._stepTime));

                Output = Output.add(DeltaOut);

                for (var C=this._buffer.length - 2; C>=0; C--)
                {
                    DeltaIn = this._buffer[C].subtract(this._buffer[C + 1]);

                    DeltaOut = DeltaIn.multiply(this.stepResponse((C + Frac) * this._stepTime));

                    Output = Output.add(DeltaOut);
                }
                
                if ( !Output.equals(this._value, this._eps) ) {
                    this._value.setValues(Output);
                    
                    this.postMessage('value', this._value);
                }
                else {
                    this.postMessage('isActive', false);
                }
                
                return this._vf.isActive;
            },
            
            updateBuffer: function(now)
            {
                var Frac = (now - this._bufferEndTime) / this._stepTime;
                var C;
                var NumToShift;
                var Alpha;
                
                if (Frac >= 1)
                {
                    NumToShift = Math.floor(Frac);
                    Frac -= NumToShift;

                    if( NumToShift < this._buffer.length)
                    {
                        this._previousValue = x3dom.fields.SFVec2f.copy(this._buffer[this._buffer.length - NumToShift]);

                        for (C=this._buffer.length - 1; C>=NumToShift; C--) {
                            this._buffer[C]= x3dom.fields.SFVec2f.copy(this._buffer[C - NumToShift]);
                        }

                        for (C=0; C<NumToShift; C++)
                        {
                            Alpha = C / NumToShift;

                            this._buffer[C] = this._buffer[NumToShift].multiply(Alpha).add(this._vf.destination.multiply((1 - Alpha)));
                        }
                    }
                    else
                    {
                        this._previousValue = x3dom.fields.SFVec2f.copy((NumToShift == this._buffer.length) ?
                                                                        this._buffer[0] : this._vf.destination);

                        for (C= 0; C<this._buffer.length; C++) {
                            this._buffer[C] = x3dom.fields.SFVec2f.copy(this._vf.destination);
                        }
                    }

                    this._bufferEndTime += NumToShift * this._stepTime;
                }

                return Frac;
            }
        }
    )
);

/* ### PositionDamper ### */
x3dom.registerNodeType(
    "PositionDamper",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DDamperNode,
        function (ctx) {
            x3dom.nodeTypes.PositionDamper.superClass.call(this, ctx);

            this.addField_SFVec3f(ctx, 'initialDestination', 0, 0, 0);
            this.addField_SFVec3f(ctx, 'initialValue', 0, 0, 0);

            this.addField_SFVec3f(ctx, 'value', 0, 0, 0);
            this.addField_SFVec3f(ctx, 'destination', 0, 0, 0);
            
            this._value0 = new x3dom.fields.SFVec3f(0, 0, 0);
            this._value1 = new x3dom.fields.SFVec3f(0, 0, 0);
            this._value2 = new x3dom.fields.SFVec3f(0, 0, 0);
            this._value3 = new x3dom.fields.SFVec3f(0, 0, 0);
            this._value4 = new x3dom.fields.SFVec3f(0, 0, 0);
            this._value5 = new x3dom.fields.SFVec3f(0, 0, 0);
            
            this.initialize();
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName === "tolerance")
                {
                    this._eps = this._vf.tolerance < 0 ? 0.001 : this._vf.tolerance;
                }
                else if (fieldName.indexOf("destination") >= 0)
                {
                    if ( !this._value0.equals(this._vf.destination, this._eps) ) {
                        this._value0 = this._vf.destination;
                        
                        if (!this._vf.isActive) {
                            //this._lastTick = 0;
                            this.postMessage('isActive', true);
                        }
                    }
                }
                else if (fieldName.indexOf("value") >= 0)
                {
                    this._value1.setValues(this._vf.value);
                    this._value2.setValues(this._vf.value);
                    this._value3.setValues(this._vf.value);
                    this._value4.setValues(this._vf.value);
                    this._value5.setValues(this._vf.value);
                    this._lastTick = 0;
                    
                    this.postMessage('value', this._value5);
                    
                    if (!this._vf.isActive) {
                        this._lastTick = 0;
                        this.postMessage('isActive', true);
                    }
                }
            },
            
            initialize: function()
            {
                this._value0.setValues(this._vf.initialDestination);
                this._value1.setValues(this._vf.initialValue);
                this._value2.setValues(this._vf.initialValue);
                this._value3.setValues(this._vf.initialValue);
                this._value4.setValues(this._vf.initialValue);
                this._value5.setValues(this._vf.initialValue);
                this._lastTick = 0;
                
                var active = !this._value0.equals(this._value1, this._eps);
                if (this._vf.isActive !== active) {
                    this.postMessage('isActive', active);
                }
            },
            
            tick: function(now)
            {
                //if (!this._vf.isActive)
                //    return false;
                
                if (!this._lastTick)
                {
                    this._lastTick = now;
                    return false;
                }

                var delta = now - this._lastTick;

                var alpha = Math.exp(-delta / this._vf.tau);

                this._value1 = this._vf.order > 0 && this._vf.tau ? 
                    this._value0.add(this._value1.subtract(this._value0).multiply(alpha)) :
                        new x3dom.fields.SFVec3f(this._value0.x, this._value0.y, this._value0.z);

                this._value2 = this._vf.order > 1 && this._vf.tau ?
                    this._value1.add(this._value2.subtract(this._value1).multiply(alpha)) :
                        new x3dom.fields.SFVec3f(this._value1.x, this._value1.y, this._value1.z);

                this._value3 = this._vf.order > 2 && this._vf.tau ?
                    this._value2.add(this._value3.subtract(this._value2).multiply(alpha)) :
                        new x3dom.fields.SFVec3f(this._value2.x, this._value2.y, this._value2.z);

                this._value4 = this._vf.order > 3 && this._vf.tau ?
                    this._value3.add(this._value4.subtract(this._value3).multiply(alpha)) :
                        new x3dom.fields.SFVec3f(this._value3.x, this._value3.y, this._value3.z);

                this._value5 = this._vf.order > 4 && this._vf.tau ?
                    this._value4.add(this._value5.subtract(this._value4).multiply(alpha)) :
                        new x3dom.fields.SFVec3f(this._value4.x, this._value4.y, this._value4.z);

                var dist = this._value1.subtract(this._value0).length();
                
                if (this._vf.order > 1)
                {
                    var dist2 = this._value2.subtract(this._value1).length();
                    if (dist2 > dist) {dist = dist2;}
                }
                if (this._vf.order > 2)
                {
                    var dist3 = this._value3.subtract(this._value2).length();
                    if (dist3 > dist) {dist = dist3;}
                }
                if (this._vf.order > 3)
                {
                    var dist4 = this._value4.subtract(this._value3).length();
                    if (dist4 > dist) {dist = dist4;}
                }
                if (this._vf.order > 4)
                {
                    var dist5 = this._value5.subtract(this._value4).length();
                    if (dist5 > dist) {dist = dist5;}
                }

                if (dist <= this._eps)
                {
                    this._value1.setValues(this._value0);
                    this._value2.setValues(this._value0);
                    this._value3.setValues(this._value0);
                    this._value4.setValues(this._value0);
                    this._value5.setValues(this._value0);
                    
                    this.postMessage('value', this._value0);
                    this.postMessage('isActive', false);
                    
                    this._lastTick = 0;
                    
                    return false;
                }
                
                this.postMessage('value', this._value5);

                this._lastTick = now;

                return true;
            }
        }
    )
);

/* ### PositionDamper2D ### */
x3dom.registerNodeType(
    "PositionDamper2D",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DDamperNode,
        function (ctx) {
            x3dom.nodeTypes.PositionDamper2D.superClass.call(this, ctx);

            this.addField_SFVec2f(ctx, 'initialDestination', 0, 0);
            this.addField_SFVec2f(ctx, 'initialValue', 0, 0);

            this.addField_SFVec2f(ctx, 'value', 0, 0);
            this.addField_SFVec2f(ctx, 'destination', 0, 0);
            
            this._value0 = new x3dom.fields.SFVec2f(0, 0);
            this._value1 = new x3dom.fields.SFVec2f(0, 0);
            this._value2 = new x3dom.fields.SFVec2f(0, 0);
            this._value3 = new x3dom.fields.SFVec2f(0, 0);
            this._value4 = new x3dom.fields.SFVec2f(0, 0);
            this._value5 = new x3dom.fields.SFVec2f(0, 0);
            
            this.initialize();
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName === "tolerance")
                {
                    this._eps = this._vf.tolerance < 0 ? 0.001 : this._vf.tolerance;
                }
                else if (fieldName.indexOf("destination") >= 0)
                {
                    if ( !this._value0.equals(this._vf.destination, this._eps) ) {
                        this._value0 = this._vf.destination;
                        
                        if (!this._vf.isActive) {
                            //this._lastTick = 0;
                            this.postMessage('isActive', true);
                        }
                    }
                }
                else if (fieldName.indexOf("value") >= 0)
                {
                    this._value1.setValues(this._vf.value);
                    this._value2.setValues(this._vf.value);
                    this._value3.setValues(this._vf.value);
                    this._value4.setValues(this._vf.value);
                    this._value5.setValues(this._vf.value);
                    this._lastTick = 0;
                    
                    this.postMessage('value', this._value5);
                    
                    if (!this._vf.isActive) {
                        this._lastTick = 0;
                        this.postMessage('isActive', true);
                    }
                }
            },
            
            initialize: function()
            {
                this._value0.setValues(this._vf.initialDestination);
                this._value1.setValues(this._vf.initialValue);
                this._value2.setValues(this._vf.initialValue);
                this._value3.setValues(this._vf.initialValue);
                this._value4.setValues(this._vf.initialValue);
                this._value5.setValues(this._vf.initialValue);
                this._lastTick = 0;
                
                var active = !this._value0.equals(this._value1, this._eps);
                if (this._vf.isActive !== active) {
                    this.postMessage('isActive', active);
                }
            },
            
            tick: function(now)
            {
                //if (!this._vf.isActive)
                //    return false;
                
                if (!this._lastTick)
                {
                    this._lastTick = now;
                    return false;
                }

                var delta = now - this._lastTick;

                var alpha = Math.exp(-delta / this._vf.tau);

                this._value1 = this._vf.order > 0 && this._vf.tau ? 
                    this._value0.add(this._value1.subtract(this._value0).multiply(alpha)) :
                        new x3dom.fields.SFVec2f(this._value0.x, this._value0.y, this._value0.z);

                this._value2 = this._vf.order > 1 && this._vf.tau ?
                    this._value1.add(this._value2.subtract(this._value1).multiply(alpha)) :
                        new x3dom.fields.SFVec2f(this._value1.x, this._value1.y, this._value1.z);

                this._value3 = this._vf.order > 2 && this._vf.tau ?
                    this._value2.add(this._value3.subtract(this._value2).multiply(alpha)) : 
                        new x3dom.fields.SFVec2f(this._value2.x, this._value2.y, this._value2.z);

                this._value4 = this._vf.order > 3 && this._vf.tau ? 
                    this._value3.add(this._value4.subtract(this._value3).multiply(alpha)) : 
                        new x3dom.fields.SFVec2f(this._value3.x, this._value3.y, this._value3.z);

                this._value5 = this._vf.order > 4 && this._vf.tau ? 
                    this._value4.add(this._value5.subtract(this._value4).multiply(alpha)) : 
                        new x3dom.fields.SFVec2f(this._value4.x, this._value4.y, this._value4.z);

                var dist = this._value1.subtract(this._value0).length();
                
                if (this._vf.order > 1)
                {
                    var dist2 = this._value2.subtract(this._value1).length();
                    if (dist2 > dist) {dist = dist2;}
                }
                if (this._vf.order > 2)
                {
                    var dist3 = this._value3.subtract(this._value2).length();
                    if (dist3 > dist) {dist = dist3;}
                }
                if (this._vf.order > 3)
                {
                    var dist4 = this._value4.subtract(this._value3).length();
                    if (dist4 > dist) {dist = dist4;}
                }
                if (this._vf.order > 4)
                {
                    var dist5 = this._value5.subtract(this._value4).length();
                    if (dist5 > dist) {dist = dist5;}
                }

                if (dist <= this._eps)
                {
                    this._value1.setValues(this._value0);
                    this._value2.setValues(this._value0);
                    this._value3.setValues(this._value0);
                    this._value4.setValues(this._value0);
                    this._value5.setValues(this._value0);
                    
                    this.postMessage('value', this._value0);
                    this.postMessage('isActive', false);
                    
                    this._lastTick = 0;
                    
                    return false;
                }
                
                this.postMessage('value', this._value5);

                this._lastTick = now;

                return true;
            }
        }
    )
);

/* ### ScalarChaser ### */
x3dom.registerNodeType(
    "ScalarChaser",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DChaserNode,
        function (ctx) {
            x3dom.nodeTypes.ScalarChaser.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'initialDestination', 0);
            this.addField_SFFloat(ctx, 'initialValue', 0);

            this.addField_SFFloat(ctx, 'value', 0);
            this.addField_SFFloat(ctx, 'destination', 0);
            
            this._buffer = [];
            this._previousValue = 0;
            this._value = 0;

            this.initialize();
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName.indexOf("destination") >= 0)
                {
                    this.initialize();
                    this.updateBuffer(this._currTime);
                    
                    if (!this._vf.isActive) {
                        this.postMessage('isActive', true);
                    }
                }
                else if (fieldName.indexOf("value") >= 0)
                {
                    this.initialize();
                    
                    this._previousValue = this._vf.value;
                    for (var C=1; C<this._buffer.length; C++) {
                        this._buffer[C] = this._vf.value;
                    }
                    
                    this.postMessage('value', this._vf.value);
                    
                    if (!this._vf.isActive) {
                        this.postMessage('isActive', true);
                    }
                }
            },
            
            initialize: function()
            {
                if (!this._initDone)
                {
                    this._initDone = true;
                    
                    this._vf.destination = this._vf.initialDestination;

                    this._buffer.length = this._numSupports;

                    this._buffer[0] = this._vf.initialDestination;
                    for (var C=1; C<this._buffer.length; C++) {
                        this._buffer[C] = this._vf.initialValue;
                    }

                    this._previousValue = this._vf.initialValue;

                    this._stepTime = this._vf.duration / this._numSupports;
                    
                    var active = (Math.abs(this._buffer[0] - this._buffer[1]) > this._eps);
                    if (this._vf.isActive !== active) {
                        this.postMessage('isActive', active);
                    }
                }
            },

            tick: function(now)
            {
                this.initialize();
                this._currTime = now;
                
                //if (!this._vf.isActive)
                //    return false;
                
                if (!this._bufferEndTime)
                {
                    this._bufferEndTime = now;

                    this._value = this._vf.initialValue;
                    
                    this.postMessage('value', this._value);
                    
                    return true;
                }

                var Frac = this.updateBuffer(now);
                
                var Output = this._previousValue;

                var DeltaIn = this._buffer[this._buffer.length - 1] - this._previousValue;

                var DeltaOut = DeltaIn * (this.stepResponse((this._buffer.length - 1 + Frac) * this._stepTime));

                Output = Output + DeltaOut;

                for (var C=this._buffer.length - 2; C>=0; C--)
                {
                    DeltaIn = this._buffer[C] - this._buffer[C + 1];

                    DeltaOut = DeltaIn * (this.stepResponse((C + Frac) * this._stepTime));

                    Output = Output + DeltaOut;
                }
                
                if (Math.abs(Output - this._value) > this._eps) {
                    this._value = Output;
                    
                    this.postMessage('value', this._value);
                }
                else {
                    this.postMessage('isActive', false);
                }
                
                return this._vf.isActive;
            },
            
            updateBuffer: function(now)
            {
                var Frac = (now - this._bufferEndTime) / this._stepTime;
                var C;
                var NumToShift;
                var Alpha;
                
                if (Frac >= 1)
                {
                    NumToShift = Math.floor(Frac);
                    Frac -= NumToShift;

                    if (NumToShift < this._buffer.length)
                    {
                        this._previousValue = this._buffer[this._buffer.length - NumToShift];

                        for (C=this._buffer.length - 1; C>=NumToShift; C--) {
                            this._buffer[C] = this._buffer[C - NumToShift];
                        }

                        for (C=0; C<NumToShift; C++)
                        {
                            Alpha = C / NumToShift;

                            this._buffer[C] = this._buffer[NumToShift] * Alpha + this._vf.destination * (1 - Alpha);
                        }
                    }
                    else
                    {
                        this._previousValue = (NumToShift == this._buffer.length) ? this._buffer[0] : this._vf.destination;

                        for (C = 0; C<this._buffer.length; C++) {
                            this._buffer[C] = this._vf.destination;
                        }
                    }

                    this._bufferEndTime += NumToShift * this._stepTime;
                }

                return Frac;
            }
        }
    )
);

/* ### ScalarDamper ### */
x3dom.registerNodeType(
    "ScalarDamper",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DDamperNode,
        function (ctx) {
            x3dom.nodeTypes.ScalarDamper.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'initialDestination', 0);
            this.addField_SFFloat(ctx, 'initialValue', 0);

            this.addField_SFFloat(ctx, 'value', 0);
            this.addField_SFFloat(ctx, 'destination', 0);
            
            this._value0 = 0;
            this._value1 = 0;
            this._value2 = 0;
            this._value3 = 0;
            this._value4 = 0;
            this._value5 = 0;
            
            this.initialize();
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName === "tolerance")
                {
                    this._eps = this._vf.tolerance < 0 ? 0.001 : this._vf.tolerance;
                }
                else if (fieldName.indexOf("destination") >= 0)
                {
                    if (Math.abs(this._value0 - this._vf.destination) > this._eps) {
                        this._value0 = this._vf.destination;
                        
                        if (!this._vf.isActive) {
                            //this._lastTick = 0;
                            this.postMessage('isActive', true);
                        }
                    }
                }
                else if (fieldName.indexOf("value") >= 0)
                {
                    this._value1 = this._vf.value;
                    this._value2 = this._vf.value;
                    this._value3 = this._vf.value;
                    this._value4 = this._vf.value;
                    this._value5 = this._vf.value;
                    this._lastTick = 0;
                    
                    this.postMessage('value', this._value5);
                    
                    if (!this._vf.isActive) {
                        this._lastTick = 0;
                        this.postMessage('isActive', true);
                    }
                }
            },
            
            initialize: function()
            {
                this._value0 = this._vf.initialDestination;
                this._value1 = this._vf.initialValue;
                this._value2 = this._vf.initialValue;
                this._value3 = this._vf.initialValue;
                this._value4 = this._vf.initialValue;
                this._value5 = this._vf.initialValue;
                this._lastTick = 0;
                
                var active = (Math.abs(this._value0 - this._value1) > this._eps);
                if (this._vf.isActive !== active) {
                    this.postMessage('isActive', active);
                }
            },
            
            tick: function(now)
            {
                //if (!this._vf.isActive)
                //    return false;
                
                if (!this._lastTick)
                {
                    this._lastTick = now;
                    return false;
                }

                var delta = now - this._lastTick;

                var alpha = Math.exp(-delta / this._vf.tau);

                this._value1 = this._vf.order > 0 && this._vf.tau ? 
                    this._value0 + alpha * (this._value1 - this._value0) : this._value0;

                this._value2 = this._vf.order > 1 && this._vf.tau ? 
                    this._value1 + alpha * (this._value2 - this._value1) : this._value1;

                this._value3 = this._vf.order > 2 && this._vf.tau ? 
                    this._value2 + alpha * (this._value3 - this._value2) : this._value2;

                this._value4 = this._vf.order > 3 && this._vf.tau ? 
                    this._value3 + alpha * (this._value4 - this._value3) : this._value3;

                this._value5 = this._vf.order > 4 && this._vf.tau ? 
                    this._value4 + alpha * (this._value5 - this._value4) : this._value4;

                var dist = Math.abs(this._value1 - this._value0);
                
                if (this._vf.order > 1)
                {
                    var dist2 = Math.abs(this._value2 - this._value1);
                    if (dist2 > dist) {dist = dist2;}
                }
                if (this._vf.order > 2)
                {
                    var dist3 = Math.abs(this._value3 - this._value2);
                    if (dist3 > dist) {dist = dist3;}
                }
                if (this._vf.order > 3)
                {
                    var dist4 = Math.abs(this._value4 - this._value3);
                    if (dist4 > dist) {dist = dist4;}
                }
                if (this._vf.order > 4)
                {
                    var dist5 = Math.abs(this._value5 - this._value4);
                    if (dist5 > dist) {dist = dist5;}
                }

                if (dist <= this._eps)
                {
                    this._value1 = this._value0;
                    this._value2 = this._value0;
                    this._value3 = this._value0;
                    this._value4 = this._value0;
                    this._value5 = this._value0;
                    
                    this.postMessage('value', this._value0);
                    this.postMessage('isActive', false);
                    
                    this._lastTick = 0;
                    
                    return false;
                }
                
                this.postMessage('value', this._value5);

                this._lastTick = now;

                return true;
            }
        }
    )
);

/* ### CoordinateDamper ### */
x3dom.registerNodeType(
    "CoordinateDamper",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DDamperNode,
        function (ctx) {
            x3dom.nodeTypes.CoordinateDamper.superClass.call(this, ctx);
            
            this.addField_MFVec3f(ctx, 'initialDestination', []);
            this.addField_MFVec3f(ctx, 'initialValue', []);
            
            this.addField_MFVec3f(ctx, 'value', []);
            this.addField_MFVec3f(ctx, 'destination', []);
            
            x3dom.debug.logWarning("CoordinateDamper NYI");
        }
    )
);

/* ### TexCoordDamper2D ### */
x3dom.registerNodeType(
    "TexCoordDamper2D",
    "Followers",
    defineClass(x3dom.nodeTypes.X3DDamperNode,
        function (ctx) {
            x3dom.nodeTypes.TexCoordDamper2D.superClass.call(this, ctx);
            
            this.addField_MFVec2f(ctx, 'initialDestination', []);
            this.addField_MFVec2f(ctx, 'initialValue', []);
            
            this.addField_MFVec2f(ctx, 'value', []);
            this.addField_MFVec2f(ctx, 'destination', []);
            
            x3dom.debug.logWarning("TexCoordDamper2D NYI");
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

// ### X3DInterpolatorNode ###
x3dom.registerNodeType(
    "X3DInterpolatorNode",
    "Interpolation",
    defineClass(x3dom.nodeTypes.X3DChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DInterpolatorNode.superClass.call(this, ctx);

            this.addField_MFFloat(ctx, 'key', []);
            this.addField_SFFloat(ctx, 'set_fraction', 0);
        },
        {
            linearInterp: function (time, interp) {
                if (time <= this._vf.key[0])
                    return this._vf.keyValue[0];
                    
                else if (time >= this._vf.key[this._vf.key.length-1])
                    return this._vf.keyValue[this._vf.key.length-1];
                    
                for (var i = 0; i < this._vf.key.length-1; ++i) {
                    if ((this._vf.key[i] < time) && (time <= this._vf.key[i+1]))
                        return interp( this._vf.keyValue[i], this._vf.keyValue[i+1],
                               (time - this._vf.key[i]) / (this._vf.key[i+1] - this._vf.key[i]) );
                }
                return this._vf.keyValue[0];
            }
        }
    )
);

// ### OrientationInterpolator ###
x3dom.registerNodeType(
    "OrientationInterpolator",
    "Interpolation",
    defineClass(x3dom.nodeTypes.X3DInterpolatorNode,
        function (ctx) {
            x3dom.nodeTypes.OrientationInterpolator.superClass.call(this, ctx);

            this.addField_MFRotation(ctx, 'keyValue', []);
        },
        {
            fieldChanged: function(fieldName)
            {
                if(fieldName === "set_fraction")
                {
                    var value = this.linearInterp(this._vf.set_fraction, function (a, b, t) {
                        return a.slerp(b, t);
                    });
                    this.postMessage('value_changed', value);
                }
            }
        }
    )
);

// ### PositionInterpolator ###
x3dom.registerNodeType(
    "PositionInterpolator",
    "Interpolation",
    defineClass(x3dom.nodeTypes.X3DInterpolatorNode,
        function (ctx) {
            x3dom.nodeTypes.PositionInterpolator.superClass.call(this, ctx);

            this.addField_MFVec3f(ctx, 'keyValue', []);
        },
        {
            fieldChanged: function(fieldName)
            {
                if(fieldName === "set_fraction")
                {
                    var value = this.linearInterp(this._vf.set_fraction, function (a, b, t) {
                        return a.multiply(1.0-t).add(b.multiply(t));
                    });
                    
                    this.postMessage('value_changed', value);
                }
            }
        }
    )
);

// ### NormalInterpolator ###
x3dom.registerNodeType(
    "NormalInterpolator",
    "Interpolation",
    defineClass(x3dom.nodeTypes.X3DInterpolatorNode,
        function (ctx) {
            x3dom.nodeTypes.NormalInterpolator.superClass.call(this, ctx);

            this.addField_MFVec3f(ctx, 'keyValue', []);
        },
        {
            fieldChanged: function(fieldName)
            {
                if(fieldName === "set_fraction")
                {
                    var value = this.linearInterp(this._vf.set_fraction, function (a, b, t) {
                        return a.multiply(1.0-t).add(b.multiply(t)).normalize();
                    });
                    
                    this.postMessage('value_changed', value);
                }
            }
        }
    )
);

// ### ColorInterpolator ###
x3dom.registerNodeType(
    "ColorInterpolator",
    "Interpolation",
    defineClass(x3dom.nodeTypes.X3DInterpolatorNode,
        function (ctx) {
            x3dom.nodeTypes.ColorInterpolator.superClass.call(this, ctx);

            this.addField_MFColor(ctx, 'keyValue', []);
        },
        {
            fieldChanged: function(fieldName)
            {
                if(fieldName === "set_fraction")
                {
                    // FIXME; perform color interpolation in HSV space
                    var value = this.linearInterp(this._vf.set_fraction, function (a, b, t) {
                        return a.multiply(1.0-t).add(b.multiply(t));
                    });
                    
                    this.postMessage('value_changed', value);
                }
            }
        }
    )
);

// ### ScalarInterpolator ###
x3dom.registerNodeType(
    "ScalarInterpolator",
    "Interpolation",
    defineClass(x3dom.nodeTypes.X3DInterpolatorNode,
        function (ctx) {
            x3dom.nodeTypes.ScalarInterpolator.superClass.call(this, ctx);

            this.addField_MFFloat(ctx, 'keyValue', []);
        },
        {
            fieldChanged: function(fieldName)
            {
                if(fieldName === "set_fraction")
                {
                    var value = this.linearInterp(this._vf.set_fraction, function (a, b, t) {
                        return (1.0-t)*a + t*b;
                    });
                    
                    this.postMessage('value_changed', value);
                }
            }
        }
    )
);

// ### CoordinateInterpolator ###
x3dom.registerNodeType(
    "CoordinateInterpolator",
    "Interpolation",
    defineClass(x3dom.nodeTypes.X3DInterpolatorNode,
        function (ctx) {
            x3dom.nodeTypes.CoordinateInterpolator.superClass.call(this, ctx);

            this.addField_MFVec3f(ctx, 'keyValue', []);
            
            if (ctx && ctx.xmlNode.hasAttribute('keyValue')) {
                this._vf.keyValue = [];     // FIXME!!!
                
                var arr = x3dom.fields.MFVec3f.parse(ctx.xmlNode.getAttribute('keyValue'));
                var key = this._vf.key.length > 0 ? this._vf.key.length : 1;
                var len = arr.length / key;
                for (var i=0; i<key; i++) {
                    var val = new x3dom.fields.MFVec3f();
                    for (var j=0; j<len; j++) {
                        val.push( arr[i*len+j] );
                    }
                    this._vf.keyValue.push(val);
                }
            }
        },
        {
            fieldChanged: function(fieldName)
            {
                if(fieldName === "set_fraction")
                {
                    var value = this.linearInterp(this._vf.set_fraction, function (a, b, t) {
                        var val = new x3dom.fields.MFVec3f();
                        for (var i=0; i<a.length; i++)
                            val.push(a[i].multiply(1.0-t).add(b[i].multiply(t)));
                            
                        return val;
                    });
                    
                    this.postMessage('value_changed', value);
                }
            }
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

// ### TimeSensor ###
x3dom.registerNodeType(
    "TimeSensor",
    "Time",
    defineClass(x3dom.nodeTypes.X3DSensorNode,
        function (ctx) {
            x3dom.nodeTypes.TimeSensor.superClass.call(this, ctx);

            if (ctx)
                ctx.doc._nodeBag.timer.push(this);
            else
                x3dom.debug.logWarning("TimeSensor: No runtime context found!");

            this.addField_SFTime(ctx, 'cycleInterval', 1);
            this.addField_SFBool(ctx, 'enabled', true);
            this.addField_SFBool(ctx, 'loop', false);
            this.addField_SFTime(ctx, 'startTime', 0);
            this.addField_SFTime(ctx, 'stopTime', 0);
            this.addField_SFTime(ctx, 'pauseTime', 0);
            this.addField_SFTime(ctx, 'resumeTime', 0);

            this.addField_SFTime(ctx, 'cycleTime', 0);
            this.addField_SFTime(ctx, 'elapsedTime', 0);
            this.addField_SFFloat(ctx, 'fraction_changed', 0);
            this.addField_SFBool(ctx, 'isActive', false);
            this.addField_SFBool(ctx, 'isPaused', false);
            this.addField_SFTime(ctx, 'time', 0);

            this.addField_SFBool(ctx,'first', true);
            this.addField_SFFloat(ctx,'firstCycle', 0.0);

            this._prevCycle = -1;
            this._lastTime = 0;
            this._cycleStopTime = 0;
            this._activatedTime = 0;

            if (this._vf.startTime > 0) {
                this._updateCycleStopTime();
            }

            this._backupStartTime = this._vf.startTime;
            this._backupStopTime = this._vf.stopTime;
            this._backupCycleInterval = this._vf.cycleInterval;
        },
        {
            tick: function (time)
            {
                if (!this._vf.enabled) {
                    this._lastTime = time;
                    return false;
                }

                var isActive = ( this._vf.cycleInterval > 0 &&
                    time >= this._vf.startTime &&
                    (time < this._vf.stopTime || this._vf.stopTime <= this._vf.startTime) &&
                    (this._vf.loop == true || (this._vf.loop == false && time < this._cycleStopTime)) );

                if (isActive && !this._vf.isActive) {
                    this.postMessage('isActive', true);
                    this._activatedTime = time;
                }

                // Checking for this._vf.isActive allows the dispatch of 'final events' (before deactivation)
                if (isActive || this._vf.isActive) {
                    this.postMessage('elapsedTime', time - this._activatedTime);

                    var isPaused = ( time >= this._vf.pauseTime && this._vf.pauseTime > this._vf.resumeTime );

                    if (isPaused && !this._vf.isPaused) {
                        this.postMessage('isPaused', true);
                        this.postMessage('pauseTime', time);
                    } else if (!isPaused && this._vf.isPaused) {
                        this.postMessage('isPaused', false);
                        this.postMessage('resumeTime', time);
                    }

                    if (!isPaused) {
                        var cycleFrac = this._getCycleAt(time);
                        var cycle = Math.floor(cycleFrac);

                        var cycleTime = this._vf.startTime + cycle*this._vf.cycleInterval;
                        var adjustTime = 0;

                        if (this._vf.stopTime > this._vf.startTime &&
                            this._lastTime < this._vf.stopTime && time >= this._vf.stopTime)
                            adjustTime = this._vf.stopTime;
                        else if (this._lastTime < cycleTime && time >= cycleTime)
                            adjustTime = cycleTime;

                        if( adjustTime > 0 ) {
                            time = adjustTime;
                            cycleFrac = this._getCycleAt(time);
                            cycle = Math.floor(cycleFrac);
                        }

                        var fraction = cycleFrac - cycle;

                        if (fraction < x3dom.fields.Eps) {
                            fraction = ( this._lastTime < this._vf.startTime ? 0.0 : 1.0 );
                            this.postMessage('cycleTime', time);
                        }

                        this.postMessage('fraction_changed', fraction);

                        this.postMessage('time', time);
                    }
                }

                if (!isActive && this._vf.isActive)
                    this.postMessage('isActive', false);

                this._lastTime = time;
                
                return true;
            },

            fieldChanged: function(fieldName)
            {
                if (fieldName == "enabled") {
                    // TODO; eval other relevant outputs
                    if (!this._vf.enabled && this._vf.isActive) {
                        this.postMessage('isActive', false);
                    }
                }
                else if (fieldName == "startTime") {
                    // Spec: Should be ignored when active. (Restore old value)
                    if (this._vf.isActive) {
                        this._vf.startTime = this._backupStartTime;
                        return;
                    }

                    this._backupStartTime = this._vf.startTime;
                    this._updateCycleStopTime();
                }
                else if (fieldName == "stopTime") {
                    // Spec: Should be ignored when active and less than startTime. (Restore old value)
                    if (this._vf.isActive && this._vf.stopTime <= this._vf.startTime) {
                        this._vf.stopTime = this._backupStopTime;
                        return;
                    }

                    this._backupStopTime = this._vf.stopTime;
                }
                else if (fieldName == "cycleInterval") {
                    // Spec: Should be ignored when active. (Restore old value)
                    if (this._vf.isActive) {
                        this._vf.cycleInterval = this._backupCycleInterval;
                        return;
                    }

                    this._backupCycleInterval = this._vf.cycleInterval;
                    this._updateCycleStopTime();
                }
                else if (fieldName == "loop") {
                    this._updateCycleStopTime();
                }
            },

            parentRemoved: function(parent)
            {
                if (this._parentNodes.length === 0) {
                    var doc = this.findX3DDoc();

                    for (var i=0, n=doc._nodeBag.timer.length; i<n; i++) {
                        if (doc._nodeBag.timer[i] === this) {
                            doc._nodeBag.timer.splice(i, 1);
                        }
                    }
                }
            },

            _getCycleAt: function(time)
            {
                return Math.max( 0.0, time - this._vf.startTime ) / this._vf.cycleInterval;
            },

            _updateCycleStopTime: function()
            {
                if (this._vf.loop == false) {
                    var now = new Date().getTime() / 1000;
                    var cycleToStop = Math.floor(this._getCycleAt(now)) + 1;

                    this._cycleStopTime = this._vf.startTime + cycleToStop*this._vf.cycleInterval;
                }
                else {
                    this._cycleStopTime = 0;
                }
            }
        }
    )
);

/* ### X3DTimeDependentNode ### */
x3dom.registerNodeType(
    "X3DTimeDependentNode",
    "Time",
    defineClass(x3dom.nodeTypes.X3DChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DTimeDependentNode.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'loop', false);
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


// ### Anchor ###
x3dom.registerNodeType(
    "Anchor",
    "Networking",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.Anchor.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'url', []);
            this.addField_MFString(ctx, 'parameter', []);
        },
        {
            doIntersect: function(line) {
                var isect = false;
                for (var i=0; i<this._childNodes.length; i++) {
                    if (this._childNodes[i]) {
                        isect = this._childNodes[i].doIntersect(line) || isect;
                    }
                }
                return isect;
            },

            handleTouch: function() {
                var url = this._vf.url.length ? this._vf.url[0] : "";
                var aPos = url.search("#");
                var anchor = "";
                if (aPos >= 0)
                    anchor = url.slice(aPos+1);
                
                var param = this._vf.parameter.length ? this._vf.parameter[0] : "";
                var tPos = param.search("target=");
                var target = "";
                if (tPos >= 0)
                    target = param.slice(tPos+7);
                
                // TODO: implement #Viewpoint bind 
                // http://www.web3d.org/files/specifications/19775-1/V3.2/Part01/components/networking.html#Anchor
                x3dom.debug.logInfo("Anchor url=" + url + ", target=" + target + ", #viewpoint=" + anchor);
                
                if (target.length == 0 || target == "_blank") {
                    window.open(this._nameSpace.getURL(url), target);
                }
                else {
                    window.location = this._nameSpace.getURL(url);
                }
            }
        }
    )
);

// ### Inline ###
x3dom.registerNodeType(
    "Inline",
    "Networking",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.Inline.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'url', []);
            this.addField_SFBool(ctx, 'load', true);
			this.addField_MFString(ctx, 'nameSpaceName', []);
			this.addField_SFBool(ctx, 'mapDEFToID', false);
            
			this.count = 0;
            this.numRetries = x3dom.nodeTypes.Inline.MaximumRetries;
        },
        {
            fieldChanged: function (fieldName)
            {
                if (fieldName == "url") {
					if (this._vf.nameSpaceName.length != 0) {
						var node = this._xmlNode;
						if (node && node.hasChildNodes())
						{
							while ( node.childNodes.length >= 1 )
							{
								node.removeChild( node.firstChild );       
							} 
						}
					}
                    this.nodeChanged();
                }
                else if (fieldName == "render") {
                    this.invalidateVolume();
                    //this.invalidateCache();
                }
            },

            fireEvents: function(eventType)
            {
                if ( this._xmlNode &&
                    (this._xmlNode['on'+eventType] ||
                     this._xmlNode.hasAttribute('on'+eventType) ||
                     this._listeners[eventType]) )
                {
                    var event = {
                        target: this._xmlNode,
                        type: eventType,
                        error: (eventType == "error") ? "XMLHttpRequest Error" : "",
                        cancelBubble: false,
                        stopPropagation: function() { this.cancelBubble = true; }
                    };

                    try {
                        var attrib = this._xmlNode["on" + eventType];

                        if (typeof(attrib) === "function") {
                            attrib.call(this._xmlNode, event);
                        }
                        else {
                            var funcStr = this._xmlNode.getAttribute("on" + eventType);
                            var func = new Function('event', funcStr);
                            func.call(this._xmlNode, event);
                        }

                        var list = this._listeners[eventType];
                        if (list) {
                            for (var i = 0; i < list.length; i++) {
                                list[i].call(this._xmlNode, event);
                            }
                        }
                    }
                    catch(ex) {
                        x3dom.debug.logException(ex);
                    }
                }
            },

            nodeChanged: function ()
            {
				var that = this;

                var xhr = new window.XMLHttpRequest();
                if (xhr.overrideMimeType)
                    xhr.overrideMimeType('text/xml');   //application/xhtml+xml

                xhr.onreadystatechange = function () 
                {
					if (xhr.readyState != 4) {
						// still loading
						//x3dom.debug.logInfo('Loading inlined data... (readyState: ' + xhr.readyState + ')');
						return xhr;
					}
					
					if (xhr.status === x3dom.nodeTypes.Inline.AwaitTranscoding && that.count < that.numRetries) {
						that.count++;
                        var refreshTime = +xhr.getResponseHeader("Refresh") || 5;
						x3dom.debug.logInfo('Statuscode ' + xhr.status + ' and send new request in ' + refreshTime + ' sec.');

						window.setTimeout(function() {
                            that._nameSpace.doc.downloadCount -= 1;
                            that.nodeChanged();
							}, refreshTime * 1000);
                        return xhr;
					}
					else if ((xhr.status !== 200) && (xhr.status !== 0)) {
						that.fireEvents("error");
                        x3dom.debug.logError('XHR status: ' + xhr.status + ' - XMLHttpRequest requires web server running!');

                        that._nameSpace.doc.downloadCount -= 1;
						that.count = 0;
                        return xhr;
                    }
                    else if ((xhr.status == 200) || (xhr.status == 0)) {
						that.count = 0;
					}
					
                    x3dom.debug.logInfo('Inline: downloading '+that._vf.url[0]+' done.');

                    var inlScene = null, newScene = null, nameSpace = null, xml = null;

                    if (navigator.appName != "Microsoft Internet Explorer")
                        xml = xhr.responseXML;
                    else
                        xml = new DOMParser().parseFromString(xhr.responseText, "text/xml");

                    //TODO; check if exists and FIXME: it's not necessarily the first scene in the doc!
                    if (xml !== undefined && xml !== null)
                    {
                        inlScene = xml.getElementsByTagName('Scene')[0] || 
                                   xml.getElementsByTagName('scene')[0];
                    }
                    else {
                        that.fireEvents("error");
					}
                    
                    if (inlScene)
                    {
                        var nsName = (that._vf.nameSpaceName.length != 0) ?
                                      that._vf.nameSpaceName.toString().replace(' ','') : "";
                        nameSpace = new x3dom.NodeNameSpace(nsName, that._nameSpace.doc);
                        
                        var url = that._vf.url.length ? that._vf.url[0] : "";
                        if ((url[0] === '/') || (url.indexOf(":") >= 0))
                            nameSpace.setBaseURL(url);
                        else
                            nameSpace.setBaseURL(that._nameSpace.baseURL + url);
                        
                        newScene = nameSpace.setupTree(inlScene);
                        that._nameSpace.addSpace(nameSpace);
                        
                        if(that._vf.nameSpaceName.length != 0)
                        {
                            Array.forEach ( inlScene.childNodes, function (childDomNode)
                            {
                                if(childDomNode instanceof Element)
                                {
                                    setNamespace(that._vf.nameSpaceName, childDomNode, that._vf.mapDEFToID);
                                    that._xmlNode.appendChild(childDomNode);
                                }
                            } );
                        }
                    }
                    else {
                        if (xml && xml.localName)
                            x3dom.debug.logError('No Scene in ' + xml.localName);
                        else
                            x3dom.debug.logError('No Scene in resource');
                    }

                    // trick to free memory, assigning a property to global object, then deleting it
                    var global = x3dom.getGlobal();

                    if (that._childNodes.length > 0 && that._childNodes[0] && that._childNodes[0]._nameSpace)
                        that._nameSpace.removeSpace(that._childNodes[0]._nameSpace);
                    
                    while (that._childNodes.length !== 0)
                        global['_remover'] = that.removeChild(that._childNodes[0]);
                    
                    delete global['_remover'];

                    if (newScene)
                    {
                        that.addChild(newScene);

                        that.invalidateVolume();
                        //that.invalidateCache();

                        that._nameSpace.doc.downloadCount -= 1;
                        that._nameSpace.doc.needRender = true;
                        x3dom.debug.logInfo('Inline: added ' + that._vf.url[0] + ' to scene.');
                        
                        // recalc changed scene bounding box twice
                        var theScene = that._nameSpace.doc._scene;

                        if (theScene) {
                            theScene.invalidateVolume();
                            //theScene.invalidateCache();

                            window.setTimeout( function() {
                                that.invalidateVolume();
                                //that.invalidateCache();

                                theScene.updateVolume();
                                that._nameSpace.doc.needRender = true;
                                }, 1000 );
                        }
                        
                        that.fireEvents("load");
                    }
                    
                    newScene = null;
                    nameSpace = null;
                    inlScene = null;
                    xml = null;

                    return xhr;
                };

                if (this._vf.url.length && this._vf.url[0].length)
                {
                    var xhrURI = this._nameSpace.getURL(this._vf.url[0]);

                    //Unfortunately, there is currently an inconsistent behavior between
                    //chrome and firefox, where the first one is "escaping" the "%" character in the
                    //blob URI, which contains a ref to a "file" object. This can also not be fixed by
                    //first using "decodeURI", because, in that case, "%3A" is not resolved to "%".
                    if (!(xhrURI.substr(0, 5) === "blob:"))
                    {
                        xhrURI = encodeURI(xhrURI);
                    }

                    xhr.open('GET', xhrURI, true);

                    this._nameSpace.doc.downloadCount += 1;

                    try {
                        xhr.send(null);
                    }
                    catch(ex) {
                        this.fireEvents("error");
                        x3dom.debug.logError(this._vf.url[0] + ": " + ex);
                    }
                }
            }
        }
    )
);

x3dom.nodeTypes.Inline.AwaitTranscoding = 202;      // Parameterizable retry state for Transcoder
x3dom.nodeTypes.Inline.MaximumRetries = 15;         // Parameterizable maximum number of retries


function setNamespace(prefix, childDomNode, mapDEFToID)
{
	if(childDomNode instanceof Element && childDomNode.__setAttribute !== undefined) {
	
		if(childDomNode.hasAttribute('id') )	{
			childDomNode.__setAttribute('id', prefix.toString().replace(' ','') +'__'+ childDomNode.getAttribute('id'));	
		} else if (childDomNode.hasAttribute('DEF') && mapDEFToID){
			childDomNode.__setAttribute('id', prefix.toString().replace(' ','') +'__'+ childDomNode.getAttribute('DEF'));
		}
	}
	
	if(childDomNode.hasChildNodes()){
		Array.forEach ( childDomNode.childNodes, function (children) {
			setNamespace(prefix, children, mapDEFToID);
		} );
	}		
}

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/* ### X3DBackgroundNode ### */
x3dom.registerNodeType(
    "X3DBackgroundNode",
    "EnvironmentalEffects",
    defineClass(x3dom.nodeTypes.X3DBindableNode,
        function (ctx) {
            x3dom.nodeTypes.X3DBackgroundNode.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'withCredentials', false);
            
            this._dirty = true;
        },
        {
            getSkyColor: function() {
                return new x3dom.fields.SFColor(0,0,0);
            },
            getTransparency: function() {
                return 0;
            },
            getTexUrl: function() {
                return [];
            }
        }
    )
);

/* ### X3DFogNode ### */
x3dom.registerNodeType(
    "X3DFogNode",
    "EnvironmentalEffects",
    defineClass(x3dom.nodeTypes.X3DBindableNode,
        function (ctx) {
            x3dom.nodeTypes.X3DFogNode.superClass.call(this, ctx);
        },
        {
        }
    )
);

/* ### Fog ### */
x3dom.registerNodeType(
    "Fog",
    "EnvironmentalEffects",
    defineClass(x3dom.nodeTypes.X3DFogNode,
        function (ctx) {
            x3dom.nodeTypes.Fog.superClass.call(this, ctx);

            this.addField_SFColor(ctx, 'color', 1, 1, 1);
            this.addField_SFString(ctx, 'fogType', "LINEAR");
            this.addField_SFFloat(ctx, 'visibilityRange', 0);
        },
        {
        }
    )
);


/* ### Background ### */
x3dom.registerNodeType(
    "Background",
    "EnvironmentalEffects",
    defineClass(x3dom.nodeTypes.X3DBackgroundNode,
        function (ctx) {
            x3dom.nodeTypes.Background.superClass.call(this, ctx);

            var trans = (ctx && ctx.autoGen) ? 1 : 0;

            this.addField_MFColor(ctx, 'skyColor', [new x3dom.fields.SFColor(0,0,0)]);
            this.addField_MFFloat(ctx, 'skyAngle', []);
            this.addField_MFColor(ctx, 'groundColor', []);
            this.addField_MFFloat(ctx, 'groundAngle', []);
            this.addField_SFFloat(ctx, 'transparency', trans);
            this.addField_MFString(ctx, 'backUrl', []);
            this.addField_MFString(ctx, 'bottomUrl', []);
            this.addField_MFString(ctx, 'frontUrl', []);
            this.addField_MFString(ctx, 'leftUrl', []);
            this.addField_MFString(ctx, 'rightUrl', []);
            this.addField_MFString(ctx, 'topUrl', []);
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName.indexOf("Url") > 0 || fieldName == "transparency" ||
                    fieldName.search("sky") >= 0 || fieldName.search("ground") >= 0) {
                    this._dirty = true;
                }
                else if (fieldName.indexOf("bind") >= 0) {
                    this.bind(this._vf.bind);
                }
            },

            getSkyColor: function() {
                return this._vf.skyColor;
            },

            getGroundColor: function() {
                return this._vf.groundColor;
            },

            getTransparency: function() {
                return this._vf.transparency;
            },

            getTexUrl: function() {
                return [
                    this._nameSpace.getURL(this._vf.backUrl[0]),
                    this._nameSpace.getURL(this._vf.frontUrl[0]),
                    this._nameSpace.getURL(this._vf.bottomUrl[0]),
                    this._nameSpace.getURL(this._vf.topUrl[0]),
                    this._nameSpace.getURL(this._vf.leftUrl[0]),
                    this._nameSpace.getURL(this._vf.rightUrl[0])
                ];
            }
        }
    )
);

/* ### X3DEnvironmentNode ### */
x3dom.registerNodeType(
    "X3DEnvironmentNode",
    "EnvironmentalEffects",
    defineClass(x3dom.nodeTypes.X3DBindableNode,
        function (ctx) {
            x3dom.nodeTypes.X3DEnvironmentNode.superClass.call(this, ctx);
        }
    )
);

/* ### Environment ### */
x3dom.registerNodeType(
    "Environment",
    "EnvironmentalEffects",
    defineClass(x3dom.nodeTypes.X3DEnvironmentNode,
        function (ctx) {
            x3dom.nodeTypes.Environment.superClass.call(this, ctx);

            // If TRUE, transparent objects are sorted from back to front (allows explicitly disabling sorting)
            this.addField_SFBool(ctx, 'sortTrans', true);

            // Transparent objects like glass do not throw much shadow, enable this IR convenience flag with TRUE
            this.addField_SFBool(ctx, 'shadowExcludeTransparentObjects', false);
            
            // The gamma correction to apply by default, see lighting and gamma tutorial.
            this.addField_SFString(ctx, 'gammaCorrectionDefault', "linear");

            // boolean flags for feature (de)activation
            // If TRUE, objects outside the viewing frustum are ignored
            this.addField_SFBool(ctx, 'frustumCulling', true);

            // If TRUE, objects smaller than the threshold below are ignored
            this.addField_SFBool(ctx, 'smallFeatureCulling', false);
            this.addField_SFFloat(ctx, 'smallFeatureThreshold', 1.0);

            // defaults can be >0 since only used upon activation
            this.addField_SFBool(ctx, 'occlusionCulling', false);
            this.addField_SFFloat(ctx, 'occlusionVisibilityThreshold', 0.0);

            // previously was scaleRenderedIdsOnMove; percentage of objects to be rendered, in [0,1]
            this.addField_SFBool(ctx, 'lowPriorityCulling', false);
            this.addField_SFFloat(ctx, 'lowPriorityThreshold', 1.0);     // 1.0 means everything is rendered

            // shape tesselation is lowered as long as resulting error is lower than threshold
            this.addField_SFBool(ctx, 'tessellationDetailCulling', false);
            this.addField_SFFloat(ctx, 'tessellationErrorThreshold', 0.0);

            // experimental If true ARC adjusts rendering parameters
            this.addField_SFBool(ctx, 'enableARC', false);
            // define frame-rate range for quality-speed trade-off (experimental)
            this.addField_SFFloat(ctx, 'minFrameRate',  1.0);
            this.addField_SFFloat(ctx, 'maxFrameRate', 62.5);

            // 4 exp. factors for controlling speed-performance trade-off
            // factors could be in [0, 1] (and not evaluated if -1)
            this.addField_SFFloat(ctx, 'userDataFactor', -1);
            this.addField_SFFloat(ctx, 'smallFeatureFactor', -1);
            this.addField_SFFloat(ctx, 'occlusionVisibilityFactor', -1);
            this.addField_SFFloat(ctx, 'lowPriorityFactor', -1);
            this.addField_SFFloat(ctx, 'tessellationErrorFactor', -1);

            this._validGammaCorrectionTypes = [
                "none", "fastlinear", "linear"
            ];

            // init internal stuff (but should be called each frame)
            this.checkSanity();
        },
        {
            checkSanity: function()
            {
                var checkParam = function(flag, value, defaultOn, defaultOff)
                {
                    if(flag && (value == defaultOff))
                        return defaultOn;

                    if(!flag && (value != defaultOff))
                        return defaultOff;
                    return value;
                };
                
                this._smallFeatureThreshold = checkParam(this._vf.smallFeatureCulling,
                                                         this._vf.smallFeatureThreshold, 10, 0); // cull objects < 10 px
                this._lowPriorityThreshold = checkParam(this._vf.lowPriorityCulling,
                                                        this._vf.lowPriorityThreshold, 0.5, 1);  // 1 means 100% visible
                this._occlusionVisibilityThreshold = checkParam(this._vf.occlusionCulling,
                                                                this._vf.occlusionVisibilityThreshold, 1, 0);
                this._tessellationErrorThreshold = checkParam(this._vf.tessellationDetailCulling,
                                                              this._vf.tessellationErrorThreshold, 1, 0);
                
                var checkGamma = function(field, that) {
                    field = field.toLowerCase();

                    if (that._validGammaCorrectionTypes.indexOf(field) > -1) {
                        return field;
                    }
                    else {
                        x3dom.debug.logWarning(field + " gammaCorrectionDefault may only be linear (default), fastLinear, or none");
                        return "linear";
                    }
                };
                
                this._vf.gammaCorrectionDefault = checkGamma(this._vf.gammaCorrectionDefault, this);
            }
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### X3DViewpointNode ### */
x3dom.registerNodeType(
    "X3DViewpointNode",
    "Navigation",
    defineClass(x3dom.nodeTypes.X3DBindableNode,
        function (ctx) {
            x3dom.nodeTypes.X3DViewpointNode.superClass.call(this, ctx);

            // attach some convenience accessor methods to dom/xml node
            if (ctx && ctx.xmlNode) {
                var domNode = ctx.xmlNode;

                if (!domNode.resetView && !domNode.getFieldOfView &&
                    !domNode.getNear && !domNode.getFar)
                {
                    domNode.resetView = function() {
                        var that = this._x3domNode;

                        that.resetView();
                        that._nameSpace.doc.needRender = true;
                    };

                    domNode.getFieldOfView = function() {
                        return this._x3domNode.getFieldOfView();
                    };

                    domNode.getNear = function() {
                        return this._x3domNode.getNear();
                    };

                    domNode.getFar = function() {
                        return this._x3domNode.getFar();
                    };
                }
            }
        },
        {
            activate: function (prev) {
                var viewarea = this._nameSpace.doc._viewarea;
                if (prev) {
                    viewarea.animateTo(this, prev._autoGen ? null : prev);
                }
                viewarea._needNavigationMatrixUpdate = true;

                x3dom.nodeTypes.X3DBindableNode.prototype.activate.call(this, prev);
                //x3dom.debug.logInfo ('activate ViewBindable ' + this._DEF + '/' + this._vf.description);
            },

            deactivate: function (prev) {
                x3dom.nodeTypes.X3DBindableNode.prototype.deactivate.call(this, prev);
                //x3dom.debug.logInfo ('deactivate ViewBindable ' + this._DEF + '/' + this._vf.description);
            },

            getTransformation: function() {
                return this.getCurrentTransform();
            },

            getCenterOfRotation: function() {
                return new x3dom.fields.SFVec3f(0, 0, 0);
            },

            getFieldOfView: function() {
                return 1.57079633;
            },

            setView: function(newView) {
                var mat = this.getCurrentTransform();
                this._viewMatrix = newView.mult(mat);
            },

            resetView: function() {
                // see derived class
            },

            getNear: function() {
                return 0.1;
            },

            getFar: function() {
                return 10000;
            },

            getImgPlaneHeightAtDistOne: function() {
                return 2.0;
            },

            getViewMatrix: function() {
                return null;
            },

            getProjectionMatrix: function(aspect) {
                return null;
            }
        }
    )
);

/* ### Viewpoint ### */
x3dom.registerNodeType(
    "Viewpoint",
    "Navigation",
    defineClass(x3dom.nodeTypes.X3DViewpointNode,
        function (ctx) {
            x3dom.nodeTypes.Viewpoint.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'fieldOfView', 0.785398);
            this.addField_SFVec3f(ctx, 'position', 0, 0, 10);
            this.addField_SFRotation(ctx, 'orientation', 0, 0, 0, 1);
            this.addField_SFVec3f(ctx, 'centerOfRotation', 0, 0, 0);
            this.addField_SFFloat(ctx, 'zNear', -1); //0.1);
            this.addField_SFFloat(ctx, 'zFar', -1);  //100000);

            //this._viewMatrix = this._vf.orientation.toMatrix().transpose().
            //    mult(x3dom.fields.SFMatrix4f.translation(this._vf.position.negate()));
            this._viewMatrix = x3dom.fields.SFMatrix4f.translation(this._vf.position).
                mult(this._vf.orientation.toMatrix()).inverse();

            this._projMatrix = null;
            this._lastAspect = 1.0;

            // z-ratio: a value around 5000 would be better...
            this._zRatio = 10000;
            this._zNear = this._vf.zNear;
            this._zFar = this._vf.zFar;
            
            // special stuff...
            this._imgPlaneHeightAtDistOne = 2.0 * Math.tan(this._vf.fieldOfView / 2.0);
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "position" || fieldName == "orientation") {
                    this.resetView();
                }
                else if (fieldName == "fieldOfView" ||
                         fieldName == "zNear" || fieldName == "zFar") {
                    this._projMatrix = null;   // only trigger refresh
                    this._zNear = this._vf.zNear;
                    this._zFar = this._vf.zFar;
                    this._imgPlaneHeightAtDistOne = 2.0 * Math.tan(this._vf.fieldOfView / 2.0);
                }
                else if (fieldName.indexOf("bind") >= 0) {
                    // FIXME; call parent.fieldChanged();
                    this.bind(this._vf.bind);
                }
            },

            getCenterOfRotation: function() {
                return this._vf.centerOfRotation;
            },
            
            getViewMatrix: function() {
                return this._viewMatrix;
            },
            
            getFieldOfView: function() {
                return this._vf.fieldOfView;
            },

            resetView: function() {
                this._viewMatrix = x3dom.fields.SFMatrix4f.translation(this._vf.position).
                    mult(this._vf.orientation.toMatrix()).inverse();
            },
            
            getNear: function() {
                return this._zNear;
            },
            
            getFar: function() {
                return this._zFar;
            },
            
            getImgPlaneHeightAtDistOne: function() {
                return this._imgPlaneHeightAtDistOne;
            },

            getProjectionMatrix: function(aspect)
            {
                var fovy = this._vf.fieldOfView;
                var zfar = this._vf.zFar;
                var znear = this._vf.zNear;

                if (znear <= 0 || zfar <= 0)
                {
                    var nearScale = 0.8, farScale = 1.2;
                    var viewarea = this._nameSpace.doc._viewarea;
                    var scene = viewarea._scene;

                    // Doesn't work if called e.g. from RenderedTexture with different sub-scene
                    var min = x3dom.fields.SFVec3f.copy(scene._lastMin);
                    var max = x3dom.fields.SFVec3f.copy(scene._lastMax);
                    
                    var dia = max.subtract(min);
                    var sRad = dia.length() / 2;
                    
                    var mat = viewarea.getViewMatrix().inverse();
                    var vp = mat.e3();

                    // account for scales around the viewpoint
                    var translation = new x3dom.fields.SFVec3f(0,0,0),
                        scaleFactor = new x3dom.fields.SFVec3f(1,1,1);
                    var rotation = new x3dom.fields.Quaternion(0,0,1,0),
                        scaleOrientation = new x3dom.fields.Quaternion(0,0,1,0);

                    // unfortunately, decompose is a rather expensive operation
                    mat.getTransform(translation, rotation, scaleFactor, scaleOrientation);

                    var minScal = scaleFactor.x, maxScal = scaleFactor.x;

                    if (maxScal < scaleFactor.y) maxScal = scaleFactor.y;
                    if (minScal > scaleFactor.y) minScal = scaleFactor.y;
                    if (maxScal < scaleFactor.z) maxScal = scaleFactor.z;
                    if (minScal > scaleFactor.z) minScal = scaleFactor.z;

                    if (maxScal > 1)
                        nearScale /= maxScal;
                    else if (minScal > x3dom.fields.Eps && minScal < 1)
                        farScale /= minScal;
                    // near/far scale adaption done

                    var sCenter = min.add(dia.multiply(0.5));
                    var vDist = (vp.subtract(sCenter)).length();
                    
                    if (sRad) {
                        if (vDist > sRad)
                            znear = (vDist - sRad) * nearScale;  // Camera outside scene
                        else
                            znear = 0;                           // Camera inside scene
                        
                        zfar = (vDist + sRad) * farScale;
                    }
                    else {
                        znear = 0.1;
                        zfar = 100000;
                    }
                    
                    var zNearLimit = zfar / this._zRatio;
                    znear = Math.max(znear, Math.max(x3dom.fields.Eps, zNearLimit));

                    if (zfar > this._vf.zNear && this._vf.zNear > 0)
                        znear = this._vf.zNear;
                    if (this._vf.zFar > znear)
                        zfar = this._vf.zFar;

                    if (zfar <= znear)
                        zfar = znear + 1;
                    //x3dom.debug.logInfo("near: " + znear + " -> far:" + zfar);
                }

                if (this._projMatrix == null)
                {
                    this._projMatrix = x3dom.fields.SFMatrix4f.perspective(fovy, aspect, znear, zfar);
                }
                else if (this._zNear != znear || this._zFar != zfar)
                {
                    var div = znear - zfar;
                    this._projMatrix._22 = (znear + zfar) / div;
                    this._projMatrix._23 = 2 * znear * zfar / div;
                }
                else if (this._lastAspect != aspect)
                {
                    this._projMatrix._00 = (1 / Math.tan(fovy / 2)) / aspect;
                }

                // also needed for being able to ask for near and far
                this._zNear = znear;
                this._zFar = zfar;
                this._lastAspect = aspect;

                return this._projMatrix;
            }
        }
    )
);

/* ### OrthoViewpoint ### */
x3dom.registerNodeType(
        "OrthoViewpoint",
        "Navigation",
        defineClass(x3dom.nodeTypes.X3DViewpointNode,
        function (ctx) {
            x3dom.nodeTypes.OrthoViewpoint.superClass.call(this, ctx);

            this.addField_MFFloat(ctx, 'fieldOfView', [-1, -1, 1, 1]);
            this.addField_SFVec3f(ctx, 'position', 0, 0, 10);
            this.addField_SFRotation(ctx, 'orientation', 0, 0, 0, 1);
            this.addField_SFVec3f(ctx, 'centerOfRotation', 0, 0, 0);
            this.addField_SFFloat(ctx, 'zNear', 0.1);
            this.addField_SFFloat(ctx, 'zFar', 10000);

            this._viewMatrix = null;
            this._projMatrix = null;
            this._lastAspect = 1.0;

            this.resetView();
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "position" || fieldName == "orientation") {
                    this.resetView();
                }
                else if (fieldName == "fieldOfView" ||
                         fieldName == "zNear" || fieldName == "zFar") {
                    this._projMatrix = null;   // trigger refresh
                    this.resetView();
                }
                else if (fieldName.indexOf("bind") >= 0) {
                    this.bind(this._vf.bind);
                }
            },

            getCenterOfRotation: function() {
                return this._vf.centerOfRotation;
            },
            
            getViewMatrix: function() {
                return this._viewMatrix;
            },
            
            resetView: function() {
                var offset = x3dom.fields.SFMatrix4f.translation(new x3dom.fields.SFVec3f(
                                (this._vf.fieldOfView[0] + this._vf.fieldOfView[2]) / 2, 
                                (this._vf.fieldOfView[1] + this._vf.fieldOfView[3]) / 2, 0));
                
                this._viewMatrix = x3dom.fields.SFMatrix4f.translation(this._vf.position).
                                                    mult(this._vf.orientation.toMatrix());
                this._viewMatrix = this._viewMatrix.mult(offset).inverse();
            },
            
            getNear: function() {
                return this._vf.zNear;
            },
            
            getFar: function() {
                return this._vf.zFar;
            },
            
            getProjectionMatrix: function(aspect)
            {
                if (this._projMatrix == null || this._lastAspect != aspect)
                {
                    var near = this.getNear();
                    var far = this.getFar();
                    
                    var left = this._vf.fieldOfView[0];
                    var bottom = this._vf.fieldOfView[1];
                    var right = this._vf.fieldOfView[2];
                    var top = this._vf.fieldOfView[3];
                    
                    this._projMatrix = x3dom.fields.SFMatrix4f.ortho(left, right, bottom, top, near, far, aspect);
                }
                this._lastAspect = aspect;
                
                return this._projMatrix;
            }
        }
    )
);

/* ### Viewfrustum ### */
x3dom.registerNodeType(
    "Viewfrustum",
    "Navigation",
    defineClass(x3dom.nodeTypes.X3DViewpointNode,
        function (ctx) {
            x3dom.nodeTypes.Viewfrustum.superClass.call(this, ctx);
            
            this.addField_SFMatrix4f(ctx, 'modelview',  1, 0, 0, 0,
                                                        0, 1, 0, 0,
                                                        0, 0, 1, 0,
                                                        0, 0, 0, 1);
            this.addField_SFMatrix4f(ctx, 'projection', 1, 0, 0, 0,
                                                        0, 1, 0, 0,
                                                        0, 0, 1, 0,
                                                        0, 0, 0, 1);

            this._viewMatrix = this._vf.modelview.transpose().inverse();
            this._projMatrix = this._vf.projection.transpose();

            this._centerOfRotation = new x3dom.fields.SFVec3f(0, 0, 0);
            // FIXME; derive near/far from current matrix, if requested!
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "modelview") {
                    this.resetView();
                }
                else if (fieldName == "projection") {
                    this._projMatrix = this._vf.projection.transpose();
                }
                else if (fieldName.indexOf("bind") >= 0) {
                    this.bind(this._vf.bind);
                }
            },

            getCenterOfRotation: function() {
                return this._centerOfRotation;  // this field is only a little helper for examine mode
            },
            
            getViewMatrix: function() {
                return this._viewMatrix;
            },
            
            getFieldOfView: function() {
                return (2.0 * Math.atan(1.0 / this._projMatrix._11));
            },

            getImgPlaneHeightAtDistOne: function() {
                return 2.0 / this._projMatrix._11;
            },
            
            resetView: function() {
                this._viewMatrix = this._vf.modelview.transpose().inverse();
                this._centerOfRotation = new x3dom.fields.SFVec3f(0, 0, 0);       // reset helper, too
            },

            getProjectionMatrix: function(aspect) {
                return this._projMatrix;
            }
        }
    )
);

/* ### X3DNavigationInfoNode ### */
x3dom.registerNodeType(
    "X3DNavigationInfoNode",
    "Navigation",
    defineClass(x3dom.nodeTypes.X3DBindableNode,
        function (ctx) {
            x3dom.nodeTypes.X3DNavigationInfoNode.superClass.call(this, ctx);
        }
    )
);

/* ### NavigationInfo ### */
x3dom.registerNodeType(
    "NavigationInfo",
    "Navigation",
    defineClass(x3dom.nodeTypes.X3DNavigationInfoNode,
        function (ctx) {
            x3dom.nodeTypes.NavigationInfo.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'headlight', true);
            this.addField_MFString(ctx, 'type', ["EXAMINE","ANY"]);
            // view angle and height for helicopter mode and
            // min/max rotation angle for turntable in ]0, PI[, starting from +y (0) down to -y (PI)
            this.addField_MFFloat(ctx, 'typeParams', [-0.4, 60, 0.05, 2.8]);
            // allows restricting examine and turntable navigation, overrides mouse buttons
            // can be one of [all, pan, zoom, rotate, none] (useful for special viewers)
            this.addField_SFString(ctx, 'explorationMode', 'all');
            // TODO; use avatarSize + visibilityLimit for projection matrix (near/far)
            this.addField_MFFloat(ctx, 'avatarSize', [0.25, 1.6, 0.75]);
            this.addField_SFFloat(ctx, 'visibilityLimit', 0.0);
            this.addField_SFFloat(ctx, 'speed', 1.0);
            // for 'jumping' between viewpoints (bind transition time)
            this.addField_SFTime(ctx, 'transitionTime', 1.0);
            this.addField_MFString(ctx, 'transitionType', ["LINEAR"]);

            this._validTypes = [
                "none", "examine", "turntable",
                "fly", "freefly", "lookat", "lookaround",
                "walk", "game", "helicopter", "any"
            ];
            this._heliUpdated = false;

            var type = this.checkType(this.getType());
            x3dom.debug.logInfo("NavType: " + type);
        },
        {
            fieldChanged: function(fieldName) {
                if (fieldName == "typeParams") {
                    this._heliUpdated = false;
                }
                else if (fieldName == "type") {
                    var type = this.checkType(this.getType());

                    switch (type) {
                        case 'game':
                            this._nameSpace.doc._viewarea.initMouseState();
                            break;
                        case 'helicopter':
                            this._heliUpdated = false;
                            break;
                        default:
                            break;
                    }

                    this._vf.type[0] = type;
                    x3dom.debug.logInfo("Switch to " + type + " mode.");
                }
            },

            setType: function(type, viewarea) {
                var navType = this.checkType(type.toLowerCase());
                var oldType = this.checkType(this.getType());

                switch (navType) {
                    case 'game':
                        if (oldType !== navType) {
                            if (viewarea)
                                viewarea.initMouseState();
                            else
                                this._nameSpace.doc._viewarea.initMouseState();
                        }
                        break;
                    case 'helicopter':
                        if (oldType !== navType) {
                            this._heliUpdated = false;
                        }
                        break;
                    default:
                        break;
                }

                this._vf.type[0] = navType;
                x3dom.debug.logInfo("Switch to " + navType + " mode.");
            },

            getType: function() {
                var type = this._vf.type[0].toLowerCase();
                // FIXME; the following if's aren't nice!
                if (type.length <= 1)
                    type = "none";
                else if (type == "any")
                    type = "examine";
                return type;
            },

            getTypeParams: function() {
                var length = this._vf.typeParams.length;

                var theta  = (length >= 1) ? this._vf.typeParams[0] : -0.4;
                var height = (length >= 2) ? this._vf.typeParams[1] : 60.0;
                var minAngle = (length >= 3) ? this._vf.typeParams[2] : x3dom.fields.Eps;
                var maxAngle = (length >= 4) ? this._vf.typeParams[3] : Math.PI - x3dom.fields.Eps;

                return [theta, height, minAngle, maxAngle];
            },

            setTypeParams: function(params) {
                for (var i=0; i<params.length; i++) {
                    this._vf.typeParams[i] = params[i];
                }
            },

            checkType: function(type) {
                if (this._validTypes.indexOf(type) > -1) {
                    return type;
                }
                else {
                    x3dom.debug.logWarning(type + " is no valid navigation type, use one of " +
                                           this._validTypes.toString());
                    return "examine";
                }
            },

            getExplorationMode: function() {
                switch (this._vf.explorationMode.toLowerCase()) {
                    case "all":    return 7;
                    case "rotate": return 1; //left btn
                    case "zoom":   return 2; //right btn
                    case "pan":    return 4; //middle btn
                    case "none":   return 0; //type 'none'
                    default:       return 7;
                }
            }
        }
    )
);


/* ### Billboard ### */
x3dom.registerNodeType(
    "Billboard",
    "Navigation",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.Billboard.superClass.call(this, ctx);

            // When the axisOfRotation field is set to (0, 0, 0),
            // the special case of viewer-alignment is indicated.
            this.addField_SFVec3f(ctx, 'axisOfRotation', 0, 1, 0);

            this._eye = new x3dom.fields.SFVec3f(0, 0, 0);
            this._eyeViewUp = new x3dom.fields.SFVec3f(0, 0, 0);
            this._eyeLook = new x3dom.fields.SFVec3f(0, 0, 0);
        },
        {
            collectDrawableObjects: function (transform, drawableCollection, singlePath, invalidateCache, planeMask)
            {
                if (singlePath && (this._parentNodes.length > 1))
                    singlePath = false;

                if (singlePath && (invalidateCache = invalidateCache || this.cacheInvalid()))
                    this.invalidateCache();

                planeMask = drawableCollection.cull(transform, this.graphState(), singlePath, planeMask);
                if (planeMask <= 0) {
                    return;
                }

                // no caching later on as transform changes almost every frame anyway
                singlePath = false;

                var vol = this.getVolume();

                var min = x3dom.fields.SFVec3f.MAX();
                var max = x3dom.fields.SFVec3f.MIN();
                vol.getBounds(min, max);
                
                var mat_view = drawableCollection.viewMatrix;
                
                var center = new x3dom.fields.SFVec3f(0, 0, 0); // eye
                center = mat_view.inverse().multMatrixPnt(center);
                
                var mat_view_model = mat_view.mult(transform);
                this._eye = transform.inverse().multMatrixPnt(center);
                this._eyeViewUp = new x3dom.fields.SFVec3f(mat_view_model._10, mat_view_model._11, mat_view_model._12);
                this._eyeLook = new x3dom.fields.SFVec3f(mat_view_model._20, mat_view_model._21, mat_view_model._22);
                
                var rotMat = x3dom.fields.SFMatrix4f.identity();
                var mid = max.add(min).multiply(0.5);
                var billboard_to_viewer = this._eye.subtract(mid);

                if(this._vf.axisOfRotation.equals(new x3dom.fields.SFVec3f(0, 0, 0), x3dom.fields.Eps)) {
                    var rot1 = x3dom.fields.Quaternion.rotateFromTo(
                                billboard_to_viewer, new x3dom.fields.SFVec3f(0, 0, 1));
                    rotMat = rot1.toMatrix().transpose();

                    var yAxis = rotMat.multMatrixPnt(new x3dom.fields.SFVec3f(0, 1, 0)).normalize();
                    var zAxis = rotMat.multMatrixPnt(new x3dom.fields.SFVec3f(0, 0, 1)).normalize();

                    if(!this._eyeViewUp.equals(new x3dom.fields.SFVec3f(0, 0, 0), x3dom.fields.Eps)) {
                        // new local z-axis aligned with camera z-axis
                        var rot2 = x3dom.fields.Quaternion.rotateFromTo(this._eyeLook, zAxis);
                        // new: local y-axis rotated by rot2
                        var rotatedyAxis = rot2.toMatrix().transpose().multMatrixVec(yAxis);
                        // new: rotated local y-axis aligned with camera y-axis
                        var rot3 = x3dom.fields.Quaternion.rotateFromTo(this._eyeViewUp, rotatedyAxis);
                        
                        rotMat = rot2.toMatrix().transpose().mult(rotMat);
                        rotMat = rot3.toMatrix().transpose().mult(rotMat);
                    }
                }
                else {
                    var normalPlane = this._vf.axisOfRotation.cross(billboard_to_viewer).normalize();

                    if(this._eye.z < 0) {
                        normalPlane = normalPlane.multiply(-1);
                    }

                    var degreesToRotate = Math.asin(normalPlane.dot(new x3dom.fields.SFVec3f(0, 0, 1)));

                    if(this._eye.z < 0) {
                        degreesToRotate += Math.PI;
                    }

                    rotMat = x3dom.fields.SFMatrix4f.parseRotation(
                            this._vf.axisOfRotation.x + ", " + this._vf.axisOfRotation.y + ", " + 
                            this._vf.axisOfRotation.z + ", " + degreesToRotate*(-1));
                }

                var childTransform = this.transformMatrix(transform.mult(rotMat));

                for (var i=0, i_n=this._childNodes.length; i<i_n; i++)
                {
                    var cnode = this._childNodes[i];
                    if (cnode) {
                        cnode.collectDrawableObjects(childTransform, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                }
            }
        }
    )
);

// ### Collision ###
x3dom.registerNodeType(
    "Collision",
    "Navigation",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.Collision.superClass.call(this, ctx);

            this.addField_SFBool (ctx, "enabled", true);
            this.addField_SFNode ("proxy", x3dom.nodeTypes.X3DGroupingNode);

            // TODO; add Slots: collideTime, isActive
        },
        {
            collectDrawableObjects: function (transform, drawableCollection, singlePath, invalidateCache, planeMask)
            {
                if (singlePath && (this._parentNodes.length > 1))
                    singlePath = false;

                if (singlePath && (invalidateCache = invalidateCache || this.cacheInvalid()))
                    this.invalidateCache();

                planeMask = drawableCollection.cull(transform, this.graphState(), singlePath, planeMask);
                if (planeMask <= 0) {
                    return;
                }

                var cnode, childTransform;

                if (singlePath) {
                    if (!this._graph.globalMatrix) {
                        this._graph.globalMatrix = this.transformMatrix(transform);
                    }
                    childTransform = this._graph.globalMatrix;
                }
                else {
                    childTransform = this.transformMatrix(transform);
                }

                for (var i=0, n=this._childNodes.length; i<n; i++)
                {
                    if ((cnode = this._childNodes[i]) && (cnode !== this._cf.proxy.node)) {
                        cnode.collectDrawableObjects(childTransform, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                }
            }
        }
    )
);

// ### X3DLODNode ###
x3dom.registerNodeType(
    "X3DLODNode",
    "Navigation",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.X3DLODNode.superClass.call(this, ctx);

            this.addField_SFBool (ctx, "forceTransitions", false);
            this.addField_SFVec3f(ctx, "center", 0, 0, 0);

            this._eye = new x3dom.fields.SFVec3f(0, 0, 0);
        },
        {
            collectDrawableObjects: function(transform, drawableCollection, singlePath, invalidateCache, planeMask)
            {
                if (singlePath && (this._parentNodes.length > 1))
                    singlePath = false;

                if (singlePath && (invalidateCache = invalidateCache || this.cacheInvalid()))
                    this.invalidateCache();

                planeMask = drawableCollection.cull(transform, this.graphState(), singlePath, planeMask);
                if (planeMask <= 0) {
                    return;
                }

                // at the moment, no caching here as children may change every frame
                singlePath = false;

                this.visitChildren(transform, drawableCollection, singlePath, invalidateCache, planeMask);

                //out.LODs.push( [transform, this] );
            },
            
            visitChildren: function(transform, drawableCollection, singlePath, invalidateCache, planeMask) {
                // overwritten
            }
        }
    )
);

// ### LOD ###
x3dom.registerNodeType(
    "LOD",
    "Navigation",
    defineClass(x3dom.nodeTypes.X3DLODNode,
        function (ctx) {
            x3dom.nodeTypes.LOD.superClass.call(this, ctx);

            this.addField_MFFloat(ctx, "range", []);

            this._lastRangePos = -1;
        },
        {
            visitChildren: function(transform, drawableCollection, singlePath, invalidateCache, planeMask)
            {
                var i=0, n=this._childNodes.length;

                var vol = this.getVolume(); 

                var min = x3dom.fields.SFVec3f.MAX();
                var max = x3dom.fields.SFVec3f.MIN();
                vol.getBounds(min, max);

                var mat_view = drawableCollection.viewMatrix;
                
                var center = new x3dom.fields.SFVec3f(0, 0, 0); // eye
                center = mat_view.inverse().multMatrixPnt(center);
                
                //var mat_view_model = mat_view.mult(transform);
                this._eye = transform.inverse().multMatrixPnt(center);
                
                var mid = max.add(min).multiply(0.5).add(this._vf.center);
                var len = mid.subtract(this._eye).length();
                
                //calculate range check for viewer distance d (with range in local coordinates)
                //N+1 children nodes for N range values (L0, if d < R0, ... Ln-1, if d >= Rn-1)
                while (i < this._vf.range.length && len > this._vf.range[i]) {
                    i++;
                }
                if (i && i >= n) {
                    i = n - 1;
                }
                this._lastRangePos = i;

                var cnode = this._childNodes[i];
                if (n && cnode)
                {
                    var childTransform = this.transformMatrix(transform);
                    cnode.collectDrawableObjects(childTransform, drawableCollection, singlePath, invalidateCache, planeMask);
                }
            },

            getVolume: function()
            {
                var vol = this._graph.volume;

                if (!this.volumeValid() && this._vf.render)
                {
                    var child, childVol;

                    if (this._lastRangePos >= 0) {
                        child = this._childNodes[this._lastRangePos];

                        childVol = (child && child._vf.render === true) ? child.getVolume() : null;

                        if (childVol && childVol.isValid())
                            vol.extendBounds(childVol.min, childVol.max);
                    }
                    else {  // first time we're here
                        for (var i=0, n=this._childNodes.length; i<n; i++)
                        {
                            if (!(child = this._childNodes[i]) || child._vf.render !== true)
                                continue;

                            childVol = child.getVolume();

                            if (childVol && childVol.isValid())
                                vol.extendBounds(childVol.min, childVol.max);
                        }
                    }
                }

                return vol;
            },
            
            nodeChanged: function() {
                //this._needReRender = true;
                this.invalidateVolume();
                //this.invalidateCache();
            },
            
            fieldChanged: function(fieldName) {
                //this._needReRender = true;
                if (fieldName == "render" ||
                    fieldName == "center" ||
                    fieldName == "range") {
                    this.invalidateVolume();
                    //this.invalidateCache();
                }
            }
        }
    )
);

// ### DynamicLOD ###
x3dom.registerNodeType(
    "DynamicLOD",
    "Navigation",
    defineClass(x3dom.nodeTypes.X3DLODNode,
        function (ctx) {
            x3dom.nodeTypes.DynamicLOD.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'subScale', 0.5);
            this.addField_SFVec2f(ctx, 'size', 2, 2);
            this.addField_SFVec2f(ctx, 'subdivision', 1, 1);
            this.addField_SFNode ('root', x3dom.nodeTypes.X3DShapeNode);
            
            this.addField_SFString(ctx, 'urlHead', "http://r");
            this.addField_SFString(ctx, 'urlCenter', ".ortho.tiles.virtualearth.net/tiles/h");
            this.addField_SFString(ctx, 'urlTail', ".png?g=-1");
            
            this.rootGeometry = new x3dom.nodeTypes.Plane(ctx);
            this.level = 0;
            this.quadrant = 4;
            this.cell = "";
        },
        {
            nodeChanged: function()
            {
                var root = this._cf.root.node;
                
                if (root == null || root._cf.geometry.node != null)
                    return;
                
                this.rootGeometry._vf.size.setValues(this._vf.size);
                this.rootGeometry._vf.subdivision.setValues(this._vf.subdivision);
                this.rootGeometry._vf.center.setValues(this._vf.center);
                this.rootGeometry.fieldChanged("subdivision");   // trigger update
                
    		    this._cf.root.node.addChild(this.rootGeometry);  // add to shape
    		    this.rootGeometry.nodeChanged();
    		    
    		    this._cf.root.node.nodeChanged();
    		    
    		    this._nameSpace.doc.needRender = true;
            },
            
            visitChildren: function(transform, drawableCollection, singlePath, invalidateCache, planeMask)
            {
                var root = this._cf.root.node;
                
                if (root == null)
                    return;
                    
                var mat_view = drawableCollection.viewMatrix;
                
                var center = new x3dom.fields.SFVec3f(0, 0, 0); // eye
                center = mat_view.inverse().multMatrixPnt(center);
                
                //var mat_view_model = mat_view.mult(transform);
                this._eye = transform.inverse().multMatrixPnt(center);
                
                var l, len = this._vf.center.subtract(this._eye).length();
                
                //calculate range check for viewer distance d (with range in local coordinates)
                if (len > x3dom.fields.Eps && len * this._vf.subScale <= this._vf.size.length()) {
                    /*  Quadrants per level: (TODO; make parameterizable, e.g. 0 and 1 might be swapped)
                        0 | 1
                        -----
                        2 | 3
                    */
                    if (this._childNodes.length <= 1) {
                        var offset = new Array(
                                new x3dom.fields.SFVec3f(-0.25*this._vf.size.x,  0.25*this._vf.size.y, 0),
                                new x3dom.fields.SFVec3f( 0.25*this._vf.size.x,  0.25*this._vf.size.y, 0),
                                new x3dom.fields.SFVec3f(-0.25*this._vf.size.x, -0.25*this._vf.size.y, 0),
                                new x3dom.fields.SFVec3f( 0.25*this._vf.size.x, -0.25*this._vf.size.y, 0)
                            );
                        
                        for (l=0; l<4; l++) {
                            var node = new x3dom.nodeTypes.DynamicLOD();                        
                            
                            node._nameSpace = this._nameSpace;
                            node._eye.setValues(this._eye);
                            
                            node.level = this.level + 1;
                            node.quadrant = l;
                            node.cell = this.cell + l;
                            
                            node._vf.urlHead = this._vf.urlHead;
                            node._vf.urlCenter = this._vf.urlCenter;
                            node._vf.urlTail = this._vf.urlTail;
                            
                            node._vf.center = this._vf.center.add(offset[l]);
                            node._vf.size = this._vf.size.multiply(0.5);
                            node._vf.subdivision.setValues(this._vf.subdivision);
                            
                            var app = new x3dom.nodeTypes.Appearance();
                            
                            //var mat = new x3dom.nodeTypes.Material();
                            //mat._vf.diffuseColor = new x3dom.fields.SFVec3f(Math.random(),Math.random(),Math.random());
                            //
                            //app.addChild(mat);
                            //mat.nodeChanged();
                            
                            var tex = new x3dom.nodeTypes.ImageTexture();
                            tex._nameSpace = this._nameSpace;
                            tex._vf.url[0] = this._vf.urlHead + node.quadrant + this._vf.urlCenter + node.cell + this._vf.urlTail;
                            //x3dom.debug.logInfo(tex._vf.url[0]);
                            
                            app.addChild(tex);
                            tex.nodeChanged();
                            
                            var shape = new x3dom.nodeTypes.Shape();
                            shape._nameSpace = this._nameSpace;
                            
                            shape.addChild(app);
                            app.nodeChanged();
                            
                            node.addChild(shape, "root");
                            shape.nodeChanged();
                            
                            this.addChild(node);
                            node.nodeChanged();
                        }
                    }
                    else {
                        for (l=1; l<this._childNodes.length; l++) {
                            this._childNodes[l].collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                        }
                    }
                }
                else {
                    root.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                }
            },

            getVolume: function() {
                var vol = this._graph.volume;

                if (!vol.isValid()) {
                    vol.min.setValues(this._vf.center);
                    vol.min.x -= 0.5 * this._vf.size.x;
                    vol.min.y -= 0.5 * this._vf.size.y;
                    vol.min.z -= x3dom.fields.Eps;

                    vol.max.setValues(this._vf.center);
                    vol.max.x += 0.5 * this._vf.size.x;
                    vol.max.y += 0.5 * this._vf.size.y;
                    vol.max.z += x3dom.fields.Eps;
                }

                return vol;
            }
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### X3DFontStyleNode ### */
x3dom.registerNodeType(
    "X3DFontStyleNode",
    "Text",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.X3DFontStyleNode.superClass.call(this, ctx);
        }
    )
);

/* ### FontStyle ### */
x3dom.registerNodeType(
    "FontStyle",
    "Text",
    defineClass(x3dom.nodeTypes.X3DFontStyleNode,
        function (ctx) {
            x3dom.nodeTypes.FontStyle.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'family', ['SERIF']);
            this.addField_SFBool(ctx, 'horizontal', true);
            this.addField_MFString(ctx, 'justify', ['BEGIN']);
            this.addField_SFString(ctx, 'language', "");
            this.addField_SFBool(ctx, 'leftToRight', true);
            this.addField_SFFloat(ctx, 'size', 1.0);
            this.addField_SFFloat(ctx, 'spacing', 1.0);
            this.addField_SFString(ctx, 'style', "PLAIN");
            this.addField_SFBool(ctx, 'topToBottom', true);
        },
		{
			fieldChanged: function(fieldName) {
				if (fieldName == 'family' || fieldName == 'horizontal' || fieldName == 'justify' ||
                    fieldName == 'language' || fieldName == 'leftToRight' || fieldName == 'size' ||
                    fieldName == 'spacing' || fieldName == 'style' || fieldName == 'topToBottom') {
                    Array.forEach(this._parentNodes, function (node) {
						node.fieldChanged(fieldName);
                    });
				}
			}
        }
    )
);

x3dom.nodeTypes.FontStyle.defaultNode = function() {
    if (!x3dom.nodeTypes.FontStyle._defaultNode) {
        x3dom.nodeTypes.FontStyle._defaultNode = new x3dom.nodeTypes.FontStyle();
        x3dom.nodeTypes.FontStyle._defaultNode.nodeChanged();
    }
    return x3dom.nodeTypes.FontStyle._defaultNode;
};

/* ### Text ### */
x3dom.registerNodeType(
    "Text",
    "Text",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Text.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'string', []);
            this.addField_MFFloat(ctx, 'length', []);
            this.addField_SFFloat(ctx, 'maxExtent', 0.0);
            this.addField_SFNode ('fontStyle', x3dom.nodeTypes.X3DFontStyleNode);

            this._mesh._positions[0] = [];
			this._mesh._normals[0]   = [0,0,1, 0,0,1, 0,0,1, 0,0,1];
            this._mesh._texCoords[0] = [0,0, 1,0, 1,1, 0,1];
            this._mesh._colors[0] 	 = [];
            this._mesh._indices[0] 	 = [0,1,2, 2,3,0];
            this._mesh._invalidate 	 = true;
            this._mesh._numFaces 	 = 2;
            this._mesh._numCoords 	 = 4;
        },
        {
            nodeChanged: function() {
                if (!this._cf.fontStyle.node) {
                    this.addChild(x3dom.nodeTypes.FontStyle.defaultNode());
                }
                this.invalidateVolume();
            },

            fieldChanged: function(fieldName) {
                if (fieldName == 'string' || fieldName == 'length' || fieldName == 'maxExtent') {
                    this.invalidateVolume();
                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                    });
                }
            }
        }
    ) // defineClass
); // registerNodeType

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/* ### X3DSoundNode ### */
x3dom.registerNodeType(
    "X3DSoundNode",
    "Sound",
    defineClass(x3dom.nodeTypes.X3DChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DSoundNode.superClass.call(this, ctx);
        }
    )
);

/* ### Sound ### */
x3dom.registerNodeType(
    "Sound",
    "Sound",
    defineClass(x3dom.nodeTypes.X3DSoundNode,
        function (ctx) {
            x3dom.nodeTypes.Sound.superClass.call(this, ctx);

            this.addField_SFNode('source', x3dom.nodeTypes.X3DSoundSourceNode);
        },
        {
            nodeChanged: function()
            {
                if (this._cf.source.node || !this._xmlNode) {
                    return;
                }

                x3dom.debug.logInfo("No AudioClip child node given, searching for &lt;audio&gt; elements...");
                /** USAGE e.g.:
                    <sound>
                        <audio src='sound/spita.wav' loop='loop'></audio>
                    </sound>
                */
                var that = this;
                try {
                    Array.forEach( this._xmlNode.childNodes, function (childDomNode) {
                        if (childDomNode.nodeType === 1)
                        {
                            // For testing: look for <audio> element if no child
                            x3dom.debug.logInfo("### Found &lt;"+childDomNode.nodeName+"&gt; tag.");

                            if (childDomNode.localName.toLowerCase() === "audio")
                            {
                                var loop = childDomNode.getAttribute("loop");
                                loop = loop ? (loop.toLowerCase() === "loop") : false;

                                // work around strange crash in Chrome
                                // by creating new audio element here

                                /*
                                var src = childDomNode.getAttribute("src");
                                var newNode = document.createElement('audio');
                                newNode.setAttribute('autobuffer', 'true');
                                newNode.setAttribute('src', src);
                                */
                                var newNode = childDomNode.cloneNode(false);

                                childDomNode.parentNode.removeChild(childDomNode);
                                childDomNode = null;
								
								if(navigator.appName != "Microsoft Internet Explorer") {
									document.body.appendChild(newNode);
								}

                                var startAudio = function() {
                                    newNode.play();
                                };

                                var audioDone = function() {
                                    if (loop) {
                                        newNode.play();
                                    }
                                };

                                newNode.addEventListener("canplaythrough", startAudio, true);
                                newNode.addEventListener("ended", audioDone, true);
                            }
                        }
                    } );
                }
                catch(e) {
                    x3dom.debug.logException(e);
                }
            }
        }
    )
);


/* ### X3DSoundSourceNode ### */
x3dom.registerNodeType(
    "X3DSoundSourceNode",
    "Sound",
    defineClass(x3dom.nodeTypes.X3DTimeDependentNode,
        function (ctx) {
            x3dom.nodeTypes.X3DSoundSourceNode.superClass.call(this, ctx);
        }
    )
);

/* ### AudioClip ### */
x3dom.registerNodeType(
    "AudioClip",
    "Sound",
    defineClass(x3dom.nodeTypes.X3DSoundSourceNode,
        function (ctx) {
            x3dom.nodeTypes.AudioClip.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'url', []);
            this.addField_SFBool(ctx, 'enabled', true);
            this.addField_SFBool(ctx, 'loop', false);

            this._audio = null;
        },
        {
            nodeChanged: function()
            {
                this._audio = document.createElement('audio');
                this._audio.setAttribute('autobuffer', 'true');
                //this._audio.setAttribute('autoplay', 'true');
				if(navigator.appName != "Microsoft Internet Explorer") {
					document.body.appendChild(this._audio);
				}

                for (var i=0; i<this._vf.url.length; i++)
                {
                    var audioUrl = this._nameSpace.getURL(this._vf.url[i]);
                    x3dom.debug.logInfo('Adding sound file: ' + audioUrl);
                    var src = document.createElement('source');
                    src.setAttribute('src', audioUrl);
                    this._audio.appendChild(src);
                }

                var that = this;

                var startAudio = function()
                {
                    that._audio.play();
                };

                var audioDone = function()
                {
                    if (that._vf.loop === true)
                    {
                        that._audio.play();
                    }
                };

                this._audio.addEventListener("canplaythrough", startAudio, true);
                this._audio.addEventListener("ended", audioDone, true);
            },

            fieldChanged: function(fieldName)
            {
                if (fieldName === "enabled")
                {
                    if (this._vf.enabled === true)
                    {
                        this._audio.play();
                    }
                    else
                    {
                        this._audio.pause();
                    }
                }
                else if (fieldName === "loop")
                {
                    if (this._vf.loop === true)
                    {
                        this._audio.play();
                    }
                }
                else if (fieldName === "url")
                {
                    this._audio.pause();
                    while (this._audio.hasChildNodes())
                    {
                        this._audio.removeChild(this._audio.firstChild);
                    }
                    
                    for (var i=0; i<this._vf.url.length; i++)
                    {
                        var audioUrl = this._nameSpace.getURL(this._vf.url[i]);
                        x3dom.debug.logInfo('Adding sound file: ' + audioUrl);
                        var src = document.createElement('source');
                        src.setAttribute('src', audioUrl);
                        this._audio.appendChild(src);
                    }
                }
            }
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### X3DTextureTransformNode ### */
x3dom.registerNodeType(
    "X3DTextureTransformNode",
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DAppearanceChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DTextureTransformNode.superClass.call(this, ctx);
        }
    )
);

/* ### TextureTransform ### */
x3dom.registerNodeType(
    "TextureTransform",
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DTextureTransformNode,
        function (ctx) {
            x3dom.nodeTypes.TextureTransform.superClass.call(this, ctx);

            this.addField_SFVec2f(ctx, 'center', 0, 0);
            this.addField_SFFloat(ctx, 'rotation', 0);
            this.addField_SFVec2f(ctx, 'scale', 1, 1);
            this.addField_SFVec2f(ctx, 'translation', 0, 0);

            //Tc' = -C * S * R * C * T * Tc
            var negCenter = new x3dom.fields.SFVec3f(-this._vf.center.x, -this._vf.center.y, 1);
            var posCenter = new x3dom.fields.SFVec3f(this._vf.center.x, this._vf.center.y, 0);
            var trans3 = new x3dom.fields.SFVec3f(this._vf.translation.x, this._vf.translation.y, 0);
            var scale3 = new x3dom.fields.SFVec3f(this._vf.scale.x, this._vf.scale.y, 0);

            this._trafo = x3dom.fields.SFMatrix4f.translation(negCenter).
                    mult(x3dom.fields.SFMatrix4f.scale(scale3)).
                    mult(x3dom.fields.SFMatrix4f.rotationZ(this._vf.rotation)).
                    mult(x3dom.fields.SFMatrix4f.translation(posCenter.add(trans3)));
        },
        {
            fieldChanged: function (fieldName) {
                //Tc' = -C * S * R * C * T * Tc
                if (fieldName == 'center' || fieldName == 'rotation' ||
                    fieldName == 'scale' || fieldName == 'translation') {

                var negCenter = new x3dom.fields.SFVec3f(-this._vf.center.x, -this._vf.center.y, 1);
                var posCenter = new x3dom.fields.SFVec3f(this._vf.center.x, this._vf.center.y, 0);
                var trans3 = new x3dom.fields.SFVec3f(this._vf.translation.x, this._vf.translation.y, 0);
                var scale3 = new x3dom.fields.SFVec3f(this._vf.scale.x, this._vf.scale.y, 0);

                this._trafo = x3dom.fields.SFMatrix4f.translation(negCenter).
                         mult(x3dom.fields.SFMatrix4f.scale(scale3)).
                         mult(x3dom.fields.SFMatrix4f.rotationZ(this._vf.rotation)).
                         mult(x3dom.fields.SFMatrix4f.translation(posCenter.add(trans3)));
                }
            },

            texTransformMatrix: function() {
                return this._trafo;
            }
        }
    )
);

/* ### TextureProperties ### */
x3dom.registerNodeType(
    "TextureProperties",
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.TextureProperties.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'anisotropicDegree', 1.0);
            this.addField_SFColorRGBA(ctx, 'borderColor', 0, 0, 0, 0);
            this.addField_SFInt32(ctx, 'borderWidth', 0);
            this.addField_SFString(ctx, 'boundaryModeS', "REPEAT");
            this.addField_SFString(ctx, 'boundaryModeT', "REPEAT");
            this.addField_SFString(ctx, 'boundaryModeR', "REPEAT");
            this.addField_SFString(ctx, 'magnificationFilter', "FASTEST");
            this.addField_SFString(ctx, 'minificationFilter', "FASTEST");
            this.addField_SFString(ctx, 'textureCompression', "FASTEST");
            this.addField_SFFloat(ctx, 'texturePriority', 0);
            this.addField_SFBool(ctx, 'generateMipMaps', false);
        },
		{
			fieldChanged: function(fieldName)
			{
                if (this._vf.hasOwnProperty(fieldName)) {
                    Array.forEach(this._parentNodes, function (texture) {
                        Array.forEach(texture._parentNodes, function (app) {
                            Array.forEach(app._parentNodes, function (shape) {
                                shape._dirty.texture = true;
                            });
                        });
                    });

                    this._nameSpace.doc.needRender = true;
                }
			}
		}
    )
);

/* ### X3DTextureNode ### */
x3dom.registerNodeType(
    "X3DTextureNode",
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DAppearanceChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DTextureNode.superClass.call(this, ctx);
			
            this.addField_SFInt32(ctx, 'origChannelCount', 0); // 0 means the system should figure out the count
            this.addField_MFString(ctx, 'url', []);
            this.addField_SFBool(ctx, 'repeatS', true);
            this.addField_SFBool(ctx, 'repeatT', true);
            this.addField_SFBool(ctx, 'scale', true);
            this.addField_SFBool(ctx, 'withCredentials', false);
            this.addField_SFNode('textureProperties', x3dom.nodeTypes.TextureProperties);

            this._needPerFrameUpdate = false;
            this._isCanvas = false;
			this._type = "diffuseMap";
			
			this._blending = (this._vf.origChannelCount == 1 || this._vf.origChannelCount == 2);
        },
        {
            invalidateGLObject: function ()
            {
                Array.forEach(this._parentNodes, function (app) {
                        Array.forEach(app._parentNodes, function (shape) {
                            shape._dirty.texture = true;
                        });
                    });

                this._nameSpace.doc.needRender = true;
            },

            parentAdded: function(parent)
            {
                Array.forEach(parent._parentNodes, function (shape) {
                    shape._dirty.texture = true;
                });
            },

            parentRemoved: function(parent)
            {
                Array.forEach(parent._parentNodes, function (shape) {
                    shape._dirty.texture = true;
                });
            },

            fieldChanged: function(fieldName)
            {
                if (fieldName == "url" || fieldName ==  "origChannelCount" ||
				    fieldName == "repeatS" || fieldName == "repeatT" ||
                    fieldName == "scale" || fieldName == "withCredentials")
                {
                    var that = this;

                    Array.forEach(this._parentNodes, function (app) {
                        if (x3dom.isa(app, x3dom.nodeTypes.X3DAppearanceNode)) {
                            app.nodeChanged();
                            Array.forEach(app._parentNodes, function (shape) {
                                shape._dirty.texture = true;
                            });
                        }
                        else if (x3dom.isa(app, x3dom.nodeTypes.ImageGeometry)) {
                            var cf = null;
                            if (that._xmlNode && that._xmlNode.hasAttribute('containerField')) {
                                cf = that._xmlNode.getAttribute('containerField');
                                app._dirty[cf] = true;
                            }
                        }
                    });
                }
            },

            getTexture: function(pos) {
                if (pos === 0) {
                    return this;
                }
                return null;
            },

            size: function() {
                return 1;
            }
        }
    )
);

/* ### MultiTexture ### */
x3dom.registerNodeType(
    "MultiTexture",
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DTextureNode,
        function (ctx) {
            x3dom.nodeTypes.MultiTexture.superClass.call(this, ctx);

            this.addField_MFNode('texture', x3dom.nodeTypes.X3DTextureNode);
        },
        {
            getTexture: function(pos) {
                if (pos >= 0 && pos < this._cf.texture.nodes.length) {
                    return this._cf.texture.nodes[pos];
                }
                return null;
            },
			
			getTextures: function() {
				return this._cf.texture.nodes;
			},

            size: function() {
                return this._cf.texture.nodes.length;
            }
        }
    )
);

/* ### Texture ### */
// intermediate layer to avoid instantiating X3DTextureNode in web profile
x3dom.registerNodeType(
    "Texture",      // X3DTexture2DNode
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DTextureNode,
        function (ctx) {
            x3dom.nodeTypes.Texture.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'hideChildren', true);

            this._video = null;
            this._intervalID = 0;
            this._canvas = null;
        },
        {
            nodeChanged: function()
            {
                if (this._vf.url.length || !this._xmlNode) {
                    return;
                }
                x3dom.debug.logInfo("No Texture URL given, searching for &lt;img&gt; elements...");
                var that = this;
                try {
                    Array.forEach( this._xmlNode.childNodes, function (childDomNode) {
                        if (childDomNode.nodeType === 1) {
                            var url = childDomNode.getAttribute("src");
                            // For testing: look for <img> element if url empty
                            if (url) {
                                that._vf.url.push(url);
                                x3dom.debug.logInfo(that._vf.url[that._vf.url.length-1]);
								//x3dom.ImageLoadManager.push( that );

                                if (childDomNode.localName === "video") {
                                    that._needPerFrameUpdate = true;
                                    //that._video = childDomNode;

                                    that._video = document.createElement('video');
                                    that._video.setAttribute('autobuffer', 'true');
                                    var p = document.getElementsByTagName('body')[0];
                                    p.appendChild(that._video);
                                    that._video.style.display = "none";
                                }
                            }
                            else if (childDomNode.localName.toLowerCase() === "canvas") {
                                that._needPerFrameUpdate = true;
                                that._isCanvas = true;
                                that._canvas = childDomNode;
                            }

                            if (childDomNode.style && that._vf.hideChildren) {
                                childDomNode.style.display = "none";
                                childDomNode.style.visibility = "hidden";
                            }
                            x3dom.debug.logInfo("### Found &lt;"+childDomNode.nodeName+"&gt; tag.");
                        }
                    } );
                }
                catch(e) {
                    x3dom.debug.logException(e);
                }
            }
        }
    )
);
/* ### RenderedTexture ### */
x3dom.registerNodeType(
    "RenderedTexture",
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DTextureNode,
        function (ctx) {
            x3dom.nodeTypes.RenderedTexture.superClass.call(this, ctx);

            if (ctx)
                ctx.doc._nodeBag.renderTextures.push(this);
            else
                x3dom.debug.logWarning("RenderedTexture: No runtime context found!");

            this.addField_SFNode('viewpoint', x3dom.nodeTypes.X3DViewpointNode);
            this.addField_SFNode('background', x3dom.nodeTypes.X3DBackgroundNode);
            this.addField_SFNode('fog', x3dom.nodeTypes.X3DFogNode);    //TODO
            this.addField_SFNode('scene', x3dom.nodeTypes.X3DNode);
            this.addField_MFNode('excludeNodes', x3dom.nodeTypes.X3DNode);
            this.addField_MFInt32(ctx, 'dimensions', [128, 128, 4]);
            this.addField_SFString(ctx, 'update', 'NONE');         // ("NONE"|"NEXT_FRAME_ONLY"|"ALWAYS")
            this.addField_SFBool(ctx, 'showNormals', false);

            this.addField_SFString(ctx, 'stereoMode', 'NONE');     // ("NONE"|"LEFT_EYE"|"RIGHT_EYE")
            this.addField_SFFloat(ctx, 'interpupillaryDistance', 0.064);

            this.hScreenSize = 0.14976;
            this.vScreenSize = 0.09356;
            this.vScreenCenter = this.vScreenSize / 2;
            this.eyeToScreenDistance = 0.041;
            this.lensSeparationDistance = 0.0635;
            this.distortionK = [1.0, 0.22, 0.24, 0.0];
            //hRes, vRes = 1280 x 800
            this.lensCenter = 1 - 2 * this.lensSeparationDistance / this.hScreenSize;

            x3dom.debug.assert(this._vf.dimensions.length >= 3);
            this._clearParents = true;
            this._needRenderUpdate = true;
        },
        {
            nodeChanged: function()
            {
                this._clearParents = true;
                this._needRenderUpdate = true;
            },

            fieldChanged: function(fieldName)
            {
                switch(fieldName) 
                {
                    case "excludeNodes":
                        this._clearParents = true;
                        break;
                    case "update":
                        if (this._vf.update.toUpperCase() == "NEXT_FRAME_ONLY" ||
                            this._vf.update.toUpperCase() == "ALWAYS") {
                            this._needRenderUpdate = true;
                        }
                        break;
                    default:
                        // TODO: dimensions
                        break;
                }
            },

            getViewMatrix: function ()
            {
                if (this._clearParents && this._cf.excludeNodes.nodes.length) {
                    // FIXME; avoid recursions cleverer and more generic than this
                    //        (Problem: nodes in excludeNodes field have this node
                    //         as first parent, which leads to a recursion loop in
                    //         getCurrentTransform()
                    var that = this;

                    Array.forEach(this._cf.excludeNodes.nodes, function(node) {
                        for (var i=0, n=node._parentNodes.length; i < n; i++) {
                            if (node._parentNodes[i] === that) {
                                node._parentNodes.splice(i, 1);
                                node.parentRemoved(that);
                            }
                        }
                    });

                    this._clearParents = false;
                }

                var vbP = this._nameSpace.doc._scene.getViewpoint();
                var view = this._cf.viewpoint.node;
                var ret_mat = null;

                if (view === null || view === vbP) {
                    ret_mat = this._nameSpace.doc._viewarea.getViewMatrix();
                }
                else {
                    var mat_viewpoint = view.getCurrentTransform();
                    ret_mat = mat_viewpoint.mult(view.getViewMatrix());
                }

                var stereoMode = this._vf.stereoMode.toUpperCase();
                if (stereoMode != "NONE") {
                    var d = this._vf.interpupillaryDistance / 2;
                    if (stereoMode == "RIGHT_EYE") {
                        d = -d;
                    }
                    var modifier = new x3dom.fields.SFMatrix4f(
                        1, 0, 0, d,
                        0, 1, 0, 0,
                        0, 0, 1, 0,
                        0, 0, 0, 1
                    );
                    ret_mat = modifier.mult(ret_mat);
                }

                return ret_mat;
            },

            getProjectionMatrix: function()
            {
                var doc = this._nameSpace.doc;
                var vbP = doc._scene.getViewpoint();
                var view = this._cf.viewpoint.node;
                var ret_mat = null;
                var f, w = this._vf.dimensions[0], h = this._vf.dimensions[1];
                var stereoMode = this._vf.stereoMode.toUpperCase();
                var stereo = (stereoMode != "NONE");

                if (view === null || view === vbP) {
                    ret_mat = x3dom.fields.SFMatrix4f.copy(doc._viewarea.getProjectionMatrix());
                    if (stereo) {
                        f = 2 * Math.atan(this.vScreenSize / (2 * this.eyeToScreenDistance));
                        f = 1 / Math.tan(f / 2);
                    }
                    else {
                        f = 1 / Math.tan(vbP._vf.fieldOfView / 2);
                    }
                    ret_mat._00 = f / (w / h);
                    ret_mat._11 = f;
                }
                else {
                    ret_mat = view.getProjectionMatrix(w / h);
                }

                if (stereo) {
                    var hp = this.lensCenter;
                    if (stereoMode == "RIGHT_EYE") {
                        hp = -hp;
                    }
                    var modifier = new x3dom.fields.SFMatrix4f(
                        1, 0, 0, hp,
                        0, 1, 0, 0,
                        0, 0, 1, 0,
                        0, 0, 0, 1
                    );
                    ret_mat = modifier.mult(ret_mat);
                }

                return ret_mat;
            },

            getWCtoCCMatrix: function()
            {
                var view = this.getViewMatrix();
                var proj = this.getProjectionMatrix();

                return proj.mult(view);
            },

            parentRemoved: function(parent)
            {
                if (this._parentNodes.length === 0) {
                    var doc = this.findX3DDoc();

                    for (var i=0, n=doc._nodeBag.renderTextures.length; i<n; i++) {
                        if (doc._nodeBag.renderTextures[i] === this) {
                            doc._nodeBag.renderTextures.splice(i, 1);
                        }
                    }
                }

                if (this._cf.scene.node) {
                    this._cf.scene.node.parentRemoved(this);
                }
            }
        }
    )
);

/* ### PixelTexture ### */
x3dom.registerNodeType(
    "PixelTexture",
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DTextureNode,
        function (ctx) {
            x3dom.nodeTypes.PixelTexture.superClass.call(this, ctx);

            this.addField_SFImage(ctx, 'image', 0, 0, 0);
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName == "image") {
                    this.invalidateGLObject();
                }
            }
        }
    )
);

/* ### ImageTexture ### */
x3dom.registerNodeType(
    "ImageTexture",
    "Texturing",
    defineClass(x3dom.nodeTypes.Texture,
        function (ctx) {
            x3dom.nodeTypes.ImageTexture.superClass.call(this, ctx);
        }
    )
);

/* ### MovieTexture ### */
x3dom.registerNodeType(
    "MovieTexture",
    "Texturing",
    defineClass(x3dom.nodeTypes.Texture,
        function (ctx) {
            x3dom.nodeTypes.MovieTexture.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'loop', false);
            this.addField_SFFloat(ctx, 'speed', 1.0);
            // TODO; implement the following fields...
            this.addField_SFTime(ctx, 'pauseTime', 0);
            this.addField_SFFloat(ctx, 'pitch', 1.0);
            this.addField_SFTime(ctx, 'resumeTime', 0);
            this.addField_SFTime(ctx, 'startTime', 0);
            this.addField_SFTime(ctx, 'stopTime', 0);
        }
    )
);

/* ### X3DEnvironmentTextureNode ### */
x3dom.registerNodeType(
    "X3DEnvironmentTextureNode",
    "CubeMapTexturing",
    defineClass(x3dom.nodeTypes.X3DTextureNode,
        function (ctx) {
            x3dom.nodeTypes.X3DEnvironmentTextureNode.superClass.call(this, ctx);
        },
        {
            getTexUrl: function() {
                return [];  //abstract accessor for gfx
            },

            getTexSize: function() {
                return -1;  //abstract accessor for gfx
            }
        }
    )
);

/* ### ComposedCubeMapTexture ### */
x3dom.registerNodeType(
    "ComposedCubeMapTexture",
    "CubeMapTexturing",
    defineClass(x3dom.nodeTypes.X3DEnvironmentTextureNode,
        function (ctx) {
            x3dom.nodeTypes.ComposedCubeMapTexture.superClass.call(this, ctx);

            this.addField_SFNode('back',   x3dom.nodeTypes.Texture);
            this.addField_SFNode('front',  x3dom.nodeTypes.Texture);
            this.addField_SFNode('bottom', x3dom.nodeTypes.Texture);
            this.addField_SFNode('top',    x3dom.nodeTypes.Texture);
            this.addField_SFNode('left',   x3dom.nodeTypes.Texture);
            this.addField_SFNode('right',  x3dom.nodeTypes.Texture);
			this._type = "cubeMap";
        },
        {
            getTexUrl: function() {
                return [
					this._nameSpace.getURL(this._cf.back.node._vf.url[0]),
                    this._nameSpace.getURL(this._cf.front.node._vf.url[0]),
                    this._nameSpace.getURL(this._cf.bottom.node._vf.url[0]),
                    this._nameSpace.getURL(this._cf.top.node._vf.url[0]),
                    this._nameSpace.getURL(this._cf.left.node._vf.url[0]),
                    this._nameSpace.getURL(this._cf.right.node._vf.url[0])
                ];
            }
        }
    )
);

/* ### GeneratedCubeMapTexture ### */
x3dom.registerNodeType(
    "GeneratedCubeMapTexture",
    "CubeMapTexturing",
    defineClass(x3dom.nodeTypes.X3DEnvironmentTextureNode,
        function (ctx) {
            x3dom.nodeTypes.GeneratedCubeMapTexture.superClass.call(this, ctx);

            this.addField_SFInt32(ctx, 'size', 128);
            this.addField_SFString(ctx, 'update', 'NONE');  // ("NONE"|"NEXT_FRAME_ONLY"|"ALWAYS")

			this._type = "cubeMap";
            x3dom.debug.logWarning("GeneratedCubeMapTexture NYI");   // TODO; impl. in gfx when fbo type ready
        },
        {
            getTexSize: function() {
                return this._vf.size;
            }
        }
    )
);

/* ### X3DTextureCoordinateNode ### */
x3dom.registerNodeType(
    "X3DTextureCoordinateNode",
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DGeometricPropertyNode,
        function (ctx) {
            x3dom.nodeTypes.X3DTextureCoordinateNode.superClass.call(this, ctx);
        },
		{
			fieldChanged: function (fieldName) {
                if (fieldName === "texCoord" || fieldName === "point" || 
                    fieldName === "parameter" || fieldName === "mode") 
                {
                    Array.forEach(this._parentNodes, function (node) {
                        node.fieldChanged("texCoord");
                    });
                }
            },

            parentAdded: function(parent) {
                if (parent._mesh && //parent._cf.coord.node &&
                    parent._cf.texCoord.node !== this) {
                    parent.fieldChanged("texCoord");
                }
            }
		}	
    )
);

/* ### TextureCoordinate ### */
x3dom.registerNodeType(
    "TextureCoordinate",
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DTextureCoordinateNode,
        function (ctx) {
            x3dom.nodeTypes.TextureCoordinate.superClass.call(this, ctx);

            this.addField_MFVec2f(ctx, 'point', []);
        }
    )
);

/* ### TextureCoordinateGenerator ### */
x3dom.registerNodeType(
    "TextureCoordinateGenerator",
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DTextureCoordinateNode,
        function (ctx) {
            x3dom.nodeTypes.TextureCoordinateGenerator.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'mode', "SPHERE");
            this.addField_MFFloat(ctx, 'parameter', []);
        }
    )
);

/* ### MultiTextureCoordinate ### */
x3dom.registerNodeType(
    "MultiTextureCoordinate",
    "Texturing",
    defineClass(x3dom.nodeTypes.X3DTextureCoordinateNode,
        function (ctx) {
            x3dom.nodeTypes.MultiTextureCoordinate.superClass.call(this, ctx);

            this.addField_MFNode('texCoord', x3dom.nodeTypes.X3DTextureCoordinateNode);
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### Uniform ### */
x3dom.registerNodeType(
    "Uniform",
    "Shaders",
    defineClass(x3dom.nodeTypes.Field,
        function (ctx) {
            x3dom.nodeTypes.Uniform.superClass.call(this, ctx);
        }
    )
);

/* ### SurfaceShaderTexture ### */
x3dom.registerNodeType(
    "SurfaceShaderTexture",
    "Shaders",
    defineClass(x3dom.nodeTypes.X3DTextureNode,
        function (ctx) {
            x3dom.nodeTypes.SurfaceShaderTexture.superClass.call(this, ctx);

            this.addField_SFInt32(ctx, 'textureCoordinatesId', 0);
            this.addField_SFString(ctx, 'channelMask', "DEFAULT");
            this.addField_SFBool(ctx, 'isSRGB', false);
            this.addField_SFNode('texture', x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('textureTransform', x3dom.nodeTypes.X3DTextureTransformNode);
        }
    )
);

/* ### X3DShaderNode ### */
x3dom.registerNodeType(
    "X3DShaderNode",
    "Shaders",
    defineClass(x3dom.nodeTypes.X3DAppearanceChildNode,
        function (ctx) {
            x3dom.nodeTypes.X3DShaderNode.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'language', "");
        }
    )
);

/* ### CommonSurfaceShader ### */
x3dom.registerNodeType(
    "CommonSurfaceShader",
    "Shaders",
    defineClass(x3dom.nodeTypes.X3DShaderNode,
        function (ctx) {
            x3dom.nodeTypes.CommonSurfaceShader.superClass.call(this, ctx);

            this.addField_SFInt32(ctx, 'tangentTextureCoordinatesId', -1);
            this.addField_SFInt32(ctx, 'binormalTextureCoordinatesId', -1);
            this.addField_SFVec3f(ctx, 'emissiveFactor', 0, 0, 0);
            this.addField_SFInt32(ctx, 'emissiveTextureId', -1);
            this.addField_SFInt32(ctx, 'emissiveTextureCoordinatesId', 0);
            this.addField_SFString(ctx, 'emissiveTextureChannelMask', 'rgb');
            this.addField_SFVec3f(ctx, 'ambientFactor', 0.2, 0.2, 0.2);
            this.addField_SFInt32(ctx, 'ambientTextureId', -1);
            this.addField_SFInt32(ctx, 'ambientTextureCoordinatesId', 0);
            this.addField_SFString(ctx, 'ambientTextureChannelMask', 'rgb');
            this.addField_SFVec3f(ctx, 'diffuseFactor', 0.8, 0.8, 0.8);
            this.addField_SFInt32(ctx, 'diffuseTextureId', -1);
            this.addField_SFInt32(ctx, 'diffuseTextureCoordinatesId', 0);
            this.addField_SFString(ctx, 'diffuseTextureChannelMask', 'rgb');
            this.addField_SFVec3f(ctx, 'specularFactor', 0, 0, 0);
            this.addField_SFInt32(ctx, 'specularTextureId', -1);
            this.addField_SFInt32(ctx, 'specularTextureCoordinatesId', 0);
            this.addField_SFString(ctx, 'specularTextureChannelMask', 'rgb');
            this.addField_SFFloat(ctx, 'shininessFactor', 0.2);
            this.addField_SFInt32(ctx, 'shininessTextureId', -1);
            this.addField_SFInt32(ctx, 'shininessTextureCoordinatesId', 0);
            this.addField_SFString(ctx, 'shininessTextureChannelMask', 'a');
            this.addField_SFString(ctx, 'normalFormat', 'UNORM');
            this.addField_SFString(ctx, 'normalSpace', 'TANGENT');
            this.addField_SFInt32(ctx, 'normalTextureId', -1);
            this.addField_SFInt32(ctx, 'normalTextureCoordinatesId', 0);
            this.addField_SFString(ctx, 'normalTextureChannelMask', 'rgb');
            this.addField_SFVec3f(ctx, 'reflectionFactor', 0, 0, 0);
            this.addField_SFInt32(ctx, 'reflectionTextureId', -1);
            this.addField_SFInt32(ctx, 'reflectionTextureCoordinatesId', 0);
            this.addField_SFString(ctx, 'reflectionTextureChannelMask', 'rgb');
            this.addField_SFVec3f(ctx, 'transmissionFactor', 0, 0, 0);
            this.addField_SFInt32(ctx, 'transmissionTextureId', -1);
            this.addField_SFInt32(ctx, 'transmissionTextureCoordinatesId', 0);
            this.addField_SFString(ctx, 'transmissionTextureChannelMask', 'rgb');
            this.addField_SFVec3f(ctx, 'environmentFactor', 1, 1, 1);
            this.addField_SFInt32(ctx, 'environmentTextureId', -1);
            this.addField_SFInt32(ctx, 'environmentTextureCoordinatesId', 0);
            this.addField_SFString(ctx, 'environmentTextureChannelMask', 'rgb');
            this.addField_SFFloat(ctx, 'relativeIndexOfRefraction', 1);
            this.addField_SFFloat(ctx, 'fresnelBlend', 0);
            this.addField_SFString(ctx, 'displacementAxis', 'y');
            this.addField_SFFloat(ctx, 'displacementFactor', 255.0);
            this.addField_SFInt32(ctx, 'displacementTextureId', -1);
            this.addField_SFInt32(ctx, 'displacementTextureCoordinatesId', 0);
            this.addField_SFNode('emissiveTexture', x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('ambientTexture', x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('diffuseTexture', x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('specularTexture', x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('shininessTexture', x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('normalTexture', x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('reflectionTexture', x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('transmissionTexture', x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('environmentTexture', x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('displacementTexture', x3dom.nodeTypes.X3DTextureNode);
            this.addField_SFNode('diffuseDisplacementTexture', x3dom.nodeTypes.X3DTextureNode);
            //this.addField_MFBool(ctx, 'textureTransformEnabled', []);     // MFBool NYI
            this.addField_SFVec3f(ctx, 'normalScale', 2, 2, 2);
            this.addField_SFVec3f(ctx, 'normalBias', -1, -1, -1);
            this.addField_SFFloat(ctx, 'alphaFactor', 1);
            this.addField_SFBool(ctx, 'invertAlphaTexture', false);
            this.addField_SFInt32(ctx, 'alphaTextureId', -1);
            this.addField_SFInt32(ctx, 'alphaTextureCoordinatesId', 0);
            this.addField_SFString(ctx, 'alphaTextureChannelMask', 'a');
            this.addField_SFNode('alphaTexture', x3dom.nodeTypes.X3DTextureNode);

            this._dirty = {
                // TODO; cp. Shape, allow for dynamic texture updates in gfx
            };
        },
        {
            getDiffuseMap: function()
            {
                if(this._cf.diffuseTexture.node) {
					this._cf.diffuseTexture.node._cf.texture.node._type = "diffuseMap";
                    return this._cf.diffuseTexture.node._cf.texture.node;
                } else {
                    return null;
                }
            },

            getNormalMap: function()
            {
                if(this._cf.normalTexture.node) {
					this._cf.normalTexture.node._cf.texture.node._type = "normalMap";
                    return this._cf.normalTexture.node._cf.texture.node;
                } else {
                    return null;
                }
            },

            getAmbientMap: function()
            {
                if(this._cf.ambientTexture.node) {
					this._cf.ambientTexture.node._cf.texture.node._type = "ambientMap";
                    return this._cf.ambientTexture.node._cf.texture.node;
                } else {
                    return null;
                }
            },

            getSpecularMap: function()
            {
                if(this._cf.specularTexture.node) {
					this._cf.specularTexture.node._cf.texture.node._type = "specularMap";
                    return this._cf.specularTexture.node._cf.texture.node;
                } else {
                    return null;
                }
            },

            getShininessMap: function()
            {
                if(this._cf.shininessTexture.node) {
					this._cf.shininessTexture.node._cf.texture.node._type = "shininessMap";
                    return this._cf.shininessTexture.node._cf.texture.node;
                } else {
                    return null;
                }
            },

            getAlphaMap: function()
            {
                if(this._cf.alphaTexture.node) {
					this._cf.alphaTexture.node._cf.texture.node._type = "alphaMap";
                    return this._cf.alphaTexture.node._cf.texture.node;
                } else {
                    return null;
                }
            },
            
            getDisplacementMap: function()
            {
                if(this._cf.displacementTexture.node) {
                    this._cf.displacementTexture.node._cf.texture.node._type = "displacementMap";
                    return this._cf.displacementTexture.node._cf.texture.node;
                } else {
                    return null;
                }
            },

            getDiffuseDisplacementMap: function()
            {
                if(this._cf.diffuseDisplacementTexture.node) {
                    this._cf.diffuseDisplacementTexture.node._cf.texture.node._type = "diffuseDisplacementMap";
                    return this._cf.diffuseDisplacementTexture.node._cf.texture.node;
                } else {
                    return null;
                }
            },
			
			getTextures: function()
			{
				var textures = [];
				
				var diff = this.getDiffuseMap();
				if(diff) textures.push(diff);
				
				var norm = this.getNormalMap();
				if(norm) textures.push(norm);
				
				var spec = this.getSpecularMap();
				if(spec) textures.push(spec);
        
                var displacement = this.getDisplacementMap();
				if(displacement) textures.push(displacement);

                var diffuseDisplacement = this.getDiffuseDisplacementMap();
                if(diffuseDisplacement) textures.push(diffuseDisplacement);
				
				return textures;
			}
        }
    )
);

/* ### ComposedShader ### */
x3dom.registerNodeType(
    "ComposedShader",
    "Shaders",
    defineClass(x3dom.nodeTypes.X3DShaderNode,
        function (ctx) {
            x3dom.nodeTypes.ComposedShader.superClass.call(this, ctx);

            this.addField_MFNode('fields', x3dom.nodeTypes.Field);
            this.addField_MFNode('parts', x3dom.nodeTypes.ShaderPart);

            // shortcut to shader parts
            this._vertex = null;
            this._fragment = null;

            if (!x3dom.nodeTypes.ComposedShader.ShaderInfoMsgShown) {
                x3dom.debug.logInfo("Current ComposedShader node implementation limitations:\n" +
                    "Vertex attributes (if given in the standard X3D fields 'coord', 'color', " +
                    "'normal', 'texCoord'), matrices and texture are provided as follows...\n" +
                    "(see also <a href='http://x3dom.org/x3dom/doc/help/composedShader.html'>" +
                    "http://x3dom.org/x3dom/doc/help/composedShader.html</a>)\n" +
                    "    attribute vec3 position;\n" +
                    "    attribute vec3 normal;\n" +
                    "    attribute vec2 texcoord;\n" +
                    "    attribute vec3 color;\n" +
                    "    uniform mat4 modelViewProjectionMatrix;\n" +
                    "    uniform mat4 modelViewMatrix;\n" +
					"    uniform mat4 normalMatrix;\n" +
					"    uniform mat4 viewMatrix;\n" +
                    "    uniform sampler2D tex;\n");
                x3dom.nodeTypes.ComposedShader.ShaderInfoMsgShown = true;
            }
        },
        {
            nodeChanged: function()
            {
                var i, n = this._cf.parts.nodes.length;

                for (i=0; i<n; i++)
                {
                    if (this._cf.parts.nodes[i]._vf.type.toLowerCase() == 'vertex') {
                        this._vertex = this._cf.parts.nodes[i];
                    }
                    else if (this._cf.parts.nodes[i]._vf.type.toLowerCase() == 'fragment') {
                        this._fragment = this._cf.parts.nodes[i];
                    }
                }

                var ctx = {};
                n = this._cf.fields.nodes.length;

                for (i=0; i<n; i++)
                {
                    var fieldName = this._cf.fields.nodes[i]._vf.name;
                    ctx.xmlNode = this._cf.fields.nodes[i]._xmlNode;

                    var needNode = false;

                    if (ctx.xmlNode === undefined || ctx.xmlNode === null) {
                        ctx.xmlNode = document.createElement("field");
                        needNode = true;
                    }

                    ctx.xmlNode.setAttribute(fieldName, this._cf.fields.nodes[i]._vf.value);

                    var funcName = "this.addField_" + this._cf.fields.nodes[i]._vf.type + "(ctx, name);";
                    var func = new Function('ctx', 'name', funcName);

                    func.call(this, ctx, fieldName);

                    if (needNode) {
                        ctx.xmlNode = null;    // cleanup
                    }
                }
				
				Array.forEach(this._parentNodes, function (app) {
					Array.forEach(app._parentNodes, function (shape) {
						//shape.setAppDirty();
						if (shape._cleanupGLObjects)
						    shape._cleanupGLObjects();
						shape.setAllDirty();
					});
				});	
            },

            fieldChanged: function(fieldName)
            {
                var i, n = this._cf.fields.nodes.length;

                for (i=0; i<n; i++)
                {
                    var field = this._cf.fields.nodes[i]._vf.name;

                    if (field === fieldName)
                    {
                        var msg = this._cf.fields.nodes[i]._vf.value;

                        try {
                            this._vf[field].setValueByStr(msg);
                        }
                        catch (exc1) {
                            try {
                                switch ((typeof(this._vf[field])).toString()) {
                                    case "number":
                                        this._vf[field] = +msg;
                                        break;
                                    case "boolean":
                                        this._vf[field] = (msg.toLowerCase() === "true");
                                        break;
                                    case "string":
                                        this._vf[field] = msg;
                                        break;
                                }
                            }
                            catch (exc2) {
                                x3dom.debug.logError("setValueByStr() NYI for " + typeof(this._vf[field]));
                            }
                        }

                        break;
                    }
                }
                
                if (field === 'url') 
                {
                    Array.forEach(this._parentNodes, function (app) {
    					Array.forEach(app._parentNodes, function (shape) {
    						shape._dirty.shader = true;
    					});
    				});
                }
            },
			
			parentAdded: function(parent)
			{
				//Array.forEach(this._parentNodes, function (app) {
				//	app.nodeChanged();
				//});
				parent.nodeChanged();
			}
        }
    )
);

x3dom.nodeTypes.ComposedShader.ShaderInfoMsgShown = false;


/* ### ShaderPart ### */
x3dom.registerNodeType(
    "ShaderPart",
    "Shaders",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.ShaderPart.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'url', []);
            this.addField_SFString(ctx, 'type', "VERTEX");

            x3dom.debug.assert(this._vf.type.toLowerCase() == 'vertex' ||
                               this._vf.type.toLowerCase() == 'fragment');
        },
        {
			nodeChanged: function()
            {
                var ctx = {};
                ctx.xmlNode = this._xmlNode;

                if (ctx.xmlNode !== undefined && ctx.xmlNode !== null) 
                {
                    var that = this;

                    if (that._vf.url.length && that._vf.url[0].indexOf('\n') == -1)
                    {
                        var xhr = new XMLHttpRequest();
                        xhr.open("GET", encodeURI(that._nameSpace.getURL(that._vf.url[0])), false);
                        xhr.onload = function() {
                            that._vf.url = new x3dom.fields.MFString( [] );
                            that._vf.url.push(xhr.response);
                        };
                        xhr.onerror = function() {
                            x3dom.debug.logError("Could not load file '" + that._vf.url[0] + "'.");
                        };
                        xhr.send(null);
                    }
                    else
                    {
                        if (that._vf.url.length) {
                            that._vf.url = new x3dom.fields.MFString( [] );
                        }
                        try {
                            that._vf.url.push(ctx.xmlNode.childNodes[1].nodeValue);
                            ctx.xmlNode.removeChild(ctx.xmlNode.childNodes[1]);
                        }
                        catch(e) {
                            Array.forEach( ctx.xmlNode.childNodes, function (childDomNode) {
                                if (childDomNode.nodeType === 3) {
                                    that._vf.url.push(childDomNode.nodeValue);
                                }
                                else if (childDomNode.nodeType === 4) {
                                    that._vf.url.push(childDomNode.data);
                                }
                                childDomNode.parentNode.removeChild(childDomNode);
                            } );
                        }
                    }
                }
                // else hope that url field was already set somehow

                Array.forEach(this._parentNodes, function (shader) {
                    shader.nodeChanged();
                });
			},
			
			fieldChanged: function(fieldName)
            {
                if (fieldName === "url") {
                    Array.forEach(this._parentNodes, function (shader) {
    					shader.fieldChanged("url");
    				});
                }
			},
			
			parentAdded: function(parent)
			{
				//Array.forEach(this._parentNodes, function (shader) {
				//	shader.nodeChanged();
				//});
				parent.nodeChanged();
			}
        }
    )
);

/* ### X3DVertexAttributeNode ### */
x3dom.registerNodeType(
    "X3DVertexAttributeNode",
    "Shaders",
    defineClass(x3dom.nodeTypes.X3DGeometricPropertyNode,
        function (ctx) {
            x3dom.nodeTypes.X3DVertexAttributeNode.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'name', "");
        }
    )
);

/* ### FloatVertexAttribute ### */
x3dom.registerNodeType(
    "FloatVertexAttribute",
    "Shaders",
    defineClass(x3dom.nodeTypes.X3DVertexAttributeNode,
        function (ctx) {
            x3dom.nodeTypes.FloatVertexAttribute.superClass.call(this, ctx);

            this.addField_SFInt32(ctx, 'numComponents', 4);
            this.addField_MFFloat(ctx, 'value', []);
        }
    )
);


/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### X3DSpatialGeometryNode ### */
x3dom.registerNodeType(
    "X3DSpatialGeometryNode",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.X3DSpatialGeometryNode.superClass.call(this, ctx);   
        }
    )
);

/* ### Plane ### */
x3dom.registerNodeType(
    "Plane",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Plane.superClass.call(this, ctx);

            this.addField_SFVec2f(ctx, 'size', 2, 2);
            this.addField_SFVec2f(ctx, 'subdivision', 1, 1);
            this.addField_SFVec3f(ctx, 'center', 0, 0, 0);
            this.addField_MFString(ctx, 'primType', ['TRIANGLES']);

            // this way currently an initialize only field
            if (this._vf.primType.length)
                this._mesh._primType = this._vf.primType[0];

            var sx = this._vf.size.x, sy = this._vf.size.y;
            var subx = this._vf.subdivision.x, suby = this._vf.subdivision.y;

            var geoCacheID = 'Plane_' + sx + '-' + sy + '-' + subx + '-' + suby + '-' +
                             this._vf.center.x + '-' + this._vf.center.y + '-' + this._vf.center.z;

            // Attention: DynamicLOD node internally creates Plane nodes, but MUST NOT 
            //            use geoCache, therefore only use cache if "ctx" is defined!
            // TODO: move mesh generation of all primitives to nodeChanged()
            if (ctx && this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined) {
                //x3dom.debug.logInfo("Using Plane from Cache");
                this._mesh = x3dom.geoCache[geoCacheID];
            }
            else {
                var x = 0, y = 0;
                var xstep = sx / subx;
                var ystep = sy / suby;

                sx /= 2; sy /= 2;

                for (y = 0; y <= suby; y++) {
                    for (x = 0; x <= subx; x++) {
                        this._mesh._positions[0].push(this._vf.center.x + x * xstep - sx);
                        this._mesh._positions[0].push(this._vf.center.y + y * ystep - sy);
                        this._mesh._positions[0].push(this._vf.center.z);
                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(1);
                        this._mesh._texCoords[0].push(x / subx);
                        this._mesh._texCoords[0].push(y / suby);
                    }
                }

                for (y = 1; y <= suby; y++) {
                    for (x = 0; x < subx; x++) {
                        this._mesh._indices[0].push((y - 1) * (subx + 1) + x);
                        this._mesh._indices[0].push((y - 1) * (subx + 1) + x + 1);
                        this._mesh._indices[0].push(y * (subx + 1) + x);

                        this._mesh._indices[0].push(y * (subx + 1) + x);
                        this._mesh._indices[0].push((y - 1) * (subx + 1) + x + 1);
                        this._mesh._indices[0].push(y * (subx + 1) + x + 1);
                    }
                }

                this._mesh._invalidate = true;
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                x3dom.geoCache[geoCacheID] = this._mesh;
            }
        },
        {
             fieldChanged: function (fieldName) {
                 if (fieldName == "size" || fieldName == "center") {
                     this._mesh._positions[0] = [];

                     var sx = this._vf.size.x, sy = this._vf.size.y;
                     var subx = this._vf.subdivision.x, suby = this._vf.subdivision.y;
                     var x = 0, y = 0;
                     var xstep = sx / subx;
                     var ystep = sy / suby;

                     sx /= 2; sy /= 2;

                     for (y = 0; y <= suby; y++) {
                         for (x = 0; x <= subx; x++) {
                             this._mesh._positions[0].push(this._vf.center.x + x * xstep - sx);
                             this._mesh._positions[0].push(this._vf.center.y + y * ystep - sy);
                             this._mesh._positions[0].push(this._vf.center.z);
                         }
                     }

                     this.invalidateVolume();
                     this._mesh._numCoords = this._mesh._positions[0].length / 3;

                     Array.forEach(this._parentNodes, function (node) {
                         node._dirty.positions = true;
                         node.invalidateVolume();
                     });
                 }
                 else if (fieldName == "subdivision") {
                     this._mesh._positions[0] = [];
                     this._mesh._indices[0] = [];
                     this._mesh._normals[0] = [];
                     this._mesh._texCoords[0] = [];

                     var sx = this._vf.size.x, sy = this._vf.size.y;
                     var subx = this._vf.subdivision.x, suby = this._vf.subdivision.y;

                     var x = 0, y = 0;
                     var xstep = sx / subx;
                     var ystep = sy / suby;

                     sx /= 2; sy /= 2;

                     for (y = 0; y <= suby; y++) {
                         for (x = 0; x <= subx; x++) {
                             this._mesh._positions[0].push(this._vf.center.x + x * xstep - sx);
                             this._mesh._positions[0].push(this._vf.center.y + y * ystep - sy);
                             this._mesh._positions[0].push(this._vf.center.z);
                             this._mesh._normals[0].push(0);
                             this._mesh._normals[0].push(0);
                             this._mesh._normals[0].push(1);
                             this._mesh._texCoords[0].push(x / subx);
                             this._mesh._texCoords[0].push(y / suby);
                         }
                     }

                     for (y = 1; y <= suby; y++) {
                         for (x = 0; x < subx; x++) {
                             this._mesh._indices[0].push((y - 1) * (subx + 1) + x);
                             this._mesh._indices[0].push((y - 1) * (subx + 1) + x + 1);
                             this._mesh._indices[0].push(y * (subx + 1) + x);

                             this._mesh._indices[0].push(y * (subx + 1) + x);
                             this._mesh._indices[0].push((y - 1) * (subx + 1) + x + 1);
                             this._mesh._indices[0].push(y * (subx + 1) + x + 1);
                         }
                     }

                     this.invalidateVolume();
                     this._mesh._numFaces = this._mesh._indices[0].length / 3;
                     this._mesh._numCoords = this._mesh._positions[0].length / 3;

                     Array.forEach(this._parentNodes, function (node) {
                         node.setAllDirty();
                         node.invalidateVolume();
                     });
                 }
             }
        }
    )
);

/* ### Box ### */
x3dom.registerNodeType(
    "Box",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Box.superClass.call(this, ctx);

            this.addField_SFVec3f(ctx, 'size', 2, 2, 2);
            this.addField_SFBool(ctx, 'hasHelperColors', false);

            var sx = this._vf.size.x,
                sy = this._vf.size.y,
                sz = this._vf.size.z;

			var geoCacheID = 'Box_'+sx+'-'+sy+'-'+sz;

			if( this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined )
			{
				//x3dom.debug.logInfo("Using Box from Cache");
				this._mesh = x3dom.geoCache[geoCacheID];
			}
			else
			{
				sx /= 2; sy /= 2; sz /= 2;

				this._mesh._positions[0] = [
					-sx,-sy,-sz,  -sx, sy,-sz,   sx, sy,-sz,   sx,-sy,-sz, //hinten 0,0,-1
					-sx,-sy, sz,  -sx, sy, sz,   sx, sy, sz,   sx,-sy, sz, //vorne 0,0,1
					-sx,-sy,-sz,  -sx,-sy, sz,  -sx, sy, sz,  -sx, sy,-sz, //links -1,0,0
					 sx,-sy,-sz,   sx,-sy, sz,   sx, sy, sz,   sx, sy,-sz, //rechts 1,0,0
					-sx, sy,-sz,  -sx, sy, sz,   sx, sy, sz,   sx, sy,-sz, //oben 0,1,0
					-sx,-sy,-sz,  -sx,-sy, sz,   sx,-sy, sz,   sx,-sy,-sz  //unten 0,-1,0
				];
				this._mesh._normals[0] = [
					0,0,-1,  0,0,-1,   0,0,-1,   0,0,-1,
					0,0,1,  0,0,1,   0,0,1,   0,0,1,
					-1,0,0,  -1,0,0,  -1,0,0,  -1,0,0,
					1,0,0,   1,0,0,   1,0,0,   1,0,0,
					0,1,0,  0,1,0,   0,1,0,   0,1,0,
					0,-1,0,  0,-1,0,   0,-1,0,   0,-1,0
				];
				this._mesh._texCoords[0] = [
					1,0, 1,1, 0,1, 0,0,
					0,0, 0,1, 1,1, 1,0,
					0,0, 1,0, 1,1, 0,1,
					1,0, 0,0, 0,1, 1,1,
					0,1, 0,0, 1,0, 1,1,
					0,0, 0,1, 1,1, 1,0
				];
                if (this._vf.hasHelperColors) {
                    this._mesh._colors[0] = [
                        0, 0, 0,  0, 1, 0,  1, 1, 0,  1, 0, 0,
                        0, 0, 1,  0, 1, 1,  1, 1, 1,  1, 0, 1,
                        0, 0, 0,  0, 0, 1,  0, 1, 1,  0, 1, 0,
                        1, 0, 0,  1, 0, 1,  1, 1, 1,  1, 1, 0,
                        0, 1, 0,  0, 1, 1,  1, 1, 1,  1, 1, 0,
                        0, 0, 0,  0, 0, 1,  1, 0, 1,  1, 0, 0
                    ];
                }
				this._mesh._indices[0] = [
					0,1,2, 2,3,0,
					4,7,5, 5,7,6,
					8,9,10, 10,11,8,
					12,14,13, 14,12,15,
					16,17,18, 18,19,16,
					20,22,21, 22,20,23
				];
				this._mesh._invalidate = true;
				this._mesh._numFaces = 12;
				this._mesh._numCoords = 24;

				x3dom.geoCache[geoCacheID] = this._mesh;
			}
        },
        {
            fieldChanged: function(fieldName) {
                if (fieldName === "size") {
                    var sx = this._vf.size.x / 2,
                        sy = this._vf.size.y / 2,
                        sz = this._vf.size.z / 2;

                    this._mesh._positions[0] = [
                        -sx,-sy,-sz,  -sx, sy,-sz,   sx, sy,-sz,   sx,-sy,-sz, //back   0,0,-1
                        -sx,-sy, sz,  -sx, sy, sz,   sx, sy, sz,   sx,-sy, sz, //front  0,0,1
                        -sx,-sy,-sz,  -sx,-sy, sz,  -sx, sy, sz,  -sx, sy,-sz, //left   -1,0,0
                         sx,-sy,-sz,   sx,-sy, sz,   sx, sy, sz,   sx, sy,-sz, //right  1,0,0
                        -sx, sy,-sz,  -sx, sy, sz,   sx, sy, sz,   sx, sy,-sz, //top    0,1,0
                        -sx,-sy,-sz,  -sx,-sy, sz,   sx,-sy, sz,   sx,-sy,-sz  //bottom 0,-1,0
                    ];

                    this.invalidateVolume();

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.positions = true;
                        node.invalidateVolume();
                    });
                }
                else if (fieldName === "hasHelperColors") {
                    if (this._vf.hasHelperColors) {
                        this._mesh._colors[0] = [
                            0, 0, 0,  0, 1, 0,  1, 1, 0,  1, 0, 0,
                            0, 0, 1,  0, 1, 1,  1, 1, 1,  1, 0, 1,
                            0, 0, 0,  0, 0, 1,  0, 1, 1,  0, 1, 0,
                            1, 0, 0,  1, 0, 1,  1, 1, 1,  1, 1, 0,
                            0, 1, 0,  0, 1, 1,  1, 1, 1,  1, 1, 0,
                            0, 0, 0,  0, 0, 1,  1, 0, 1,  1, 0, 0
                        ];
                    }
                    else {
                        this._mesh._colors[0] = [];
                    }

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.colors = true;
                    });
                }
            }
        }
    )
);

/* ### Sphere ### */
x3dom.registerNodeType(
    "Sphere",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Sphere.superClass.call(this, ctx);

            // sky box background creates sphere with r = 10000
			this.addField_SFFloat(ctx, 'radius', ctx ? 1 : 10000);
			this.addField_SFVec2f(ctx, 'subdivision', 24, 24);
			 
            var qfactor = 1.0;
			var r = this._vf.radius;
			var subx = this._vf.subdivision.x, suby = this._vf.subdivision.y;
			
			var geoCacheID = 'Sphere_' + r + '-' + subx + '-' + suby;

			if (this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined) {
				//x3dom.debug.logInfo("Using Sphere from Cache");
				this._mesh = x3dom.geoCache[geoCacheID];
			}
			else {
				if(ctx) {
					qfactor = ctx.doc.properties.getProperty("PrimitiveQuality", "Medium");
				}
                if (!x3dom.Utils.isNumber(qfactor)) {
                    switch (qfactor.toLowerCase()) {
                        case "low":
                            qfactor = 0.3;
                            break;
                        case "medium":
                            qfactor = 0.5;
                            break;
                        case "high":
                            qfactor = 1.0;
                            break;
                    }
                } else {
                    qfactor = parseFloat(qfactor);
                }
				
				this._quality = qfactor;

				var latNumber, longNumber;
				var latitudeBands = Math.floor(subx * qfactor);
				var longitudeBands = Math.floor(suby * qfactor);

				var theta, sinTheta, cosTheta;
				var phi, sinPhi, cosPhi;
				var x, y, z, u, v;

				for (latNumber = 0; latNumber <= latitudeBands; latNumber++) {
					theta = (latNumber * Math.PI) / latitudeBands;
					sinTheta = Math.sin(theta);
					cosTheta = Math.cos(theta);

					for (longNumber = 0; longNumber <= longitudeBands; longNumber++) {
						phi = (longNumber * 2.0 * Math.PI) / longitudeBands;
						sinPhi = Math.sin(phi);
						cosPhi = Math.cos(phi);

						x = -cosPhi * sinTheta;
						y = -cosTheta;
						z = -sinPhi * sinTheta;

						u = 0.25 - (longNumber / longitudeBands);
						v = latNumber / latitudeBands;

						this._mesh._positions[0].push(r * x);
						this._mesh._positions[0].push(r * y);
						this._mesh._positions[0].push(r * z);
						this._mesh._normals[0].push(x);
						this._mesh._normals[0].push(y);
						this._mesh._normals[0].push(z);
						this._mesh._texCoords[0].push(u);
						this._mesh._texCoords[0].push(v);
					}
				}

				var first, second;

				for (latNumber = 0; latNumber < latitudeBands; latNumber++) {
					for (longNumber = 0; longNumber < longitudeBands; longNumber++) {
						first = (latNumber * (longitudeBands + 1)) + longNumber;
						second = first + longitudeBands + 1;

						this._mesh._indices[0].push(first);
						this._mesh._indices[0].push(second);
						this._mesh._indices[0].push(first + 1);

						this._mesh._indices[0].push(second);
						this._mesh._indices[0].push(second + 1);
						this._mesh._indices[0].push(first + 1);
					}
				}
				
				this._mesh._invalidate = true;
				this._mesh._numFaces = this._mesh._indices[0].length / 3;
				this._mesh._numCoords = this._mesh._positions[0].length / 3;

				x3dom.geoCache[geoCacheID] = this._mesh;
			}
        },
        {
            fieldChanged: function(fieldName) {
                 if (fieldName === "radius") {
                    this._mesh._positions[0] = [];
					var r = this._vf.radius;
					var subx = this._vf.subdivision.x, suby = this._vf.subdivision.y;
					var qfactor = this._quality;
									
					var latNumber, longNumber;
					var latitudeBands = Math.floor(subx * qfactor);
					var longitudeBands = Math.floor(suby * qfactor);
					
					var theta, sinTheta, cosTheta;
					var phi, sinPhi, cosPhi;
					var x, y, z;
	
					for (latNumber = 0; latNumber <= latitudeBands; latNumber++) {
						theta = (latNumber * Math.PI) / latitudeBands;
						sinTheta = Math.sin(theta);
						cosTheta = Math.cos(theta);
	
						for (longNumber = 0; longNumber <= longitudeBands; longNumber++) {
							phi = (longNumber * 2.0 * Math.PI) / longitudeBands;
							sinPhi = Math.sin(phi);
							cosPhi = Math.cos(phi);
	
							x = -cosPhi * sinTheta;
							y = -cosTheta;
							z = -sinPhi * sinTheta;
	
							this._mesh._positions[0].push(r * x);
							this._mesh._positions[0].push(r * y);
							this._mesh._positions[0].push(r * z);
						}
					}

                    this.invalidateVolume();
					this._mesh._numCoords = this._mesh._positions[0].length / 3;
				
                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.positions = true;
                        node.invalidateVolume();
                    });
                }
                else if (fieldName === "subdivision") {
					this._mesh._positions[0] = [];
					this._mesh._indices[0] =[];
					this._mesh._normals[0] = [];
					this._mesh._texCoords[0] =[];
					
					var r = this._vf.radius;
					var subx = this._vf.subdivision.x, suby = this._vf.subdivision.y;
					var qfactor = this._quality;
					
					var latNumber, longNumber;
					var latitudeBands = Math.floor(subx * qfactor);
					var longitudeBands = Math.floor(suby * qfactor);
	
					var theta, sinTheta, cosTheta;
					var phi, sinPhi, cosPhi;
					var x, y, z, u, v;
	
					for (latNumber = 0; latNumber <= latitudeBands; latNumber++) {
						theta = (latNumber * Math.PI) / latitudeBands;
						sinTheta = Math.sin(theta);
						cosTheta = Math.cos(theta);
	
						for (longNumber = 0; longNumber <= longitudeBands; longNumber++) {
							phi = (longNumber * 2.0 * Math.PI) / longitudeBands;
							sinPhi = Math.sin(phi);
							cosPhi = Math.cos(phi);
	
							x = -cosPhi * sinTheta;
							y = -cosTheta;
							z = -sinPhi * sinTheta;
	
							u = 0.25 - (longNumber / longitudeBands);
							v = latNumber / latitudeBands;
	
							this._mesh._positions[0].push(r * x);
							this._mesh._positions[0].push(r * y);
							this._mesh._positions[0].push(r * z);
							this._mesh._normals[0].push(x);
							this._mesh._normals[0].push(y);
							this._mesh._normals[0].push(z);
							this._mesh._texCoords[0].push(u);
							this._mesh._texCoords[0].push(v);
						}
					}
	
					var first, second;
	
					for (latNumber = 0; latNumber < latitudeBands; latNumber++) {
						for (longNumber = 0; longNumber < longitudeBands; longNumber++) {
							first = (latNumber * (longitudeBands + 1)) + longNumber;
							second = first + longitudeBands + 1;
	
							this._mesh._indices[0].push(first);
							this._mesh._indices[0].push(second);
							this._mesh._indices[0].push(first + 1);
	
							this._mesh._indices[0].push(second);
							this._mesh._indices[0].push(second + 1);
							this._mesh._indices[0].push(first + 1);
						}
					}

                    this.invalidateVolume();
					this._mesh._numFaces = this._mesh._indices[0].length / 3;
					this._mesh._numCoords = this._mesh._positions[0].length / 3;
					
					 Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                        node.invalidateVolume();
                    });
				}
            }
        }
    )
);

/* ### Torus ### */
x3dom.registerNodeType(
    "Torus",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Torus.superClass.call(this, ctx);

            var twoPi = 2.0 * Math.PI;

			this.addField_SFFloat(ctx, 'innerRadius', 0.5);
			this.addField_SFFloat(ctx, 'outerRadius', 1.0);
            this.addField_SFFloat(ctx, 'angle', twoPi);
            this.addField_SFBool(ctx, 'caps', true);
			this.addField_SFVec2f(ctx, 'subdivision', 24, 24);
            this.addField_SFBool(ctx, 'insideOutsideRadius', false);    // use other radius/orientation behavior

            // assure that angle in [0, 2 * PI]
            if (this._vf.angle < 0)
                this._vf.angle = 0;
            else if (this._vf.angle > twoPi)
                this._vf.angle = twoPi;

            this._origCCW = this._vf.ccw;

            var innerRadius = this._vf.innerRadius;
            var outerRadius = this._vf.outerRadius;

            if (this._vf.insideOutsideRadius == true)
            {
                if (innerRadius > outerRadius) {
                    var tmp = innerRadius;
                    innerRadius = outerRadius;
                    outerRadius = tmp;
                }

                var rad = (outerRadius - innerRadius) / 2;

                outerRadius = innerRadius + rad;
                innerRadius = rad;

                // fix wrong face orientation in case of clockwise rotation
                this._vf.ccw = !this._origCCW;
            }

			var rings = this._vf.subdivision.x, sides = this._vf.subdivision.y;
            rings = Math.max(3, Math.round((this._vf.angle / twoPi) * rings));

            // FIXME; check/update geoCache on field update (for ALL primitives)!
			var geoCacheID = 'Torus_'+innerRadius+'_'+outerRadius+'_'+this._vf.angle+'_'+
                             this._vf.subdivision+'-'+this._vf.caps;

			if( this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined )
			{
				//x3dom.debug.logInfo("Using Torus from Cache");
				this._mesh = x3dom.geoCache[geoCacheID];
			}
			else
			{
				var ringDelta = this._vf.angle / rings;
				var sideDelta = twoPi / sides;
				var a, b, theta, phi;
                var cosTheta, sinTheta, cosPhi, sinPhi, dist;

				for (a=0, theta=0; a <= rings; a++, theta+=ringDelta)
				{
					cosTheta = Math.cos(theta);
                    sinTheta = Math.sin(theta);

					for (b=0, phi=0; b<=sides; b++, phi+=sideDelta)
					{
						cosPhi = Math.cos(phi);
						sinPhi = Math.sin(phi);
						dist = outerRadius + innerRadius * cosPhi;

                        if (this._vf.insideOutsideRadius) {
                            this._mesh._positions[0].push(cosTheta * dist, innerRadius * sinPhi, -sinTheta * dist);
                            this._mesh._normals[0].push(cosTheta * cosPhi, sinPhi, -sinTheta * cosPhi);
                        }
                        else {
                            this._mesh._positions[0].push(cosTheta * dist, -sinTheta * dist, innerRadius * sinPhi);
                            this._mesh._normals[0].push(cosTheta * cosPhi, -sinTheta * cosPhi, sinPhi);
                        }
						this._mesh._texCoords[0].push(-a / rings, b / sides);
					}
				}

				for (a=0; a<sides; a++)
				{
					for (b=0; b<rings; b++)
					{
						this._mesh._indices[0].push(b * (sides+1) + a);
						this._mesh._indices[0].push(b * (sides+1) + a + 1);
						this._mesh._indices[0].push((b + 1) * (sides+1) + a);

						this._mesh._indices[0].push(b * (sides+1) + a + 1);
						this._mesh._indices[0].push((b + 1) * (sides+1) + a + 1);
						this._mesh._indices[0].push((b + 1) * (sides+1) + a);
					}
				}

                if (this._vf.angle < twoPi && this._vf.caps == true)
                {
                    // create first cap
                    var origPos = this._mesh._positions[0].length / 3;

                    if (this._vf.insideOutsideRadius) {
                        this._mesh._positions[0].push(outerRadius, 0, 0);
                        this._mesh._normals[0].push(0, 0, 1);
                    }
                    else {
                        this._mesh._positions[0].push(outerRadius, 0, 0);
                        this._mesh._normals[0].push(0, 1, 0);
                    }
                    this._mesh._texCoords[0].push(0.5, 0.5);

                    for (b=0, phi=0; b<=sides; b++, phi+=sideDelta)
                    {
                        cosPhi = Math.cos(phi);
                        sinPhi = Math.sin(phi);
                        dist = outerRadius + innerRadius * cosPhi;

                        if (this._vf.insideOutsideRadius) {
                            this._mesh._positions[0].push(dist, sinPhi * innerRadius, 0);
                            this._mesh._normals[0].push(0, 0, 1);
                        }
                        else {
                            this._mesh._positions[0].push(dist, 0, sinPhi * innerRadius);
                            this._mesh._normals[0].push(0, 1, 0);
                        }
                        this._mesh._texCoords[0].push((1 + cosPhi) * 0.5, (1 - sinPhi) * 0.5);

                        if (b > 0) {
                            this._mesh._indices[0].push(origPos);
                            this._mesh._indices[0].push(origPos + b);
                            this._mesh._indices[0].push(origPos + b - 1);
                        }
                        if (b == sides) {
                            this._mesh._indices[0].push(origPos);
                            this._mesh._indices[0].push(origPos + 1);
                            this._mesh._indices[0].push(origPos + b);
                        }
                    }

                    // second cap
                    cosTheta = Math.cos(this._vf.angle);
                    sinTheta = Math.sin(this._vf.angle);

                    origPos = this._mesh._positions[0].length / 3;
                    var nx = -sinTheta, ny = -cosTheta;

                    if (this._vf.insideOutsideRadius) {
                        this._mesh._positions[0].push(cosTheta * outerRadius, 0, -sinTheta * outerRadius);
                        this._mesh._normals[0].push(nx, 0, ny);
                    }
                    else {
                        this._mesh._positions[0].push(cosTheta * outerRadius, -sinTheta * outerRadius, 0);
                        this._mesh._normals[0].push(nx, ny, 0);
                    }
                    this._mesh._texCoords[0].push(0.5, 0.5);

                    for (b=0, phi=0; b<=sides; b++, phi+=sideDelta)
                    {
                        cosPhi = Math.cos(phi);
                        sinPhi = Math.sin(phi);
                        dist = outerRadius + innerRadius * cosPhi;

                        if (this._vf.insideOutsideRadius) {
                            this._mesh._positions[0].push(cosTheta * dist, sinPhi * innerRadius, -sinTheta * dist);
                            this._mesh._normals[0].push(nx, 0, ny);
                        }
                        else {
                            this._mesh._positions[0].push(cosTheta * dist, -sinTheta * dist, sinPhi * innerRadius);
                            this._mesh._normals[0].push(nx, ny, 0);
                        }
                        this._mesh._texCoords[0].push(1 - (1 + cosPhi) * 0.5, (1 - sinPhi) * 0.5);

                        if (b > 0) {
                            this._mesh._indices[0].push(origPos);
                            this._mesh._indices[0].push(origPos + b - 1);
                            this._mesh._indices[0].push(origPos + b);
                        }
                        if (b == sides) {
                            this._mesh._indices[0].push(origPos);
                            this._mesh._indices[0].push(origPos + b);
                            this._mesh._indices[0].push(origPos + 1);
                        }
                    }
                }
				
				this._mesh._invalidate = true;
				this._mesh._numFaces = this._mesh._indices[0].length / 3;
				this._mesh._numCoords = this._mesh._positions[0].length / 3;

				x3dom.geoCache[geoCacheID] = this._mesh;
			}
        },
        {
            fieldChanged: function(fieldName)
            {
                // TODO; invalidate geometry cache if necessary (to be fixed for all primitives)!
                if (fieldName == "innerRadius" || fieldName == "outerRadius" ||
                    fieldName == "subdivision" || fieldName == "angle" ||
                    fieldName == "insideOutsideRadius" || fieldName == "caps")
                {
                    // assure that angle in [0, 2 * PI]
                    var twoPi = 2.0 * Math.PI;

                    if (this._vf.angle < 0)
                        this._vf.angle = 0;
                    else if (this._vf.angle > twoPi)
                        this._vf.angle = twoPi;

                    var innerRadius = this._vf.innerRadius;
                    var outerRadius = this._vf.outerRadius;

                    if (this._vf.insideOutsideRadius == true)
                    {
                        if (innerRadius > outerRadius) {
                            var tmp = innerRadius;
                            innerRadius = outerRadius;
                            outerRadius = tmp;
                        }

                        var rad = (outerRadius - innerRadius) / 2;

                        outerRadius = innerRadius + rad;
                        innerRadius = rad;

                        this._vf.ccw = !this._origCCW;
                    }
                    else
                        this._vf.ccw = this._origCCW;

                    var rings = this._vf.subdivision.x, sides = this._vf.subdivision.y;
                    rings = Math.max(3, Math.round((this._vf.angle / twoPi) * rings));

                    var ringDelta = this._vf.angle / rings;
                    var sideDelta = twoPi / sides;
                    var a, b, theta, phi;
                    var cosTheta, sinTheta, cosPhi, sinPhi, dist;

					this._mesh._positions[0] = [];
					this._mesh._normals[0]   = [];
					this._mesh._texCoords[0] = [];
                    this._mesh._indices[0]   = [];

					for (a=0, theta=0; a <= rings; a++, theta+=ringDelta)
					{
						cosTheta = Math.cos(theta);
						sinTheta = Math.sin(theta);
	
						for (b=0, phi=0; b<=sides; b++, phi+=sideDelta)
						{
							cosPhi = Math.cos(phi);
							sinPhi = Math.sin(phi);
							dist = outerRadius + innerRadius * cosPhi;

                            if (this._vf.insideOutsideRadius) {
                                this._mesh._positions[0].push(cosTheta * dist, innerRadius * sinPhi, -sinTheta * dist);
                                this._mesh._normals[0].push(cosTheta * cosPhi, sinPhi, -sinTheta * cosPhi);
                            }
                            else {
                                this._mesh._positions[0].push(cosTheta * dist, -sinTheta * dist, innerRadius * sinPhi);
                                this._mesh._normals[0].push(cosTheta * cosPhi, -sinTheta * cosPhi, sinPhi);
                            }
							this._mesh._texCoords[0].push(-a / rings, b / sides);
						}
					}

					for (a=0; a<sides; a++)
					{
						for (b=0; b<rings; b++)
						{
							this._mesh._indices[0].push(b * (sides+1) + a);
							this._mesh._indices[0].push(b * (sides+1) + a + 1);
							this._mesh._indices[0].push((b + 1) * (sides+1) + a);
	
							this._mesh._indices[0].push(b * (sides+1) + a + 1);
							this._mesh._indices[0].push((b + 1) * (sides+1) + a + 1);
							this._mesh._indices[0].push((b + 1) * (sides+1) + a);
						}
					}

                    if (this._vf.angle < twoPi && this._vf.caps == true)
                    {
                        // create first cap
                        var origPos = this._mesh._positions[0].length / 3;

                        if (this._vf.insideOutsideRadius) {
                            this._mesh._positions[0].push(outerRadius, 0, 0);
                            this._mesh._normals[0].push(0, 0, 1);
                        }
                        else {
                            this._mesh._positions[0].push(outerRadius, 0, 0);
                            this._mesh._normals[0].push(0, 1, 0);
                        }
                        this._mesh._texCoords[0].push(0.5, 0.5);

                        for (b=0, phi=0; b<=sides; b++, phi+=sideDelta)
                        {
                            cosPhi = Math.cos(phi);
                            sinPhi = Math.sin(phi);
                            dist = outerRadius + innerRadius * cosPhi;

                            if (this._vf.insideOutsideRadius) {
                                this._mesh._positions[0].push(dist, sinPhi * innerRadius, 0);
                                this._mesh._normals[0].push(0, 0, 1);
                            }
                            else {
                                this._mesh._positions[0].push(dist, 0, sinPhi * innerRadius);
                                this._mesh._normals[0].push(0, 1, 0);
                            }
                            this._mesh._texCoords[0].push((1 + cosPhi) * 0.5, (1 - sinPhi) * 0.5);

                            if (b > 0) {
                                this._mesh._indices[0].push(origPos);
                                this._mesh._indices[0].push(origPos + b);
                                this._mesh._indices[0].push(origPos + b - 1);
                            }
                            if (b == sides) {
                                this._mesh._indices[0].push(origPos);
                                this._mesh._indices[0].push(origPos + 1);
                                this._mesh._indices[0].push(origPos + b);
                            }
                        }

                        // second cap
                        cosTheta = Math.cos(this._vf.angle);
                        sinTheta = Math.sin(this._vf.angle);

                        origPos = this._mesh._positions[0].length / 3;
                        var nx = -sinTheta, ny = -cosTheta;

                        if (this._vf.insideOutsideRadius) {
                            this._mesh._positions[0].push(cosTheta * outerRadius, 0, -sinTheta * outerRadius);
                            this._mesh._normals[0].push(nx, 0, ny);
                        }
                        else {
                            this._mesh._positions[0].push(cosTheta * outerRadius, -sinTheta * outerRadius, 0);
                            this._mesh._normals[0].push(nx, ny, 0);
                        }
                        this._mesh._texCoords[0].push(0.5, 0.5);

                        for (b=0, phi=0; b<=sides; b++, phi+=sideDelta)
                        {
                            cosPhi = Math.cos(phi);
                            sinPhi = Math.sin(phi);
                            dist = outerRadius + innerRadius * cosPhi;

                            if (this._vf.insideOutsideRadius) {
                                this._mesh._positions[0].push(cosTheta * dist, sinPhi * innerRadius, -sinTheta * dist);
                                this._mesh._normals[0].push(nx, 0, ny);
                            }
                            else {
                                this._mesh._positions[0].push(cosTheta * dist, -sinTheta * dist, sinPhi * innerRadius);
                                this._mesh._normals[0].push(nx, ny, 0);
                            }
                            this._mesh._texCoords[0].push(1 - (1 + cosPhi) * 0.5, (1 - sinPhi) * 0.5);

                            if (b > 0) {
                                this._mesh._indices[0].push(origPos);
                                this._mesh._indices[0].push(origPos + b - 1);
                                this._mesh._indices[0].push(origPos + b);
                            }
                            if (b == sides) {
                                this._mesh._indices[0].push(origPos);
                                this._mesh._indices[0].push(origPos + b);
                                this._mesh._indices[0].push(origPos + 1);
                            }
                        }
                    }

                    this.invalidateVolume();
					this._mesh._numFaces = this._mesh._indices[0].length / 3;
					this._mesh._numCoords = this._mesh._positions[0].length / 3;
					
					Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                        node.invalidateVolume();
                    });
				}
            }
        }
    )
);

/* ### Cone ### */
x3dom.registerNodeType(
    "Cone",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Cone.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'bottomRadius', 1.0);
            this.addField_SFFloat(ctx, 'topRadius', 0);
            this.addField_SFFloat(ctx, 'height', 2.0);
            this.addField_SFBool(ctx, 'bottom', true);
            this.addField_SFBool(ctx, 'side', true);
            this.addField_SFBool(ctx, 'top', true);
            this.addField_SFFloat(ctx, 'subdivision', 32);

            var geoCacheID = 'Cone_' + this._vf.bottomRadius + '_' + this._vf.height + '_' + this._vf.top + '_' +
                             this._vf.bottom + '_' + this._vf.side + '_' + this._vf.topRadius + '_' + this._vf.subdivision;

            if (this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined) {
                //x3dom.debug.logInfo("Using Cone from Cache");
                this._mesh = x3dom.geoCache[geoCacheID];
            }
            else {
                var bottomRadius = this._vf.bottomRadius, height = this._vf.height;
                var topRadius = this._vf.topRadius, sides = this._vf.subdivision;

                var beta, x, z;
                var delta = 2.0 * Math.PI / sides;

                var incl = (bottomRadius - topRadius) / height;
                var nlen = 1.0 / Math.sqrt(1.0 + incl * incl);

                var j = 0, k = 0;
                var h, base;

                if (this._vf.side && height > 0) {
                    var px = 0, pz = 0;

                    for (j = 0, k = 0; j <= sides; j++) {
                        beta = j * delta;
                        x = Math.sin(beta);
                        z = -Math.cos(beta);

                        if (topRadius > x3dom.fields.Eps) {
                            px = x * topRadius;
                            pz = z * topRadius;
                        }

                        this._mesh._positions[0].push(px, height / 2, pz);
                        this._mesh._normals[0].push(x / nlen, incl / nlen, z / nlen);
                        this._mesh._texCoords[0].push(1.0 - j / sides, 1);

                        this._mesh._positions[0].push(x * bottomRadius, -height / 2, z * bottomRadius);
                        this._mesh._normals[0].push(x / nlen, incl / nlen, z / nlen);
                        this._mesh._texCoords[0].push(1.0 - j / sides, 0);

                        if (j > 0) {
                            this._mesh._indices[0].push(k    );
                            this._mesh._indices[0].push(k + 2);
                            this._mesh._indices[0].push(k + 1);

                            this._mesh._indices[0].push(k + 1);
                            this._mesh._indices[0].push(k + 2);
                            this._mesh._indices[0].push(k + 3);

                            k += 2;
                        }
                    }
                }

                if (this._vf.bottom && bottomRadius > 0) {
                    base = this._mesh._positions[0].length / 3;

                    for (j = sides - 1; j >= 0; j--) {
                        beta = j * delta;
                        x = bottomRadius * Math.sin(beta);
                        z = -bottomRadius * Math.cos(beta);

                        this._mesh._positions[0].push(x, -height / 2, z);
                        this._mesh._normals[0].push(0, -1, 0);
                        this._mesh._texCoords[0].push(x / bottomRadius / 2 + 0.5, z / bottomRadius / 2 + 0.5);
                    }

                    h = base + 1;

                    for (j = 2; j < sides; j++) {
                        this._mesh._indices[0].push(h);
                        this._mesh._indices[0].push(base);

                        h = base + j;
                        this._mesh._indices[0].push(h);
                    }
                }

                if (this._vf.top && topRadius > x3dom.fields.Eps) {
                    base = this._mesh._positions[0].length / 3;

                    for (j = sides - 1; j >= 0; j--) {
                        beta = j * delta;
                        x =  topRadius * Math.sin(beta);
                        z = -topRadius * Math.cos(beta);

                        this._mesh._positions[0].push(x, height / 2, z);
                        this._mesh._normals[0].push(0, 1, 0);
                        this._mesh._texCoords[0].push(x / topRadius / 2 + 0.5, 1.0 - z / topRadius / 2 + 0.5);
                    }

                    h = base + 1;

                    for (j = 2; j < sides; j++) {
                        this._mesh._indices[0].push(base);
                        this._mesh._indices[0].push(h);

                        h = base + j;
                        this._mesh._indices[0].push(h);
                    }
                }

                this._mesh._invalidate = true;
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                x3dom.geoCache[geoCacheID] = this._mesh;
            }
        },
        {
            fieldChanged: function (fieldName)
            {
                if (fieldName == "bottomRadius" || fieldName == "topRadius" ||
                    fieldName == "height" || fieldName == "subdivision" ||
                    fieldName == "bottom" || fieldName == "top" || fieldName == "side")
                {
                    this._mesh._positions[0] = [];
                    this._mesh._indices[0] = [];
                    this._mesh._normals[0] = [];
                    this._mesh._texCoords[0] = [];

                    var bottomRadius = this._vf.bottomRadius, height = this._vf.height;
                    var topRadius = this._vf.topRadius, sides = this._vf.subdivision;

                    var beta, x, z;
                    var delta = 2.0 * Math.PI / sides;

                    var incl = (bottomRadius - topRadius) / height;
                    var nlen = 1.0 / Math.sqrt(1.0 + incl * incl);

                    var j = 0, k = 0;
                    var h, base;

                    if (this._vf.side && height > 0)
                    {
                        var px = 0, pz = 0;

                        for (j = 0, k = 0; j <= sides; j++) {
                            beta = j * delta;
                            x = Math.sin(beta);
                            z = -Math.cos(beta);

                            if (topRadius > x3dom.fields.Eps) {
                                px = x * topRadius;
                                pz = z * topRadius;
                            }

                            this._mesh._positions[0].push(px, height / 2, pz);
                            this._mesh._normals[0].push(x / nlen, incl / nlen, z / nlen);
                            this._mesh._texCoords[0].push(1.0 - j / sides, 1);

                            this._mesh._positions[0].push(x * bottomRadius, -height / 2, z * bottomRadius);
                            this._mesh._normals[0].push(x / nlen, incl / nlen, z / nlen);
                            this._mesh._texCoords[0].push(1.0 - j / sides, 0);

                            if (j > 0) {
                                this._mesh._indices[0].push(k    );
                                this._mesh._indices[0].push(k + 2);
                                this._mesh._indices[0].push(k + 1);

                                this._mesh._indices[0].push(k + 1);
                                this._mesh._indices[0].push(k + 2);
                                this._mesh._indices[0].push(k + 3);

                                k += 2;
                            }
                        }
                    }

                    if (this._vf.bottom && bottomRadius > 0)
                    {
                        base = this._mesh._positions[0].length / 3;

                        for (j = sides - 1; j >= 0; j--) {
                            beta = j * delta;
                            x = bottomRadius * Math.sin(beta);
                            z = -bottomRadius * Math.cos(beta);

                            this._mesh._positions[0].push(x, -height / 2, z);
                            this._mesh._normals[0].push(0, -1, 0);
                            this._mesh._texCoords[0].push(x / bottomRadius / 2 + 0.5, z / bottomRadius / 2 + 0.5);
                        }

                        h = base + 1;

                        for (j = 2; j < sides; j++) {
                            this._mesh._indices[0].push(h);
                            this._mesh._indices[0].push(base);

                            h = base + j;
                            this._mesh._indices[0].push(h);
                        }
                    }

                    if (this._vf.top && topRadius > x3dom.fields.Eps)
                    {
                        base = this._mesh._positions[0].length / 3;

                        for (j = sides - 1; j >= 0; j--) {
                            beta = j * delta;
                            x =  topRadius * Math.sin(beta);
                            z = -topRadius * Math.cos(beta);

                            this._mesh._positions[0].push(x, height / 2, z);
                            this._mesh._normals[0].push(0, 1, 0);
                            this._mesh._texCoords[0].push(x / topRadius / 2 + 0.5, 1.0 - z / topRadius / 2 + 0.5);
                        }

                        h = base + 1;

                        for (j = 2; j < sides; j++) {
                            this._mesh._indices[0].push(base);
                            this._mesh._indices[0].push(h);

                            h = base + j;
                            this._mesh._indices[0].push(h);
                        }
                    }

                    this.invalidateVolume();
                    this._mesh._numFaces = this._mesh._indices[0].length / 3;
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);

/* ### Cylinder ### */
x3dom.registerNodeType(
    "Cylinder",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Cylinder.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'radius', 1.0);
            this.addField_SFFloat(ctx, 'height', 2.0);
            this.addField_SFBool(ctx, 'bottom', true);
            this.addField_SFBool(ctx, 'top', true);
            this.addField_SFFloat(ctx, 'subdivision', 32);
            this.addField_SFBool(ctx, 'side', true);
			
			var sides = this._vf.subdivision;

			var geoCacheID = 'Cylinder_'+this._vf.radius+'_'+this._vf.height+'_'+this._vf.bottom+'_'+this._vf.top+'_'+
                             this._vf.side+'_'+this._vf.subdivision;

			if( this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined )
			{
				//x3dom.debug.logInfo("Using Cylinder from Cache");
				this._mesh = x3dom.geoCache[geoCacheID];
			}
			else
			{
				var radius = this._vf.radius;
				var height = this._vf.height / 2;

				var beta, x, z;
				var delta = 2.0 * Math.PI / sides;
				var j, k;

				if (this._vf.side)
				{
				  for (j=0, k=0; j<=sides; j++)
				  {
					beta = j * delta;
					x = Math.sin(beta);
					z = -Math.cos(beta);

					this._mesh._positions[0].push(x * radius, -height, z * radius);
					this._mesh._normals[0].push(x, 0, z);
					this._mesh._texCoords[0].push(1.0 - j / sides, 0);

					this._mesh._positions[0].push(x * radius, height, z * radius);
					this._mesh._normals[0].push(x, 0, z);
					this._mesh._texCoords[0].push(1.0 - j / sides, 1);

					if (j > 0)
					{
						this._mesh._indices[0].push(k    );
						this._mesh._indices[0].push(k + 1);
						this._mesh._indices[0].push(k + 2);

						this._mesh._indices[0].push(k + 2);
						this._mesh._indices[0].push(k + 1);
						this._mesh._indices[0].push(k + 3);

						k += 2;
					}
				  }
				}

				if (radius > 0)
				{
					var h, base = this._mesh._positions[0].length / 3;

					if (this._vf.top)
					{
					  for (j=sides-1; j>=0; j--)
					  {
						beta = j * delta;
						x = radius * Math.sin(beta);
						z = -radius * Math.cos(beta);

						this._mesh._positions[0].push(x, height, z);
						this._mesh._normals[0].push(0, 1, 0);
						this._mesh._texCoords[0].push(x / radius / 2 + 0.5, -z / radius / 2 + 0.5);
					  }

					  h = base + 1;

					  for (j=2; j<sides; j++)
					  {
						this._mesh._indices[0].push(base);
						this._mesh._indices[0].push(h);

						h = base + j;
						this._mesh._indices[0].push(h);
					  }

					  base = this._mesh._positions[0].length / 3;
					}

					if (this._vf.bottom)
					{
					  for (j=sides-1; j>=0; j--)
					  {
						beta = j * delta;
						x = radius * Math.sin(beta);
						z = -radius * Math.cos(beta);

						this._mesh._positions[0].push(x, -height, z);
						this._mesh._normals[0].push(0, -1, 0);
						this._mesh._texCoords[0].push(x / radius / 2 + 0.5, z / radius / 2 + 0.5);
					  }

					  h = base + 1;

					  for (j=2; j<sides; j++)
					  {
						this._mesh._indices[0].push(h);
						this._mesh._indices[0].push(base);

						h = base + j;
						this._mesh._indices[0].push(h);
					  }
					}
				}

				this._mesh._invalidate = true;
				this._mesh._numFaces = this._mesh._indices[0].length / 3;
				this._mesh._numCoords = this._mesh._positions[0].length / 3;

				x3dom.geoCache[geoCacheID] = this._mesh;
			}
        },
        {
            fieldChanged: function(fieldName) {
                if (fieldName === "radius" || fieldName === "height")
                {
                    this._mesh._positions[0] = [];
					
					var radius = this._vf.radius, height = this._vf.height / 2;
					var sides = this._vf.subdivision;	
					
					var beta, x, z, j;
					var delta = 2.0 * Math.PI / sides;

					if (this._vf.side)
					{
					  for (j=0; j<=sides; j++)
					  {
						beta = j * delta;
						x = Math.sin(beta);
						z = -Math.cos(beta);
	
						this._mesh._positions[0].push(x * radius, -height, z * radius);
						this._mesh._positions[0].push(x * radius, height, z * radius);
					  }
					}
	
					if (radius > 0)
					{
						var h, base = this._mesh._positions[0].length / 3;
	
						if (this._vf.top)
						{
						  for (j=sides-1; j>=0; j--)
						  {
							beta = j * delta;
							x = radius * Math.sin(beta);
							z = -radius * Math.cos(beta);
	
							this._mesh._positions[0].push(x, height, z);
						  }
						}
					}
	
					if (this._vf.bottom)
					{
					  for (j=sides-1; j>=0; j--)
					  {
						beta = j * delta;
						x = radius * Math.sin(beta);
						z = -radius * Math.cos(beta);
						
						this._mesh._positions[0].push(x, -height, z);
					  }
					}

                    this.invalidateVolume();
					this._mesh._numCoords = this._mesh._positions[0].length / 3;
				
                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.positions = true;
                        node.invalidateVolume();
                    });
                }
                else if (fieldName === "subdivision" || fieldName === "bottom" ||
                         fieldName === "top" || fieldName === "side")
                {
					this._mesh._positions[0] = [];
					this._mesh._indices[0] =[];
					this._mesh._normals[0] = [];
					this._mesh._texCoords[0] =[];
					
					var radius = this._vf.radius, height = this._vf.height / 2;
					var sides = this._vf.subdivision;
					
					var beta, x, z, j;
					var delta = 2.0 * Math.PI / sides;
					var k = 0;

					if (this._vf.side)
					{
					  for (j=0, k=0; j<=sides; j++)
					  {
						beta = j * delta;
						x = Math.sin(beta);
						z = -Math.cos(beta);
	
						this._mesh._positions[0].push(x * radius, -height, z * radius);
						this._mesh._normals[0].push(x, 0, z);
						this._mesh._texCoords[0].push(1.0 - j / sides, 0);
	
						this._mesh._positions[0].push(x * radius, height, z * radius);
						this._mesh._normals[0].push(x, 0, z);
						this._mesh._texCoords[0].push(1.0 - j / sides, 1);
	
						if (j > 0)
						{
							this._mesh._indices[0].push(k + 0);
							this._mesh._indices[0].push(k + 1);
							this._mesh._indices[0].push(k + 2);
	
							this._mesh._indices[0].push(k + 2);
							this._mesh._indices[0].push(k + 1);
							this._mesh._indices[0].push(k + 3);
	
							k += 2;
						}
					  }
					}
	
					if (radius > 0)
					{
						var h, base = this._mesh._positions[0].length / 3;
	
						if (this._vf.top)
						{
						  for (j=sides-1; j>=0; j--)
						  {
							beta = j * delta;
							x = radius * Math.sin(beta);
							z = -radius * Math.cos(beta);
	
							this._mesh._positions[0].push(x, height, z);
							this._mesh._normals[0].push(0, 1, 0);
							this._mesh._texCoords[0].push(x / radius / 2 + 0.5, -z / radius / 2 + 0.5);
						  }
	
						  h = base + 1;
	
						  for (j=2; j<sides; j++)
						  {
							this._mesh._indices[0].push(base);
							this._mesh._indices[0].push(h);
	
							h = base + j;
							this._mesh._indices[0].push(h);
						  }
	
						  base = this._mesh._positions[0].length / 3;
						}
	
						if (this._vf.bottom)
						{
						  for (j=sides-1; j>=0; j--)
						  {
							beta = j * delta;
							x = radius * Math.sin(beta);
							z = -radius * Math.cos(beta);
	
							this._mesh._positions[0].push(x, -height, z);
							this._mesh._normals[0].push(0, -1, 0);
							this._mesh._texCoords[0].push(x / radius / 2 + 0.5, z / radius / 2 + 0.5);
						  }
	
						  h = base + 1;
	
						  for (j=2; j<sides; j++)
						  {
							this._mesh._indices[0].push(h);
							this._mesh._indices[0].push(base);
	
							h = base + j;
							this._mesh._indices[0].push(h);
						  }
						}
					}

                    this.invalidateVolume();
					this._mesh._numFaces = this._mesh._indices[0].length / 3;
					this._mesh._numCoords = this._mesh._positions[0].length / 3;
					
					 Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                        node.invalidateVolume();
                    });
				}
            }
        }
    )
);


/* ### X3DBinaryContainerGeometryNode ### */
x3dom.registerNodeType(
    "X3DBinaryContainerGeometryNode",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.X3DBinaryContainerGeometryNode.superClass.call(this, ctx);

            this.addField_SFVec3f(ctx, 'position', 0, 0, 0);
            this.addField_SFVec3f(ctx, 'size', 1, 1, 1);
            this.addField_MFInt32(ctx, 'vertexCount', [0]);
            this.addField_MFString(ctx, 'primType', ['TRIANGLES']);

            // correct min/max of bounding volume set in BinaryContainerGeometry
            this._mesh._invalidate = false;
            this._mesh._numCoords = 0;
            this._mesh._numFaces = 0;

            this._diameter = this._vf.size.length();
        },
        {
            getMin: function() {
                var vol = this._mesh._vol;

                if (!vol.isValid()) {
                    vol.setBoundsByCenterSize(this._vf.position, this._vf.size);
                }

                return vol.min;
            },

            getMax: function() {
                var vol = this._mesh._vol;

                if (!vol.isValid()) {
                    vol.setBoundsByCenterSize(this._vf.position, this._vf.size);
                }

                return vol.max;
            },

            getVolume: function() {
                var vol = this._mesh._vol;

                if (!vol.isValid()) {
                    vol.setBoundsByCenterSize(this._vf.position, this._vf.size);
                }

                return vol;
            },

            invalidateVolume: function() {
                // at the moment, do nothing here since field updates are not impl.
            },

            getCenter: function() {
                return this._vf.position;
            },

            getDiameter: function() {
                return this._diameter;
            }
        }
    )
);

/* ### BinaryGeometry ### */
x3dom.registerNodeType(
    "BinaryGeometry",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DBinaryContainerGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.BinaryGeometry.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'index', "");   // Uint16
            this.addField_SFString(ctx, 'coord', "");   // Float32
            this.addField_SFString(ctx, 'normal', "");
            this.addField_SFString(ctx, 'texCoord', "");    // THINKABOUTME: add texCoord1, texCoord2, ...?
            this.addField_SFString(ctx, 'color', "");
            this.addField_SFString(ctx, 'tangent', "");     // TODO
            this.addField_SFString(ctx, 'binormal', "");    // TODO

            // Typed Array View Types
            // Int8, Uint8, Int16, Uint16, Int32, Uint32, Float32, Float64
            this.addField_SFString(ctx, 'indexType', "Uint16");
            this.addField_SFString(ctx, 'coordType', "Float32");
            this.addField_SFString(ctx, 'normalType', "Float32");
            this.addField_SFString(ctx, 'texCoordType', "Float32");
            this.addField_SFString(ctx, 'colorType', "Float32");
            this.addField_SFString(ctx, 'tangentType', "Float32");
            this.addField_SFString(ctx, 'binormalType', "Float32");
            
            this.addField_SFBool(ctx, 'normalAsSphericalCoordinates', false);
            this.addField_SFBool(ctx, 'rgbaColors', false);
            this.addField_SFInt32(ctx, 'numTexCoordComponents', 2);
            this.addField_SFBool(ctx, 'normalPerVertex', true);
            this.addField_SFBool(ctx, 'idsPerVertex', false);    /// Experimental flag to decide if IDs are in texCoords
            
            // workaround
            this._hasStrideOffset = false;
            this._mesh._numPosComponents = this._vf.normalAsSphericalCoordinates ? 4 : 3;
			this._mesh._numTexComponents = this._vf.numTexCoordComponents;
			this._mesh._numColComponents = this._vf.rgbaColors ? 4 : 3;
			this._mesh._numNormComponents = this._vf.normalAsSphericalCoordinates ? 2 : 3;

		    // info helper members
		    this._vertexCountSum = 0;
		    for (var i=0; i<this._vf.vertexCount.length; ++i) {
                this._vertexCountSum += this._vf.vertexCount[i];
            }
        },
        {
            parentAdded: function(parent)
            {
                // TODO; also handle multiple shape parents!
                var offsetInd, strideInd, offset, stride;

                offsetInd = this._vf.coord.lastIndexOf('#');
                strideInd = this._vf.coord.lastIndexOf('+');
                if (offsetInd >= 0 && strideInd >= 0) {
                    offset = +this._vf.coord.substring(++offsetInd, strideInd);
                    stride = +this._vf.coord.substring(strideInd);
                    parent._coordStrideOffset = [stride, offset];
                    this._hasStrideOffset = true;
                    if ((offset / 8) - Math.floor(offset / 8) == 0) {
                        this._mesh._numPosComponents = 4;
                    }
                    //x3dom.debug.logInfo("coord stride/offset: " + stride + ", " + offset);
                }
                else if (strideInd >= 0) {
                    stride = +this._vf.coord.substring(strideInd);
                    parent._coordStrideOffset = [stride, 0];
                    if ((stride / 8) - Math.floor(stride / 8) == 0) {
                        this._mesh._numPosComponents = 4;   // ???
                    }
                    //x3dom.debug.logInfo("coord stride: " + stride);
                }

                offsetInd = this._vf.normal.lastIndexOf('#');
                strideInd = this._vf.normal.lastIndexOf('+');
                if (offsetInd >= 0 && strideInd >= 0) {
                    offset = +this._vf.normal.substring(++offsetInd, strideInd);
                    stride = +this._vf.normal.substring(strideInd);
                    parent._normalStrideOffset = [stride, offset];
                    //x3dom.debug.logInfo("normal stride/offset: " + stride + ", " + offset);
                }
                else if (strideInd >= 0) {
                    stride = +this._vf.normal.substring(strideInd);
                    parent._normalStrideOffset = [stride, 0];
                    //x3dom.debug.logInfo("normal stride: " + stride);
                }

                offsetInd = this._vf.texCoord.lastIndexOf('#');
                strideInd = this._vf.texCoord.lastIndexOf('+');
                if (offsetInd >= 0 && strideInd >= 0) {
                    offset = +this._vf.texCoord.substring(++offsetInd, strideInd);
                    stride = +this._vf.texCoord.substring(strideInd);
                    parent._texCoordStrideOffset = [stride, offset];
                    //x3dom.debug.logInfo("texCoord stride/offset: " + stride + ", " + offset);
                }
                else if (strideInd >= 0) {
                    stride = +this._vf.texCoord.substring(strideInd);
                    parent._texCoordStrideOffset = [stride, 0];
                    //x3dom.debug.logInfo("texCoord stride: " + stride);
                }

                offsetInd = this._vf.color.lastIndexOf('#');
                strideInd = this._vf.color.lastIndexOf('+');
                if (offsetInd >= 0 && strideInd >= 0) {
                    offset = +this._vf.color.substring(++offsetInd, strideInd);
                    stride = +this._vf.color.substring(strideInd);
                    parent._colorStrideOffset = [stride, offset];
                    //x3dom.debug.logInfo("color stride/offset: " + stride + ", " + offset);
                }
                else if (strideInd >= 0) {
                    stride = +this._vf.color.substring(strideInd);
                    parent._colorStrideOffset = [stride, 0];
                    //x3dom.debug.logInfo("color stride: " + stride);
                }
                
                if (this._vf.indexType != "Uint16" && !x3dom.caps.INDEX_UINT)
    		        x3dom.debug.logWarning("Index type " + this._vf.indexType + " problematic");
            },
			
			doIntersect: function(line)
            {
                var min = this.getMin();
                var max = this.getMax();
                var isect = line.intersect(min, max);

                if (isect && line.enter < line.dist) {
                    line.dist = line.enter;
                    line.hitObject = this;
                    line.hitPoint = line.pos.add(line.dir.multiply(line.enter));
                    return true;
                }
                else {
                    return false;
                }
            },
			
			getPrecisionMax: function(type)
			{
    			switch(this._vf[type])
                {
                    case "Int8":
                        return 127.0;
                    case "Uint8":
                        return 255.0;
                    case "Int16":
                        return 32767.0;
                    case "Uint16":
                        return 65535.0;
                    case "Int32":
                        return 2147483647.0;
                    case "Uint32":
                        return 4294967295.0;
                    case "Float32":
                    case "Float64":
                    default:
                        return 1.0;
                }
			}
        }
    )
);

/* ### PopGeometryLevel ### */
x3dom.registerNodeType(
    "PopGeometryLevel",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DGeometricPropertyNode,
        function (ctx) {
            x3dom.nodeTypes.PopGeometryLevel.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'src', "");
            this.addField_SFInt32(ctx, 'numIndices', 0);
            this.addField_SFInt32(ctx, 'vertexDataBufferOffset', 0);
        },
        {
            getSrc: function () {
                return this._vf.src;
            },

            getNumIndices: function () {
                return this._vf.numIndices;
            },

            getVertexDataBufferOffset: function () {
                return this._vf.vertexDataBufferOffset;
            }
        }
    )
);

/* ### PopGeometry ### */
x3dom.registerNodeType(
    "PopGeometry",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DBinaryContainerGeometryNode,
        function (ctx) {        
            x3dom.nodeTypes.PopGeometry.superClass.call(this, ctx);

            //@todo: remove this
            this.addField_SFVec3f (ctx, 'tightSize',  1, 1, 1);
            //@todo: add this on export
            this.addField_SFVec3f (ctx, 'maxBBSize',  1, 1, 1);
            this.addField_SFVec3f (ctx, 'bbMinModF',  0, 0, 0);
            this.addField_SFVec3f (ctx, 'bbMaxModF',  1, 1, 1);
            this.addField_SFVec3f (ctx, 'bbMin', 0, 0, 0);
            this.addField_SFVec3f (ctx, 'bbShiftVec', 0, 0, 0);

            if (this._vf.bbMinModF.x > this._vf.bbMaxModF.x)
                this._vf.bbShiftVec.x = 1.0;
            if (this._vf.bbMinModF.y > this._vf.bbMaxModF.y)
                this._vf.bbShiftVec.y = 1.0;
            if (this._vf.bbMinModF.z > this._vf.bbMaxModF.z)
                this._vf.bbShiftVec.z = 1.0;
      
            this.addField_MFNode('levels', x3dom.nodeTypes.PopGeometryLevel);
            
            this.addField_SFInt32(ctx, 'attributeStride',   0);
            this.addField_SFInt32(ctx, 'positionOffset',    0);
            this.addField_SFInt32(ctx, 'normalOffset',      0);
            this.addField_SFInt32(ctx, 'texcoordOffset',    0);
            this.addField_SFInt32(ctx, 'colorOffset',       0);
            this.addField_SFInt32(ctx, 'numAnchorVertices', 0);
            
            this.addField_SFInt32(ctx, 'positionPrecision', 2);
            this.addField_SFInt32(ctx, 'normalPrecision',   1);
            this.addField_SFInt32(ctx, 'texcoordPrecision', 2);
            this.addField_SFInt32(ctx, 'colorPrecision',    1); 

            this.addField_SFInt32(ctx, 'minPrecisionLevel', -1);
            this.addField_SFInt32(ctx, 'maxPrecisionLevel', -1);
            this.addField_SFFloat(ctx, 'precisionFactor',  1.0);

            //those four fields are read by the x3dom renderer            
            this.addField_SFString(ctx, 'coordType',    "Uint16");
            this.addField_SFString(ctx, 'normalType',   "Uint8");
            this.addField_SFString(ctx, 'texCoordType', "Uint16");
            this.addField_SFString(ctx, 'colorType',    "Uint8");            
           
            this.addField_SFInt32(ctx, 'vertexBufferSize', 0);
            
            this.addField_SFBool(ctx, 'indexedRendering', false);
            //ATTENTION: Although it might be supported by aopt,
            //           X3DOM does not accept 16 bit spherical normals yet,
            //           spherical normals are assumed to be 8 bit and get
            //           encoded as the 4th 16 bit position component
            this.addField_SFBool(ctx, 'sphericalNormals', false);
            
            //needed as we manipulate vertexCount during loading
            this.addField_MFInt32(ctx, 'originalVertexCount', [0]);
            
            for (var i = 0; i < this._vf.vertexCount.length; ++i) {
                this._vf.originalVertexCount[i] = this._vf.vertexCount[i];
            }

            //@todo: remove this three lines after cleanup
            this._vf.maxBBSize = x3dom.fields.SFVec3f.copy(this._vf.size);
            this._vf.size  = this._vf.tightSize;
            this._diameter = this._vf.size.length();

            this._bbMinBySize = [ Math.floor(this._vf.bbMin.x / this._vf.maxBBSize.x),
                                  Math.floor(this._vf.bbMin.y / this._vf.maxBBSize.y),
                                  Math.floor(this._vf.bbMin.z / this._vf.maxBBSize.z) ];
            this._volRadius        = this._vf.size.length() / 2;
            this._volLargestRadius = this._vf.maxBBSize.length() / 2;

            // workaround            
            this._mesh._numPosComponents  = this._vf.sphericalNormals ? 4 : 3;
            this._mesh._numNormComponents = this._vf.sphericalNormals ? 2 : 3;
            this._mesh._numTexComponents  = 2;
            this._mesh._numColComponents  = 3;

            x3dom.nodeTypes.PopGeometry.numTotalVerts += this.getVertexCount();
            x3dom.nodeTypes.PopGeometry.numTotalTris  += (this.hasIndex() ? 
                         this.getTotalNumberOfIndices() : this.getVertexCount()) / 3;
        },
        {
            forceUpdateCoverage: function() {
                return true;
            },
            
            getBBoxShiftVec: function() {
              return this._vf.bbShiftVec;
            },
         
            getBBoxSize: function() {
              return this._vf.size;
            },
            
            hasIndex: function() {
              return this._vf.indexedRendering;
            },
            
            getTotalNumberOfIndices: function() {                
              if (this._vf.indexedRendering) {
                var sum = 0;
                for (var i = 0; i < this._vf.originalVertexCount.length; ++i) {
                    sum += this._vf.originalVertexCount[i];
                }
                return sum;
              }
              else  {
                return 0;
              }              
            },
            
            getVertexCount: function() {
                var sum = 0;
                for (var i = 0; i < this._vf.originalVertexCount.length; ++i) {
                    sum += this._vf.originalVertexCount[i];
                }
                return sum;
            },
            
            //adapts the vertex count according to the given total number of indices / vertices
            //which is used by the renderer
            adaptVertexCount: function(numVerts) {
                var verts = 0;
                for (var i = 0; i < this._vf.originalVertexCount.length; ++i) {
                    if ((this._vf.originalVertexCount[i] + verts) <= numVerts) {
                        this._vf.vertexCount[i] = this._vf.originalVertexCount[i];
                        verts += this._vf.originalVertexCount[i];
                    }
                    else {
                        this._vf.vertexCount[i] = numVerts - verts;
                        break;
                    }                    
                }
            },
            
            hasNormal: function() {
              return (this._vf.normalOffset != 0) && !this._vf.sphericalNormals;
            },
            
            hasTexCoord: function() {
              return (this._vf.texcoordOffset != 0);
            },
            
            hasColor: function() {
              return (this._vf.colorOffset != 0);
            },
            
            getPositionPrecision : function() {
              return this._vf.positionPrecision;
            },
            
            getNormalPrecision : function() {
              return this._vf.normalPrecision;
            },
            
            getTexCoordPrecision : function() {
              return this._vf.texcoordPrecision;
            },
            
            getColorPrecision : function() {
              return this._vf.colorPrecision;
            },
            
            getAttributeStride : function() {
              return this._vf.attributeStride;
            },
            
            getPositionOffset : function() {
              return this._vf.positionOffset;
            },
            
            getNormalOffset : function() {
              return this._vf.normalOffset;
            },
            
            getTexCoordOffset : function() {
              return this._vf.texcoordOffset;
            },
            
            getColorOffset : function() {
              return this._vf.colorOffset;
            },
            
            getBufferTypeStringFromByteCount: function(bytes) {
                switch(bytes)
                {
                    case 1:
                        return "Uint8";
                    case 2:
                        return "Uint16";              
                    //case 4: //currently not supported by PopGeometry
                    //    return "Float32";
                    default:
                        return 0;
                }
            },            
            
            getDataURLs : function() {
              var urls = [];
                                  
              for (var i = 0; i < this._cf.levels.nodes.length; ++i) {
                urls.push(this._cf.levels.nodes[i].getSrc());                          
              }
              
              return urls;
            },
            
            getNumIndicesByLevel : function(lvl) {
              return this._cf.levels.nodes[lvl].getNumIndices();
            },
            
            getNumLevels : function(lvl) {
              return this._cf.levels.nodes.length;
            },
            
            getVertexDataBufferOffset : function(lvl) {
              return this._cf.levels.nodes[lvl].getVertexDataBufferOffset();
            },
            
            getPrecisionMax: function(type) {
              switch(this._vf[type])
              {
                  //currently, only Uint8 and Uint16 are supported
                  //case "Int8":
                  //    return 127.0;
                  case "Uint8":
                      return 255.0;
                  //case "Int16":
                  //    return 32767.0;
                  case "Uint16":
                      return 65535.0;
                  //case "Int32":
                     //return 2147483647.0;
                  //case "Uint32":
                     //return 4294967295.0;
                  //case "Float32":
                  //case "Float64":
                  default:
                      return 1.0;
              }
            }
        }
    )
);

/** Static class members (needed for stats) */
x3dom.nodeTypes.PopGeometry.ErrorToleranceFactor  = 1;
x3dom.nodeTypes.PopGeometry.PrecisionFactorOnMove = 1;
x3dom.nodeTypes.PopGeometry.numRenderedVerts      = 0;
x3dom.nodeTypes.PopGeometry.numRenderedTris       = 0;
x3dom.nodeTypes.PopGeometry.numTotalVerts         = 0;
x3dom.nodeTypes.PopGeometry.numTotalTris          = 0;

/** Static LUT for LOD computation */
x3dom.nodeTypes.PopGeometry.powLUT = [32768, 16384, 8192, 4096, 2048, 1024, 512, 256,
                                        128,    64,   32,   16,   8,    4,    2,   1];


/* ### BitLODGeoComponent ### */
x3dom.registerNodeType(
    "BitLODGeoComponent",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DGeometricPropertyNode,
        function (ctx) {
            x3dom.nodeTypes.BitLODGeoComponent.superClass.call(this, ctx);
			
			this.addField_SFString(ctx, 'src', "");
			this.addField_MFInt32(ctx, 'format', []);
			this.addField_MFString(ctx, 'attrib', []);
			
			this._attribShift = [];
			this._attribShiftDec = [];
			this._mask = [];
			
			this._bitsPerComponent = 0;
		},
		{
			nodeChanged: function()
            {		
				//Get Bits per component
				for(var f=0; f<this._vf.format.length; f++) {
					this._bitsPerComponent += this._vf.format[f];
				}
			},
			
			getSrc: function()
			{
				return this._vf.src;
			},
			
			getFormat: function()
			{
				return this._vf.format;
			},
			
			getAttrib: function(idx)
			{
				return this._vf.attrib[idx];
			},
			
			getNumAttribs: function()
			{
				return this._vf.attrib.length;
			}
		}
	)
);

/* ### BitLODGeometry ### */
x3dom.registerNodeType(
    "BitLODGeometry",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DBinaryContainerGeometryNode,
        function (ctx) {	
            x3dom.nodeTypes.BitLODGeometry.superClass.call(this, ctx);

			this.addField_SFString(ctx, 'index', "");   // Uint16
            this.addField_SFBool(ctx, 'usesVLCIndices', false);  // variable-length coding
            this.addField_SFBool(ctx, 'clientSideNormals', false);  // variable-length coding            
            this.addField_SFBool(ctx, 'normalAsSphericalCoordinates', false);
            this.addField_SFBool(ctx, 'normalPerVertex', true);
			this.addField_MFNode('components', x3dom.nodeTypes.BitLODGeoComponent);

			// Typed Array View Types
            // Int8, Uint8, Int16, Uint16, Int32, Uint32, Float32, Float64
            //this.addField_SFString(ctx, 'indexType', "Uint16");
            this.addField_SFString(ctx, 'coordType', "Uint16");
            this.addField_SFString(ctx, 'normalType', "Uint16");
            this.addField_SFString(ctx, 'texCoordType', "Uint16");
            this.addField_SFString(ctx, 'colorType', "Uint16");
            //this.addField_SFString(ctx, 'tangentType', "Float32");
            //this.addField_SFString(ctx, 'binormalType', "Float32");

			// workaround
			this._hasStrideOffset = false;
			this._mesh._numTexComponents = 2;
			this._mesh._numColComponents = 3;

            this._vf.clientSideNormals            = false;
            this._vf.normalPerVertex              = !this._vf.clientSideNormals;
            this._vf.normalAsSphericalCoordinates = this._vf.normalPerVertex;
			this._mesh._numNormComponents         = this._vf.normalAsSphericalCoordinates ? 2 : 3;
		},
		{
		    parentAdded: function(parent)
		    {
			  parent._coordStrideOffset    = [12, 0];
			  parent._normalStrideOffset   = [12, 8];
			  parent._texCoordStrideOffset = [ 4, 0];
			  parent._colorStrideOffset    = [ 6, 0];
		    },
			
			// ATTENTION: the following accessor methods are NOT shared 
			// by all Geometry nodes, so be careful when using them!!!
			hasIndex: function()
			{
				return (this._vf.index.length) ? true : false;
			},

            usesVLCIndices: function()
			{
				return this._vf.usesVLCIndices == true;
			},
            
            usesClientSideNormals: function()
			{
                return this._vf.clientSideNormals == true;
            },
			
			hasColor: function()
			{
				for(var i=0; i<this.getNumComponents(); i++) {
					for(var j=0; j<this.getComponent(i).getNumAttribs(); j++) {
						if(this.getComponent(i).getAttrib(j) == "color3")
						    return true;
					}
				}
				return false;
			},
			
			hasTexCoord: function()
			{
				for(var i=0; i<this.getNumComponents(); i++) {
					for(var j=0; j<this.getComponent(i).getNumAttribs(); j++) {
						if(this.getComponent(i).getAttrib(j) == "texcoord2")
						    return true;
					}
				}
				return false;
			},
			
			getCoordNormalURLs: function() {
				var coordNormalURLs = [];
				for(var i=0; i<this.getNumComponents(); i++) {
					for(var j=0; j<this.getComponent(i).getNumAttribs(); j++) {
						if(this.getComponent(i).getAttrib(j) == "coord3") {
							coordNormalURLs.push(this.getComponent(i).getSrc());
						}
					}
				}
				return coordNormalURLs;
			},
			
			getTexCoordURLs: function() {
				var texCoordURLs = [];
				for(var i=0; i<this.getNumComponents(); i++) {
					for(var j=0; j<this.getComponent(i).getNumAttribs(); j++) {
						if(this.getComponent(i).getAttrib(j) == "texcoord2") {
							texCoordURLs.push(this.getComponent(i).getSrc());
						}
					}
				}
				return texCoordURLs;
			},
			
			getColorURLs: function() {
				var colorURLs = [];
				for(var i=0; i<this.getNumComponents(); i++) {
					for(var j=0; j<this.getComponent(i).getNumAttribs(); j++) {
						if(this.getComponent(i).getAttrib(j) == "color3") {
							colorURLs.push(this.getComponent(i).getSrc());
						}
					}
				}
				return colorURLs;
			},
			
			getNumPrimTypes: function()
			{
				return this._vf.primType.length;
			},
			
			getPrimType: function(idx)
			{
				if( idx < this.getNumPrimTypes() )
					return this._vf.primType[idx].toUpperCase();
                return "";
			},
			
			getNumVertexCounts: function()
			{
				return this._vf.vertexCount.length;
			},
			
			getVertexCount: function(idx)
			{
				if( idx < this.getNumVertexCounts() ) 
					return this._vf.vertexCount[idx];
                return 0;
			},
			
			setVertexCount: function(idx, value)
			{
				this._vf.vertexCount[idx] = value;
			},
			
			getNumComponents: function()
			{
				return this._cf.components.nodes.length;
			},
			
			getComponent: function(idx)
			{
				return this._cf.components.nodes[idx];
			},
			
			getComponentsURLs: function()
			{
				var URLs = [];
				
				for(var c=0; c<this._cf.components.nodes.length; c++)
					URLs[c] = this._cf.components.nodes[c].getSrc();
					
				return URLs;
			},
			
			getComponentFormats: function()
			{
				var formats = [];
				
				for(var c=0; c<this._cf.components.nodes.length; c++)
					formats[c] = this._cf.components.nodes[c]._vf.format;
					
				return formats;
			},
			
			getComponentAttribs: function()
			{
				var attribs = [];
				
				for(var c=0; c<this._cf.components.nodes.length; c++)
					attribs[c] = this._cf.components.nodes[c]._vf.attrib;
					
				return attribs;
			},
			
			getNumVertices: function()
			{
				var count = 0;
				for(var i=0; i<this._vf.vertexCount.length; i++) {
					count += this._vf.vertexCount[i];
				}
				
				return count;
			},

			getAttribType: function(bits)
			{
    			switch(bits)
                {
                    case 8:
                        return "Uint8";
                    case 16:
                        return "Uint16";
                    case 32:
                        return "Float32";
                    default:
                        return 0;
                }
			},
			
			getPrecisionMax: function(type)
			{                   
    			switch(this._vf[type])
                {                
                    case "Int8":
                        return 127.0;
                    case "Uint8":
                        return 255.0 - (Math.pow(2.0, 8.0 - this.loadedLevels) - 1.0);
                    case "Int16":
                        return 32767.0;
                    case "Uint16":
                        if (type === 'normalType')
                            return 65535.0 - (Math.pow(2.0, 16.0 - this.loadedLevels) - 1.0);
                        else
                            return 65535.0 - (Math.pow(2.0, 16.0 - this.loadedLevels*2.0) - 1.0);
                    case "Int32":
                        return 2147483647.0;
                    case "Uint32":
                        return 4294967295.0;
                    case "Float32":
                    case "Float64":
                    default:
                        return 1.0;
                }
			}
		}
	)
);


/* ### ImageGeometry ### */
x3dom.registerNodeType(
    "ImageGeometry",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DBinaryContainerGeometryNode,
        function (ctx) {	
            x3dom.nodeTypes.ImageGeometry.superClass.call(this, ctx);

			this.addField_SFVec2f(ctx, 'implicitMeshSize', 256, 256);
			this.addField_SFInt32(ctx, 'numColorComponents', 3);
            this.addField_SFInt32(ctx, 'numTexCoordComponents', 2);

			this.addField_SFNode('index', x3dom.nodeTypes.X3DTextureNode);
			this.addField_MFNode('coord', x3dom.nodeTypes.X3DTextureNode);
			this.addField_SFNode('normal', x3dom.nodeTypes.X3DTextureNode);
			this.addField_SFNode('texCoord', x3dom.nodeTypes.X3DTextureNode);
			this.addField_SFNode('color', x3dom.nodeTypes.X3DTextureNode);
			
			this._mesh._numColComponents = this._vf.numColorComponents;
			this._mesh._numTexComponents = this._vf.numTexCoordComponents;
			
			if (this._vf.implicitMeshSize.y == 0)
			    this._vf.implicitMeshSize.y = this._vf.implicitMeshSize.x;
			
			//TODO check if GPU-Version is supported (Flash, etc.)
			//Dummy mesh generation only needed for GPU-Version
			if (x3dom.caps.BACKEND == 'webgl' && x3dom.caps.MAX_VERTEX_TEXTURE_IMAGE_UNITS > 0) {

				var geoCacheID = 'ImageGeometry_' + this._vf.implicitMeshSize.x + '_' + this._vf.implicitMeshSize.y;

				if( this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined )
				{
					//x3dom.debug.logInfo("Using ImageGeometry-Mesh from Cache");
					this._mesh = x3dom.geoCache[geoCacheID];
				}
				else
				{
					for(var y=0; y<this._vf.implicitMeshSize.y; y++)
					{
						for(var x=0; x<this._vf.implicitMeshSize.x; x++)
						{
							this._mesh._positions[0].push(x / this._vf.implicitMeshSize.x,
                                                          y / this._vf.implicitMeshSize.y, 0);
						}
					}
					
					//this._mesh._invalidate = true;
					this._mesh._numFaces = this._mesh._indices[0].length / 3;
					this._mesh._numCoords = this._mesh._positions[0].length / 3;

					x3dom.geoCache[geoCacheID] = this._mesh;
				}
			}

            // needed because mesh is shared due to cache
            this._vol = new x3dom.fields.BoxVolume();

            this._dirty = {
                coord: true,
                normal: true,
                texCoord: true,
                color: true,
                index: true
            };
		},
		{
            setGeoDirty: function () {
                this._dirty.coord = true;
                this._dirty.normal = true;
                this._dirty.texCoords = true;
                this._dirty.color = true;
                this._dirty.index = true;
            },

            unsetGeoDirty: function () {
                this._dirty.coord = false;
                this._dirty.normal = false;
                this._dirty.texCoords = false;
                this._dirty.color = false;
                this._dirty.index = false;
            },

			nodeChanged: function()
            {		
				Array.forEach(this._parentNodes, function (node) {
                    node._dirty.positions = true;
					node._dirty.normals = true;
					node._dirty.texcoords = true;
                    node._dirty.colors = true;
				});
                this._vol.invalidate();
			},

            fieldChanged: function(fieldName)
            {
                if (fieldName == "index" ||fieldName == "coord" || fieldName == "normal" ||
                    fieldName == "texCoord" || fieldName == "color") {
                    this._dirty[fieldName] = true;
                    this._vol.invalidate();
                }
                else if (fieldName == "implicitMeshSize") {
                    this._vol.invalidate();
                }
            },

            getMin: function() {
                var vol = this._vol;

                if (!vol.isValid()) {
                    vol.setBoundsByCenterSize(this._vf.position, this._vf.size);
                }

                return vol.min;
            },

            getMax: function() {
                var vol = this._vol;

                if (!vol.isValid()) {
                    vol.setBoundsByCenterSize(this._vf.position, this._vf.size);
                }

                return vol.max;
            },

            getVolume: function() {
                var vol = this._vol;

                if (!vol.isValid()) {
                    vol.setBoundsByCenterSize(this._vf.position, this._vf.size);
                }

                return vol;
            },
			
			numCoordinateTextures: function()
			{
				return this._cf.coord.nodes.length;
			},
			
			getIndexTexture: function()
            {
                if(this._cf.index.node) {
					this._cf.index.node._type = "IG_index";
                    return this._cf.index.node;
                } else {
                    return null;
                }
            },
			
			getIndexTextureURL: function()
            {
                if(this._cf.index.node) {
                    return this._cf.index.node._vf.url;
                } else {
                    return null;
                }
            },
			
			getCoordinateTexture: function(pos)
            {
                if(this._cf.coord.nodes[pos]) {
					this._cf.coord.nodes[pos]._type = "IG_coords" + pos;
                    return this._cf.coord.nodes[pos];
                } else {
                    return null;
                }
            },
			
			getCoordinateTextureURL: function(pos)
            {
                if(this._cf.coord.nodes[pos]) {
                    return this._cf.coord.nodes[pos]._vf.url;
                } else {
                    return null;
                }
            },
			
			getCoordinateTextureURLs: function()
            {
                var urls = [];
				for(var i=0; i<this._cf.coord.nodes.length; i++)
				{
					urls.push(this._cf.coord.nodes[i]._vf.url);
				}
                return urls;
            },

            getNormalTexture: function()
            {
                if(this._cf.normal.node) {
					this._cf.normal.node._type = "IG_normals";
                    return this._cf.normal.node;
                } else {
                    return null;
                }
            },
			
			getNormalTextureURL: function()
            {
                if(this._cf.normal.node) {
                    return this._cf.normal.node._vf.url;
                } else {
                    return null;
                }
            },

            getTexCoordTexture: function()
            {
                if(this._cf.texCoord.node) {
					this._cf.texCoord.node._type = "IG_texCoords";
                    return this._cf.texCoord.node;
                } else {
                    return null;
                }
            },
			
			getTexCoordTextureURL: function()
            {
                if(this._cf.texCoord.node) {
                    return this._cf.texCoord.node._vf.url;
                } else {
                    return null;
                }
            },
			
			getColorTexture: function()
            {
                if(this._cf.color.node) {
					this._cf.color.node._type = "IG_colors";
                    return this._cf.color.node;
                } else {
                    return null;
                }
            },
			
			getColorTextureURL: function()
            {
                if(this._cf.color.node) {
                    return this._cf.color.node._vf.url;
                } else {
                    return null;
                }
			},
			
			getTextures: function()
			{
				var textures = [];
				
				var index = this.getIndexTexture();
				if(index) textures.push(index);
				
				for(i=0; i<this.numCoordinateTextures(); i++) {
					var coord = this.getCoordinateTexture(i);
					if(coord) textures.push(coord);
				}
				
				var normal = this.getNormalTexture();
				if(normal) textures.push(normal);
				
				var texCoord = this.getTexCoordTexture();
				if(texCoord) textures.push(texCoord);
				
				var color = this.getColorTexture();
				if(color) textures.push(color);
				
				return textures;
			}
		}
	)
);


/* ### IndexedFaceSet ### */
x3dom.registerNodeType(
    "IndexedFaceSet",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DComposedGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.IndexedFaceSet.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'creaseAngle', 0);   // TODO
            this.addField_SFBool(ctx, 'convex', true);

            this.addField_MFInt32(ctx, 'coordIndex', []);
            this.addField_MFInt32(ctx, 'normalIndex', []);
            this.addField_MFInt32(ctx, 'colorIndex', []);
            this.addField_MFInt32(ctx, 'texCoordIndex', []);
        },
        {
            nodeChanged: function()
            {
                var time0 = new Date().getTime();

                this.handleAttribs();

                var indexes = this._vf.coordIndex;
                
                if (indexes.length && indexes[indexes.length-1] != -1)
                {
                    indexes.push(-1);
                    x3dom.debug.logWarning('Last index value should be -1.');
                }
                
                var normalInd = this._vf.normalIndex;
                var texCoordInd = this._vf.texCoordIndex;
                var colorInd = this._vf.colorIndex;

                var hasNormal = false, hasNormalInd = false;
                var hasTexCoord = false, hasTexCoordInd = false;
                var hasColor = false, hasColorInd = false;

                var colPerVert = this._vf.colorPerVertex;
                var normPerVert = this._vf.normalPerVertex;

                if (normalInd.length > 0)
                {
                    hasNormalInd = true;
                }
                if (texCoordInd.length > 0)
                {
                    hasTexCoordInd = true;
                }
                if (colorInd.length > 0)
                {
                    hasColorInd = true;
                }

                var positions, normals, texCoords, colors;

                var coordNode = this._cf.coord.node;
                x3dom.debug.assert(coordNode);
                positions = coordNode.getPoints();

                var normalNode = this._cf.normal.node;
                if (normalNode)
                {
                    hasNormal = true;
                    normals = normalNode._vf.vector;
                }
                else {
                    hasNormal = false;
                }

                var texMode = "", numTexComponents = 2;
                var texCoordNode = this._cf.texCoord.node;
                if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                    if (texCoordNode._cf.texCoord.nodes.length)
                        texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                }
                if (texCoordNode)
                {
                    if (texCoordNode._vf.point) {
                        hasTexCoord = true;
                        texCoords = texCoordNode._vf.point;

                        if (x3dom.isa(texCoordNode, x3dom.nodeTypes.TextureCoordinate3D)) {
                            numTexComponents = 3;
                        }
                    }
                    else if (texCoordNode._vf.mode) {
                        texMode = texCoordNode._vf.mode;
                    }
                }
                else {
                    hasTexCoord = false;
                }
                this._mesh._numTexComponents = numTexComponents;

                var numColComponents = 3;
                var colorNode = this._cf.color.node;
                if (colorNode)
                {
                    hasColor = true;
                    colors = colorNode._vf.color;

                    if (x3dom.isa(colorNode, x3dom.nodeTypes.ColorRGBA)) {
                        numColComponents = 4;
                    }
                }
                else {
                    hasColor = false;
                }
                this._mesh._numColComponents = numColComponents;

                this._mesh._indices[0] = [];
                this._mesh._positions[0] = [];
                this._mesh._normals[0] = [];
                this._mesh._texCoords[0] = [];
                this._mesh._colors[0] = [];
                
                var i, j, t, cnt, faceCnt;
                var p0, p1, p2, n0, n1, n2, t0, t1, t2, c0, c1, c2;

                if ( (this._vf.creaseAngle <= x3dom.fields.Eps) ||  // FIXME; what to do for ipols?
                     (positions.length > x3dom.Utils.maxIndexableCoords) ||
                     (hasNormal && hasNormalInd) ||
                     (hasTexCoord && hasTexCoordInd) ||
                     (hasColor && hasColorInd) )
                {
                    if (this._vf.creaseAngle <= x3dom.fields.Eps)
                        x3dom.debug.logWarning('Fallback to inefficient multi-index mode since creaseAngle=0.');
                    
                    // Found MultiIndex Mesh
					if(this._vf.convex) {
						t = 0;
						cnt = 0;
						faceCnt = 0;
						this._mesh._multiIndIndices = [];
						this._mesh._posSize = positions.length;
						
						for (i=0; i < indexes.length; ++i)
						{
							// Convert non-triangular polygons to a triangle fan
							// (TODO: this assumes polygons are convex)
							if (indexes[i] == -1) {
								t = 0;
								faceCnt++;
								continue;
							}
	
							if (hasNormalInd) {
								x3dom.debug.assert(normalInd[i] != -1);
							}
							if (hasTexCoordInd) {
								x3dom.debug.assert(texCoordInd[i] != -1);
							}
							if (hasColorInd) {
								x3dom.debug.assert(colorInd[i] != -1);
							}
	
							//TODO: OPTIMIZE but think about cache coherence regarding arrays!!!
							switch (t)
							{
								case 0:
									p0 = +indexes[i];
									if (hasNormalInd && normPerVert) { n0 = +normalInd[i]; }
									else if (hasNormalInd && !normPerVert) { n0 = +normalInd[faceCnt]; }
									else if (normPerVert) { n0 = p0; }
									else { n0 = faceCnt; }

									if (hasTexCoordInd) { t0 = +texCoordInd[i]; }
									else { t0 = p0; }
									if (hasColorInd && colPerVert) { c0 = +colorInd[i]; }
									else if (hasColorInd && !colPerVert) { c0 = +colorInd[faceCnt]; }
									else if (colPerVert) { c0 = p0; }
									else { c0 = faceCnt; }
									t = 1;
								break;
								case 1:
									p1 = +indexes[i];
									if (hasNormalInd && normPerVert) { n1 = +normalInd[i]; }
									else if (hasNormalInd && !normPerVert) { n1 = +normalInd[faceCnt]; }
									else if (normPerVert) { n1 = p1; }
									else { n1 = faceCnt; }

									if (hasTexCoordInd) { t1 = +texCoordInd[i]; }
									else { t1 = p1; }
									if (hasColorInd && colPerVert) { c1 = +colorInd[i]; }
									else if (hasColorInd && !colPerVert) { c1 = +colorInd[faceCnt]; }
									else if (colPerVert) { c1 = p1; }
									else { c1 = faceCnt; }
									t = 2;
								break;
								case 2:
									p2 = +indexes[i];
									if (hasNormalInd && normPerVert) { n2 = +normalInd[i]; }
									else if (hasNormalInd && !normPerVert) { n2 = +normalInd[faceCnt]; }
									else if (normPerVert) { n2 = p2; }
									else { n2 = faceCnt; }

									if (hasTexCoordInd) { t2 = +texCoordInd[i]; }
									else { t2 = p2; }
									if (hasColorInd && colPerVert) { c2 = +colorInd[i]; }
									else if (hasColorInd && !colPerVert) { c2 = +colorInd[faceCnt]; }
									else if (colPerVert) { c2 = p2; }
									else { c2 = faceCnt; }
									t = 3;

									//this._mesh._indices[0].push(cnt++, cnt++, cnt++);
	
									this._mesh._positions[0].push(positions[p0].x);
									this._mesh._positions[0].push(positions[p0].y);
									this._mesh._positions[0].push(positions[p0].z);
									this._mesh._positions[0].push(positions[p1].x);
									this._mesh._positions[0].push(positions[p1].y);
									this._mesh._positions[0].push(positions[p1].z);
									this._mesh._positions[0].push(positions[p2].x);
									this._mesh._positions[0].push(positions[p2].y);
									this._mesh._positions[0].push(positions[p2].z);
	
									if (hasNormal) {
										this._mesh._normals[0].push(normals[n0].x);
										this._mesh._normals[0].push(normals[n0].y);
										this._mesh._normals[0].push(normals[n0].z);
										this._mesh._normals[0].push(normals[n1].x);
										this._mesh._normals[0].push(normals[n1].y);
										this._mesh._normals[0].push(normals[n1].z);
										this._mesh._normals[0].push(normals[n2].x);
										this._mesh._normals[0].push(normals[n2].y);
										this._mesh._normals[0].push(normals[n2].z);
									}
									//else {
										this._mesh._multiIndIndices.push(p0, p1, p2);
										//this._mesh._multiIndIndices.push(cnt-3, cnt-2, cnt-1);
									//}
	
									if (hasColor) {
										this._mesh._colors[0].push(colors[c0].r);
										this._mesh._colors[0].push(colors[c0].g);
										this._mesh._colors[0].push(colors[c0].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c0].a);
										}
										this._mesh._colors[0].push(colors[c1].r);
										this._mesh._colors[0].push(colors[c1].g);
										this._mesh._colors[0].push(colors[c1].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c1].a);
										}
										this._mesh._colors[0].push(colors[c2].r);
										this._mesh._colors[0].push(colors[c2].g);
										this._mesh._colors[0].push(colors[c2].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c2].a);
										}
									}
	
									if (hasTexCoord) {
										this._mesh._texCoords[0].push(texCoords[t0].x);
										this._mesh._texCoords[0].push(texCoords[t0].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t0].z);
										}
										this._mesh._texCoords[0].push(texCoords[t1].x);
										this._mesh._texCoords[0].push(texCoords[t1].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t1].z);
										}
										this._mesh._texCoords[0].push(texCoords[t2].x);
										this._mesh._texCoords[0].push(texCoords[t2].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t2].z);
										}
									}
	
									//faceCnt++;
								break;
								case 3:
									p1 = p2;
									t1 = t2;
									if (normPerVert) {
										n1 = n2;
									}
									if (colPerVert) {
										c1 = c2;
									}
									p2 = +indexes[i];
	
									if (hasNormalInd && normPerVert) {
										n2 = +normalInd[i];
									} else if (hasNormalInd && !normPerVert) {
										/*n2 = +normalInd[faceCnt];*/
									} else if (normPerVert) {
										n2 = p2;
									} else {
										n2 = faceCnt;
									}
	
									if (hasTexCoordInd) {
										t2 = +texCoordInd[i];
									} else {
										t2 = p2;
									}
	
									if (hasColorInd && colPerVert) {
										c2 = +colorInd[i];
									} else if (hasColorInd && !colPerVert) {
										/*c2 = +colorInd[faceCnt];*/
									} else if (colPerVert) {
										c2 = p2;
									} else {
										c2 = faceCnt;
									}

									//this._mesh._indices[0].push(cnt++, cnt++, cnt++);
	
									this._mesh._positions[0].push(positions[p0].x);
									this._mesh._positions[0].push(positions[p0].y);
									this._mesh._positions[0].push(positions[p0].z);
									this._mesh._positions[0].push(positions[p1].x);
									this._mesh._positions[0].push(positions[p1].y);
									this._mesh._positions[0].push(positions[p1].z);
									this._mesh._positions[0].push(positions[p2].x);
									this._mesh._positions[0].push(positions[p2].y);
									this._mesh._positions[0].push(positions[p2].z);
	
									if (hasNormal) {
										this._mesh._normals[0].push(normals[n0].x);
										this._mesh._normals[0].push(normals[n0].y);
										this._mesh._normals[0].push(normals[n0].z);
										this._mesh._normals[0].push(normals[n1].x);
										this._mesh._normals[0].push(normals[n1].y);
										this._mesh._normals[0].push(normals[n1].z);
										this._mesh._normals[0].push(normals[n2].x);
										this._mesh._normals[0].push(normals[n2].y);
										this._mesh._normals[0].push(normals[n2].z);
									}
									//else {
										this._mesh._multiIndIndices.push(p0, p1, p2);
										//this._mesh._multiIndIndices.push(cnt-3, cnt-2, cnt-1);
									//}
	
									if (hasColor) {
										this._mesh._colors[0].push(colors[c0].r);
										this._mesh._colors[0].push(colors[c0].g);
										this._mesh._colors[0].push(colors[c0].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c0].a);
										}
										this._mesh._colors[0].push(colors[c1].r);
										this._mesh._colors[0].push(colors[c1].g);
										this._mesh._colors[0].push(colors[c1].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c1].a);
										}
										this._mesh._colors[0].push(colors[c2].r);
										this._mesh._colors[0].push(colors[c2].g);
										this._mesh._colors[0].push(colors[c2].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c2].a);
										}
									}
	
									if (hasTexCoord) {
										this._mesh._texCoords[0].push(texCoords[t0].x);
										this._mesh._texCoords[0].push(texCoords[t0].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t0].z);
										}
										this._mesh._texCoords[0].push(texCoords[t1].x);
										this._mesh._texCoords[0].push(texCoords[t1].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t1].z);
										}
										this._mesh._texCoords[0].push(texCoords[t2].x);
										this._mesh._texCoords[0].push(texCoords[t2].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t2].z);
										}
									}
	
									//faceCnt++;
								break;
								default:
							}
						}
					}
					else {
						var linklist = new x3dom.DoublyLinkedList();
						var data = {};
						cnt = 0; faceCnt = 0;
												
						for (i = 0; i < indexes.length; ++i)
						{	
							if (indexes[i] == -1) {
								var multi_index_data = x3dom.EarClipping.getMultiIndexes(linklist);
								
								for (j = 0; j < multi_index_data.indices.length; j++)
								{
									this._mesh._indices[0].push(cnt);
									cnt++;
									
									this._mesh._positions[0].push(multi_index_data.point[j].x,
																  multi_index_data.point[j].y,
																  multi_index_data.point[j].z);
									if (hasNormal) { 
										this._mesh._normals[0].push(multi_index_data.normals[j].x,
																	multi_index_data.normals[j].y,
																	multi_index_data.normals[j].z);
									}
									if (hasColor) { 
										this._mesh._colors[0].push(multi_index_data.colors[j].r, 
																   multi_index_data.colors[j].g, 
																   multi_index_data.colors[j].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(multi_index_data.colors[j].a);
										}
									} 
									if (hasTexCoord) {	
										this._mesh._texCoords[0].push(multi_index_data.texCoords[j].x,
																	  multi_index_data.texCoords[j].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(multi_index_data.texCoords[j].z);
										}
									}
								}
									
								linklist = new x3dom.DoublyLinkedList();
								faceCnt++;
								continue;
							}
										
							if (hasNormal) {
								if (hasNormalInd && normPerVert) {
									data.normals =  normals[normalInd[i]];	
								} else if (hasNormalInd && !normPerVert) {
									data.normals =  normals[normalInd[faceCnt]];
								} else {
									data.normals =  normals[indexes[i]];
								}		
							}
							
							if (hasColor) {
								if (hasColorInd && colPerVert) {
									data.colors =  colors[colorInd[i]];
								} else if (hasColorInd && !colPerVert) {
									data.colors =  colors[colorInd[faceCnt]];
								} else if (colPerVert) {
									data.colors =  colors[indexes[i]];
								} else {
									data.colors =  colors[faceCnt];
								}
							}
							if (hasTexCoord) {
								if (hasTexCoordInd) {
									data.texCoords =  texCoords[texCoordInd[i]];
								} else {
									data.texCoords =  texCoords[indexes[i]];
								}			
							}
							
							linklist.appendNode(new x3dom.DoublyLinkedList.ListNode(
							    positions[indexes[i]], indexes[i], data.normals, data.colors, data.texCoords));						
						}

                        this._mesh.splitMesh();
					}
					
					if (!hasNormal) {
						this._mesh.calcNormals(this._vf.creaseAngle, this._vf.ccw);
					}
					if (!hasTexCoord) {
						this._mesh.calcTexCoords(texMode);
					}
                } // if isMulti
                else
                {
                    t = 0;
                    if (this._vf.convex) {
						for (i = 0; i < indexes.length; ++i)
						{
							// Convert non-triangular polygons to a triangle fan
							if (indexes[i] == -1) {
								t = 0;
								continue;
							}
							
							switch (t) {
							case 0: n0 = +indexes[i]; t = 1; break;
							case 1: n1 = +indexes[i]; t = 2; break;
							case 2: n2 = +indexes[i]; t = 3; this._mesh._indices[0].push(n0, n1, n2); break;
							case 3: n1 = n2; n2 = +indexes[i]; this._mesh._indices[0].push(n0, n1, n2); break;
							}

						}
					}
                    else {
						//  Convert non-triangular convex polygons to a triangle fan					
						linklist = new x3dom.DoublyLinkedList();
						for (i = 0; i < indexes.length; ++i)
						{
							if (indexes[i] == -1) {
								var linklist_indices = x3dom.EarClipping.getIndexes(linklist);

								for (j = 0; j < linklist_indices.length; j++) {
									this._mesh._indices[0].push(linklist_indices[j]);
								}
								linklist = new x3dom.DoublyLinkedList();
							    continue;
							}

							linklist.appendNode(new x3dom.DoublyLinkedList.ListNode(positions[indexes[i]], indexes[i]));
						}
					}
                   
                    this._mesh._positions[0] = positions.toGL();
	
                    if (hasNormal) {
                        this._mesh._normals[0] = normals.toGL();
                    }
                    else {
                        this._mesh.calcNormals(this._vf.creaseAngle, this._vf.ccw);
                    }
                    if (hasTexCoord) {
                        this._mesh._texCoords[0] = texCoords.toGL();
                        this._mesh._numTexComponents = numTexComponents;
                    }
                    else {
                        this._mesh.calcTexCoords(texMode);
                    }
                    if (hasColor) {
                        this._mesh._colors[0] = colors.toGL();
                        this._mesh._numColComponents = numColComponents;
                    }
                }

                this.invalidateVolume();

                this._mesh._numFaces = 0;
                this._mesh._numCoords = 0;

                for (i=0; i<this._mesh._positions.length; i++) {
                    var indexLength = this._mesh._indices[i].length;
                    var numCoords = this._mesh._positions[i].length / 3;
                    this._mesh._numCoords += numCoords;
                    if (indexLength > 0)
                        this._mesh._numFaces += indexLength / 3;
                    else
                        this._mesh._numFaces += numCoords / 3;
                }

                //var time1 = new Date().getTime() - time0;
                //x3dom.debug.logInfo("Mesh load time: " + time1 + " ms");
            },

            fieldChanged: function(fieldName)
            {
                if (fieldName != "coord" && fieldName != "normal" &&
    				fieldName != "texCoord" && fieldName != "color" &&
                    fieldName != "coordIndex")
    			{
    			    x3dom.debug.logWarning("IndexedFaceSet: fieldChanged for " +
    			                           fieldName + " not yet implemented!");
    			    return;
    			}
                
                var pnts = this._cf.coord.node._vf.point;
                var n = pnts.length;
                
                var texCoordNode = this._cf.texCoord.node;
                if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                    if (texCoordNode._cf.texCoord.nodes.length)
                        texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                }

                if (((this._vf.creaseAngle <= x3dom.fields.Eps) || (n > x3dom.Utils.maxIndexableCoords) ||
                     (this._vf.normalIndex.length > 0 && this._cf.normal.node) ||
                     (this._vf.texCoordIndex.length > 0 && texCoordNode) ||
                     (this._vf.colorIndex.length > 0 && this._cf.color.node)) && this._mesh._multiIndIndices)
                {
                    var needNormals = !this._cf.normal.node && this._vf.normalUpdateMode.toLowerCase() != 'none';

                    n = this._mesh._multiIndIndices.length;

                    this._mesh._positions[0] = [];
                    this._mesh._indices[0] =[];

                    // special coordinate interpolator handler
                    if (fieldName == "coord" && n)
                    {
                        if (needNormals) {
                            this._mesh._normals[0] = [];
                        }

                        for (i=0; i<n; i+=3) {
                            var ind0 = this._mesh._multiIndIndices[i  ];
                            var ind1 = this._mesh._multiIndIndices[i+1];
                            var ind2 = this._mesh._multiIndIndices[i+2];

                            var pos0 = pnts[ind0];
                            var pos1 = pnts[ind1];
                            var pos2 = pnts[ind2];

                            this._mesh._positions[0].push(pos0.x, pos0.y, pos0.z);
                            this._mesh._positions[0].push(pos1.x, pos1.y, pos1.z);
                            this._mesh._positions[0].push(pos2.x, pos2.y, pos2.z);

                            if (needNormals) {
                                var a = pos0.subtract(pos1);
                                var b = pos1.subtract(pos2);

                                var norm = a.cross(b).normalize();
                                if (!this._vf.ccw)
                                    norm = norm.negate();

                                this._mesh._normals[0].push(norm.x, norm.y, norm.z);
                                this._mesh._normals[0].push(norm.x, norm.y, norm.z);
                                this._mesh._normals[0].push(norm.x, norm.y, norm.z);
                            }
                        }

                        this.invalidateVolume();

                        Array.forEach(this._parentNodes, function (node) {
                            node._dirty.positions = true;
                            if (needNormals)
                                node._dirty.normals = true;
                        });

                        return;
                    }

                    // TODO; optimize this very slow and brute force code, at least for creaseAngle=0 case!
                    this._mesh._normals[0] = [];
                    this._mesh._texCoords[0] =[];
                    this._mesh._colors[0] = [];
					
					var indexes = this._vf.coordIndex;
					var normalInd = this._vf.normalIndex;
					var texCoordInd = this._vf.texCoordIndex;
					var colorInd = this._vf.colorIndex;
					var hasNormal = false, hasNormalInd = false;
					var hasTexCoord = false, hasTexCoordInd = false;
					var hasColor = false, hasColorInd = false;

					var colPerVert = this._vf.colorPerVertex;
					var normPerVert = this._vf.normalPerVertex;

					if (normalInd.length > 0)
					{
						hasNormalInd = true;
					}
					if (texCoordInd.length > 0)
					{
						hasTexCoordInd = true;
					}
					if (colorInd.length > 0)
					{
						hasColorInd = true;
					}

					var positions, normals, texCoords, colors;

					var coordNode = this._cf.coord.node;
					x3dom.debug.assert(coordNode);
					positions = coordNode.getPoints();

					var normalNode = this._cf.normal.node;
					if (normalNode)
					{
						hasNormal = true;
						normals = normalNode._vf.vector;
					}
					else {
						hasNormal = false;
					}

					var texMode = "", numTexComponents = 2;
                    texCoordNode = this._cf.texCoord.node;
                    if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                        if (texCoordNode._cf.texCoord.nodes.length)
                            texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                    }
					if (texCoordNode)
					{
						if (texCoordNode._vf.point) {
							hasTexCoord = true;
							texCoords = texCoordNode._vf.point;

							if (x3dom.isa(texCoordNode, x3dom.nodeTypes.TextureCoordinate3D)) {
								numTexComponents = 3;
							}
						}
						else if (texCoordNode._vf.mode) {
							texMode = texCoordNode._vf.mode;
						}
					}
					else {
						hasTexCoord = false;
					}
					this._mesh._numTexComponents = numTexComponents;

					var numColComponents = 3;
					var colorNode = this._cf.color.node;
					if (colorNode)
					{
						hasColor = true;
						colors = colorNode._vf.color;

						if (x3dom.isa(colorNode, x3dom.nodeTypes.ColorRGBA)) {
							numColComponents = 4;
						}
					}
					else {
						hasColor = false;
					}
					this._mesh._numColComponents = numColComponents;

					var i, j, t, cnt, faceCnt;
					var p0, p1, p2, n0, n1, n2, t0, t1, t2, c0, c1, c2;
					
					if(this._vf.convex) {
						t = 0;
						cnt = 0;
						faceCnt = 0;
						this._mesh._multiIndIndices = [];
						this._mesh._posSize = positions.length;

						for (i=0; i < indexes.length; ++i)
						{
							if (indexes[i] == -1) {
								t = 0;
								faceCnt++;
								continue;
							}

							if (hasNormalInd) {
								x3dom.debug.assert(normalInd[i] != -1);
							}
							if (hasTexCoordInd) {
								x3dom.debug.assert(texCoordInd[i] != -1);
							}
							if (hasColorInd) {
								x3dom.debug.assert(colorInd[i] != -1);
							}

							switch (t)
							{
								case 0:
									p0 = +indexes[i];
									if (hasNormalInd && normPerVert) { n0 = +normalInd[i]; }
									else if (hasNormalInd && !normPerVert) { n0 = +normalInd[faceCnt]; }
									else if (normPerVert) { n0 = p0; }
									else { n0 = faceCnt; }

									if (hasTexCoordInd) { t0 = +texCoordInd[i]; }
									else { t0 = p0; }
									if (hasColorInd && colPerVert) { c0 = +colorInd[i]; }
									else if (hasColorInd && !colPerVert) { c0 = +colorInd[faceCnt]; }
									else if (colPerVert) { c0 = p0; }
									else { c0 = faceCnt; }
									t = 1;
								break;
								case 1:
									p1 = +indexes[i];
									if (hasNormalInd && normPerVert) { n1 = +normalInd[i]; }
									else if (hasNormalInd && !normPerVert) { n1 = +normalInd[faceCnt]; }
									else if (normPerVert) { n1 = p1; }
									else { n1 = faceCnt; }

									if (hasTexCoordInd) { t1 = +texCoordInd[i]; }
									else { t1 = p1; }
									if (hasColorInd && colPerVert) { c1 = +colorInd[i]; }
									else if (hasColorInd && !colPerVert) { c1 = +colorInd[faceCnt]; }
									else if (colPerVert) { c1 = p1; }
									else { c1 = faceCnt; }
									t = 2;
								break;
								case 2:
									p2 = +indexes[i];
									if (hasNormalInd && normPerVert) { n2 = +normalInd[i]; }
									else if (hasNormalInd && !normPerVert) { n2 = +normalInd[faceCnt]; }
									else if (normPerVert) { n2 = p2; }
									else { n2 = faceCnt; }

									if (hasTexCoordInd) { t2 = +texCoordInd[i]; }
									else { t2 = p2; }
									if (hasColorInd && colPerVert) { c2 = +colorInd[i]; }
									else if (hasColorInd && !colPerVert) { c2 = +colorInd[faceCnt]; }
									else if (colPerVert) { c2 = p2; }
									else { c2 = faceCnt; }
									t = 3;

									//this._mesh._indices[0].push(cnt++, cnt++, cnt++);

									this._mesh._positions[0].push(positions[p0].x);
									this._mesh._positions[0].push(positions[p0].y);
									this._mesh._positions[0].push(positions[p0].z);
									this._mesh._positions[0].push(positions[p1].x);
									this._mesh._positions[0].push(positions[p1].y);
									this._mesh._positions[0].push(positions[p1].z);
									this._mesh._positions[0].push(positions[p2].x);
									this._mesh._positions[0].push(positions[p2].y);
									this._mesh._positions[0].push(positions[p2].z);

									if (hasNormal) {
										this._mesh._normals[0].push(normals[n0].x);
										this._mesh._normals[0].push(normals[n0].y);
										this._mesh._normals[0].push(normals[n0].z);
										this._mesh._normals[0].push(normals[n1].x);
										this._mesh._normals[0].push(normals[n1].y);
										this._mesh._normals[0].push(normals[n1].z);
										this._mesh._normals[0].push(normals[n2].x);
										this._mesh._normals[0].push(normals[n2].y);
										this._mesh._normals[0].push(normals[n2].z);
									}
									//else {
										this._mesh._multiIndIndices.push(p0, p1, p2);
									//}

									if (hasColor) {
										this._mesh._colors[0].push(colors[c0].r);
										this._mesh._colors[0].push(colors[c0].g);
										this._mesh._colors[0].push(colors[c0].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c0].a);
										}
										this._mesh._colors[0].push(colors[c1].r);
										this._mesh._colors[0].push(colors[c1].g);
										this._mesh._colors[0].push(colors[c1].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c1].a);
										}
										this._mesh._colors[0].push(colors[c2].r);
										this._mesh._colors[0].push(colors[c2].g);
										this._mesh._colors[0].push(colors[c2].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c2].a);
										}
									}

									if (hasTexCoord) {
										this._mesh._texCoords[0].push(texCoords[t0].x);
										this._mesh._texCoords[0].push(texCoords[t0].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t0].z);
										}
										this._mesh._texCoords[0].push(texCoords[t1].x);
										this._mesh._texCoords[0].push(texCoords[t1].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t1].z);
										}
										this._mesh._texCoords[0].push(texCoords[t2].x);
										this._mesh._texCoords[0].push(texCoords[t2].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t2].z);
										}
									}

									//faceCnt++;
								break;
								case 3:
									p1 = p2;
									t1 = t2;
									if (normPerVert) {
										n1 = n2;
									}
									if (colPerVert) {
										c1 = c2;
									}
									p2 = +indexes[i];

									if (hasNormalInd && normPerVert) {
										n2 = +normalInd[i];
									} else if (hasNormalInd && !normPerVert) {
										/*n2 = +normalInd[faceCnt];*/
									} else if (normPerVert) {
										n2 = p2;
									} else {
										n2 = faceCnt;
									}

									if (hasTexCoordInd) {
										t2 = +texCoordInd[i];
									} else {
										t2 = p2;
									}

									if (hasColorInd && colPerVert) {
										c2 = +colorInd[i];
									} else if (hasColorInd && !colPerVert) {
										/*c2 = +colorInd[faceCnt];*/
									} else if (colPerVert) {
										c2 = p2;
									} else {
										c2 = faceCnt;
									}

									//this._mesh._indices[0].push(cnt++, cnt++, cnt++);

									this._mesh._positions[0].push(positions[p0].x);
									this._mesh._positions[0].push(positions[p0].y);
									this._mesh._positions[0].push(positions[p0].z);
									this._mesh._positions[0].push(positions[p1].x);
									this._mesh._positions[0].push(positions[p1].y);
									this._mesh._positions[0].push(positions[p1].z);
									this._mesh._positions[0].push(positions[p2].x);
									this._mesh._positions[0].push(positions[p2].y);
									this._mesh._positions[0].push(positions[p2].z);

									if (hasNormal) {
										this._mesh._normals[0].push(normals[n0].x);
										this._mesh._normals[0].push(normals[n0].y);
										this._mesh._normals[0].push(normals[n0].z);
										this._mesh._normals[0].push(normals[n1].x);
										this._mesh._normals[0].push(normals[n1].y);
										this._mesh._normals[0].push(normals[n1].z);
										this._mesh._normals[0].push(normals[n2].x);
										this._mesh._normals[0].push(normals[n2].y);
										this._mesh._normals[0].push(normals[n2].z);
									}
									//else {
										this._mesh._multiIndIndices.push(p0, p1, p2);
									//}

									if (hasColor) {
										this._mesh._colors[0].push(colors[c0].r);
										this._mesh._colors[0].push(colors[c0].g);
										this._mesh._colors[0].push(colors[c0].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c0].a);
										}
										this._mesh._colors[0].push(colors[c1].r);
										this._mesh._colors[0].push(colors[c1].g);
										this._mesh._colors[0].push(colors[c1].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c1].a);
										}
										this._mesh._colors[0].push(colors[c2].r);
										this._mesh._colors[0].push(colors[c2].g);
										this._mesh._colors[0].push(colors[c2].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(colors[c2].a);
										}
									}

									if (hasTexCoord) {
										this._mesh._texCoords[0].push(texCoords[t0].x);
										this._mesh._texCoords[0].push(texCoords[t0].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t0].z);
										}
										this._mesh._texCoords[0].push(texCoords[t1].x);
										this._mesh._texCoords[0].push(texCoords[t1].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t1].z);
										}
										this._mesh._texCoords[0].push(texCoords[t2].x);
										this._mesh._texCoords[0].push(texCoords[t2].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(texCoords[t2].z);
										}
									}

									//faceCnt++;
								break;
								default:
							}
						}
					}
					else {
						var linklist = new x3dom.DoublyLinkedList();
						var data = {};
						cnt = 0; faceCnt = 0;
												
						for (i = 0; i < indexes.length; ++i)
						{	
							if (indexes[i] == -1) {
								var multi_index_data = x3dom.EarClipping.getMultiIndexes(linklist);
								
								for (j = 0; j < multi_index_data.indices.length; j++)
								{	
									this._mesh._indices[0].push(cnt);
									cnt++;
									
									this._mesh._positions[0].push(multi_index_data.point[j].x,
																  multi_index_data.point[j].y,
																  multi_index_data.point[j].z);
									if (hasNormal) { 
										this._mesh._normals[0].push(multi_index_data.normals[j].x,
																	multi_index_data.normals[j].y,
																	multi_index_data.normals[j].z);
									}
									if (hasColor) { 
										this._mesh._colors[0].push(multi_index_data.colors[j].r, 
																   multi_index_data.colors[j].g, 
																   multi_index_data.colors[j].b);
										if (numColComponents === 4) {
											this._mesh._colors[0].push(multi_index_data.colors[j].a);
										}
									} 
									if (hasTexCoord) {	
										this._mesh._texCoords[0].push(multi_index_data.texCoords[j].x,
																	  multi_index_data.texCoords[j].y);
										if (numTexComponents === 3) {
											this._mesh._texCoords[0].push(multi_index_data.texCoords[j].z);
										}
									}
								}
									
								linklist = new x3dom.DoublyLinkedList();
								faceCnt++;
								continue;
							}
										
							if (hasNormal) {
								if (hasNormalInd && normPerVert) {
									data.normals =  normals[normalInd[i]];	
								} else if (hasNormalInd && !normPerVert) {
									data.normals =  normals[normalInd[faceCnt]];
								} else {
									data.normals =  normals[indexes[i]];
								}		
							}
							
							if (hasColor) {
								if (hasColorInd && colPerVert) {
									data.colors =  colors[colorInd[i]];
								} else if (hasColorInd && !colPerVert) {
									data.colors =  colors[colorInd[faceCnt]];
								} else {
									data.colors =  colors[indexes[i]];
								}
							}
							if (hasTexCoord) {
								if (hasTexCoordInd) {
									data.texCoords =  texCoords[texCoordInd[i]];
								} else {
									data.texCoords =  texCoords[indexes[i]];
								}			
							}
							
							linklist.appendNode(new x3dom.DoublyLinkedList.ListNode(
								positions[indexes[i]], indexes[i], data.normals, data.colors, data.texCoords));						
						}

                        this._mesh.splitMesh();
					}

					if (!hasNormal) {
						this._mesh.calcNormals(this._vf.creaseAngle, this._vf.ccw);
					}
					if (!hasTexCoord) {
						this._mesh.calcTexCoords(texMode);
					}

                    this.invalidateVolume();

					this._mesh._numFaces = 0;
					this._mesh._numCoords = 0;
					
					for (i=0; i<this._mesh._positions.length; i++) {
                        var indexLength = this._mesh._indices[i].length;
                        var numCoords = this._mesh._positions[i].length / 3;
                        this._mesh._numCoords += numCoords;
                        if (indexLength > 0)
						    this._mesh._numFaces += indexLength / 3;
                        else
                            this._mesh._numFaces += numCoords / 3;
					}
	
					Array.forEach(this._parentNodes, function (node) {
						node.setGeoDirty();
					});
                }
				else {
					if (fieldName == "coord")
					{
                        var needNormals = !this._cf.normal.node && this._vf.normalUpdateMode.toLowerCase() != 'none';

						this._mesh._positions[0] = pnts.toGL();

                        if (needNormals) {
                            // position update usually also requires update of vertex normals
                            this._mesh.calcNormals(this._vf.creaseAngle, this._vf.ccw);
                        }

						// tells the mesh that its bbox requires update
                        this.invalidateVolume();

						Array.forEach(this._parentNodes, function (node) {					
							node._dirty.positions = true;
                            if (needNormals)
                                node._dirty.normals = true;
                            node.invalidateVolume();
						});
					}
					else if (fieldName == "color")
					{ 
						pnts = this._cf.color.node._vf.color;
						
						this._mesh._colors[0] = pnts.toGL();

						Array.forEach(this._parentNodes, function (node) {
							node._dirty.colors = true;
						});
					}
					else if (fieldName == "normal")
					{
						pnts = this._cf.normal.node._vf.vector;
						
						this._mesh._normals[0] = pnts.toGL();
						
						Array.forEach(this._parentNodes, function (node) {
							 node._dirty.normals = true;
						});
					}
					else if (fieldName == "texCoord")
					{
                        texCoordNode = this._cf.texCoord.node;
                        if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                            if (texCoordNode._cf.texCoord.nodes.length)
                                texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                        }
						pnts = texCoordNode._vf.point;
						
						this._mesh._texCoords[0] = pnts.toGL();
						
						Array.forEach(this._parentNodes, function (node) {
							node._dirty.texcoords = true;
						});
					}
                    else if (fieldName == "coordIndex")
                    {
                        needNormals = !this._cf.normal.node && this._vf.normalUpdateMode.toLowerCase() != 'none';

                        indexes = this._vf.coordIndex;
                        t = 0;
                        n = indexes.length;

                        this._mesh._indices[0] = [];

                        for (i = 0; i < n; ++i) {
                            if (indexes[i] == -1) {
                                t = 0;
                            }
                            else {
                                switch (t) {
                                    case 0: p0 = +indexes[i]; t = 1; break;
                                    case 1: p1 = +indexes[i]; t = 2; break;
                                    case 2: p2 = +indexes[i]; t = 3; this._mesh._indices[0].push(p0, p1, p2); break;
                                    case 3: p1 = p2; p2 = +indexes[i]; this._mesh._indices[0].push(p0, p1, p2); break;
                                }
                            }
                        }

                        if (needNormals) {
                            // index update usually also requires update of vertex normals
                            this._mesh.calcNormals(this._vf.creaseAngle, this._vf.ccw);
                        }

                        Array.forEach(this._parentNodes, function (node) {
                            node._dirty.indexes = true;
                            if (needNormals)
                                node._dirty.normals = true;
                        });
                    }
				}
            }
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */

/* ### X3DTexture3DNode ### */
x3dom.registerNodeType(
    "X3DTexture3DNode",
    "Texturing3D",
    defineClass(x3dom.nodeTypes.X3DTextureNode,
        function (ctx) {
            x3dom.nodeTypes.X3DTexture3DNode.superClass.call(this, ctx);
        }
    )
);

/* ### ComposedTexture3D ### */
x3dom.registerNodeType(
    "ComposedTexture3D",
    "Texturing3D",
    defineClass(x3dom.nodeTypes.X3DTexture3DNode,
        function (ctx) {
            x3dom.nodeTypes.ComposedTexture3D.superClass.call(this, ctx);

            this.addField_MFNode('texture', x3dom.nodeTypes.X3DTexture3DNode);
        }
    )
);

/* ### ImageTexture3D ### */
x3dom.registerNodeType(
    "ImageTexture3D",
    "Texturing3D",
    defineClass(x3dom.nodeTypes.X3DTexture3DNode,
        function (ctx) {
            x3dom.nodeTypes.ImageTexture3D.superClass.call(this, ctx);
        }
    )
);

/* ### PixelTexture3D ### */
x3dom.registerNodeType(
    "PixelTexture3D",
    "Texturing3D",
    defineClass(x3dom.nodeTypes.X3DTexture3DNode,
        function (ctx) {
            x3dom.nodeTypes.PixelTexture3D.superClass.call(this, ctx);
        }
    )
);

/* ### TextureCoordinate3D ### */
x3dom.registerNodeType(
    "TextureCoordinate3D",
    "Texturing3D",
    defineClass(x3dom.nodeTypes.X3DTextureCoordinateNode,
        function (ctx) {
            x3dom.nodeTypes.TextureCoordinate3D.superClass.call(this, ctx);

            this.addField_MFVec3f(ctx, 'point', []);
        }
    )
);

/* ### TextureTransform3D ### */
x3dom.registerNodeType(
    "TextureTransform3D",
    "Texturing3D",
    defineClass(x3dom.nodeTypes.X3DTextureTransformNode,
        function (ctx) {
            x3dom.nodeTypes.TextureTransform3D.superClass.call(this, ctx);

            this.addField_SFVec3f(ctx, 'center', 0, 0, 0);
            this.addField_SFRotation(ctx, 'rotation', 0, 0, 1, 0);
            this.addField_SFVec3f(ctx, 'scale', 1, 1, 1);
            this.addField_SFVec3f(ctx, 'translation', 0, 0, 0);
            this.addField_SFRotation(ctx, 'scaleOrientation', 0, 0, 1, 0);
        }
    )
);

/* ### TextureTransformMatrix3D ### */
x3dom.registerNodeType(
    "TextureTransformMatrix3D",
    "Texturing3D",
    defineClass(x3dom.nodeTypes.X3DTextureTransformNode,
        function (ctx) {
            x3dom.nodeTypes.TextureTransformMatrix3D.superClass.call(this, ctx);

            this.addField_SFMatrix4f(ctx, 'matrix', 1, 0, 0, 0,
                                                    0, 1, 0, 0,
                                                    0, 0, 1, 0,
                                                    0, 0, 0, 1);
        }
    )
);

/* ### ImageTextureAtlas ### */
x3dom.registerNodeType(
    "ImageTextureAtlas",
    "Texturing",
    defineClass(x3dom.nodeTypes.Texture,
        function (ctx) {
            x3dom.nodeTypes.ImageTextureAtlas.superClass.call(this, ctx);

            this.addField_SFInt32(ctx, 'numberOfSlices', 0);
            this.addField_SFInt32(ctx, 'slicesOverX', 0);
            this.addField_SFInt32(ctx, 'slicesOverY', 0);
            // Special helper node to represent tiles for volume rendering
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### GeoCoordinate ### */
x3dom.registerNodeType(
    "GeoCoordinate",
    "Geospatial",
    defineClass(x3dom.nodeTypes.X3DCoordinateNode,
        function (ctx) {
            x3dom.nodeTypes.GeoCoordinate.superClass.call(this, ctx);

            this.addField_MFVec3f(ctx, 'point', []);
            this.addField_MFString(ctx, 'geoSystem', ['GD', 'WE']);
            this.addField_SFNode('geoOrigin', x3dom.nodeTypes.GeoOrigin);
        },
        {
            elipsoideParameters:
            {
                'AA' : [ 'Airy 1830', '6377563.396', '299.3249646' ],
                'AM' : [ 'Modified Airy', '6377340.189', '299.3249646' ],
                'AN' : [ 'Australian National', '6378160', '298.25' ],
                'BN' : [ 'Bessel 1841 (Namibia)', '6377483.865', '299.1528128' ],
                'BR' : [ 'Bessel 1841 (Ethiopia Indonesia...)', '6377397.155', '299.1528128' ],
                'CC' : [ 'Clarke 1866', '6378206.4', '294.9786982' ],
                'CD' : [ 'Clarke 1880', '6378249.145', '293.465' ],
                'EA' : [ 'Everest (India 1830)', '6377276.345', '300.8017' ],
                'EB' : [ 'Everest (Sabah & Sarawak)', '6377298.556', '300.8017' ],
                'EC' : [ 'Everest (India 1956)', '6377301.243', '300.8017' ],
                'ED' : [ 'Everest (W. Malaysia 1969)', '6377295.664', '300.8017' ],
                'EE' : [ 'Everest (W. Malaysia & Singapore 1948)', '6377304.063', '300.8017' ],
                'EF' : [ 'Everest (Pakistan)', '6377309.613', '300.8017' ],
                'FA' : [ 'Modified Fischer 1960', '6378155', '298.3' ],
                'HE' : [ 'Helmert 1906', '6378200', '298.3' ],
                'HO' : [ 'Hough 1960', '6378270', '297' ],
                'ID' : [ 'Indonesian 1974', '6378160', '298.247' ],
                'IN' : [ 'International 1924', '6378388', '297' ],
                'KA' : [ 'Krassovsky 1940', '6378245', '298.3' ],
                'RF' : [ 'Geodetic Reference System 1980 (GRS 80)', '6378137', '298.257222101' ],
                'SA' : [ 'South American 1969', '6378160', '298.25' ],
                'WD' : [ 'WGS 72', '6378135', '298.26' ],
                'WE' : [ 'WGS 84', '6378137', '298.257223563' ]
            },
            
            fieldChanged: function(fieldName) {
                if (fieldName == "point" || fieldName == "geoSystem") {
                    Array.forEach(this._parentNodes, function (node) {
                        node.fieldChanged("coord");
                    });
                }
            },

            isLogitudeFirst: function(geoSystem) {
              for(var i=0; i<geoSystem.length; ++i)
                if(geoSystem[i] == 'longitude_first')
                  return true;
              
              return false;
            },

            getElipsoide: function(geoSystem)
            {
              for(var i=0; i<geoSystem.length; ++i)
              {
                var code = geoSystem[i];
                if(this.elipsoideParameters[code])
                  return this.elipsoideParameters[code];
              }

              // default elipsoide
              return this.elipsoideParameters['WE'];
            },

            getReferenceFrame: function(geoSystem)
            {
              for(var i=0; i<geoSystem.length; ++i)
              {
                var code = geoSystem[i];

                if(code == 'GD' || code == 'GDC')
                  return 'GD';
                if(code == 'GC' || code == 'GCC')
                  return 'GC';
                if(code == 'UTM')
                  return 'UTM';

                else
                  x3dom.debug.logError('Unknown GEO system: [' + geoSystem + ']');
              }

              // default elipsoide
              return this.elipsoideParameters['WE'];
            },

            UTMtoGC: function(geoSystem, coords) {
              x3dom.debug.logError('Not implemented GeoCoordinate: UTM');
            },
            
            GDtoGC: function(geoSystem, coords) {
            
              var output = new x3dom.fields.MFVec3f();
              
              var elipsoide = this.getElipsoide(geoSystem);
              var radius = elipsoide[1];
              var eccentricity = elipsoide[2];

              var longitudeFirst = this.isLogitudeFirst(geoSystem);

              // large parts of this code from freeWRL
              var A = radius;
              var A2 = radius*radius;
              var F = 1.0/eccentricity;
              var C = A*(1.0-F);
              var C2 = C*C;
              var Eps2 = F*(2.0-F);
              var Eps25 = 0.25*Eps2;
              
              var radiansPerDegree = 0.0174532925199432957692;

              // for (current in coords)
              for(var i=0; i<coords.length; ++i)
              {
                var current = new x3dom.fields.SFVec3f();
                
                var source_lat = radiansPerDegree * (longitudeFirst == true ? coords[i].y : coords[i].x);
                var source_lon = radiansPerDegree * (longitudeFirst == true ? coords[i].x : coords[i].y);

                var slat = Math.sin(source_lat);
                var slat2 = slat*slat;
                var clat = Math.cos(source_lat);

                /* square root approximation for Rn */
                var Rn = A / ( (0.25 - Eps25 * slat2 + 0.9999944354799/4.0) + 
                         (0.25-Eps25 * slat2)/(0.25 - Eps25 * slat2 + 0.9999944354799/4.0));

                var RnPh = Rn + coords[i].z;
                
                current.x = RnPh * clat * Math.cos(source_lon);
                current.y = RnPh * clat * Math.sin(source_lon);
                current.z = ((C2 / A2) * Rn + coords[i].z) * slat;

                output.push(current);
              }
              
              return output;
            },

            GEOtoGC: function(geoSystem, geoOrigin, coords)
            {
              var referenceFrame = this.getReferenceFrame(geoSystem);

              if(referenceFrame == 'GD')
                return this.GDtoGC(geoSystem, coords);
              
              else if(referenceFrame == 'UTM')
                return this.UTMtoGC(geoSystem, coords);

              else if(referenceFrame ==  'GC')
              {
                // Performance Hack
                // Normaly GDtoGC & UTMtoGC will create a copy
                // If we are already in GC & have an origin: we have to copy here
                // Else Origin will change original DOM elements

                if(geoOrigin.node)
                {
                  var copy = new x3dom.fields.MFVec3f();
                  for(var i=0; i<coords.length; ++i)
                  {
                    var current = new x3dom.fields.SFVec3f();
                    
                    current.x = coords[i].x;
                    current.y = coords[i].y;
                    current.z = coords[i].z;
                    
                    copy.push(current);
                  }
                  return copy;
                }
                else
                  return coords;
              }
              else {
                x3dom.debug.logError('Unknown geoSystem: ' + geoSystem[0]);
                return new x3dom.fields.MFVec3f();
              }
            },

            OriginToGC: function(geoOrigin)
            {
              // dummy function to send a scalar to an array function
              var geoCoords = geoOrigin.node._vf.geoCoords;
              var geoSystem = geoOrigin.node._vf.geoSystem;

              var point = new x3dom.fields.SFVec3f;
              point.x = geoCoords.x;
              point.y = geoCoords.y;
              point.z = geoCoords.z;

              var temp = new x3dom.fields.MFVec3f;
              temp.push(point);

              // transform origin to GeoCentric
              var origin = this.GEOtoGC(geoSystem, geoOrigin, temp);
              
              return origin[0];
            },

            GEOtoX3D: function(geoSystem, geoOrigin, coords)
            {
              // transform points to GeoCentric
              var gc = this.GEOtoGC(geoSystem, geoOrigin, coords);

              // transform by origin
              if(geoOrigin.node)
              {
                // transform points by origin
                var origin = this.OriginToGC(geoOrigin);

                var matrix = x3dom.fields.SFMatrix4f.translation(origin);
                matrix = matrix.inverse();

                for(var i=0; i<coords.length; ++i)
                  gc[i] = matrix.multMatrixPnt(gc[i]);
              }

              return gc;
            },
            
            getPoints: function()
            {
              return this.GEOtoX3D(this._vf.geoSystem, this._cf.geoOrigin, this._vf.point);
            }
        }
    )
);

/* ### GeoElevationGrid ### */
x3dom.registerNodeType(
    "GeoElevationGrid",
    "Geospatial",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.GeoElevationGrid.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'geoSystem', ['GD', 'WE']);
            this.addField_SFVec3d(ctx, 'geoGridOrigin', 0, 0, 0);
            this.addField_MFDouble(ctx, 'height', 0, 0);
            this.addField_SFBool(ctx, 'ccw', true);
            //this.addField_SFBool(ctx, 'colorPerVertex', true);
            this.addField_SFDouble(ctx, 'creaseAngle', 0);
            //this.addField_SFBool(ctx, 'normalPerVertex', true);
            //this.addField_SFBool(ctx, 'solid', true);
            this.addField_SFInt32(ctx, 'xDimension', 0);
            this.addField_SFDouble(ctx, 'xSpacing', 1.0);
            this.addField_SFFloat(ctx, 'yScale', 1);
            this.addField_SFInt32(ctx, 'zDimension', 0);
            this.addField_SFDouble(ctx, 'zSpacing', 1.0);
            // this.addField_SFNode('color', x3dom.nodeTypes.PropertySetGeometry);
            // this.addField_SFNode('normal', x3dom.nodeTypes.PropertySetGeometry);
            // this.addField_SFNode('texCoord', x3dom.nodeTypes.PropertySetGeometry);
            this.addField_SFNode('geoOrigin', x3dom.nodeTypes.GeoOrigin);
            this.addField_SFBool(ctx, 'lit', true);
        },
        {
            nodeChanged: function()
            {
              var geoSystem = this._vf.geoSystem;
              var geoOrigin = this._cf.geoOrigin;

              var height = this._vf.height;
              
              var yScale = this._vf.yScale;
              var xDimension = this._vf.xDimension;
              var zDimension = this._vf.zDimension;
              var xSpacing = this._vf.xSpacing;
              var zSpacing = this._vf.zSpacing;
              var geoGridOrigin = this._vf.geoGridOrigin;

              // check for no height == dimensions
              if(height.length !== (xDimension * zDimension))
                x3dom.debug.logError('GeoElevationGrid: height.length(' + height.length + 
                                ') != x/zDimension(' + xDimension + '*' + zDimension + ')');
              
              var longitude_first = x3dom.nodeTypes.GeoCoordinate.prototype.isLogitudeFirst(geoSystem);
              var ccw = this._vf.ccw;

              // coords, texture coords
              var delta_x = 1 / (xDimension-1);
              var delta_z = 1 / (zDimension-1);

              var positions = new x3dom.fields.MFVec3f();
              var texCoords = new x3dom.fields.MFVec2f();
              
              for(var z=0; z<zDimension; ++z)
                for(var x=0; x<xDimension; ++x)
                {
                  // texture coord
                  var tex_coord = new x3dom.fields.SFVec2f(x*delta_x, z*delta_z);
                  texCoords.push(tex_coord);

                  // coord
                  var coord = new x3dom.fields.SFVec3f();
                  if(longitude_first)
                  {
                    coord.x = x * xSpacing;
                    coord.y = z * zSpacing;
                  }
                  else
                  {
                    coord.x = z * zSpacing;
                    coord.y = x * xSpacing;
                  }
                  coord.z = height[(z*xDimension)+x] * yScale;
                  coord = coord.add(geoGridOrigin);

                  positions.push(coord);
                }

              // indices
              var indices = new x3dom.fields.MFInt32();
              for(var z=0; z<(zDimension-1); z++)
              {
                for(var x=0; x<(xDimension-1); x++)
                {
                  var p0 = x + (z * xDimension);
                  var p1 = x + (z * xDimension) + 1;
                  var p2 = x + ((z + 1) * xDimension) + 1;
                  var p3 = x + ((z + 1) * xDimension);

                  if(ccw)
                  {
                    indices.push(p0);
                    indices.push(p1);
                    indices.push(p2);

                    indices.push(p0);
                    indices.push(p2);
                    indices.push(p3);
                  }
                  else
                  {
                    indices.push(p0);
                    indices.push(p3);
                    indices.push(p2);

                    indices.push(p0);
                    indices.push(p2);
                    indices.push(p1);
                  }
                }
              }

              // convert to x3dom coord system
              var transformed = x3dom.nodeTypes.GeoCoordinate.prototype.GEOtoX3D(geoSystem, geoOrigin, positions);

              //if we want flat shading, we have to duplicate some vertices here
              //(as webgl does only support single-indexed rendering)
              if (this._vf.creaseAngle <= x3dom.fields.Eps) {

                var that = this;

                (function (){
                    var indicesFlat   = new x3dom.fields.MFInt32(),
                        positionsFlat = new x3dom.fields.MFVec3f(),
                        texCoordsFlat = new x3dom.fields.MFVec3f();

                    that.generateNonIndexedTriangleData(indices, transformed, null, texCoords, null,
                                                        positionsFlat, null, texCoordsFlat, null);

                    for (var i = 0; i < positionsFlat.length; ++i) {
                        indicesFlat.push(i);
                    }

                    that._mesh._indices[0]   = indicesFlat.toGL();
                    that._mesh._positions[0] = positionsFlat.toGL();
                    that._mesh._texCoords[0] = texCoordsFlat.toGL();
                })();

                this._mesh.calcNormals(0);
              }
              //smooth shading
              else {
                this._mesh._indices[0]   = indices.toGL();
                this._mesh._positions[0] = transformed.toGL();
                this._mesh._texCoords[0] = texCoords.toGL();

                this._mesh.calcNormals(Math.PI);
              }

              this._mesh._invalidate = true;
              this._mesh._numFaces = this._mesh._indices[0].length / 3;
              this._mesh._numCoords = this._mesh._positions[0].length / 3;
            },

            generateNonIndexedTriangleData: function(indices, positions, normals, texCoords, colors,
                                                     newPositions, newNormals, newTexCoords, newColors)
            {
                //@todo: add support for RGBA colors and 3D texture coordinates
                //@todo: if there is any need for that, add multi-index support

                for (var i = 0; i < indices.length; i+=3) {
                    var i0 = indices[i  ],
                        i1 = indices[i+1],
                        i2 = indices[i+2];

                    if (positions) {
                        var p0 = new x3dom.fields.SFVec3f(),
                            p1 = new x3dom.fields.SFVec3f(),
                            p2 = new x3dom.fields.SFVec3f();

                        p0.setValues(positions[i0]);
                        p1.setValues(positions[i1]);
                        p2.setValues(positions[i2]);

                        newPositions.push(p0);
                        newPositions.push(p1);
                        newPositions.push(p2);
                    }

                    if (normals) {
                        var n0 = new x3dom.fields.SFVec3f(),
                            n1 = new x3dom.fields.SFVec3f(),
                            n2 = new x3dom.fields.SFVec3f();

                        n0.setValues(normals[i0]);
                        n1.setValues(normals[i1]);
                        n2.setValues(normals[i2]);

                        newNormals.push(n0);
                        newNormals.push(n1);
                        newNormals.push(n2);
                    }

                    if (texCoords) {
                        var t0 = new x3dom.fields.SFVec2f(),
                            t1 = new x3dom.fields.SFVec2f(),
                            t2 = new x3dom.fields.SFVec2f();

                        t0.setValues(texCoords[i0]);
                        t1.setValues(texCoords[i1]);
                        t1.setValues(texCoords[i2]);

                        newTexCoords.push(t0);
                        newTexCoords.push(t1);
                        newTexCoords.push(t2);
                    }

                    if (colors) {
                        var c0 = new x3dom.fields.SFVec3f(),
                            c1 = new x3dom.fields.SFVec3f(),
                            c2 = new x3dom.fields.SFVec3f();

                        c0.setValues(texCoords[i0]);
                        c1.setValues(texCoords[i1]);
                        c1.setValues(texCoords[i2]);

                        newColors.push(c0);
                        newColors.push(c1);
                        newColors.push(c2);
                    }
                }
            }
        }
    )
);

/* ### GeoLOD ### */
x3dom.registerNodeType(
    "GeoLOD",
    "Geospatial",
    defineClass(x3dom.nodeTypes.X3DLODNode,
        function (ctx) {
            x3dom.nodeTypes.GeoLOD.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'geoSystem', ['GD', 'WE']);
            this.addField_MFString(ctx, 'rootUrl', []);
            this.addField_MFString(ctx, 'child1Url', []);
            this.addField_MFString(ctx, 'child2Url', []);
            this.addField_MFString(ctx, 'child3Url', []);
            this.addField_MFString(ctx, 'child4Url', []);
            //this.addField_SFVec3d(ctx, 'center', 0, 0, 0);
            this.addField_SFFloat(ctx, 'range', 10);
            this.addField_SFString(ctx, 'referenceBindableDescription', []);
            this.addField_SFNode('geoOrigin', x3dom.nodeTypes.X3DChildNode);
            this.addField_SFNode('rootNode', x3dom.nodeTypes.X3DChildNode);
            this.addField_SFNode('privateChild1Node', x3dom.nodeTypes.X3DChildNode);
            this.addField_SFNode('privateChild2Node', x3dom.nodeTypes.X3DChildNode);
            this.addField_SFNode('privateChild3Node', x3dom.nodeTypes.X3DChildNode);
            this.addField_SFNode('privateChild4Node', x3dom.nodeTypes.X3DChildNode);
            this.addField_SFNode('privateRootNode', x3dom.nodeTypes.X3DChildNode);
        }
    )
);

/* ### GeoLocation ### */
x3dom.registerNodeType(
    "GeoLocation",
    "Geospatial",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.GeoLocation.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'geoSystem', ['GD', 'WE']);
            this.addField_SFVec3d(ctx, 'geoCoords', 0, 0, 0);
            this.addField_SFNode('geoOrigin', x3dom.nodeTypes.X3DChildNode);
        }
    )
);

/* ### GeoMetadata ### */
x3dom.registerNodeType(
    "GeoMetadata",
    "Geospatial",
    defineClass(x3dom.nodeTypes.X3DInfoNode,
        function (ctx) {
            x3dom.nodeTypes.GeoMetadata.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'url', []);
            this.addField_MFNode('data', x3dom.nodeTypes.X3DInfoNode);
            this.addField_MFString(ctx, 'summary', []);
        }
    )
);

/* ### GeoOrigin ### */
x3dom.registerNodeType(
    "GeoOrigin",
    "Geospatial",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.GeoOrigin.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'geoSystem', ['GD', 'WE']);
            this.addField_SFVec3d(ctx, 'geoCoords', 0, 0, 0);
            this.addField_SFBool(ctx, 'rotateYUp', false);
        }
    )
);

/* ### GeoPositionInterpolator ### */
x3dom.registerNodeType(
    "GeoPositionInterpolator",
    "Geospatial",
    defineClass(x3dom.nodeTypes.X3DInterpolatorNode,
        function (ctx) {
            x3dom.nodeTypes.GeoPositionInterpolator.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'geoSystem', ['GD', 'WE']);
            this.addField_MFVec3d(ctx, 'keyValue', []);
            this.addField_SFNode('geoOrigin', x3dom.nodeTypes.X3DInterpolatorNode);
        }
    )
);

/* ### GeoTransform ### */
x3dom.registerNodeType(
    "GeoTransform",
    "Geospatial",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.GeoTransform.superClass.call(this, ctx);

            this.addField_SFVec3d(ctx, 'geoCenter', 0, 0, 0);
            this.addField_SFRotation(ctx, 'rotation', 0, 0, 1, 0);
            this.addField_SFVec3f(ctx, 'scale', 1, 1, 1);
            this.addField_SFRotation(ctx, 'scaleOrientation', 0, 0, 1, 0);
            this.addField_SFVec3f(ctx, 'translation', 0, 0, 0);
            this.addField_SFNode('geoOrigin', x3dom.nodeTypes.Transform);
            this.addField_MFString(ctx, 'geoSystem', ['GD', 'WE']);
        }
    )
);

/* ### GeoViewpoint ### */
x3dom.registerNodeType(
    "GeoViewpoint",
    "Geospatial",
    defineClass(x3dom.nodeTypes.X3DViewpointNode,
        function (ctx) {
            x3dom.nodeTypes.GeoViewpoint.superClass.call(this, ctx);

            this.addField_MFString(ctx, 'geoSystem', ['GD', 'WE']);
            this.addField_SFFloat(ctx, 'fieldOfView', 0.785398);
            this.addField_SFRotation(ctx, 'orientation', 0, 0, 1, 0);
            this.addField_SFVec3d(ctx, 'position', 0, 0, 100000);
            this.addField_SFBool(ctx, 'headlight', true);
            this.addField_MFString(ctx, 'navType', 'EXAMINE');
            this.addField_SFFloat(ctx, 'speedFactor', 1.0);
            this.addField_SFNode('geoOrigin', x3dom.nodeTypes.X3DViewpointNode);
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### X3DPlanarGeometryNode ### */
x3dom.registerNodeType(
    "X3DPlanarGeometryNode",
    "Geometry2D",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.X3DPlanarGeometryNode.superClass.call(this, ctx);
        }
    )
);

/* ### Arc2D ### */
x3dom.registerNodeType(
    "Arc2D",
    "Geometry2D",
    defineClass(x3dom.nodeTypes.X3DPlanarGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Arc2D.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'radius', 1);
            this.addField_SFFloat(ctx, 'startAngle', 0);
            this.addField_SFFloat(ctx, 'endAngle', 1.570796);
            this.addField_SFFloat(ctx, 'subdivision', 32);

            this._mesh._primType = 'LINES';

            var r = this._vf.radius;
            var start = this._vf.startAngle;
            var end = this._vf.endAngle;

            // The following code ensures that:
            // 1. 0 <= startAngle < 2*Pi
            // 2. startAngle < endAngle
            // 3. endAngle - startAngle <= 2*Pi
            var Pi2 = Math.PI * 2.0;
            start -= Math.floor(start / Pi2) * Pi2;
            end -= Math.floor(end / Pi2) * Pi2;
            if (end <= start)
                end += Pi2;

            var geoCacheID = 'Arc2D_' + r + start + end;

            if (this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined) {
                //x3dom.debug.logInfo("Using Arc2D from Cache");
                this._mesh = x3dom.geoCache[geoCacheID];
            } else {

                var anzahl = this._vf.subdivision;
                var t = (end - start) / anzahl;
                var theta = start;

                for (var i = 0; i <= anzahl + 1; i++) {
                    var x = Math.cos(theta) * r;
                    var y = Math.sin(theta) * r;

                    this._mesh._positions[0].push(x);
                    this._mesh._positions[0].push(y);
                    this._mesh._positions[0].push(0.0);
                    theta += t;
                }

                for (var j = 0; j < anzahl; j++) {
                    this._mesh._indices[0].push(j);
                    this._mesh._indices[0].push(j + 1);
                }

                this._mesh._invalidate = true;
                this._mesh._numFaces = this._mesh._indices[0].length / 2;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                x3dom.geoCache[geoCacheID] = this._mesh;
            }
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "radius" || fieldName == "subdivision" ||
                    fieldName == "startAngle" || fieldName == "endAngle") {
                    this._mesh._positions[0] = [];
                    this._mesh._indices[0] = [];

                    var r = this._vf.radius;
                    var start = this._vf.startAngle;
                    var end = this._vf.endAngle;
                    var anzahl = this._vf.subdivision;

                    var Pi2 = Math.PI * 2.0;
                    start -= Math.floor(start / Pi2) * Pi2;
                    end -= Math.floor(end / Pi2) * Pi2;
                    if (end <= start)
                        end += Pi2;

                    var t = (end - start) / anzahl;
                    var theta = start;

                    for (var i = 0; i <= anzahl + 1; i++) {
                        var x = Math.cos(theta) * r;
                        var y = Math.sin(theta) * r;

                        this._mesh._positions[0].push(x);
                        this._mesh._positions[0].push(y);
                        this._mesh._positions[0].push(0.0);
                        theta += t;
                    }

                    for (var j = 0; j < anzahl; j++) {
                        this._mesh._indices[0].push(j);
                        this._mesh._indices[0].push(j + 1);
                    }

                    this.invalidateVolume();
                    this._mesh._numFaces = this._mesh._indices[0].length / 2;
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.positions = true;
                        node._dirty.indexes = true;
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);

/* ### ArcClose2D ### */
x3dom.registerNodeType(
    "ArcClose2D",
    "Geometry2D",
    defineClass(x3dom.nodeTypes.X3DPlanarGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.ArcClose2D.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'closureType', "PIE");
            this.addField_SFFloat(ctx, 'radius', 1);
            this.addField_SFFloat(ctx, 'startAngle', 0);
            this.addField_SFFloat(ctx, 'endAngle', 1.570796);
            this.addField_SFFloat(ctx, 'subdivision', 32);

            var r = this._vf.radius;
            var start = this._vf.startAngle;
            var end = this._vf.endAngle;
            var anzahl = this._vf.subdivision;

            // The following code ensures that:
            // 1. 0 <= startAngle < 2*Pi
            // 2. startAngle < endAngle
            // 3. endAngle - startAngle <= 2*Pi
            var Pi2 = Math.PI * 2.0;
            start -= Math.floor(start / Pi2) * Pi2;
            end -= Math.floor(end / Pi2) * Pi2;
            if (end <= start)
                end += Pi2;

            var geoCacheID = 'ArcClose2D_' + r + start + end + this._vf.closureType;

            if (this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined) {
                //x3dom.debug.logInfo("Using ArcClose2D from Cache");
                this._mesh = x3dom.geoCache[geoCacheID];
            } else {
                var t = (end - start) / anzahl;
                var theta = start;

                if (this._vf.closureType.toUpperCase() == 'PIE') {

                    this._mesh._positions[0].push(0.0);
                    this._mesh._positions[0].push(0.0);
                    this._mesh._positions[0].push(0.0);

                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(1);

                    this._mesh._texCoords[0].push(0.5);
                    this._mesh._texCoords[0].push(0.5);

                    for (var i = 0; i <= anzahl; i++) {
                        var x = Math.cos(theta) * r;
                        var y = Math.sin(theta) * r;

                        this._mesh._positions[0].push(x);
                        this._mesh._positions[0].push(y);
                        this._mesh._positions[0].push(0.0);

                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(1);

                        this._mesh._texCoords[0].push((x + r) / (2 * r));
                        this._mesh._texCoords[0].push((y + r) / (2 * r));

                        theta += t;
                    }

                    for (var j = 1; j <= anzahl; j++) {
                        this._mesh._indices[0].push(j + 1);
                        this._mesh._indices[0].push(0);
                        this._mesh._indices[0].push(j);
                    }

                } else {    // "CHORD"
                    for (var i = 0; i <= anzahl; i++) {
                        var x = Math.cos(theta) * r;
                        var y = Math.sin(theta) * r;

                        this._mesh._positions[0].push(x);
                        this._mesh._positions[0].push(y);
                        this._mesh._positions[0].push(0.0);

                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(1);

                        this._mesh._texCoords[0].push((x + r) / (2 * r));
                        this._mesh._texCoords[0].push((y + r) / (2 * r));

                        theta += t;
                    }

                    var x = (this._mesh._positions[0][0] + this._mesh._positions[0][this._mesh._positions[0].length - 3]) / 2;
                    var y = (this._mesh._positions[0][1] + this._mesh._positions[0][this._mesh._positions[0].length - 2]) / 2;

                    this._mesh._positions[0].push(x);
                    this._mesh._positions[0].push(y);
                    this._mesh._positions[0].push(0.0);

                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(1);

                    this._mesh._texCoords[0].push((x + r) / (2 * r));
                    this._mesh._texCoords[0].push((y + r) / (2 * r));

                    for (var j = 0; j < anzahl; j++) {
                        this._mesh._indices[0].push(j + 1);
                        this._mesh._indices[0].push(anzahl + 1);
                        this._mesh._indices[0].push(j);
                    }
                }

                this._mesh._numTexComponents = 2;
                this._mesh._invalidate = true;
                this._mesh._numFaces = this._mesh._indices[0].length / 2;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                x3dom.geoCache[geoCacheID] = this._mesh;
            }
        },
        {
            fieldChanged: function (fieldName) {
                var r = this._vf.radius;
                var start = this._vf.startAngle;
                var end = this._vf.endAngle;
                var anzahl = this._vf.subdivision;

                var Pi2 = Math.PI * 2.0;
                start -= Math.floor(start / Pi2) * Pi2;
                end -= Math.floor(end / Pi2) * Pi2;
                if (end <= start)
                    end += Pi2;

                var t = (end - start) / anzahl;
                var theta = start;

                if (fieldName === "radius") {
                    this._mesh._positions[0] = [];

                    if (this._vf.closureType.toUpperCase() == 'PIE') {

                        this._mesh._positions[0].push(0.0);
                        this._mesh._positions[0].push(0.0);
                        this._mesh._positions[0].push(0.0);

                        for (var i = 0; i <= anzahl; i++) {
                            var x = Math.cos(theta) * r;
                            var y = Math.sin(theta) * r;

                            this._mesh._positions[0].push(x);
                            this._mesh._positions[0].push(y);
                            this._mesh._positions[0].push(0.0);

                            theta += t;
                        }
                    } else {
                        for (var i = 0; i <= anzahl; i++) {
                            var x = Math.cos(theta) * r;
                            var y = Math.sin(theta) * r;

                            this._mesh._positions[0].push(x);
                            this._mesh._positions[0].push(y);
                            this._mesh._positions[0].push(0.0);

                            theta += t;
                        }

                        var x = (this._mesh._positions[0][0] + this._mesh._positions[0][this._mesh._positions[0].length - 3]) / 2;
                        var y = (this._mesh._positions[0][1] + this._mesh._positions[0][this._mesh._positions[0].length - 2]) / 2;

                        this._mesh._positions[0].push(x);
                        this._mesh._positions[0].push(y);
                        this._mesh._positions[0].push(0.0);
                    }

                    this.invalidateVolume();
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.positions = true;
                        node.invalidateVolume();
                    });

                } else if (fieldName == "closureType" || fieldName == "subdivision" ||
                           fieldName == "startAngle" || fieldName == "endAngle") {
                    this._mesh._positions[0] = [];
                    this._mesh._indices[0] = [];
                    this._mesh._normals[0] = [];
                    this._mesh._texCoords[0] = [];

                    if (this._vf.closureType.toUpperCase() == 'PIE') {

                        this._mesh._positions[0].push(0.0);
                        this._mesh._positions[0].push(0.0);
                        this._mesh._positions[0].push(0.0);

                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(1);

                        this._mesh._texCoords[0].push(0.5);
                        this._mesh._texCoords[0].push(0.5);

                        for (var i = 0; i <= anzahl; i++) {
                            var x = Math.cos(theta) * r;
                            var y = Math.sin(theta) * r;

                            this._mesh._positions[0].push(x);
                            this._mesh._positions[0].push(y);
                            this._mesh._positions[0].push(0.0);

                            this._mesh._normals[0].push(0);
                            this._mesh._normals[0].push(0);
                            this._mesh._normals[0].push(1);

                            this._mesh._texCoords[0].push((x + r) / (2 * r));
                            this._mesh._texCoords[0].push((y + r) / (2 * r));

                            theta += t;
                        }

                        for (var j = 1; j <= anzahl; j++) {
                            this._mesh._indices[0].push(j + 1);
                            this._mesh._indices[0].push(0);
                            this._mesh._indices[0].push(j);
                        }

                    } else {
                        for (var i = 0; i <= anzahl; i++) {
                            var x = Math.cos(theta) * r;
                            var y = Math.sin(theta) * r;

                            this._mesh._positions[0].push(x);
                            this._mesh._positions[0].push(y);
                            this._mesh._positions[0].push(0.0);

                            this._mesh._normals[0].push(0);
                            this._mesh._normals[0].push(0);
                            this._mesh._normals[0].push(1);

                            this._mesh._texCoords[0].push((x + r) / (2 * r));
                            this._mesh._texCoords[0].push((y + r) / (2 * r));

                            theta += t;
                        }

                        var x = (this._mesh._positions[0][0] + this._mesh._positions[0][this._mesh._positions[0].length - 3]) / 2;
                        var y = (this._mesh._positions[0][1] + this._mesh._positions[0][this._mesh._positions[0].length - 2]) / 2;

                        this._mesh._positions[0].push(x);
                        this._mesh._positions[0].push(y);
                        this._mesh._positions[0].push(0.0);

                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(1);

                        this._mesh._texCoords[0].push((x + r) / (2 * r));
                        this._mesh._texCoords[0].push((y + r) / (2 * r));

                        for (var j = 0; j < anzahl; j++) {
                            this._mesh._indices[0].push(j + 1);
                            this._mesh._indices[0].push(anzahl + 1);
                            this._mesh._indices[0].push(j);
                        }
                    }

                    this._mesh._numTexComponents = 2;
                    this.invalidateVolume();
                    this._mesh._numFaces = this._mesh._indices[0].length / 2;
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                    });
                }
            }
        }
    )
);

/* ### Circle2D ### */
x3dom.registerNodeType(
    "Circle2D",
    "Geometry2D",
    defineClass(x3dom.nodeTypes.X3DPlanarGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Circle2D.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'radius', 1);
            this.addField_SFFloat(ctx, 'subdivision', 32);

            this._mesh._primType = 'LINES';

            var r = this._vf.radius;

            var geoCacheID = 'Circle2D_' + r;

            if (this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined) {
                //x3dom.debug.logInfo("Using Circle2D from Cache");
                this._mesh = x3dom.geoCache[geoCacheID];
            } else {

                var anzahl = this._vf.subdivision;

                for (var i = 0; i <= anzahl; i++) {
                    var theta = i * ((2 * Math.PI) / anzahl);

                    var x = Math.cos(theta) * r;
                    var y = Math.sin(theta) * r;

                    this._mesh._positions[0].push(x);
                    this._mesh._positions[0].push(y);
                    this._mesh._positions[0].push(0.0);
                }


                for (i = 0; i < anzahl; i++) {
                    this._mesh._indices[0].push(i);
                    if ((i + 1) == anzahl) {
                        this._mesh._indices[0].push(0);
                    } else {
                        this._mesh._indices[0].push(i + 1);
                    }
                }

                this._mesh._invalidate = true;
                this._mesh._numFaces = this._mesh._indices[0].length / 2;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                x3dom.geoCache[geoCacheID] = this._mesh;
            }
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "radius" || fieldName == "subdivision") {
                    var r = this._vf.radius;
                    var anzahl = this._vf.subdivision;

                    this._mesh._positions[0] = [];
                    this._mesh._indices[0] = [];

                    for (var i = 0; i <= anzahl; i++) {
                        var theta = i * ((2 * Math.PI) / anzahl);

                        var x = Math.cos(theta) * r;
                        var y = Math.sin(theta) * r;

                        this._mesh._positions[0].push(x);
                        this._mesh._positions[0].push(y);
                        this._mesh._positions[0].push(0.0);
                    }

                    for (i = 0; i < anzahl; i++) {
                        this._mesh._indices[0].push(i);
                        if ((i + 1) == anzahl) {
                            this._mesh._indices[0].push(0);
                        } else {
                            this._mesh._indices[0].push(i + 1);
                        }
                    }

                    this.invalidateVolume();
                    this._mesh._numFaces = this._mesh._indices[0].length / 2;
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.positions = true;
                        node._dirty.indexes = true;
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);

/* ### Disk2D ### */
x3dom.registerNodeType(
    "Disk2D",
    "Geometry2D",
    defineClass(x3dom.nodeTypes.X3DPlanarGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Disk2D.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'innerRadius', 0);
            this.addField_SFFloat(ctx, 'outerRadius', 1);
            this.addField_SFFloat(ctx, 'subdivision', 32);

            var ir = this._vf.innerRadius;
            var or = this._vf.outerRadius;

            var geoCacheID = 'Disk2D_' + ir + or;

            if (this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined) {
                //x3dom.debug.logInfo("Using Disk2D from Cache");
                this._mesh = x3dom.geoCache[geoCacheID];
            } else {

                var anzahl = this._vf.subdivision;
                for (var i = 0; i <= anzahl; i++) {

                    var theta = i * ((2 * Math.PI) / anzahl);

                    var ox = Math.cos(theta) * or;
                    var oy = Math.sin(theta) * or;
                    var ix = Math.cos(theta) * ir;
                    var iy = Math.sin(theta) * ir;
                    this._mesh._positions[0].push(ox);
                    this._mesh._positions[0].push(oy);
                    this._mesh._positions[0].push(0.0);

                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(1);

                    this._mesh._texCoords[0].push((ox + or) / (2 * or));
                    this._mesh._texCoords[0].push((oy + or) / (2 * or));

                    this._mesh._positions[0].push(ix);
                    this._mesh._positions[0].push(iy);
                    this._mesh._positions[0].push(0.0);

                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(1);
                    this._mesh._texCoords[0].push((ix + or) / (2 * or));
                    this._mesh._texCoords[0].push((iy + or) / (2 * or));
                }

                for (i = 0; i < anzahl * 2; i = i + 2) {
                    if (i == (anzahl * 2) - 2) {
                        this._mesh._indices[0].push(i + 1);
                        this._mesh._indices[0].push(i);
                        this._mesh._indices[0].push(1);

                        this._mesh._indices[0].push(1);
                        this._mesh._indices[0].push(i);
                        this._mesh._indices[0].push(0);
                    } else {
                        this._mesh._indices[0].push(i + 1);
                        this._mesh._indices[0].push(i);
                        this._mesh._indices[0].push(i + 3);

                        this._mesh._indices[0].push(i + 3);
                        this._mesh._indices[0].push(i);
                        this._mesh._indices[0].push(i + 2);
                    }
                }

                this._mesh._numTexComponents = 2;
                this._mesh._invalidate = true;
                this._mesh._numFaces = this._mesh._indices[0].length / 2;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                x3dom.geoCache[geoCacheID] = this._mesh;
            }
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "innerRadius" || fieldName == "outerRadius" ||
                    fieldName == "subdivision") {
                    this._mesh._positions[0] = [];
                    this._mesh._indices[0] = [];
                    this._mesh._normals[0] = [];
                    this._mesh._texCoords[0] = [];

                    var ir = this._vf.innerRadius;
                    var or = this._vf.outerRadius;

                    var anzahl = this._vf.subdivision;
                    for (var i = 0; i <= anzahl; i++) {

                        var theta = i * ((2 * Math.PI) / anzahl);

                        var ox = Math.cos(theta) * or;
                        var oy = Math.sin(theta) * or;
                        var ix = Math.cos(theta) * ir;
                        var iy = Math.sin(theta) * ir;
                        this._mesh._positions[0].push(ox);
                        this._mesh._positions[0].push(oy);
                        this._mesh._positions[0].push(0.0);

                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(1);

                        this._mesh._texCoords[0].push((ox + or) / (2 * or));
                        this._mesh._texCoords[0].push((oy + or) / (2 * or));

                        this._mesh._positions[0].push(ix);
                        this._mesh._positions[0].push(iy);
                        this._mesh._positions[0].push(0.0);

                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(1);
                        this._mesh._texCoords[0].push((ix + or) / (2 * or));
                        this._mesh._texCoords[0].push((iy + or) / (2 * or));
                    }

                    for (i = 0; i < anzahl * 2; i = i + 2) {
                        if (i == (anzahl * 2) - 2) {
                            this._mesh._indices[0].push(i + 1);
                            this._mesh._indices[0].push(i);
                            this._mesh._indices[0].push(1);

                            this._mesh._indices[0].push(1);
                            this._mesh._indices[0].push(i);
                            this._mesh._indices[0].push(0);
                        } else {
                            this._mesh._indices[0].push(i + 1);
                            this._mesh._indices[0].push(i);
                            this._mesh._indices[0].push(i + 3);

                            this._mesh._indices[0].push(i + 3);
                            this._mesh._indices[0].push(i);
                            this._mesh._indices[0].push(i + 2);
                        }
                    }

                    this._mesh._numTexComponents = 2;
                    this.invalidateVolume();
                    this._mesh._numFaces = this._mesh._indices[0].length / 3;
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                    });
                }
            }
        }
    )
);

/* ### Polyline2D ### */
x3dom.registerNodeType(
    "Polyline2D",
    "Geometry2D",
    defineClass(x3dom.nodeTypes.X3DPlanarGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Polyline2D.superClass.call(this, ctx);

            this.addField_MFVec2f(ctx, 'lineSegments', []);

            this._mesh._primType = 'LINES';

            var x = 0, y = 0;
            if (this._vf.lineSegments.length) {
                x = this._vf.lineSegments[0].x;
                y = this._vf.lineSegments[0].y;
            }

            var geoCacheID = 'Polyline2D_' + x + '-' + y;

            if (this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined) {
                //x3dom.debug.logInfo("Using Polyline2D from Cache");
                this._mesh = x3dom.geoCache[geoCacheID];
            }
            else {
                for (var i = 0; i < this._vf.lineSegments.length; i++) {
                    x = this._vf.lineSegments[i].x;
                    y = this._vf.lineSegments[i].y;
                    this._mesh._positions[0].push(x);
                    this._mesh._positions[0].push(y);
                    this._mesh._positions[0].push(0.0);
                }
                for (var j = 0; j < this._vf.lineSegments.length - 1; j++) {
                    this._mesh._indices[0].push(j);
                    this._mesh._indices[0].push(j + 1);
                }

                this._mesh._invalidate = true;
                this._mesh._numFaces = this._mesh._indices[0].length / 2;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                x3dom.geoCache[geoCacheID] = this._mesh;
            }
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "lineSegments") {
                    var x, y;
                    this._mesh._positions[0] = [];
                    this._mesh._indices[0] = [];
                    for (var i = 0; i < this._vf.lineSegments.length; i++) {
                        x = this._vf.lineSegments[i].x;
                        y = this._vf.lineSegments[i].y;
                        this._mesh._positions[0].push(x);
                        this._mesh._positions[0].push(y);
                        this._mesh._positions[0].push(0.0);
                    }
                    for (var j = 0; j < this._vf.lineSegments.length - 1; j++) {
                        this._mesh._indices[0].push(j);
                        this._mesh._indices[0].push(j + 1);
                    }

                    this.invalidateVolume();
                    this._mesh._numFaces = this._mesh._indices[0].length / 2;
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.positions = true;
                        node._dirty.indexes = true;
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);

/* ### Polypoint2D ### */
x3dom.registerNodeType(
    "Polypoint2D",
    "Geometry2D",
    defineClass(x3dom.nodeTypes.X3DPlanarGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Polypoint2D.superClass.call(this, ctx);

            this.addField_MFVec2f(ctx, 'point', []);

            this._mesh._primType = 'POINTS';

            var x = 0, y = 0;
            if (this._vf.point.length) {
                x = this._vf.point[0].x;
                y = this._vf.point[0].y;
            }

            var geoCacheID = 'Polypoint2D_' + x + '-' + y;

            if (this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined) {
                //x3dom.debug.logInfo("Using Polypoint2D from Cache");
                this._mesh = x3dom.geoCache[geoCacheID];
            }
            else {
                for (var i = 0; i < this._vf.point.length; i++) {
                    x = this._vf.point[i].x;
                    y = this._vf.point[i].y;
                    this._mesh._positions[0].push(x);
                    this._mesh._positions[0].push(y);
                    this._mesh._positions[0].push(0.0);
                }

                this._mesh._invalidate = true;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                x3dom.geoCache[geoCacheID] = this._mesh;
            }
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "point") {
                    this._mesh._positions[0] = [];
                    this._mesh._indices[0] = [];
                    for (var i = 0; i < this._vf.point.length; i++) {
                        var x = this._vf.point[i].x;
                        var y = this._vf.point[i].y;
                        this._mesh._positions[0].push(x);
                        this._mesh._positions[0].push(y);
                        this._mesh._positions[0].push(0.0);
                    }

                    this.invalidateVolume();
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.positions = true;
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);

/* ### Rectangle2D ### */
x3dom.registerNodeType(
    "Rectangle2D",
    "Geometry2D",
    defineClass(x3dom.nodeTypes.X3DPlanarGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Rectangle2D.superClass.call(this, ctx);

            this.addField_SFVec2f(ctx, 'size', 2, 2);
            this.addField_SFVec2f(ctx, 'subdivision', 1, 1);

            var sx = this._vf.size.x, sy = this._vf.size.y;
            var partx = this._vf.subdivision.x, party = this._vf.subdivision.y;

            var geoCacheID = 'Rectangle2D_' + sx + '-' + sy;

            if (this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined) {
                //x3dom.debug.logInfo("Using Rectangle2D from Cache");
                this._mesh = x3dom.geoCache[geoCacheID];
            }
            else {
                var xstep = sx / partx;
                var ystep = sy / party;

                sx /= 2;
                sy /= 2;

                for (var i = 0; i <= partx; i++) {
                    for (var j = 0; j <= party; j++) {
                        this._mesh._positions[0].push(i * xstep - sx, j * ystep - sy, 0);
                        this._mesh._normals[0].push(0, 0, 1);
                        this._mesh._texCoords[0].push(i / partx, j / party);
                    }
                }

                for (var i = 1; i <= party; i++) {
                    for (var j = 0; j < partx; j++) {
                        this._mesh._indices[0].push((i - 1) * (partx + 1) + j + 1);
                        this._mesh._indices[0].push((i - 1) * (partx + 1) + j);
                        this._mesh._indices[0].push(i * (partx + 1) + j);

                        this._mesh._indices[0].push((i - 1) * (partx + 1) + j + 1);
                        this._mesh._indices[0].push(i * (partx + 1) + j);
                        this._mesh._indices[0].push(i * (partx + 1) + j + 1);
                    }
                }

                this._mesh._invalidate = true;
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                x3dom.geoCache[geoCacheID] = this._mesh;
            }
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "size") {
                    this._mesh._positions[0] = [];
                    var size = this._vf.size;
                    var sx = size.x / 2;
                    var sy = size.y / 2;

                    var partx = this._vf.subdivision.x, party = this._vf.subdivision.y;

                    var xstep = sx / partx;
                    var ystep = sy / party;

                    sx /= 2;
                    sy /= 2;

                    for (var i = 0; i <= partx; i++) {
                        for (var j = 0; j <= party; j++) {
                            this._mesh._positions[0].push(i * xstep - sx, j * ystep - sy, 0);
                        }
                    }

                    this.invalidateVolume();
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                    });

                } else if (fieldName == "subdivision") {
                    this._mesh._positions[0] = [];
                    this._mesh._indices[0] = [];
                    this._mesh._normals[0] = [];
                    this._mesh._texCoords[0] = [];

                    var sx = this._vf.size.x / 2;
                    var sy = this._vf.size.y / 2;

                    var partx = this._vf.subdivision.x, party = this._vf.subdivision.y;
                    var xstep = sx / partx;
                    var ystep = sy / party;

                    sx /= 2;
                    sy /= 2;

                    for (var i = 0; i <= partx; i++) {
                        for (var j = 0; j <= party; j++) {
                            this._mesh._positions[0].push(i * xstep - sx, j * ystep - sy, 0);
                            this._mesh._normals[0].push(0, 0, 1);
                            this._mesh._texCoords[0].push(i / partx, j / party);
                        }
                    }

                    for (var i = 1; i <= party; i++) {
                        for (var j = 0; j < partx; j++) {
                            this._mesh._indices[0].push((i - 1) * (partx + 1) + j + 1);
                            this._mesh._indices[0].push((i - 1) * (partx + 1) + j);
                            this._mesh._indices[0].push(i * (partx + 1) + j);

                            this._mesh._indices[0].push((i - 1) * (partx + 1) + j + 1);
                            this._mesh._indices[0].push(i * (partx + 1) + j);
                            this._mesh._indices[0].push(i * (partx + 1) + j + 1);
                        }
                    }

                    this.invalidateVolume();
                    this._mesh._numFaces = this._mesh._indices[0].length / 3;
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                    });
                }
            }
        }
    )
);

/* ### TriangleSet2D ### */
x3dom.registerNodeType(
    "TriangleSet2D",
    "Geometry2D",
    defineClass(x3dom.nodeTypes.X3DPlanarGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.TriangleSet2D.superClass.call(this, ctx);

            this.addField_MFVec2f(ctx, 'vertices', []);
            this.addField_MFVec2f(ctx, 'lineSegments', []);

            var x = 0, y = 0;
            if (this._vf.vertices.length) {
                x = this._vf.vertices[0].x;
                y = this._vf.vertices[0].y;
            }

            var geoCacheID = 'TriangleSet2D_' + x + '-' + y;

            if (this._vf.useGeoCache && x3dom.geoCache[geoCacheID] !== undefined) {
                //x3dom.debug.logInfo("Using TriangleSet2D from Cache");
                this._mesh = x3dom.geoCache[geoCacheID];
            }
            else {
                var minx = 0, miny = 0, maxx = 0, maxy = 0;

                if (this._vf.vertices.length) {
                    minx = this._vf.vertices[0].x;
                    miny = this._vf.vertices[0].y;
                    maxx = this._vf.vertices[0].x;
                    maxy = this._vf.vertices[0].y;
                }

                for (var i = 0; i < this._vf.vertices.length; i++) {
                    if (this._vf.vertices[i].x < minx) {
                        minx = this._vf.vertices[i].x
                    }
                    if (this._vf.vertices[i].y < miny) {
                        miny = this._vf.vertices[i].y
                    }
                    if (this._vf.vertices[i].x > maxx) {
                        maxx = this._vf.vertices[i].x
                    }
                    if (this._vf.vertices[i].y > maxy) {
                        maxy = this._vf.vertices[i].y
                    }
                }

                for (var i = 0; i < this._vf.vertices.length; i++) {
                    x = this._vf.vertices[i].x;
                    y = this._vf.vertices[i].y;
                    this._mesh._positions[0].push(x);
                    this._mesh._positions[0].push(y);
                    this._mesh._positions[0].push(0.0);

                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(1);

                    this._mesh._texCoords[0].push((x - minx) / (maxx - minx));
                    this._mesh._texCoords[0].push((y - miny) / (maxy - miny));
                }

                for (var j = 0; j < this._vf.vertices.length; j += 3) {
                    this._mesh._indices[0].push(j);
                    this._mesh._indices[0].push(j + 2);
                    this._mesh._indices[0].push(j + 1);
                }

                this._mesh._numTexComponents = 2;
                this._mesh._invalidate = true;
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;

                x3dom.geoCache[geoCacheID] = this._mesh;
            }
        },
        {
            fieldChanged: function (fieldName) {
                if (fieldName == "vertices" || fieldName == "lineSegments") {
                    this._mesh._positions[0] = [];
                    this._mesh._indices[0] = [];
                    this._mesh._normals[0] = [];
                    this._mesh._texCoords[0] = [];

                    var minx = this._vf.vertices[0].x;
                    var miny = this._vf.vertices[0].y;
                    var maxx = this._vf.vertices[0].x;
                    var maxy = this._vf.vertices[0].y;

                    for (var i = 0; i < this._vf.vertices.length; i++) {
                        if (this._vf.vertices[i].x < minx) {
                            minx = this._vf.vertices[i].x
                        }
                        if (this._vf.vertices[i].y < miny) {
                            miny = this._vf.vertices[i].y
                        }
                        if (this._vf.vertices[i].x > maxx) {
                            maxx = this._vf.vertices[i].x
                        }
                        if (this._vf.vertices[i].y > maxy) {
                            maxy = this._vf.vertices[i].y
                        }
                    }

                    for (var i = 0; i < this._vf.vertices.length; i++) {
                        var x = this._vf.vertices[i].x;
                        var y = this._vf.vertices[i].y;
                        this._mesh._positions[0].push(x);
                        this._mesh._positions[0].push(y);
                        this._mesh._positions[0].push(0.0);

                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(0);
                        this._mesh._normals[0].push(1);

                        this._mesh._texCoords[0].push((x - minx) / (maxx - minx));
                        this._mesh._texCoords[0].push((y - miny) / (maxy - miny));
                    }

                    for (var j = 0; j < this._vf.vertices.length; j += 3) {
                        this._mesh._indices[0].push(j);
                        this._mesh._indices[0].push(j + 2);
                        this._mesh._indices[0].push(j + 1);
                    }

                    this._mesh._numTexComponents = 2;
                    this.invalidateVolume();
                    this._mesh._numFaces = this._mesh._indices[0].length / 3;
                    this._mesh._numCoords = this._mesh._positions[0].length / 3;

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                    });
                }
            }
        }
    )
);

/*
 * MEDX3DOM JavaScript Library
 * http://medx3dom.org
 *
 * (C)2011 Vicomtech Research Center,
 *         Donostia - San Sebastian
 * Dual licensed under the MIT and GPL.
 *
 * Based on code originally provided by
 * http://www.x3dom.org
 */

 /**
  * http://igraphics.com/Standards/ISO_IEC_19775_1_2_PDAM1_Candidate_2011_05_12/Part01/components/volume.html
  */

/* ### X3DVolumeDataNode ### */
x3dom.registerNodeType(
    "X3DVolumeDataNode",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DShapeNode,   // changed inheritance!
        function (ctx) {
            x3dom.nodeTypes.X3DVolumeDataNode.superClass.call(this, ctx);

            this.addField_SFVec3f(ctx, 'dimensions', 1, 1, 1);
            this.addField_SFNode('voxels', x3dom.nodeTypes.Texture);
            //this.addField_MFNode('voxels', x3dom.nodeTypes.X3DTexture3DNode);
            //this.addField_SFBool(ctx, 'swapped', false);
            //this.addField_SFVec3f(ctx, 'sliceThickness', 1, 1, 1);

            x3dom.debug.logWarning('VolumeRendering component NYI!!!');
        },
        {
            getTextureSize: function(texture) {
                var size = { w: 0, h: 0, valid: false };
                var texBag = this._webgl ? this._webgl.texture : null;
                var t, n = (texture && texBag) ? texBag.length : 0;

                for (t=0; t<n; t++) {
                    if (texture == texBag[t].node && texBag[t].texture) {
                        size.w = texBag[t].texture.width;
                        size.h = texBag[t].texture.height;
                        if (size.w && size.h) {
                            size.valid = true;
                        }
                        break;
                    }
                }

                return size;
            }
        }
    )
);

/* ### X3DVolumeRenderStyleNode ### */
x3dom.registerNodeType(
    "X3DVolumeRenderStyleNode",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DNode,
        function (ctx) {
            x3dom.nodeTypes.X3DVolumeRenderStyleNode.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'enabled', true);

            this.preamble = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n" +
                            "  precision highp float;\n" +
                            "#else\n" +
                            "  precision mediump float;\n" +
                            "#endif\n\n";
        },
        {
            vertexShaderText: function(){
                var shader = 
                "attribute vec3 position;\n"+
                "attribute vec3 color;\n"+
                "uniform mat4 modelViewProjectionMatrix;\n"+
                "varying vec3 vertexColor;\n"+
                "varying vec4 vertexPosition;\n"+
                "\n" +
                "void main()\n"+
                "{\n"+
                "  vertexColor = color;\n"+
                "  vertexPosition = modelViewProjectionMatrix * vec4(position, 1.0);\n"+
                "  gl_Position = vertexPosition;\n"+
                "}";
                return shader;
            },

            defaultUniformsShaderText: function(numberOfSlices, slicesOverX, slicesOverY){
                var uniformsText = 
                "uniform sampler2D uBackCoord;\n"+
                "uniform sampler2D uVolData;\n"+
                "uniform mat4 normalMatrix;\n"+
                "varying vec3 vertexColor;\n"+
                "varying vec4 vertexPosition;\n"+
                "const float Steps = 60.0;\n"+
                "const float numberOfSlices = "+ numberOfSlices.toPrecision(5)+";\n"+
                "const float slicesOverX = " + slicesOverX.toPrecision(5) +";\n"+
                "const float slicesOverY = " + slicesOverY.toPrecision(5) +";\n";
                return uniformsText;
            },

            texture3DFunctionShaderText: "vec4 cTexture3D(sampler2D vol, vec3 volpos, float nS, float nX, float nY)\n"+
                "{\n"+
                "  float s1,s2;\n"+
                "  float dx1,dy1;\n"+
                "  float dx2,dy2;\n"+
                "  vec2 texpos1,texpos2;\n"+
                "  s1 = floor(volpos.z*nS);\n"+
                "  s2 = s1+1.0;\n"+
                "  dx1 = fract(s1/nX);\n"+
                "  dy1 = floor(s1/nY)/nY;\n"+
                "  dx2 = fract(s2/nX);\n"+
                "  dy2 = floor(s2/nY)/nY;\n"+
                "  texpos1.x = dx1+(volpos.x/nX);\n"+
                "  texpos1.y = dy1+(volpos.y/nY);\n"+
                "  texpos2.x = dx2+(volpos.x/nX);\n"+
                "  texpos2.y = dy2+(volpos.y/nY);\n"+
                "  return mix( texture2D(vol,texpos1), texture2D(vol,texpos2), (volpos.z*nS)-s1);\n"+
                "}\n"+
                "\n",

            lightEquationShaderText: "void lighting(in float lType, in vec3 lLocation, in vec3 lDirection, in vec3 lColor, in vec3 lAttenuation, " + 
                "in float lRadius, in float lIntensity, in float lAmbientIntensity, in float lBeamWidth, " +
                "in float lCutOffAngle, in vec3 N, in vec3 V, inout vec3 ambient, inout vec3 diffuse, " +
                "inout vec3 specular)\n" +
                "{\n" +
                "   vec3 L;\n" +
                "   float spot = 1.0, attentuation = 0.0;\n" +
                "   if(lType == 0.0) {\n" +
                "       L = -normalize(lDirection);\n" +
                "       V = normalize(V);\n" +
                "       attentuation = 1.0;\n" +
                "   } else{\n" +
                "       L = (lLocation - (-V));\n" +
                "       float d = length(L);\n" +
                "       L = normalize(L);\n" +
                "       V = normalize(V);\n" +
                "       if(lRadius == 0.0 || d <= lRadius) {\n" +
                "           attentuation = 1.0 / max(lAttenuation.x + lAttenuation.y * d + lAttenuation.z * (d * d), 1.0);\n" +
                "       }\n" +
                "       if(lType == 2.0) {\n" +
                "           float spotAngle = acos(max(0.0, dot(-L, normalize(lDirection))));\n" +
                "           if(spotAngle >= lCutOffAngle) spot = 0.0;\n" +
                "           else if(spotAngle <= lBeamWidth) spot = 1.0;\n" +
                "           else spot = (spotAngle - lCutOffAngle ) / (lBeamWidth - lCutOffAngle);\n" +
                "       }\n" +
                "   }\n" +   
                "   vec3  H = normalize( L + V );\n" +
                "   float NdotL = max(0.0, dot(L, N));\n" +
                "   float NdotH = max(0.0, dot(H, N));\n" +   
                "   float ambientFactor  = lAmbientIntensity;\n" +
                "   float diffuseFactor  = lIntensity * NdotL;\n" +
                "   float specularFactor = lIntensity * pow(NdotH,128.0);\n" +
                "   ambient  += lColor * ambientFactor * attentuation * spot;\n" +
                "   diffuse  += lColor * diffuseFactor * attentuation * spot;\n" +
                "   specular += lColor * specularFactor * attentuation * spot;\n" +  
                "}\n",

            normalFunctionShaderText: function(){
                if (this._cf.surfaceNormals.node) {
                    // The surface normals, are taken from the given texture, must be of the same size of the Volume Data
                    return "vec4 getNormal(vec3 pos, float nS, float nX, float nY) {\n"+
                    "   vec4 n = cTexture3D(uSurfaceNormals, pos, nS, nX, nY);\n"+
                    "   n.xyz = (2.0*n.xyz)-1.0;\n"+
                    "   n.xyz = (normalMatrix * vec4(n.xyz, 0.0)).xyz;\n"+
                    "   n.a = length(n.xyz);\n"+
                    "   n.xyz = normalize(n.xyz);\n"+
                    "   return n;\n"+
                    "}\n"+
                    "\n";
                }else{
                    // No extra texture provided, the surface normals are obtained by calculating the gradient with the Central differences method on each sampled voxel
                    return "vec4 getNormal(vec3 voxPos, float nS, float nX, float nY){\n"+
                    "   float v0 = cTexture3D(uVolData, voxPos + vec3(offset.x, 0, 0), nS, nX, nY).r;\n"+
                    "   float v1 = cTexture3D(uVolData, voxPos - vec3(offset.x, 0, 0), nS, nX, nY).r;\n"+
                    "   float v2 = cTexture3D(uVolData, voxPos + vec3(0, offset.y, 0), nS, nX, nY).r;\n"+
                    "   float v3 = cTexture3D(uVolData, voxPos - vec3(0, offset.y, 0), nS, nX, nY).r;\n"+
                    "   float v4 = cTexture3D(uVolData, voxPos + vec3(0, 0, offset.z), nS, nX, nY).r;\n"+
                    "   float v5 = cTexture3D(uVolData, voxPos - vec3(0, 0, offset.z), nS, nX, nY).r;\n"+
                    "   vec3 grad = (normalMatrix * vec4((v0-v1)/2.0, (v2-v3)/2.0, (v4-v5)/2.0, 0.0)).xyz;\n"+
                    "   return vec4(normalize(grad), length(grad));\n"+
                    "}\n"+
                    "\n";
                }
            },    

            //Takes an array as an argument which contains the calls that will be made inside the main loop
            defaultLoopFragmentShaderText: function(inlineShaderText, inlineLightAssigment){
                var shaderLoop = "void main()\n"+
                "{\n"+
                "  vec2 texC = vertexPosition.xy/vertexPosition.w;\n"+
                "  texC = 0.5*texC + 0.5;\n"+
                "  vec4 backColor = texture2D(uBackCoord,texC);\n"+
                "  vec3 dir = backColor.rgb - vertexColor.rgb;\n"+
                "  vec3 pos = vertexColor;\n"+
                "  vec4 accum  = vec4(0.0, 0.0, 0.0, 0.0);\n"+
                "  vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);\n"+
                "  vec4 value  = vec4(0.0, 0.0, 0.0, 0.0);\n";
                //Light init values
                if(x3dom.nodeTypes.X3DLightNode.lightID>0){
                    shaderLoop +=
                    "  vec3 ambient = vec3(0.0, 0.0, 0.0);\n"+
                    "  vec3 diffuse = vec3(0.0, 0.0, 0.0);\n"+
                    "  vec3 specular = vec3(0.0, 0.0, 0.0);\n";
                }
                shaderLoop +=
                "  float cont = 0.0;\n"+
                "  vec3 step = dir/Steps;\n";
                if(x3dom.nodeTypes.X3DLightNode.lightID>0){
                    shaderLoop += "  float lightFactor = 1.0;\n";
                }else{
                    shaderLoop += "  float lightFactor = 1.2;\n";
                }
                shaderLoop +=
                "  float opacityFactor = 6.0;\n"+
                "  for(float i = 0.0; i < Steps; i+=1.0)\n"+
                "  {\n"+
                "    value = cTexture3D(uVolData,pos,numberOfSlices,slicesOverX,slicesOverY);\n"+
                "    value = vec4(value.rgb,(0.299*value.r)+(0.587*value.g)+(0.114*value.b));\n"+
                "    vec4 grad = getNormal(pos,numberOfSlices,slicesOverX,slicesOverY);\n";
                for(var l=0; l<x3dom.nodeTypes.X3DLightNode.lightID; l++) {
                    shaderLoop += "    lighting(light"+l+"_Type, " +
                    "light"+l+"_Location, " +
                    "light"+l+"_Direction, " +
                    "light"+l+"_Color, " + 
                    "light"+l+"_Attenuation, " +
                    "light"+l+"_Radius, " +
                    "light"+l+"_Intensity, " + 
                    "light"+l+"_AmbientIntensity, " +
                    "light"+l+"_BeamWidth, " +
                    "light"+l+"_CutOffAngle, " +
                    "grad.xyz, dir, ambient, diffuse, specular);\n";
                }
                shaderLoop += inlineShaderText;
                if(x3dom.nodeTypes.X3DLightNode.lightID>0){
                    shaderLoop += inlineLightAssigment;
                }
                shaderLoop +=
                "    //Process the volume sample\n"+
                "    sample.a = value.a * opacityFactor * (1.0/Steps);\n"+
                "    sample.rgb = value.rgb * sample.a * lightFactor ;\n"+
                "    accum.rgb += (1.0 - accum.a) * sample.rgb;\n"+
                "    accum.a += (1.0 - accum.a) * sample.a;\n"+
                "    //advance the current position\n"+
                "    pos.xyz += step;\n"+
                "    //break if the position is greater than <1, 1, 1>\n"+
                "    if(pos.x > 1.0 || pos.y > 1.0 || pos.z > 1.0 || accum.a>=1.0)\n"+
                "      break;\n"+
                "  }\n"+
                "  gl_FragColor = accum;\n"+
                "}";
                return shaderLoop;
            }
        }
    )
);

/* ### X3DComposableVolumeRenderStyleNode ### */
x3dom.registerNodeType(
    "X3DComposableVolumeRenderStyleNode",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode.superClass.call(this, ctx);

            this.addField_SFNode('surfaceNormals', x3dom.nodeTypes.X3DTexture3DNode);
        },
        {
            defaultUniformsShaderText: function(numberOfSlices, slicesOverX, slicesOverY, offset){
               var uniformsText = 
                "uniform sampler2D uBackCoord;\n"+
                "uniform sampler2D uVolData;\n"+
                "uniform mat4 normalMatrix;\n";
                if (!(this._cf.surfaceNormals.node==null)) {
                    uniformsText += "uniform sampler2D uSurfaceNormals;\n";
                }
                uniformsText +=
                "varying vec3 vertexColor;\n"+
                "varying vec4 vertexPosition;\n"+
                "const float Steps = 60.0;\n"+
                "const float numberOfSlices = "+ numberOfSlices.toPrecision(5)+";\n"+
                "const float slicesOverX = " + slicesOverX.toPrecision(5) +";\n"+
                "const float slicesOverY = " + slicesOverY.toPrecision(5) +";\n"+
                "const vec3 offset = vec3(0.5/512.0, 0.5/512.0, 0.5/96.0);\n";
                //LIGHTS
                var n_lights = x3dom.nodeTypes.X3DLightNode.lightID;
                for(var l=0; l<n_lights; l++) {
                    uniformsText +=   "uniform float light"+l+"_On;\n" +
                    "uniform float light"+l+"_Type;\n" +
                    "uniform vec3  light"+l+"_Location;\n" +
                    "uniform vec3  light"+l+"_Direction;\n" +
                    "uniform vec3  light"+l+"_Color;\n" +
                    "uniform vec3  light"+l+"_Attenuation;\n" +
                    "uniform float light"+l+"_Radius;\n" +
                    "uniform float light"+l+"_Intensity;\n" +
                    "uniform float light"+l+"_AmbientIntensity;\n" +
                    "uniform float light"+l+"_BeamWidth;\n" +
                    "uniform float light"+l+"_CutOffAngle;\n" +
                    "uniform float light"+l+"_ShadowIntensity;\n";
                }
                return uniformsText;
            }
        }
    )
);

/* ### BlendedVolumeStyle ### */
x3dom.registerNodeType(
    "BlendedVolumeStyle",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.BlendedVolumeStyle.superClass.call(this, ctx);

            this.addField_SFNode('renderStyle', x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode);
            this.addField_SFNode('voxels', x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode);
            this.addField_SFFloat(ctx, 'weightConstant1', 0.5);
            this.addField_SFFloat(ctx, 'weightConstant2', 0.5);
            this.addField_SFString(ctx, 'weightFunction1', "CONSTANT");
            this.addField_SFString(ctx, 'weightFunction2', "CONSTANT");
            this.addField_SFNode('weightTransferFunction1', x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode);
            this.addField_SFNode('weightTransferFunction2', x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode);
        }
    )
);

/* ### BoundaryEnhancementVolumeStyle ### */
x3dom.registerNodeType(
    "BoundaryEnhancementVolumeStyle",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.BoundaryEnhancementVolumeStyle.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'retainedOpacity', 1);
            this.addField_SFFloat(ctx, 'boundaryOpacity', 0);
            this.addField_SFFloat(ctx, 'opacityFactor', 1);
        }
    )
);

/* ### CartoonVolumeStyle ### */
x3dom.registerNodeType(
    "CartoonVolumeStyle",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.CartoonVolumeStyle.superClass.call(this, ctx);

            this.addField_SFColor(ctx, 'parallelColor', 0, 0, 0);
            this.addField_SFColor(ctx, 'orthogonalColor', 1, 1, 1);
            this.addField_SFInt32(ctx, 'colorSteps', 4);
        }
    )
);

/* ### ComposedVolumeStyle ### */
x3dom.registerNodeType(
    "ComposedVolumeStyle",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.ComposedVolumeStyle.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'ordered', false);
            this.addField_MFNode('renderStyle', x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode);
        }
    )
);

/* ### EdgeEnhancementVolumeStyle ### */
x3dom.registerNodeType(
    "EdgeEnhancementVolumeStyle",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.EdgeEnhancementVolumeStyle.superClass.call(this, ctx);

            this.addField_SFColor(ctx, 'edgeColor', 0, 0, 0);
            this.addField_SFFloat(ctx, 'gradientThreshold', 0.4);
        }
    )
);

/* ### ISOSurfaceVolumeData ### */
x3dom.registerNodeType(
    "ISOSurfaceVolumeData",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DVolumeDataNode,
        function (ctx) {
            x3dom.nodeTypes.ISOSurfaceVolumeData.superClass.call(this, ctx);

            this.addField_MFNode('renderStyle', x3dom.nodeTypes.X3DVolumeRenderStyleNode);
            this.addField_SFNode('gradients', x3dom.nodeTypes.X3DTexture3DNode);
            this.addField_MFFloat(ctx, 'surfaceValues', []);
            this.addField_SFFloat(ctx, 'contourStepSize', 0);
            this.addField_SFFloat(ctx, 'surfaceTolerance', 0);
        }
    )
);

/* ### MPRVolumeStyle ### */
x3dom.registerNodeType(
     "MPRVolumeStyle",
     "VolumeRendering",
     defineClass(x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode,
         function (ctx) {
            x3dom.nodeTypes.MPRVolumeStyle.superClass.call(this, ctx);
            
            this.addField_SFVec3f(ctx, 'originLine', 1.0, 1.0, 0.0);
            this.addField_SFVec3f(ctx, 'finalLine', 0.0, 1.0, 0.0);
            this.addField_SFFloat(ctx, 'positionLine', 0.2);
            
            this.uniformVec3fOriginLine = new x3dom.nodeTypes.Uniform(ctx);
            this.uniformVec3fFinalLine = new x3dom.nodeTypes.Uniform(ctx);
            this.uniformFloatPosition = new x3dom.nodeTypes.Uniform(ctx);
         },
         {
            fieldChanged: function(fieldName) {
                 if (fieldName == "originLine" || fieldName == "finalLine" ||
                     fieldName == "positionLine") {
                      //var that = this;
                      //Array.forEach(this._parentNodes, function (vol) {
                      //  vol.updateFields("positionLine", that._vf.positionLine);
                      //});
                     this.uniformFloatPosition._vf.value = this._vf.positionLine;
                     this.uniformFloatPosition.fieldChanged("value");
                 }
            },

            uniforms: function() {
                var unis = [];

                this.uniformVec3fOriginLine._vf.name = 'originLine';
                this.uniformVec3fOriginLine._vf.type = 'SFVec3f';
                this.uniformVec3fOriginLine._vf.value = this._vf.originLine.toString();
                unis.push(this.uniformVec3fOriginLine);

                this.uniformVec3fFinalLine._vf.name = 'finalLine';
                this.uniformVec3fFinalLine._vf.type = 'SFVec3f';
                this.uniformVec3fFinalLine._vf.value = this._vf.finalLine.toString();
                unis.push(this.uniformVec3fFinalLine);

                this.uniformFloatPosition._vf.name = 'positionLine';
                this.uniformFloatPosition._vf.type = 'SFFloat';
                this.uniformFloatPosition._vf.value = this._vf.positionLine;
                unis.push(this.uniformFloatPosition);
  
                return unis;
            },

            styleUniformsShaderText: function(){
                return "uniform vec3 originLine;\nuniform vec3 finalLine;\nuniform float positionLine;\n";
            },

            fragmentShaderText : function (numberOfSlices, slicesOverX, slicesOverY) {
                var shader = 
                this.preamble+
                this.defaultUniformsShaderText(numberOfSlices, slicesOverX, slicesOverY)+
                this.styleUniformsShaderText()+
                this.texture3DFunctionShaderText+
                "void main()\n"+
                "{\n"+
                "  vec2 texC = vertexPosition.xy/vertexPosition.w;\n"+
                "  texC = 0.5*texC + 0.5;\n"+
                "  vec4 backColor = texture2D(uBackCoord,texC);\n"+
                "  vec3 dir =  backColor.xyz -vertexColor.xyz;\n"+
                "  vec3 normalPlane = finalLine-originLine;\n"+
                "  vec3 pointLine = normalPlane*positionLine+originLine;\n"+
                "  float d = dot(pointLine-vertexColor.xyz,normalPlane)/dot(dir,normalPlane);\n"+
                "  vec4 color = vec4(0.0,0.0,0.0,0.0);\n"+
                "  vec3 pos = d*dir+vertexColor.rgb;\n"+
                "  if (!(pos.x > 1.0 || pos.y > 1.0 || pos.z > 1.0 || pos.x<0.0 || pos.y<0.0 || pos.z<0.0)){\n"+
                "    color = vec4(cTexture3D(uVolData,pos.rgb,numberOfSlices,slicesOverX,slicesOverY).rgb,1.0);\n"+
                "  }\n"+
                "  gl_FragColor = color;\n"+
                "}";
                return shader;
            }
         }
    )
);

/* ### OpacityMapVolumeStyle ### */
x3dom.registerNodeType(
    "OpacityMapVolumeStyle",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.OpacityMapVolumeStyle.superClass.call(this, ctx);

            this.addField_SFNode('transferFunction', x3dom.nodeTypes.Texture);
            this.addField_SFString(ctx, 'type', "simple");
            this.addField_SFFloat(ctx, 'opacityFactor', 6.0);
            this.addField_SFFloat(ctx, 'lightFactor', 1.2);

            this.uniformFloatOpacityFactor = new x3dom.nodeTypes.Uniform(ctx);
            this.uniformFloatLightFactor = new x3dom.nodeTypes.Uniform(ctx);
            this.uniformSampler2DTransferFunction = new x3dom.nodeTypes.Uniform(ctx);
        },
        {
            uniforms: function() {
                var unis = [];
                
                if (this._cf.transferFunction.node) {
                    this.uniformSampler2DTransferFunction._vf.name = 'uTransferFunction';
                    this.uniformSampler2DTransferFunction._vf.type = 'SFInt32';
                    this.uniformSampler2DTransferFunction._vf.value = 2; //FIXME: Number of textures could be variable
                    unis.push(this.uniformSampler2DTransferFunction);
                }

                this.uniformFloatOpacityFactor._vf.name = 'uOpacityFactor';
                this.uniformFloatOpacityFactor._vf.type = 'SFFloat';
                this.uniformFloatOpacityFactor._vf.value = this._vf.opacityFactor;
                unis.push(this.uniformFloatOpacityFactor);

                this.uniformFloatLightFactor._vf.name = 'uLightFactor';
                this.uniformFloatLightFactor._vf.type = 'SFFloat';
                this.uniformFloatLightFactor._vf.value = this._vf.lightFactor;
                unis.push(this.uniformFloatLightFactor);

                return unis;
            },

            textures: function() {
                var texs = [];
                var tex = this._cf.transferFunction.node;
                if (tex) {
                    tex._vf.repeatS = false;
                    tex._vf.repeatT = false;
                    texs.push(tex)
                }
                return texs;
            },

            styleUniformsShaderText: function() {
                var uniformsText = "uniform float uOpacityFactor;\n"+
                "uniform float uLightFactor;\n";
                if (this._cf.transferFunction.node) {
                        uniformsText += "uniform sampler2D uTransferFunction;\n";
                }
                return uniformsText;
            },

            inlineStyleShaderText: function(){
                var shaderText =
                "    opacityFactor = uOpacityFactor;\n"+
                "    lightFactor = uLightFactor;\n";
                if (this._cf.transferFunction.node){
                        shaderText += "    value = texture2D(uTransferFunction,vec2(value.r,0.5));\n";
                }
                return shaderText;
            },

            lightAssigment: function(){
                return "value.rgb = ambient*value.rgb + diffuse*value.rgb + specular;\n";
            },

            fragmentShaderText : function (numberOfSlices, slicesOverX, slicesOverY) {
                var shader = 
                this.preamble+
                this.defaultUniformsShaderText(numberOfSlices, slicesOverX, slicesOverY)+
                this.styleUniformsShaderText()+
                this.texture3DFunctionShaderText+
                this.normalFunctionShaderText()+
                this.lightEquationShaderText+
                this.defaultLoopFragmentShaderText(this.inlineStyleShaderText(), this.lightAssigment());
                return shader;
            }
        }
    )
);

/* ### ProjectionVolumeStyle ### */
x3dom.registerNodeType(
    "ProjectionVolumeStyle",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.ProjectionVolumeStyle.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'intensityThreshold', 0);
            this.addField_SFString(ctx, 'type', "MAX");

            this.uniformIntensityThreshold = new x3dom.nodeTypes.Uniform(ctx);
            this.uniformType = new x3dom.nodeTypes.Uniform(ctx);
        },
        {
            uniforms: function(){
                var unis = [];
                var type_map = {'max':0,'min':1,'average':2};

                this.uniformIntensityThreshold._vf.name = 'uIntensityThreshold';
                this.uniformIntensityThreshold._vf.type = 'SFFloat';
                this.uniformIntensityThreshold._vf.value = this._vf.intensityThreshold;
                unis.push(this.uniformIntensityThreshold);

                this.uniformType._vf.name = 'uType';
                this.uniformType._vf.type = 'SFInt32';
                this.uniformType._vf.value = type_map[this._vf.type.toLowerCase()];
                unis.push(this.uniformType);

                return unis;
            },

            styleUniformsShaderText: function(){
                return "uniform int uType;\nuniform float uIntensityThreshold;\n";
            },

            fragmentShaderText: function(numberOfSlices, slicesOverX, slicesOverY){
                var shader = 
                this.preamble+
                this.defaultUniformsShaderText(numberOfSlices, slicesOverX, slicesOverY)+
                this.styleUniformsShaderText()+
                this.texture3DFunctionShaderText+
                "void main()\n"+
                "{\n"+
                "  vec2 texC = vertexPosition.xy/vertexPosition.w;\n"+
                "  texC = 0.5*texC + 0.5;\n"+
                "  vec4 backColor = texture2D(uBackCoord,texC);\n"+
                "  vec3 dir = backColor.rgb - vertexColor.rgb;\n"+
                "  vec3 pos = vertexColor;\n"+
                "  vec4 accum  = vec4(0.0, 0.0, 0.0, 0.0);\n"+
                "  vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);\n"+
                "  vec4 value  = vec4(0.0, 0.0, 0.0, 0.0);\n"+
                "  vec4 color  = vec4(0.0);\n";
                if (this._vf.type.toLowerCase() === "max") {
                    shader += "vec2 previous_value = vec2(0.0);\n";
                }else {
                    shader += "vec2 previous_value = vec2(1.0);\n";
                }
                shader +=
                "  float cont = 0.0;\n"+
                "  vec3 step = dir/Steps;\n"+
                "  const float lightFactor = 1.3;\n"+
                "  const float opacityFactor = 3.0;\n"+
                "  for(float i = 0.0; i < Steps; i+=1.0)\n"+
                "  {\n"+
                "    value = cTexture3D(uVolData,pos,numberOfSlices,slicesOverX,slicesOverY);\n"+
                "    value = vec4(value.rgb,(0.299*value.r)+(0.587*value.g)+(0.114*value.b));\n"+
                "    //Process the volume sample\n"+
                "    sample.a = value.a * opacityFactor * (1.0/Steps);\n"+
                "    sample.rgb = value.rgb * sample.a * lightFactor;\n"+
                "    accum.a += (1.0-accum.a)*sample.a;\n";
                switch (this._vf.type.toLowerCase()) {
                    case "max":
                        shader += "if(value.r > uIntensityThreshold && value.r <= previous_value.x){\n"+
                        "   break;\n"+
                        "}\n"+
                        "color.rgb = vec3(max(value.r, previous_value.x));\n"+
                        "color.a = (value.r > previous_value.x) ? accum.a : previous_value.y;\n";
                        break;
                    case "min":
                        shader += "if(value.r < uIntensityThreshold && value.r >= previous_value.x){\n"+
                        "   break;\n"+
                        "}\n"+
                        "color.rgb = vec3(min(value.r, previous_value.x));\n"+
                        "color.a = (value.r < previous_value.x) ? accum.a : previous_value.y;\n";
                        break;
                    case "average":
                        shader+= "color.rgb += (1.0 - accum.a) * sample.rgb;\n"+
                        "color.a = accum.a;\n";
                        break;
                }
                shader += 
                "    //update the previous value and keeping the accumulated alpha\n"+
                "    previous_value.x = color.r;\n"+
                "    previous_value.y = accum.a;\n"+
                "    //advance the current position\n"+
                "    pos.xyz += step;\n"+
                "    //break if the position is greater than <1, 1, 1>\n"+
                "    if(pos.x > 1.0 || pos.y > 1.0 || pos.z > 1.0 || accum.a>=1.0){\n";
                if(this._vf.type.toLowerCase() == "average"){
                    shader += "     if((i > 0.0) && (i < Steps-1.0)){\n"+
                    "color.rgb = color.rgb/i;\n"+
                    "}\n";
                }
                shader+=
                "      break;\n"+
                "    }\n"+
                " }\n"+
                " gl_FragColor = color;\n"+
                "}";
                return shader;
            }
        }
    )
);

/* ### SegmentedVolumeData ### */
x3dom.registerNodeType(
    "SegmentedVolumeData",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DVolumeDataNode,
        function (ctx) {
            x3dom.nodeTypes.SegmentedVolumeData.superClass.call(this, ctx);

            this.addField_MFNode('renderStyle', x3dom.nodeTypes.X3DVolumeDataNode);
            this.addField_SFNode('segmentIdentifiers', x3dom.nodeTypes.X3DVolumeDataNode);
            this.addField_MFBoolean(ctx, 'segmentEnabled', []); // TODO: impl. parsing of MFBoolean in fields.js
        }
    )
);

/* ### ShadedVolumeStyle ### */
x3dom.registerNodeType(
    "ShadedVolumeStyle",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.ShadedVolumeStyle.superClass.call(this, ctx);

            this.addField_SFNode('material', x3dom.nodeTypes.X3DMaterialNode);
            this.addField_SFBool(ctx, 'lighting', false);
            this.addField_SFBool(ctx, 'shadows', false);
            this.addField_SFString(ctx, 'phaseFunction', "Henyey-Greenstein");
        }
    )
);

/* ### SilhouetteEnhancementVolumeStyle ### */
x3dom.registerNodeType(
    "SilhouetteEnhancementVolumeStyle",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.SilhouetteEnhancementVolumeStyle.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'silhouetteBoundaryOpacity', 0);
            this.addField_SFFloat(ctx, 'silhouetteRetainedOpacity', 1);
            this.addField_SFFloat(ctx, 'silhouetteSharpness', 0.5);
        }
    )
);

/* ### StippleVolumeStyle ### */
x3dom.registerNodeType(
    "StippleVolumeStyle",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.StippleVolumeStyle.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'distanceFactor', 1);
            this.addField_SFFloat(ctx, 'interiorFactor', 1);
            this.addField_SFFloat(ctx, 'lightingFactor', 1);
            this.addField_SFFloat(ctx, 'gradientThreshold', 0.4);
            this.addField_SFFloat(ctx, 'gradientRetainedOpacity', 1);
            this.addField_SFFloat(ctx, 'gradientBoundaryOpacity', 0);
            this.addField_SFFloat(ctx, 'gradientOpacityFactor', 1);
            this.addField_SFFloat(ctx, 'silhouetteRetainedOpacity', 1);
            this.addField_SFFloat(ctx, 'silhouetteBoundaryOpacity', 0);
            this.addField_SFFloat(ctx, 'silhouetteOpacityFactor', 1);
            this.addField_SFFloat(ctx, 'resolutionFactor', 1);
        }
    )
);

/* ### ToneMappedVolumeStyle ### */
x3dom.registerNodeType(
    "ToneMappedVolumeStyle",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DComposableVolumeRenderStyleNode,
        function (ctx) {
            x3dom.nodeTypes.ToneMappedVolumeStyle.superClass.call(this, ctx);

            this.addField_SFColor(ctx, 'coolColor', 0, 0, 1);
            this.addField_SFColor(ctx, 'warmColor', 1, 1, 0);
        }
    )
);

/* ### VolumeData ### */
x3dom.registerNodeType(
    "VolumeData",
    "VolumeRendering",
    defineClass(x3dom.nodeTypes.X3DVolumeDataNode,
        function (ctx) {
            x3dom.nodeTypes.VolumeData.superClass.call(this, ctx);

            this.addField_SFNode('renderStyle', x3dom.nodeTypes.X3DVolumeRenderStyleNode);

            this.vrcMultiTexture = new x3dom.nodeTypes.MultiTexture(ctx);
            this.vrcRenderTexture = new x3dom.nodeTypes.RenderedTexture(ctx);
            this.vrcVolumeTexture = null;

            this.vrcBackCubeShape = new x3dom.nodeTypes.Shape(ctx);
            this.vrcBackCubeAppearance = new x3dom.nodeTypes.Appearance();
            this.vrcBackCubeGeometry = new x3dom.nodeTypes.Box(ctx);
            this.vrcBackCubeShader = new x3dom.nodeTypes.ComposedShader(ctx);
            this.vrcBackCubeShaderVertex = new x3dom.nodeTypes.ShaderPart(ctx);
            this.vrcBackCubeShaderFragment = new x3dom.nodeTypes.ShaderPart(ctx);

            this.vrcFrontCubeShader = new x3dom.nodeTypes.ComposedShader(ctx);
            this.vrcFrontCubeShaderVertex = new x3dom.nodeTypes.ShaderPart(ctx);
            this.vrcFrontCubeShaderFragment = new x3dom.nodeTypes.ShaderPart(ctx);
            this.vrcFrontCubeShaderFieldBackCoord = new x3dom.nodeTypes.Field(ctx);
            this.vrcFrontCubeShaderFieldVolData = new x3dom.nodeTypes.Field(ctx);
        },
        {
            // nodeChanged is called after subtree is parsed and attached in DOM
            nodeChanged: function()
            {
                // uhhhh, manually build backend-graph scene-subtree,
                // therefore, try to mimic depth-first parsing scheme
                if (!this._cf.appearance.node) 
                {
                    var that = this;
                    var i;

                    this.addChild(x3dom.nodeTypes.Appearance.defaultNode());
                    
                    // second texture, ray direction and length
                    this.vrcBackCubeShaderVertex._vf.type = 'vertex';
                    this.vrcBackCubeShaderVertex._vf.url[0] =
                        "attribute vec3 position;\n" +
                        "attribute vec3 color;\n" +
                        "varying vec3 fragColor;\n" +
                        "uniform mat4 modelViewProjectionMatrix;\n" +
                        "\n" +
                        "void main(void) {\n" +
                        "    fragColor = color;\n" +
                        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);\n" +
                        "}\n";

                    this.vrcBackCubeShaderFragment._vf.type = 'fragment';
                    this.vrcBackCubeShaderFragment._vf.url[0] =
                        "#ifdef GL_FRAGMENT_PRECISION_HIGH\n" +
                        "  precision highp float;\n" +
                        "#else\n" +
                        "  precision mediump float;\n" +
                        "#endif\n" +
                        "\n" +
                        "varying vec3 fragColor;\n" +
                        "\n" +
                        "void main(void) {\n" +
                        "    gl_FragColor = vec4(fragColor, 1.0);\n" +
                        "}\n";
                    
                    this.vrcBackCubeShader.addChild(this.vrcBackCubeShaderFragment, 'parts');
                    this.vrcBackCubeShaderFragment.nodeChanged();
                    
                    this.vrcBackCubeShader.addChild(this.vrcBackCubeShaderVertex, 'parts');
                    this.vrcBackCubeShaderVertex.nodeChanged();
                    
                    this.vrcBackCubeAppearance.addChild(this.vrcBackCubeShader);
                    this.vrcBackCubeShader.nodeChanged();
                    
                    // initialize fbo - note that internally the datatypes must fit!
                    this.vrcRenderTexture._vf.update = 'always';
                    this.vrcRenderTexture._vf.dimensions = [500, 500, 4];
                    this.vrcRenderTexture._vf.repeatS = false;
                    this.vrcRenderTexture._vf.repeatT = false;
                    this.vrcRenderTexture._nameSpace = this._nameSpace;
                    
                    this.vrcBackCubeGeometry._vf.size = new x3dom.fields.SFVec3f(
                        this._vf.dimensions.x, this._vf.dimensions.y, this._vf.dimensions.z);
                    this.vrcBackCubeGeometry._vf.ccw = false;
                    this.vrcBackCubeGeometry._vf.solid = true;
                    // manually trigger size update
                    this.vrcBackCubeGeometry.fieldChanged("size");
                    
                    this.vrcBackCubeShape.addChild(this.vrcBackCubeGeometry);
                    this.vrcBackCubeGeometry.nodeChanged();
                    
                    this.vrcBackCubeShape.addChild(this.vrcBackCubeAppearance);
                    this.vrcBackCubeAppearance.nodeChanged();
                    
                    this.vrcRenderTexture.addChild(this.vrcBackCubeShape, 'scene');
                    this.vrcBackCubeShape.nodeChanged();
                    
                    // create shortcut to volume data set
                    this.vrcVolumeTexture = this._cf.voxels.node;
                    this.vrcVolumeTexture._vf.repeatS = false;
                    this.vrcVolumeTexture._vf.repeatT = false;
                    
                    this.vrcMultiTexture._nameSpace = this._nameSpace;
                    
                    this.vrcMultiTexture.addChild(this.vrcRenderTexture, 'texture');
                    this.vrcRenderTexture.nodeChanged();
                    
                    this.vrcMultiTexture.addChild(this.vrcVolumeTexture, 'texture');
                    this.vrcVolumeTexture.nodeChanged();
                    
                    // textures from styles
                    if (this._cf.renderStyle.node.textures) {
                        var styleTextures = this._cf.renderStyle.node.textures();
                        for (i = 0; i<styleTextures.length; i++)
                        {
                            this.vrcMultiTexture.addChild(styleTextures[i], 'texture');
                            this.vrcVolumeTexture.nodeChanged();

                            /* TODO: Take texture size for the ComposableRenderStyles offset parameter
                            // check for texture size (test)
                            window.setInterval((function(aTex) {
                                return function() {
                                    var s = that.getTextureSize(aTex);
                                    console.log(s);
                                }
                            })(styleTextures[i]), 100);
                            */
                        }
                    }
                    
                    this._cf.appearance.node.addChild(this.vrcMultiTexture);
                    this.vrcMultiTexture.nodeChanged();
                    
                    // here goes the volume shader
                    this.vrcFrontCubeShaderVertex._vf.type = 'vertex';
                    this.vrcFrontCubeShaderVertex._vf.url[0]=this._cf.renderStyle.node.vertexShaderText();

                    this.vrcFrontCubeShaderFragment._vf.type = 'fragment';
                    this.vrcFrontCubeShaderFragment._vf.url[0]=this._cf.renderStyle.node.fragmentShaderText(
                            this.vrcVolumeTexture._vf.numberOfSlices,
                            this.vrcVolumeTexture._vf.slicesOverX, this.vrcVolumeTexture._vf.slicesOverY);

                    this.vrcFrontCubeShader.addChild(this.vrcFrontCubeShaderVertex, 'parts');
                    this.vrcFrontCubeShaderVertex.nodeChanged();
                    
                    this.vrcFrontCubeShader.addChild(this.vrcFrontCubeShaderFragment, 'parts');
                    this.vrcFrontCubeShaderFragment.nodeChanged();
                    
                    this.vrcFrontCubeShaderFieldBackCoord._vf.name = 'uBackCoord';
                    this.vrcFrontCubeShaderFieldBackCoord._vf.type = 'SFInt32';
                    this.vrcFrontCubeShaderFieldBackCoord._vf.value = 0;

                    this.vrcFrontCubeShaderFieldVolData._vf.name = 'uVolData';
                    this.vrcFrontCubeShaderFieldVolData._vf.type = 'SFInt32';
                    this.vrcFrontCubeShaderFieldVolData._vf.value = 1;

                    this.vrcFrontCubeShader.addChild(this.vrcFrontCubeShaderFieldBackCoord, 'fields');
                    this.vrcFrontCubeShaderFieldBackCoord.nodeChanged();
                    
                    this.vrcFrontCubeShader.addChild(this.vrcFrontCubeShaderFieldVolData, 'fields');
                    this.vrcFrontCubeShaderFieldVolData.nodeChanged();
                    
                    var ShaderUniforms = this._cf.renderStyle.node.uniforms();
                    for (i = 0; i<ShaderUniforms.length; i++)
                    {
                        this.vrcFrontCubeShader.addChild(ShaderUniforms[i], 'fields');
                    }
                
                    this._cf.appearance.node.addChild(this.vrcFrontCubeShader);
                    this.vrcFrontCubeShader.nodeChanged();
                    
                    this._cf.appearance.node.nodeChanged();
                }

                if (!this._cf.geometry.node) {
                    this.addChild(new x3dom.nodeTypes.Box());

                    this._cf.geometry.node._vf.hasHelperColors = true;
                    this._cf.geometry.node._vf.size = new x3dom.fields.SFVec3f(
                        this._vf.dimensions.x, this._vf.dimensions.y, this._vf.dimensions.z);

                    // workaround to trigger field change...
                    this._cf.geometry.node.fieldChanged("hasHelperColors");
                    this._cf.geometry.node.fieldChanged("size");
                }
            }
        }
    )
);

/*
 * CADGeometry:
 * CADGeometry component of X3D extension to the
 * X3DOM JavaScript Library
 * http://x3dom.org
 *

 * Closely adapted from the code for the Grouping components in X3D as
 * implemented in X3DOM
 
 Dual licensed under the MIT and GPL.
 http://x3dom.org/download/dev/docs/html/license.html
 
 * Based on code originally provided by
 *  Philip Taylor: http://philip.html5.org
 
 * 19 Nov 2012  Vincent Marchetti:  vmarchetti@kshell.com
 * 25 May 2013  -- implemented QuadSet, IndexedQuadSet; based largely on the code
                for IndexedTriangleSet in Rendering.js
 */


// ### IndexedQuadSet ###
x3dom.registerNodeType(
    "IndexedQuadSet",
    "CADGeometry",
    defineClass(x3dom.nodeTypes.X3DComposedGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.IndexedQuadSet.superClass.call(this, ctx);

            this.addField_MFInt32(ctx, 'index', []);
        },
        {
            nodeChanged: function()
            {
                /*
                This code largely taken from the IndexedTriangleSet code
                */
                var time0 = new Date().getTime();

                this.handleAttribs();

				var colPerVert = this._vf.colorPerVertex;
                var normPerVert = this._vf.normalPerVertex;

                var indexes = this._vf.index;

                var hasNormal = false, hasTexCoord = false, hasColor = false;
                var positions, normals, texCoords, colors;

                var coordNode = this._cf.coord.node;
                x3dom.debug.assert(coordNode);
                positions = coordNode._vf.point;

                var normalNode = this._cf.normal.node;
                if (normalNode) {
                    hasNormal = true;
                    normals = normalNode._vf.vector;
                }
                else {
                    hasNormal = false;
                }

                var texMode = "", numTexComponents = 2;
                var texCoordNode = this._cf.texCoord.node;
                if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                    if (texCoordNode._cf.texCoord.nodes.length)
                        texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                }
                if (texCoordNode) {
                    if (texCoordNode._vf.point) {
                        hasTexCoord = true;
                        texCoords = texCoordNode._vf.point;

                        if (x3dom.isa(texCoordNode, x3dom.nodeTypes.TextureCoordinate3D)) {
                            numTexComponents = 3;
                        }
                    }
                    else if (texCoordNode._vf.mode) {
                        texMode = texCoordNode._vf.mode;
                    }
                }
                else {
                    hasTexCoord = false;
                }

                var numColComponents = 3;
                var colorNode = this._cf.color.node;
                if (colorNode) {
                    hasColor = true;
                    colors = colorNode._vf.color;

                    if (x3dom.isa(colorNode, x3dom.nodeTypes.ColorRGBA)) {
                        numColComponents = 4;
                    }
                }
                else {
                    hasColor = false;
                }

                this._mesh._indices[0] = [];
                this._mesh._positions[0] = [];
                this._mesh._normals[0] = [];
                this._mesh._texCoords[0] = [];
                this._mesh._colors[0] = [];

                var i, t, cnt, faceCnt, posMax;
                var p0, p1, p2, n0, n1, n2, t0, t1, t2, c0, c1, c2;

                // if positions array too short add degenerate triangle
                while (positions.length % 4 > 0) {
                    positions.push(positions.length-1);
                }
                posMax = positions.length;

                /*
                Note: A separate section setting the _mesh field members
                and starting with this test:
                if (!normPerVert || positions.length > x3dom.Utils.maxIndexableCoords)
                is in the IndexedTriangleSet code. It has been removed
                here until it's applicability to the QUadSet case can
                be evaluated

                NOTE: !normPerVert or creaseAngle == 0 means per-face normals
                      therefore, the original multi-index structure also can't
                      be retained since this means every face has other vertices
                      with other attribute properties.
                      A similar problem arises if we have more than 2^16 coordinates
                      since WebGL only supports 16-bit indices, why we have to split
                      the mesh here (which is most easiest achieved by using just the
                      same code path previously mentioned)
                */
                //if (true)
                {
					faceCnt = 0;
					for (i=0; i<indexes.length; i++)
					{
						if ((i > 0) && (i % 4 === 3 )) {                   
							faceCnt++;
							
							// then pushe the the 2nd triangle
							// of the quad on
							this._mesh._indices[0].push(indexes[i-3]);
							this._mesh._indices[0].push(indexes[i-1]);
							this._mesh._indices[0].push(indexes[i]);
                        }	
						else{
						    this._mesh._indices[0].push(indexes[i]);
						}
							
						if(!normPerVert && hasNormal) {
							this._mesh._normals[0].push(normals[faceCnt].x);
							this._mesh._normals[0].push(normals[faceCnt].y);
							this._mesh._normals[0].push(normals[faceCnt].z);
						}
						if(!colPerVert && hasColor) {								
							this._mesh._colors[0].push(colors[faceCnt].r);
							this._mesh._colors[0].push(colors[faceCnt].g);
							this._mesh._colors[0].push(colors[faceCnt].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(colors[faceCnt].a);
							}   
						}  				
					}
               
                    this._mesh._positions[0] = positions.toGL();
                    
                    if (hasNormal) {
                        this._mesh._normals[0] = normals.toGL();
                    }
                    else {
                        this._mesh.calcNormals(normPerVert ? Math.PI : 0);
                    }
                    
                    if (hasTexCoord) {
                        this._mesh._texCoords[0] = texCoords.toGL();
                        this._mesh._numTexComponents = numTexComponents;
                    }
                    else {
                        this._mesh.calcTexCoords(texMode);
                    }
                    
                    if (hasColor && colPerVert) {
                        this._mesh._colors[0] = colors.toGL();
                        this._mesh._numColComponents = numColComponents;
                    }
                }

                this.invalidateVolume();
                this._mesh._numFaces = 0;
                this._mesh._numCoords = 0;
                for (i=0; i<this._mesh._indices.length; i++) {
                    this._mesh._numFaces += this._mesh._indices[i].length / 3;
                    this._mesh._numCoords += this._mesh._positions[i].length / 3;
                }

                var time1 = new Date().getTime() - time0;
                //x3dom.debug.logInfo("Mesh load time: " + time1 + " ms");
            },

            fieldChanged: function(fieldName)
            {
                var pnts = this._cf.coord.node._vf.point;
                
                if ( pnts.length > x3dom.Utils.maxIndexableCoords )  // are there other problematic cases?
                {
					// TODO; implement
                    x3dom.debug.logWarning("IndexedQuadSet: fieldChanged with " +
                                           "too many coordinates not yet implemented!");
                    return;
                }
                
                if (fieldName == "coord")
                {
                    this._mesh._positions[0] = pnts.toGL();
                    
                    // tells the mesh that its bbox requires update
                    this.invalidateVolume();

                    Array.forEach(this._parentNodes, function (node) {					
                        node._dirty.positions = true;
                        node.invalidateVolume();
                    });
                }
                else if (fieldName == "color")
                {                                      
					pnts = this._cf.color.node._vf.color;
						
					if (this._vf.colorPerVertex) { 
				
						this._mesh._colors[0] = pnts.toGL();	
							
					} else if (!this._vf.colorPerVertex) {
						
						var faceCnt = 0;
						var numColComponents = 3;	
                   		if (x3dom.isa(this._cf.color.node, x3dom.nodeTypes.ColorRGBA)) {
							numColComponents = 4;
						}
							
						this._mesh._colors[0] = [];
							
						var indexes = this._vf.index;
						for (i=0; i < indexes.length; ++i)
						{
							if ((i > 0) && (i % 3 === 0 )) {                   
								faceCnt++;							
							}	
								
							this._mesh._colors[0].push(pnts[faceCnt].r);
							this._mesh._colors[0].push(pnts[faceCnt].g);
							this._mesh._colors[0].push(pnts[faceCnt].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(pnts[faceCnt].a);
							}  
						}
					}
					Array.forEach(this._parentNodes, function (node) {
						node._dirty.colors = true;
					});
                }
				else if (fieldName == "normal")
                {                 
					pnts = this._cf.normal.node._vf.vector;
						
					if (this._vf.normalPerVertex) { 
						
						this._mesh._normals[0] = pnts.toGL();
							
					} else if (!this._vf.normalPerVertex) {
							
						var indexes = this._vf.index;
						this._mesh._normals[0] = [];
						
						var faceCnt = 0;
						for (i=0; i < indexes.length; ++i)
						{
							if ((i > 0) && (i % 3 === 0 )) {                   
								faceCnt++;							
							}	
							
							this._mesh._normals[0].push(pnts[faceCnt].x);
							this._mesh._normals[0].push(pnts[faceCnt].y);
							this._mesh._normals[0].push(pnts[faceCnt].z);	
						}
					}

					Array.forEach(this._parentNodes, function (node) {
						 node._dirty.normals = true;
					});
                }
				else if (fieldName == "texCoord")
                {
                    var texCoordNode = this._cf.texCoord.node;
                    if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                        if (texCoordNode._cf.texCoord.nodes.length)
                            texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                    }
                    pnts = texCoordNode._vf.point;
                    
                    this._mesh._texCoords[0] = pnts.toGL();
                    
                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.texcoords = true;
                    });
                }
            }
        }
    )
);

// ### QuadSet ###
x3dom.registerNodeType(
    "QuadSet",
    "CADGeometry",
    defineClass(x3dom.nodeTypes.X3DComposedGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.QuadSet.superClass.call(this, ctx);
        },
        {
            nodeChanged: function()
            {
                /*
                This code largely taken from the IndexedTriangleSet code
                */
                var time0 = new Date().getTime();

                this.handleAttribs();

				var colPerVert = this._vf.colorPerVertex;
                var normPerVert = this._vf.normalPerVertex;

                var hasNormal = false, hasTexCoord = false, hasColor = false;
                var positions, normals, texCoords, colors;

                var coordNode = this._cf.coord.node;
                x3dom.debug.assert(coordNode);
                positions = coordNode._vf.point;

                var normalNode = this._cf.normal.node;
                if (normalNode) {
                    hasNormal = true;
                    normals = normalNode._vf.vector;
                }
                else {
                    hasNormal = false;
                }

                var texMode = "", numTexComponents = 2;
                var texCoordNode = this._cf.texCoord.node;
                if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                    if (texCoordNode._cf.texCoord.nodes.length)
                        texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                }
                if (texCoordNode) {
                    if (texCoordNode._vf.point) {
                        hasTexCoord = true;
                        texCoords = texCoordNode._vf.point;

                        if (x3dom.isa(texCoordNode, x3dom.nodeTypes.TextureCoordinate3D)) {
                            numTexComponents = 3;
                        }
                    }
                    else if (texCoordNode._vf.mode) {
                        texMode = texCoordNode._vf.mode;
                    }
                }
                else {
                    hasTexCoord = false;
                }

                var numColComponents = 3;
                var colorNode = this._cf.color.node;
                if (colorNode) {
                    hasColor = true;
                    colors = colorNode._vf.color;

                    if (x3dom.isa(colorNode, x3dom.nodeTypes.ColorRGBA)) {
                        numColComponents = 4;
                    }
                }
                else {
                    hasColor = false;
                }

                this._mesh._indices[0] = [];
                this._mesh._positions[0] = [];
                this._mesh._normals[0] = [];
                this._mesh._texCoords[0] = [];
                this._mesh._colors[0] = [];

                var i, t, cnt, faceCnt, posMax;
                var p0, p1, p2, n0, n1, n2, t0, t1, t2, c0, c1, c2;

                // if positions array too short add degenerate triangle
                while (positions.length % 4 > 0) {
                    positions.push(positions.length-1);
                }
                posMax = positions.length;

                /*
                Note: A separate section setting the _mesh field members
                and starting with this test:
                if (!normPerVert || positions.length > x3dom.Utils.maxIndexableCoords)
                is in the IndexedTriangleSet code. It has been removed
                here until it's applicability to the QUadSet case can
                be evaluated
                */
                if (1)
                {
					faceCnt = 0;
					for (i=0; i<positions.length; i++)
					{
						if ((i > 0) && (i % 4 === 3 )) {                   
							faceCnt++;
							
							// then pushe the the 2nd triangle
							// of the quad on
							this._mesh._indices[0].push(i-3);
							this._mesh._indices[0].push(i-1);
							this._mesh._indices[0].push(i);
                        }	
						else{
						    this._mesh._indices[0].push(i);
						}
							
						if(!normPerVert && hasNormal) {
							this._mesh._normals[0].push(normals[faceCnt].x);
							this._mesh._normals[0].push(normals[faceCnt].y);
							this._mesh._normals[0].push(normals[faceCnt].z);
						}
						if(!colPerVert && hasColor) {								
							this._mesh._colors[0].push(colors[faceCnt].r);
							this._mesh._colors[0].push(colors[faceCnt].g);
							this._mesh._colors[0].push(colors[faceCnt].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(colors[faceCnt].a);
							}   
						}  				
					}
               
                    this._mesh._positions[0] = positions.toGL();
                    
                    if (hasNormal) {
                        this._mesh._normals[0] = normals.toGL();
                    }
                    else {
                        this._mesh.calcNormals(normPerVert ? Math.PI : 0);
                    }
                    
                    if (hasTexCoord) {
                        this._mesh._texCoords[0] = texCoords.toGL();
                        this._mesh._numTexComponents = numTexComponents;
                    }
                    else {
                        this._mesh.calcTexCoords(texMode);
                    }
                    
                    if (hasColor && colPerVert) {
                        this._mesh._colors[0] = colors.toGL();
                        this._mesh._numColComponents = numColComponents;
                    }
                }

                this.invalidateVolume();
                this._mesh._numFaces = 0;
                this._mesh._numCoords = 0;
                for (i=0; i<this._mesh._indices.length; i++) {
                    this._mesh._numFaces += this._mesh._indices[i].length / 3;
                    this._mesh._numCoords += this._mesh._positions[i].length / 3;
                }

                var time1 = new Date().getTime() - time0;
                //x3dom.debug.logInfo("Mesh load time: " + time1 + " ms");
            },

            fieldChanged: function(fieldName)
            {
                var pnts = this._cf.coord.node._vf.point;
                
                if ( pnts.length > x3dom.Utils.maxIndexableCoords )  // are there other problematic cases?
                {
					// TODO; implement
                    x3dom.debug.logWarning("QuadSet: fieldChanged with " + 
                                           "too many coordinates not yet implemented!");
                    return;
                }
                
                if (fieldName == "coord")
                {
                    this._mesh._positions[0] = pnts.toGL();
                    
                    // tells the mesh that its bbox requires update
                    this.invalidateVolume();

                    Array.forEach(this._parentNodes, function (node) {					
                        node._dirty.positions = true;
                        node.invalidateVolume();
                    });
                }
                else if (fieldName == "color")
                {                                      
					pnts = this._cf.color.node._vf.color;
						
					if (this._vf.colorPerVertex) { 
				
						this._mesh._colors[0] = pnts.toGL();	
							
					} else if (!this._vf.colorPerVertex) {
						
						var faceCnt = 0;
						var numColComponents = 3;	
                   		if (x3dom.isa(this._cf.color.node, x3dom.nodeTypes.ColorRGBA)) {
							numColComponents = 4;
						}
							
						this._mesh._colors[0] = [];
							
						var indexes = this._vf.index;
						for (i=0; i < indexes.length; ++i)
						{
							if ((i > 0) && (i % 3 === 0 )) {                   
								faceCnt++;							
							}	
								
							this._mesh._colors[0].push(pnts[faceCnt].r);
							this._mesh._colors[0].push(pnts[faceCnt].g);
							this._mesh._colors[0].push(pnts[faceCnt].b);
							if (numColComponents === 4) {
								this._mesh._colors[0].push(pnts[faceCnt].a);
							}  
						}
					}
					Array.forEach(this._parentNodes, function (node) {
						node._dirty.colors = true;
					});
                }
				else if (fieldName == "normal")
                {                 
					pnts = this._cf.normal.node._vf.vector;
						
					if (this._vf.normalPerVertex) { 
						
						this._mesh._normals[0] = pnts.toGL();
							
					} else if (!this._vf.normalPerVertex) {
							
						var indexes = this._vf.index;
						this._mesh._normals[0] = [];
						
						var faceCnt = 0;
						for (i=0; i < indexes.length; ++i)
						{
							if ((i > 0) && (i % 3 === 0 )) {                   
								faceCnt++;							
							}	
							
							this._mesh._normals[0].push(pnts[faceCnt].x);
							this._mesh._normals[0].push(pnts[faceCnt].y);
							this._mesh._normals[0].push(pnts[faceCnt].z);	
						}
					}

					Array.forEach(this._parentNodes, function (node) {
						 node._dirty.normals = true;
					});
                }
				else if (fieldName == "texCoord")
                {
                    var texCoordNode = this._cf.texCoord.node;
                    if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                        if (texCoordNode._cf.texCoord.nodes.length)
                            texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                    }
                    pnts = texCoordNode._vf.point;
                    
                    this._mesh._texCoords[0] = pnts.toGL();
                    
                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.texcoords = true;
                    });
                }
            }
        }
    )
);


// ### CADLayer ###
x3dom.registerNodeType(
    "CADLayer",
    "CADGeometry",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.CADLayer.superClass.call(this, ctx);

            this.addField_SFString(ctx,'name', "");
            // to be implemented: the 'visible' field
            // there already is a 'render' field defined in base class
            // which basically defines visibility...
            // NOTE: bbox stuff also already defined in a base class!
        }
    )
);

// ### CADAssembly ###
x3dom.registerNodeType(
    "CADAssembly",
    "CADGeometry",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.CADAssembly.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'name', "");
        }
    )
);

// ### CADPart ###
// According to the CADGeometry specification,
// the CADPart node has transformation fields identical to 
// those used in the Transform node, therefore just inherit it
x3dom.registerNodeType(
    "CADPart",
    "CADGeometry",
    defineClass(x3dom.nodeTypes.Transform,
        function (ctx) {
            x3dom.nodeTypes.CADPart.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'name', "");
        }
    )
);

// ### CADFace ###
x3dom.registerNodeType(
    "CADFace",
    "CADGeometry",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.CADFace.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'name', "");
            this.addField_SFNode('shape', x3dom.nodeTypes.X3DShapeNode);
        },
        {
            getVolume: function()
            {
                var vol = this._graph.volume;

                if (!this.volumeValid() && this._vf.render)
                {
                    var child = this._cf.shape.node;
                    var childVol = (child && child._vf.render === true) ? child.getVolume() : null;

                    if (childVol && childVol.isValid())
                        vol.extendBounds(childVol.min, childVol.max);
                }

                return vol;
            },

            collectDrawableObjects: function (transform, drawableCollection, singlePath, invalidateCache, planeMask)
            {
                if (singlePath && (this._parentNodes.length > 1))
                    singlePath = false;

                if (singlePath && (invalidateCache = invalidateCache || this.cacheInvalid()))
                    this.invalidateCache();

                if (!this._cf.shape.node ||
                    (planeMask = drawableCollection.cull(transform, this.graphState(), singlePath, planeMask)) <= 0) {
                    return;
                }

                var cnode, childTransform;

                if (singlePath) {
                    if (!this._graph.globalMatrix) {
                        this._graph.globalMatrix = this.transformMatrix(transform);
                    }
                    childTransform = this._graph.globalMatrix;
                }
                else {
                    childTransform = this.transformMatrix(transform);
                }

                if ( (cnode = this._cf.shape.node) ) {
                    cnode.collectDrawableObjects(childTransform, drawableCollection, singlePath, invalidateCache, planeMask);
                }
            }
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### Patch ### */
x3dom.registerNodeType(
    "Patch",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Patch.superClass.call(this, ctx);

            this.addField_SFVec2f(ctx, 'size', 2, 2);
            this.addField_SFVec2f(ctx, 'subdivision', 1, 1);
            this.addField_SFVec3f(ctx, 'center', 0, 0, 0);
            this.addField_MFString(ctx, 'primType', ['TRIANGLES']);

            var sx = this._vf.size.x, sy = this._vf.size.y;
            var subx = this._vf.subdivision.x, suby = this._vf.subdivision.y;

            this._indexBufferTriangulationParts = [];

            var x = 0, y = 0;
            var xstep = sx / subx / 2;
            var ystep = sy / suby / 2;

            sx /= 2;
            sy /= 2;
            var countX = subx * 2 + 1;
            var countY = suby * 2 + 1;

            /*************************************************************/
            // VERTEX-INFORMATION
            /*************************************************************/
            for (y = 0; y <= suby * 2; y++) {
                for (x = 0; x <= subx * 2; x++) {
                    this._mesh._positions[0].push(this._vf.center.x + x * xstep - sx);
                    this._mesh._positions[0].push(this._vf.center.y + y * ystep - sy);
                    this._mesh._positions[0].push(this._vf.center.z);
                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(0);
                    this._mesh._normals[0].push(1);
                    this._mesh._texCoords[0].push(x / (subx * 2));
                    this._mesh._texCoords[0].push(y / (suby * 2));
                }
            }

            /*************************************************************/
            // regular triangulation
            for (y = 0; y < countY - 2; y += 2) {
                for (x = 0; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + y * countX);

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                }
            }

            this._indexBufferTriangulationParts.push({
                offset: 0, 
                count: subx * suby * 6
            });

            /*************************************************************/
            // finer bottom triangulation
            for (y = 0; y < countY - 2; y += 2) {
                for (x = 0; x < 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 1) * countX);

                    this._mesh._indices[0].push((x) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            for (y = 0; y < countY - 2; y += 2) {
                for (x = 2; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + y * countX);

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                }
            }

            this._indexBufferTriangulationParts.push({ 
                offset: this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].offset + 
                        this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].count * 2, 
                count: subx * suby * 6 + suby * 9
            });
            
            /*************************************************************/
            // finer top triangulation
            for (y = 0; y < countY - 2; y += 2) {
                for (x = countX - 3; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 1) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            for (y = 0; y < countY - 2; y += 2) {
                for (x = 0; x < countX - 4; x += 2) {
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + y * countX);

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                }
            }

            this._indexBufferTriangulationParts.push({ 
                offset: this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].offset + 
                        this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].count * 2, 
                count: subx * suby * 6 + suby * 9
            });

            /*************************************************************/
            // finer right triangulation
            for (y = 2; y < countY - 2; y += 2) {
                for (x = 0; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + y * countX);

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                }
            }

            for (y = 0; y < 2; y += 2) {
                for (x = 0; x < countX - 2; x += 2) {

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + y * countX);

                    this._mesh._indices[0].push((x + 1) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            this._indexBufferTriangulationParts.push({ 
                offset: this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].offset + 
                        this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].count * 2, 
                count: subx * suby * 6 + subx * 9
            });
            
            /*************************************************************/
            // finer left triangulation
            for (y = countY - 3; y < countY - 2; y += 2) {
                for (x = 0; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 1) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            for (y = 0; y < countY - 4; y += 2) {
                for (x = 0; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + y * countX);

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                }
            }

            this._indexBufferTriangulationParts.push({ 
                offset: this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].offset + 
                        this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].count * 2, 
                count: subx * suby * 6 + subx * 9
            });
            
            /*************************************************************/
            // finer topLeft triangulation
            for (y = countY - 3; y < countY - 2; y += 2) {
                for (x = countX - 3; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 1) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 1) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            for (y = 0; y < countY - 4; y += 2) {
                for (x = 0; x < countX - 4; x += 2) {
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + y * countX);

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                }
            }

            for (y = 0; y < countY - 4; y += 2) {
                for (x = countX - 3; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 1) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            for (y = countY - 3; y < countY - 2; y += 2) {
                for (x = 0; x < countX - 4; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 1) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            this._indexBufferTriangulationParts.push({ 
                offset: this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].offset + 
                        this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].count * 2, 
                count: subx * suby * 6 + subx * 9 + (suby - 1) * 9 + 3
            });
            
            /*************************************************************/
            // finer bottomLeft triangulation
            for (y = countY - 3; y < countY - 2; y += 2) {
                for (x = 0; x < 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 1) * countX);

                    this._mesh._indices[0].push((x) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 1) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            for (y = 0; y < countY - 4; y += 2) {
                for (x = 2; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + y * countX);

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                }
            }

            // finer left
            for (y = countY - 3; y < countY - 2; y += 2) {
                for (x = 2; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 1) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            // finer bottom
            for (y = 0; y < countY - 4; y += 2) {
                for (x = 0; x < 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 1) * countX);

                    this._mesh._indices[0].push((x) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            this._indexBufferTriangulationParts.push({ 
                offset: this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].offset + 
                        this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].count * 2, 
                count: subx * suby * 6 + subx * 9 + (suby - 1) * 9 + 3
            });
            
            /*************************************************************/
            // finer bottomRight triangulation
            for (y = 0; y < 2; y += 2) {
                for (x = 0; x < 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 1) * countX);

                    this._mesh._indices[0].push((x) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + y * countX);

                    this._mesh._indices[0].push((x + 1) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            for (y = 2; y < countY - 2; y += 2) {
                for (x = 2; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + y * countX);

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                }
            }

            // finer bottom
            for (y = 2; y < countY - 2; y += 2) {
                for (x = 0; x < 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 1) * countX);

                    this._mesh._indices[0].push((x) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            // finer right
            for (y = 0; y < 2; y += 2) {
                for (x = 2; x < countX - 2; x += 2) {

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + y * countX);

                    this._mesh._indices[0].push((x + 1) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            this._indexBufferTriangulationParts.push({ 
                offset: this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].offset + 
                        this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].count * 2, 
                count: subx * suby * 6 + subx * 9 + (suby - 1) * 9 + 3
            });

            /*************************************************************/
            // finer topRight triangulation
            // finer right
            for (y = 0; y < 2; y += 2) {
                for (x = countX - 3; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 1) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + y * countX);

                    this._mesh._indices[0].push((x + 1) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            for (y = 2; y < countY - 2; y += 2) {
                for (x = 0; x < countX - 4; x += 2) {
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x) + y * countX);

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                }
            }

            //  finer top
            for (y = 2; y < countY - 2; y += 2) {
                for (x = countX - 3; x < countX - 2; x += 2) {
                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 1) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            // finer right
            for (y = 0; y < 2; y += 2) {
                for (x = 0; x < countX - 4; x += 2) {

                    this._mesh._indices[0].push((x) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + (y + 2) * countX);

                    this._mesh._indices[0].push((x) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);

                    this._mesh._indices[0].push((x + 2) + (y + 2) * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 2) + y * countX);

                    this._mesh._indices[0].push((x + 2) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x + 1) + y * countX);

                    this._mesh._indices[0].push((x + 1) + y * countX);
                    this._mesh._indices[0].push((x + 1) + (y + 1) * countX);
                    this._mesh._indices[0].push((x) + y * countX);
                }
            }

            this._indexBufferTriangulationParts.push({ 
                offset: this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].offset + 
                        this._indexBufferTriangulationParts[this._indexBufferTriangulationParts.length - 1].count * 2, 
                count: subx * suby * 6 + subx * 9 + (suby - 1) * 9 + 3
            });

            this._mesh._invalidate = true;
            this._mesh._numFaces = this._mesh._indices[0].length / 3;
            this._mesh._numCoords = this._mesh._positions[0].length / 3;
        },
        {
            hasIndexOffset: function() {
                return true;
            },

            getTriangulationAttributes: function(triangulationIndex){
                return this._indexBufferTriangulationParts[triangulationIndex];
            }
        }
    )
);



// ### BVHRefiner ###
x3dom.registerNodeType(
    "BVHRefiner",
    "Navigation",
    defineClass(x3dom.nodeTypes.X3DLODNode,
        function (ctx) {
            x3dom.nodeTypes.BVHRefiner.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'factor', 1.0);
            this.addField_SFInt32(ctx, 'maxDepth', 3);
            this.addField_SFInt32(ctx, 'minDepth', 0);
            this.addField_SFInt32(ctx, 'smoothLoading', 1);
            this.addField_SFInt32(ctx, 'interactionDepth', this._vf.maxDepth);
            this.addField_SFVec2f(ctx, 'size', 1, 1);
            // TODO: delete if octree will be deleted
            this.addField_SFVec3f(ctx, 'octSize', 1, 1, 1);
            this.addField_SFVec2f(ctx, 'subdivision', 1, 1);
            this.addField_SFString(ctx, 'url', "");
            this.addField_SFString(ctx, 'elevationUrl', "");
            this.addField_SFString(ctx, 'textureUrl', "");
            this.addField_SFString(ctx, 'normalUrl', "");
            this.addField_SFString(ctx, 'mode', "3d");
            this.addField_SFString(ctx, 'subMode', "wmts");
            this.addField_SFString(ctx, 'elevationFormat', "png");
            this.addField_SFString(ctx, 'textureFormat', "png");
            this.addField_SFString(ctx, 'normalFormat', "png");
            this.addField_SFFloat(ctx, 'maxElevation', 1.0);
            this.addField_SFBool(ctx, 'useNormals', true);
            this.addField_SFBool(ctx, 'lit', true);
            // count of elements on next level
            this.addField_SFInt32(ctx, 'bvhCount', 8);

            this.creationSmooth = 0;
            this.togglePoints = true;
            this.nodeProducer = new NodeProducer();
            // calculation of the array-size for storing the quad-pointers
            var nodeListSize = 0;
            for (var x = 0; x <= this._vf.maxDepth; x++) {
                nodeListSize += Math.pow(4, x);
            }
            this.nodeList = new Array(nodeListSize);

            if (this._vf.mode === "bin") {
                // creating the root-node of the quadtree
                this.rootNode = new QuadtreeNodeBin(ctx, this, 0, 0, 0, null);
            }
            else if (this._vf.mode === "3d" || this._vf.mode === "2d") {
                // 2D-Mesh that will represent the geometry of this node
                var geometry = new x3dom.nodeTypes.Plane(ctx);
                // definition the parameters of the geometry
                geometry._vf.subdivision.setValues(this._vf.subdivision);
                geometry.fieldChanged("subdivision");
                geometry._vf.size.setValues(this._vf.size);
                //geometry._vf.center.setValues(this._vf.center);
                
                if (this._vf.mode === "2d") {
                    if (this._vf.subMode === "wmts"){
                        // creating the root-node of the quadtree
                        this.rootNode = new QuadtreeNode2dWMTS(ctx, this, 0, 0,
                                                               x3dom.fields.SFMatrix4f.identity(), 
                                                               0, 0, geometry);
                    }
                    else {
                        // creating the root-node of the quadtree
                        this.rootNode = new QuadtreeNode2D(ctx, this, 0, 0,
                                                           x3dom.fields.SFMatrix4f.identity(), 
                                                           0, 0, geometry, "/", 1);
                    }
                }
                else {
                    if (this._vf.subMode === "32bit"){
                        this.rootNode = new QuadtreeNode3D_32bit(ctx, this, 0, 0,
                                                           x3dom.fields.SFMatrix4f.identity(), 
                                                           0, 0, geometry);
                    }
                    else {
                        geometry = new x3dom.nodeTypes.Patch(ctx);
                        this.rootNode = new QuadtreeNode3D(ctx, this, 0, 0,
                                                           x3dom.fields.SFMatrix4f.identity(), 
                                                           0, 0, geometry);
                    }
                }
            }
            else if (this._vf.mode === "bvh"){
                // creating the root-node of the quadtree
                this.rootNode = new BVHNode(ctx, this, 0, "/", 1, this._vf.bvhCount);
            }
            else {
                x3dom.debug.logError("Error attribute mode. Value: '" + this._vf.mode +
                                     "' isn't conform. Please use type 'bin', '2d' or '3d'");
            }
        },
        {
            visitChildren: function(transform, drawableCollection, singlePath, invalidateCache, planeMask) {
                var x3dElement = this._nameSpace.doc._x3dElem;

                if (this._vf.mode === "oct") {
                    if (x3dElement.runtime.isReady && this.togglePoints){
                        x3dElement.runtime.togglePoints();
                        this.togglePoints = false;
                        this.view = drawableCollection.viewarea;
                    }
                    this.creationSmooth++;
                    singlePath = false;         // TODO (specify if unique node path or multi-parent)
                    invalidateCache = true;     // TODO (reuse world transform and volume cache)
                    this.rootNode.collectDrawables(transform, drawableCollection, singlePath, invalidateCache, planeMask);

                    if (!this.view.isMovingOrAnimating() && ((this.creationSmooth % this._vf.smoothLoading) === 0)) {
                        this.nodeProducer.CreateNewNode();
                    }
                }
                else {
                    if (x3dElement.runtime.isReady && this.togglePoints){
                        this.view = x3dElement.runtime.canvas.doc._viewarea;
                        this.togglePoints = false;
                    }
                    this.createChildren = 0;
                    this.creationSmooth++;
                    singlePath = false;         // TODO (specify if unique node path or multi-parent)
                    invalidateCache = true;     // TODO (reuse world transform and volume cache)
                    this.rootNode.collectDrawables(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                    if (!this.view.isMovingOrAnimating() && ((this.creationSmooth % this._vf.smoothLoading) === 0)) {
                        this.nodeProducer.CreateNewNode();
                    }
                }
            },

            getVolume: function()
            {
                var vol = this._graph.volume;

                if (!this.volumeValid() && this._vf.render)
                {
                    var childVol = this.rootNode.getVolume();
                    if (childVol && childVol.isValid())
                        vol.extendBounds(childVol.min, childVol.max);
                }
                
                return vol;
            }
        }
    )
);



/*
 * All bvh-nodes must login at this element if they want to
 * create their children on next frame. This node decides what node
 * has the highest priority and creates its four children on the next 
 * frame. On the next frame the same course will happen till all children
 * are created. 
 * @returns {NodeProducer}
 */
function NodeProducer()
{
    // Node thats children should be created after current frame is rendered
    var nextNode        = null;
    // Distance of the node that should be created after current frame
    var nearestDistance = 1000000;
    // Depth of the node that should be created after current frame
    var smallestDepth   = 1000000;
    
    
    
    /*
     * Decides if the given node has a smaller or the same depth as the 
     * current "nextNode", and if this is true if the distance to camera
     * is less. In this case it will be new "nextNode"
     * @param {Node of BVHRefiner} node node that will create children
     * @param {type} distance distance of the node to camera
     * @returns {null}
     */
    this.AddNewNode = function(node, distance){
        if (node.Level() < smallestDepth) {
            smallestDepth = node.Level();
            nextNode = node;
        }
        if (node.Level() === smallestDepth){
            if (distance < nearestDistance){
                distance = nearestDistance;
                nextNode = node;
            }
        }
    };
    
    
    
    /*
     * Creates the children of the node with highest priority in the last frame 
     * @returns {null}
     */
    this.CreateNewNode = function(){
        if (nextNode !== null) {
            nextNode.CreateChildren();
        }
        nextNode = null;
        smallestDepth = 1000;
    };
}



/*******************************************************************************
 *******************************************************************************
 **************************** QuadtreeNode2dWMTS *******************************
 *******************************************************************************
 *******************************************************************************
 *
 * Defines one 2D node (plane) of a quadtree that represents a part 
 * (nxn vertices) of the whole mesh.
 * @param {object} ctx context
 * @param {x3dom.nodeTypes.BVHRefiner} bvhRefiner root bvhRefiner node  
 * @param {number} level level of the node within the quadtree
 * @param {number} nodeNumber id of the node within the level
 * @param {x3dom.fields.SFMatrix4f} nodeTransformation transformation matrix 
 *                                  that defines scale and position
 * @param {number} columnNr column number in the wmts matrix within the level
 * @param {number} rowNr row number in the wmts matrix within the level
 * @param {x3dom.nodeTypes.Plane} geometry plane
 * @returns {QuadtreeNode2dWMTS}
 */
function QuadtreeNode2dWMTS(ctx, bvhRefiner, level, nodeNumber, nodeTransformation, 
                            columnNr, rowNr, geometry)
{
    // array with the maximal four child nodes
    var children = [];
    // drawable component of this node
    var shape = new x3dom.nodeTypes.Shape();
    // position of the node in world space
    var position = null;
    // true if this component is available and renderable
    var readyState = false;
    // checks if children are ready
    var childrenReadyState = false;
    // url of the data source
    var url = bvhRefiner._vf.textureUrl + "/" + level + "/" + columnNr + 
              "/" + rowNr + "." + (bvhRefiner._vf.textureFormat).toLowerCase();
    // defines the resizing factor
    var resizeFac = (bvhRefiner._vf.size.x + bvhRefiner._vf.size.y) / 2.0;
    // object that stores all information to do a frustum culling
    var cullObject = {};
    
    
    
    /* 
     * Initializes all nodeTypes that are needed to create the drawable
     * component for this node
     * @returns {null}
     */
    function initialize() {

        // appearance of the drawable component of this node
        var appearance = new x3dom.nodeTypes.Appearance(ctx);
        // texture that should represent the surface-data of this node
        var texture = new x3dom.nodeTypes.ImageTexture(ctx);

        // definition of the nameSpace of this shape
        shape._nameSpace = bvhRefiner._nameSpace;
        
        // create height-data
        var texProp = new x3dom.nodeTypes.TextureProperties(ctx);
        texProp._vf.boundaryModeS = "CLAMP_TO_EDGE";
        texProp._vf.boundaryModeT = "CLAMP_TO_EDGE";
        texProp._vf.boundaryModeR = "CLAMP_TO_EDGE";
        texProp._vf.minificationFilter = "LINEAR";
        texProp._vf.magnificationFilter = "LINEAR";
        texture.addChild(texProp, "textureProperties");
        texture.nodeChanged();
        // definition of texture
        texture._nameSpace = bvhRefiner._nameSpace;
        texture._vf.url[0] = url;

        // calculate the average position of the node
        position = nodeTransformation.e3();
        
        // add textures to the appearence of this node
        appearance.addChild(texture);
        texture.nodeChanged();

        // create shape with geometry and appearance data
        shape.addChild(appearance);
        appearance.nodeChanged();
        shape.addChild(geometry);
        geometry.nodeChanged();

        // add shape to bvhRefiner object
        bvhRefiner.addChild(shape);
        shape.nodeChanged();
        
        // definition the static properties of cullObject
        cullObject.boundedNode = shape;
        cullObject.volume = shape.getVolume();
    }
    
    
    
    /*
     * Creates the four children
     * @returns {null}
     */
    this.CreateChildren = function () {
        create();
    };
    
    
    
    /*
     * Creates the four children
     * @returns {null}
     */
    function create() {
        
        // calculation of children number nodeNumber within their level
        var deltaR = Math.sqrt(Math.pow(4, level));
        var deltaR1 = Math.sqrt(Math.pow(4, level + 1));
        var lt = Math.floor(nodeNumber / deltaR) * 4 * deltaR + 
                           (nodeNumber % deltaR) * 2;
        var rt = lt + 1;
        var lb = lt + deltaR1;
        var rb = lb + 1;
        
        // calculation of the scaling factor
        var s = (bvhRefiner._vf.size).multiply(0.25);

        // creation of all children
        children.push(new QuadtreeNode2dWMTS(ctx, bvhRefiner, (level + 1), lt,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2), (rowNr * 2), geometry));
        children.push(new QuadtreeNode2dWMTS(ctx, bvhRefiner, (level + 1), rt,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2 + 1), (rowNr * 2), geometry));
        children.push(new QuadtreeNode2dWMTS(ctx, bvhRefiner, (level + 1), lb,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, -s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2), (rowNr * 2 + 1), geometry));
        children.push(new QuadtreeNode2dWMTS(ctx, bvhRefiner, (level + 1), rb,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, -s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2 + 1), (rowNr * 2 + 1), geometry));
    }
    
    
    
    /*
     * Returns the shape of this node 
     * @returns {x3dom.nodeTypes.Shape}
     */
    this.Shape = function () {
        return shape;
    };
    
    
    
    /*
     * Runs only local ready() method. This is needed from parent to ask if 
     * all children are ready to render or not
     * @returns {Boolean} true if ready to render, else false
     */
    this.Ready = function(){
        if (shape._webgl !== undefined && shape._webgl.texture !== undefined) {
                return ready();
        }
        
        return false;
    };
    
    
    
    /*
     * Iterates through all textures of this node and sets readState parameter
     * to true if all textures have been loaded to gpu yet, false if not.
     * @returns {Boolean} true if ready to render, else false
     */
    function ready() {
        readyState = true;
        for (var i = 0; i < shape._webgl.texture.length; i++){
            if (!shape._webgl.texture[i].texture.ready){
                readyState = false;
            }
            
            
        }

        return readyState;
    }

    
    
    /*
     * Updates the loading state of children and initializes this node
     * if this wasn't done before 
     * @param {x3dom.DrawableCollection} drawableCollection 
     * @param {x3dom.fields.SFMatrix4f} transform outer transformation matrix
     * @returns {null}
     */
    function updateLoadingState(drawableCollection, transform){

        childrenReadyState = true;
        for (var i = 0; i < children.length; i++){
            if (!children[i].Ready()) {
                childrenReadyState = false;
            }
        }
        
        if (children.length < 4){
            childrenReadyState = false;
        }
        else if (childrenReadyState) {
            for (var i = 0; i < children.length; i++){
                children[i].Shape()._vf.render = true;
            }
        }
  
        if (shape._webgl === undefined || shape._webgl.texture === undefined) {
            drawableCollection.context.setupShape(drawableCollection.gl, 
                                                 {shape:shape, 
                                                  transform:transform}, 
                                                  drawableCollection.viewarea);
        }
        else {
            ready(); 
        }
    }
    
    
    
    /*
     * Decides to create new children and if the node shoud be drawn or not
     * @param {x3dom.fields.SFMatrix4f} transform outer transformation matrix
     * @param {x3dom.DrawableCollection} drawableCollection 
     * @param {bool} singlePath 
     * @param {bool} invalidateCache
     * @param {number} planeMask
     * @returns {null}
     */
    this.collectDrawables = function (transform, drawableCollection, 
                                      singlePath, invalidateCache, planeMask) {

        // definition the actual transformation of the node
        cullObject.localMatrix = nodeTransformation;
        // calculation of new plane mask
        planeMask = drawableCollection.cull(nodeTransformation, cullObject, singlePath, planeMask);
        
        // Checks the actual loading state of itself and children if something wasn't loaded in last frame
        if (!readyState || !childrenReadyState) 
            updateLoadingState(drawableCollection, nodeTransformation); 
 
        if (readyState && planeMask > 0) {
            var mat_view = drawableCollection.viewMatrix;
            var vPos = mat_view.multMatrixPnt(nodeTransformation.multMatrixPnt(position));
            var distanceToCamera = Math.sqrt(Math.pow(vPos.x, 2) + Math.pow(vPos.y, 2) + Math.pow(vPos.z, 2));

            if ((distanceToCamera < Math.pow((bvhRefiner._vf.maxDepth - level), 2) * resizeFac / bvhRefiner._vf.factor) || level < bvhRefiner._vf.minDepth) {
                if (bvhRefiner.view.isMovingOrAnimating() && children.length === 0 ||
                    bvhRefiner.view.isMovingOrAnimating() && level >= bvhRefiner._vf.interactionDepth) {
                    shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                }
                else {
                    if (children.length === 0) {
                        bvhRefiner.nodeProducer.AddNewNode(that, distanceToCamera);
                        shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                    else {
                        if (childrenReadyState) {
                            for (var i = 0; i < children.length; i++) {
                                children[i].collectDrawables(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                            }
                        }
                        else {
                            shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                            for (var i = 0; i < children.length; i++) {
                                children[i].collectDrawables(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                                children[i].Shape()._vf.render = false;
                            }
                        }
                    }
                }
            }
            else {
                shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
            }
        }
    };



    /*
     * Returns the volume of this node 
     * @returns {x3dom.fields.BoxVolume}
     */
    this.getVolume = function() {
        return shape.getVolume();
    };


    /*
     * Returns the level of this node 
     * @returns {number}
     */
    this.Level = function () {
        return level;
    };


    // reference to get access to public methods within this node
    var that = this;
    // initializes this node directly after creating
    initialize();
}



/*******************************************************************************
 *******************************************************************************
 **************************** QuadtreeNode2D ***********************************
 *******************************************************************************
 *******************************************************************************
 *
 * Defines one 2D node (plane) of a quadtree that represents a part 
 * (nxn vertices) of the whole mesh.
 * @param {object} ctx context
 * @param {x3dom.nodeTypes.BVHRefiner} bvhRefiner root bvhRefiner node  
 * @param {number} level level of the node within the quadtree
 * @param {number} nodeNumber id of the node within the level
 * @param {x3dom.fields.SFMatrix4f} nodeTransformation transformation matrix 
 *                                  that defines scale and position
 * @param {number} columnNr column number in the wmts matrix within the level
 * @param {number} rowNr row number in the wmts matrix within the level
 * @param {x3dom.nodeTypes.Plane} geometry plane
 * @param {string} path path to the nodes data 
 * @param {type} imgNumber number of the image within the path
 * @returns {QuadtreeNode2D}
 */
function QuadtreeNode2D(ctx, bvhRefiner, level, nodeNumber, nodeTransformation, 
                        columnNr, rowNr, geometry, path, imgNumber)
{

     // array with the maximal four child nodes
    var children = [];
    // drawable component of this node
    var shape = new x3dom.nodeTypes.Shape();
    // position of the node in world space
    var position = null;
    // true if this component is available and renderable
    var readyState = false;
    // checks if children are ready
    var childrenReadyState = false;
    // true if components are available and renderable
    var exists = true;
    // url of the data source
    var url = bvhRefiner._vf.textureUrl + path + imgNumber + "." + bvhRefiner._vf.textureFormat;
    // defines the resizing factor
    var resizeFac = (bvhRefiner._vf.size.x + bvhRefiner._vf.size.y) / 2.0;
    // object that stores all information to do a frustum culling
    var cullObject = {};
    
    
    
    /* 
     * Initializes all nodeTypes that are needed to create the drawable
     * component for this node
     * @returns {null}
     */
    function initialize() {

        // appearance of the drawable component of this node
        var appearance = new x3dom.nodeTypes.Appearance(ctx);
        // texture that should represent the surface-data of this node
        var texture = new x3dom.nodeTypes.ImageTexture(ctx);

        // definition of the nameSpace of this shape
        shape._nameSpace = bvhRefiner._nameSpace;
        
        // create height-data
        var texProp = new x3dom.nodeTypes.TextureProperties(ctx);
        texProp._vf.boundaryModeS = "CLAMP_TO_EDGE";
        texProp._vf.boundaryModeT = "CLAMP_TO_EDGE";
        texProp._vf.boundaryModeR = "CLAMP_TO_EDGE";
        texProp._vf.minificationFilter = "LINEAR";
        texProp._vf.magnificationFilter = "LINEAR";
        texture.addChild(texProp, "textureProperties");
        texture.nodeChanged();
        // definition of texture
        texture._nameSpace = bvhRefiner._nameSpace;
        texture._vf.url[0] = url;

        // calculate the average position of the node
        position = nodeTransformation.e3();
        
        // add textures to the appearence of this node
        appearance.addChild(texture);
        texture.nodeChanged();

        // create shape with geometry and appearance data
        shape.addChild(appearance);
        appearance.nodeChanged();
        shape.addChild(geometry);
        geometry.nodeChanged();

        // add shape to bvhRefiner object
        bvhRefiner.addChild(shape);
        shape.nodeChanged();
        
        // definition the static properties of cullObject
        cullObject.boundedNode = shape;
        cullObject.volume = shape.getVolume();
    }
    
    
    
    /*
     * Creates the four children
     * @returns {null}
     */
    this.CreateChildren = function () {
        create();
    };
    
    
    
    /*
     * Creates the four children
     * @returns {null}
     */
    function create() {
        
        // calculation of children number nodeNumber within their level
        var deltaR = Math.sqrt(Math.pow(4, level));
        var deltaR1 = Math.sqrt(Math.pow(4, level + 1));
        var lt = Math.floor(nodeNumber / deltaR) * 4 * deltaR + 
                           (nodeNumber % deltaR) * 2;
        var rt = lt + 1;
        var lb = lt + deltaR1;
        var rb = lb + 1;
        
        // calculation of the scaling factor
        var s = (bvhRefiner._vf.size).multiply(0.25);

        // creation of all children
        children.push(new QuadtreeNode2D(ctx, bvhRefiner, (level + 1), lt,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2), (rowNr * 2), geometry, path + imgNumber + "/", 1));
        children.push(new QuadtreeNode2D(ctx, bvhRefiner, (level + 1), rt,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2 + 1), (rowNr * 2), geometry, path + imgNumber + "/", 3));
        children.push(new QuadtreeNode2D(ctx, bvhRefiner, (level + 1), lb,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, -s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2), (rowNr * 2 + 1), geometry, path + imgNumber + "/", 2));
        children.push(new QuadtreeNode2D(ctx, bvhRefiner, (level + 1), rb,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, -s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2 + 1), (rowNr * 2 + 1), geometry, path + imgNumber + "/", 4));
    }    
    
    
    
    /*
     * Returns the shape of this node 
     * @returns {x3dom.nodeTypes.Shape}
     */
    this.Shape = function () {
        return shape;
    };
    
    
    
    /*
     * Runs only local ready() method. This is needed from parent to ask if 
     * all children are ready to render or not
     * @returns {Boolean} true if ready to render, else false
     */
    this.Ready = function(){
        if (shape._webgl !== undefined && shape._webgl.texture !== undefined) {
                return ready();
        }
        
        return false;
    };
    
    
    
    /*
     * Iterates through all textures of this node and sets readState parameter
     * to true if all textures have been loaded to gpu yet, false if not.
     * @returns {Boolean} true if ready to render, else false
     */
    function ready() {
        readyState = true;
        for (var i = 0; i < shape._webgl.texture.length; i++){
            if (!shape._webgl.texture[i].texture.ready){
                readyState = false;
            }
            
            
        }

        return readyState;
    }

    
    
    /*
     * Updates the loading state of children and initializes this node
     * if this wasn't done before 
     * @param {x3dom.DrawableCollection} drawableCollection 
     * @param {x3dom.fields.SFMatrix4f} transform outer transformation matrix
     * @returns {null}
     */
    function updateLoadingState(drawableCollection, transform){
        
        childrenReadyState = true;
        for (var i = 0; i < children.length; i++){
            if (!children[i].Ready()) {
                childrenReadyState = false;
            }
        }
        
        if (children.length < 4){
            childrenReadyState = false;
        }
        else if (childrenReadyState) {
            for (var i = 0; i < children.length; i++){
                children[i].Shape()._vf.render = true;
            }
        }
        

        if (shape._webgl === undefined || shape._webgl.texture === undefined) {
            drawableCollection.context.setupShape(drawableCollection.gl, 
                                                 {shape:shape, transform:transform}, 
                                                  drawableCollection.viewarea);
        }
        else {
            ready(); 
        }
        
    }
    
    
    
    /*
     * Decides to create new children and if the node shoud be drawn or not
     * @param {x3dom.fields.SFMatrix4f} transform outer transformation matrix
     * @param {x3dom.DrawableCollection} drawableCollection 
     * @param {bool} singlePath 
     * @param {bool} invalidateCache
     * @param {number} planeMask
     * @returns {null}
     */
    this.collectDrawables = function (transform, drawableCollection, 
                                      singlePath, invalidateCache, planeMask) {

        // definition the actual transformation of the node
        cullObject.localMatrix = nodeTransformation;
        // Checks the actual loading state of itself and children if something wasn't loaded in last frame
        if (!readyState || !childrenReadyState) { updateLoadingState(drawableCollection, nodeTransformation); }

        if (readyState && (planeMask = drawableCollection.cull(nodeTransformation, cullObject, singlePath, planeMask)) > 0) {
            var mat_view = drawableCollection.viewMatrix;
            var vPos = mat_view.multMatrixPnt(nodeTransformation.multMatrixPnt(position));
            var distanceToCamera = Math.sqrt(Math.pow(vPos.x, 2) + Math.pow(vPos.y, 2) + Math.pow(vPos.z, 2));

            if ((distanceToCamera < Math.pow((bvhRefiner._vf.maxDepth - level), 2) * resizeFac / bvhRefiner._vf.factor) || level < bvhRefiner._vf.minDepth) {
                if (bvhRefiner.view.isMovingOrAnimating() && children.length === 0 ||
                    bvhRefiner.view.isMovingOrAnimating() && level >= bvhRefiner._vf.interactionDepth) {
                    shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                }
                else {
                    if (children.length === 0) {
                        bvhRefiner.nodeProducer.AddNewNode(that, distanceToCamera);
                        shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                    else {
                        if (childrenReadyState) {
                            for (var i = 0; i < children.length; i++) {
                                children[i].collectDrawables(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                            }
                        }
                        else {
                            shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                            for (var i = 0; i < children.length; i++) {
                                children[i].collectDrawables(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                                children[i].Shape()._vf.render = false;
                            }
                        }
                    }
                }
            }
            else {
                shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
            }
        }
    };



    /*
     * Returns the volume of this node 
     * @returns {x3dom.fields.BoxVolume}
     */
    this.getVolume = function() {
        return shape.getVolume();
    };


    /*
     * Returns the level of this node 
     * @returns {number}
     */
    this.Level = function () {
        return level;
    };


    
    // reference to get access to public methods within this node
    var that = this;
    // initializes this node directly after creating
    initialize();
}



/*******************************************************************************
 *******************************************************************************
 **************************** QuadtreeNode3D ***********************************
 *******************************************************************************
 *******************************************************************************
 *
 * Defines one 3D node (plane with displacement) of a quadtree that represents 
 * a part (nxn vertices) of the whole mesh.
 * @param {object} ctx context
 * @param {x3dom.nodeTypes.BVHRefiner} bvhRefiner root bvhRefiner node  
 * @param {number} level level of the node within the quadtree
 * @param {number} nodeNumber id of the node within the level
 * @param {x3dom.fields.SFMatrix4f} nodeTransformation transformation matrix 
 *                                  that defines scale and position
 * @param {number} columnNr column number in the wmts matrix within the level
 * @param {number} rowNr row number in the wmts matrix within the level
 * @param {x3dom.nodeTypes.Plane} geometry plane
 * @returns {QuadtreeNode3D}
 */
function QuadtreeNode3D(ctx, bvhRefiner, level, nodeNumber, nodeTransformation, 
                        columnNr, rowNr, geometry)
{
    // array with the maximal four child nodes
    var children = [];
    // neighborhood of the node (0=left, 1=right, 2=bottom, 3=top)
    var neighbors = [];
    // drawable component of this node
    var shape = new x3dom.nodeTypes.Shape();
    // position of the node in world space
    var position = null;
    // address of the image for the bvhRefiner surface
    var imageAddressColor = bvhRefiner._vf.textureUrl + "/" + level + "/" + 
                            columnNr + "/" + rowNr + "." + 
                            (bvhRefiner._vf.textureFormat).toLowerCase();
    // address of the image for the bvhRefiner height-data
    var imageAddressHeight = bvhRefiner._vf.elevationUrl + "/" + level + "/" + 
                             columnNr + "/" + rowNr + "." + 
                             (bvhRefiner._vf.elevationFormat).toLowerCase();
    if (bvhRefiner._vf.normalUrl !== "")
        // address of the image for the bvhRefiner normal-data
        var imageAddressNormal = bvhRefiner._vf.normalUrl + "/" + level + "/" + 
                                 columnNr + "/" + rowNr + "." + 
                                 (bvhRefiner._vf.normalFormat).toLowerCase();
    // true if this component is available and renderable
    var readyState = false;
    // checks if children are ready
    var childrenReadyState = false;
    // defines the resizing factor
    var resizeFac = (bvhRefiner._vf.size.x + bvhRefiner._vf.size.y) / 2.0;
    // object that stores all information to do a frustum culling
    var cullObject = {};
    // last indice number of mesh
    var lastIndice = 0;
    // triangulation attributes --> offset and count of triangulation buffer
    var triangulationAttributes = null;



    /* 
     * Initializes all nodeTypes that are needed to create the drawable
     * component for this node
     */
    function initialize() {

        // appearance of the drawable component of this node
        var appearance = new x3dom.nodeTypes.Appearance(ctx);
        // multiTexture to get heightmap and colormap to gpu
        var textures = new x3dom.nodeTypes.MultiTexture(ctx);
        // texture that should represent the surface-data of this node
        var colorTexture = new x3dom.nodeTypes.ImageTexture(ctx);
        // texture that should represent the height-data of this node
        var heightTexture = new x3dom.nodeTypes.ImageTexture(ctx);
        // texture that should represent the normal-data of this node
        var normalTexture = new x3dom.nodeTypes.ImageTexture(ctx);
        // creating the special shader for these nodes
        var composedShader = new x3dom.nodeTypes.ComposedShader(ctx);

        // definition of the nameSpace of this shape
        shape._nameSpace = bvhRefiner._nameSpace;

        // calculate the average position of the node
        position = nodeTransformation.e3();
        position.z = bvhRefiner._vf.maxElevation / 2;
        
        // creating the special vertex-shader for bvhRefiner-nodes
        var vertexShader = new x3dom.nodeTypes.ShaderPart(ctx);
        vertexShader._vf.type = 'vertex';
        vertexShader._vf.url[0] = createVertexShader();

        // creating the special fragment-shader for bvhRefiner-nodes
        var fragmentShader = new x3dom.nodeTypes.ShaderPart(ctx);
        fragmentShader._vf.type = 'fragment';
        fragmentShader._vf.url[0] = createFragmentShader();

        // create complete-shader with vertex- and fragment-shader
        composedShader.addChild(vertexShader, 'parts');
        composedShader.addChild(fragmentShader, 'parts');

        var colorTexProp = new x3dom.nodeTypes.TextureProperties(ctx);
        colorTexProp._vf.boundaryModeS = "CLAMP_TO_EDGE";
        colorTexProp._vf.boundaryModeT = "CLAMP_TO_EDGE";
        colorTexProp._vf.boundaryModeR = "CLAMP_TO_EDGE";
        colorTexProp._vf.minificationFilter = "LINEAR";
        colorTexProp._vf.magnificationFilter = "LINEAR";
        colorTexture.addChild(colorTexProp, "textureProperties");
        colorTexture.nodeChanged();
        // create texture-data of this node with url's of the texture data
        colorTexture._nameSpace = bvhRefiner._nameSpace;
        colorTexture._vf.url[0] = imageAddressColor;
        colorTexture._vf.repeatT = false;
        colorTexture._vf.repeatS = false;
        textures.addChild(colorTexture, 'texture');
        colorTexture.nodeChanged();
        var colorTextureField = new x3dom.nodeTypes.Field(ctx);
        colorTextureField._vf.name = 'texColor';
        colorTextureField._vf.type = 'SFInt32';
        colorTextureField._vf.value = 0;
        composedShader.addChild(colorTextureField, 'fields');
        colorTextureField.nodeChanged();

        // create height-data
        var heightTexProp = new x3dom.nodeTypes.TextureProperties(ctx);
        heightTexProp._vf.boundaryModeS = "CLAMP_TO_EDGE";
        heightTexProp._vf.boundaryModeT = "CLAMP_TO_EDGE";
        heightTexProp._vf.boundaryModeR = "CLAMP_TO_EDGE";
        heightTexProp._vf.minificationFilter = "NEAREST";
        heightTexProp._vf.magnificationFilter = "NEAREST";
        heightTexture.addChild(heightTexProp, "textureProperties");
        heightTexture.nodeChanged();
        heightTexture._nameSpace = bvhRefiner._nameSpace;
        heightTexture._vf.url[0] = imageAddressHeight;
        heightTexture._vf.repeatT = false;
        heightTexture._vf.repeatS = false;
        heightTexture._vf.scale = false;
        textures.addChild(heightTexture, 'texture');
        heightTexture.nodeChanged();
        var heightTextureField = new x3dom.nodeTypes.Field(ctx);
        heightTextureField._vf.name = 'texHeight';
        heightTextureField._vf.type = 'SFInt32';
        heightTextureField._vf.value = 1;
        composedShader.addChild(heightTextureField, 'fields');
        heightTextureField.nodeChanged();

        if (bvhRefiner._vf.normalUrl !== "") {
            var normalTexProp = new x3dom.nodeTypes.TextureProperties(ctx);
            normalTexProp._vf.boundaryModeS = "CLAMP_TO_EDGE";
            normalTexProp._vf.boundaryModeT = "CLAMP_TO_EDGE";
            normalTexProp._vf.boundaryModeR = "CLAMP_TO_EDGE";
            normalTexProp._vf.minificationFilter = "LINEAR";
            normalTexProp._vf.magnificationFilter = "LINEAR";
            normalTexture.addChild(normalTexProp, "textureProperties");
            normalTexture.nodeChanged();
            // create normal-data
            normalTexture._nameSpace = bvhRefiner._nameSpace;
            normalTexture._vf.url[0] = imageAddressNormal;
            normalTexture._vf.repeatT = false;
            normalTexture._vf.repeatS = false;
            textures.addChild(normalTexture, 'texture');
            normalTexture.nodeChanged();
            var normalTextureField = new x3dom.nodeTypes.Field(ctx);
            normalTextureField._vf.name = 'texNormal';
            normalTextureField._vf.type = 'SFInt32';
            normalTextureField._vf.value = 2;
            composedShader.addChild(normalTextureField, 'fields');
            normalTextureField.nodeChanged();
        }
        
        // transmit maximum elevation value to gpu
        var maxHeight = new x3dom.nodeTypes.Field(ctx);
        maxHeight._vf.name = 'maxElevation';
        maxHeight._vf.type = 'SFFloat';
        maxHeight._vf.value = bvhRefiner._vf.maxElevation;
        composedShader.addChild(maxHeight, 'fields');
        maxHeight.nodeChanged();

        // add textures to the appearence of this node
        appearance.addChild(textures);
        textures.nodeChanged();
        appearance.addChild(composedShader);
        composedShader.nodeChanged();

        // create shape with geometry and appearance data
        shape.addChild(appearance);
        appearance.nodeChanged();
        shape.addChild(geometry);

        // add shape to bvhRefiner object
        bvhRefiner.addChild(shape);
        shape.nodeChanged();

        // definition the static properties of cullObject
        cullObject.boundedNode = shape;
        cullObject.volume = shape.getVolume();
        // setting max and min in z-direction to get the complete volume
        cullObject.volume.max.z = bvhRefiner._vf.maxElevation;
        cullObject.volume.min.z = 0;

        cullObject.volume.center = cullObject.volume.min.add(cullObject.volume.max).multiply(0.5);
        cullObject.volume.transform(nodeTransformation);
        //shape._graph.volume = cullObject.volume;
        
        calculateNeighborhood();
    }
    
    
    
    function calculateNeighborhood() {

        // stores the start-ID of this level in quadList
        var levelStartID = 0;

        // calculate id in quadList where to store this quad
        for (var i = 0; i < level; i++) {
            levelStartID += Math.pow(4, i);
        }
        var sid = levelStartID + nodeNumber;
        bvhRefiner.nodeList[sid] = that;

        var c = Math.sqrt(Math.pow(4, level));
        // calculate neighbor-IDs
        // on the left side of the quad
        neighbors[0] = levelStartID + (Math.ceil(((nodeNumber + 1) / c) - 1) * c + ((nodeNumber + (c - 1)) % c));
        // on the right side of the quad
        neighbors[1] = levelStartID + (Math.ceil(((nodeNumber + 1) / c) - 1) * c + ((nodeNumber + 1) % c));
        // on the top side of the quad
        neighbors[3] = levelStartID + (nodeNumber + (c * (c - 1))) % (Math.pow(4, level));
        // on the bottom side of the quad
        neighbors[2] = levelStartID + (nodeNumber + c) % (Math.pow(4, level));

        if (columnNr === 0) { neighbors[0] = -1; }
        if (rowNr === 0) { neighbors[3] = -1; }
        if (columnNr === c - 1) { neighbors[1] = -1; }
        if (rowNr === c - 1) { neighbors[2] = -1; }
    }



    /* 
     * Creates the code for the vertex shader
     * @returns {String} code of the vertex shader 
     */
    function createVertexShader() {
        if (bvhRefiner._vf.normalUrl !== "")
            return "attribute vec3 position;\n" +
                "attribute vec3 texcoord;\n" +
                "uniform mat4 modelViewMatrix;\n" +
                "uniform mat4 modelViewProjectionMatrix;\n" +
                "uniform sampler2D texColor;\n" +
                "uniform sampler2D texHeight;\n" +
                "uniform float maxElevation;\n" +
                "uniform sampler2D texNormal;\n" +
                "varying vec2 texC;\n" +
                "varying vec3 vLight;\n" +
                "const float shininess = 32.0;\n" + 
                "\n" +
                "void main(void) {\n" +
                "    vec3 uLightPosition = vec3(160.0, -9346.0, 4806.0);\n" +
                "    vec4 colr = texture2D(texColor, vec2(texcoord[0], 1.0-texcoord[1]));\n" +
                "    vec3 uAmbientMaterial = vec3(1.0, 1.0, 0.9);" +
                "    vec3 uAmbientLight = vec3(0.5, 0.5, 0.5);" +
                "    vec3 uDiffuseMaterial = vec3(0.7, 0.7, 0.7);" +
                "    vec3 uDiffuseLight = vec3(1.0, 1.0, 1.0);" +
                "    vec4 vertexPositionEye4 = modelViewMatrix * vec4(position, 1.0);" +
                "    vec3 vertexPositionEye3 = vec3((modelViewMatrix * vec4(vertexPositionEye4.xyz, 1.0)).xyz);" +
                "    vec3 vectorToLightSource = normalize(uLightPosition - vertexPositionEye3);" +
                "    vec4 height = texture2D(texHeight, vec2(texcoord[0], 1.0 - texcoord[1]));\n" +
                "    vec4 normalEye = 2.0 * texture2D(texNormal, vec2(texcoord[0], 1.0-texcoord[1])) - 1.0;\n" +
                "    float diffuseLightWeighting = max(dot(normalEye.xyz, vectorToLightSource), 0.0);" +
                "    texC = vec2(texcoord[0], 1.0-texcoord[1]);\n" +
                "    vec3 diffuseReflectance = uDiffuseMaterial * uDiffuseLight * diffuseLightWeighting;" +
                "    vec3 uSpecularMaterial = vec3(0.0, 0.0, 0.0);" +
                "    vec3 uSpecularLight = vec3(1.0, 1.0, 1.0);" +
                "    vec3 reflectionVector = normalize(reflect(-vectorToLightSource, normalEye.xyz));" +
                "    vec3 viewVectorEye = -normalize(vertexPositionEye3);" +
                "    float rdotv = max(dot(reflectionVector, viewVectorEye), 0.0);" +
                "    float specularLightWeight = pow(rdotv, shininess);" +
                "    vec3 specularReflection = uSpecularMaterial * uSpecularLight * specularLightWeight;" +
                "    vLight = vec4(uAmbientMaterial * uAmbientLight + diffuseReflectance + specularReflection, 1.0).xyz;" +
                "    gl_Position = modelViewProjectionMatrix * vec4(position.xy, height.x * maxElevation, 1.0);\n" +
                "}\n";
        else
            return "attribute vec3 position;\n" +
                "attribute vec3 texcoord;\n" +
                "uniform mat4 modelViewProjectionMatrix;\n" +
                "uniform sampler2D texHeight;\n" +
                "uniform float maxElevation;\n" +
                "varying vec2 texC;\n" +
                "\n" +
                "void main(void) {\n" +
                "    vec4 height = texture2D(texHeight, vec2(texcoord[0], 1.0 - texcoord[1]));\n" +
                "    texC = vec2(texcoord[0], 1.0-texcoord[1]);\n" +
                "    gl_Position = modelViewProjectionMatrix * vec4(position.xy, height.x * maxElevation, 1.0);\n" +
                "}\n";
    }


    
    /* 
     * Creates the code for the fragment shader
     * @returns {String} code of the fragment shader 
     */
    function createFragmentShader() {
        if (bvhRefiner._vf.normalUrl !== "")
            return "#ifdef GL_ES\n" +
                "precision highp float;\n" +
                "#endif\n" +
                "uniform sampler2D texColor;\n" +
                "uniform sampler2D texNormal;\n" +
                "varying vec2 texC;\n" +
                "varying vec3 vLight;\n" +
                "\n" +
                "\n" +
                "void main(void) {\n" +
                "    vec4 normal = 2.0 * texture2D(texNormal, texC) - 1.0;\n" +
                "    vec4 colr = texture2D(texColor, texC);\n" +
                "    gl_FragColor = vec4(colr.xyz * vLight, colr.w);\n" +
                "}\n";
        else 
            return "#ifdef GL_ES\n" +
                "precision highp float;\n" +
                "#endif\n" +
                "uniform sampler2D texColor;\n" +
                "varying vec2 texC;\n" +
                "\n" +
                "\n" +
                "void main(void) {\n" +
                "    gl_FragColor = texture2D(texColor, texC);\n" +
                "}\n";
    }
    
    
    
    this.CreateChildren = function() {
        create();
    };



    /* 
     * Creates the four children 
     */
    function create() {
        
        // calculation of children number nodeNumber within their level
        var deltaR = Math.sqrt(Math.pow(4, level));
        var deltaR1 = Math.sqrt(Math.pow(4, level + 1));
        var lt = Math.floor(nodeNumber / deltaR) * 4 * deltaR + 
                           (nodeNumber % deltaR) * 2;
        var rt = lt + 1;
        var lb = lt + deltaR1;
        var rb = lb + 1;
        
        // calculation of the scaling factor
        var s = (bvhRefiner._vf.size).multiply(0.25);

        // creation of all children
        children.push(new QuadtreeNode3D(ctx, bvhRefiner, (level + 1), lt,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2), (rowNr * 2), geometry));
        children.push(new QuadtreeNode3D(ctx, bvhRefiner, (level + 1), rt,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2 + 1), (rowNr * 2), geometry));
        children.push(new QuadtreeNode3D(ctx, bvhRefiner, (level + 1), lb,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, -s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2), (rowNr * 2 + 1), geometry));
        children.push(new QuadtreeNode3D(ctx, bvhRefiner, (level + 1), rb,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, -s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2 + 1), (rowNr * 2 + 1), geometry));
    }
    
    
    
    this.Shape = function(){
        return shape;
    };
    
    
    
    /* 
     * Returns if the children of this node exist and are ready to render
     */
    this.ChildrenReady = function(){
        return childrenReadyState;
    };
    
    
    
    /* 
     * Runs only local ready() method. This is needed from parent to ask if 
     * all children are ready to render or not 
     */
    this.Ready = function(){
        if (shape._webgl !== undefined && shape._webgl.texture !== undefined) {
                return ready();
        }

        return false;
    };
    
    
    
    /* 
     * Iterates through all textures of this node and sets readState parameter
     * to true if all textures have been loaded to gpu yet, false if not.
     */
    function ready() {
        readyState = true;
        for (var i = 0; i < shape._webgl.texture.length; i++){
            if (!shape._webgl.texture[i].texture.ready){
                readyState = false;
            }
        }

        return readyState;
    }

    
    
    /* 
     * Updates the loading state of children and initializes this node
     * if this wasn't done before 
     */
    function updateLoadingState(drawableCollection, transform){

        childrenReadyState = true;
        for (var i = 0; i < children.length; i++){
            if (!children[i].Ready()) {
                childrenReadyState = false;
            }
        }
        
        if (children.length < 4){
            childrenReadyState = false;
        }
        else if (childrenReadyState) {
            for (var i = 0; i < children.length; i++){
                children[i].Shape()._vf.render = true;
            }
        }
  
        if (shape._webgl === undefined || shape._webgl.texture === undefined) {
            drawableCollection.context.setupShape(drawableCollection.gl, 
                                                 {shape:shape, transform:transform}, 
                                                  drawableCollection.viewarea);
        }
        else {
            ready(); 
        }
        
    }
    
    
    
    
    /*
     * Decides to create new children and if the node shoud be drawn or not
     * @param {x3dom.fields.SFMatrix4f} transform outer transformation matrix
     * @param {x3dom.DrawableCollection} drawableCollection 
     * @param {bool} singlePath 
     * @param {bool} invalidateCache
     * @param {number} planeMask
     * @returns {null}
     */
    this.collectDrawables = function (transform, drawableCollection, singlePath, invalidateCache, planeMask) {

        // TODO: IMPLEMENT RIGHT
        drawableCollection.frustumCulling = false;


        // definition the actual transformation of the node
        cullObject.localMatrix = nodeTransformation;   
        // Checks the actual loading state of itself and children if something wasn't loaded in last frame
        if (!readyState || !childrenReadyState) {
            updateLoadingState(drawableCollection, nodeTransformation);
        }
        var mat_view = drawableCollection.viewMatrix;
        var vPos = mat_view.multMatrixPnt(nodeTransformation.multMatrixPnt(position));
        var distanceToCamera = Math.sqrt(Math.pow(vPos.x, 2) + Math.pow(vPos.y, 2) + Math.pow(vPos.z, 2));

        //if (readyState && (planeMask = drawableCollection.cull(nodeTransformation, shape.graphState(), singlePath, planeMask)) > 0) {
        if (readyState && vPos.z - (cullObject.volume.diameter / 2) < 0) {
            if ((distanceToCamera < Math.pow((bvhRefiner._vf.maxDepth - level), 2) * resizeFac / bvhRefiner._vf.factor) ||
                    level < bvhRefiner._vf.minDepth) {
                if (bvhRefiner.view.isMovingOrAnimating() && (children.length == 0 || level >= bvhRefiner._vf.interactionDepth)){
                    render(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                }
                else {
                    if (children.length === 0) {
                        bvhRefiner.nodeProducer.AddNewNode(that, distanceToCamera);
                        render(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                    else {
                        if (childrenReadyState){
                            for (var i = 0; i < children.length; i++) {
                                children[i].collectDrawables(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                            }
                        }
                        else {
                            render(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                            for (var i = 0; i < children.length; i++) {
                                children[i].collectDrawables(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                                children[i].Shape()._vf.render = false;
                            }
                        }
                    }
                }
            }
            else {
                render(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
            }
        }
    };
    
    
    
    /*
     * Decides if this node should be rendered or the children of this node
     * @param {x3dom.DrawableCollection} drawableCollection 
     * @returns {Boolean}
     */
    this.hasHigherRenderLevel = function(drawableCollection){

            var mat_view = drawableCollection.viewMatrix;
            var vPos = mat_view.multMatrixPnt(nodeTransformation.multMatrixPnt(position));
            var distanceToCamera = Math.sqrt(Math.pow(vPos.x, 2) + Math.pow(vPos.y, 2) + Math.pow(vPos.z, 2));

            if (distanceToCamera < Math.pow((bvhRefiner._vf.maxDepth - level), 2) * resizeFac / bvhRefiner._vf.factor){
                return true;
            }
        
        
        return false;
    };
    
    
    
    /*
     * Renders the object with the required patch version
     * @param {x3dom.fields.SFMatrix4f} transform outer transformation matrix
     * @param {x3dom.DrawableCollection} drawableCollection 
     * @param {bool} singlePath 
     * @param {bool} invalidateCache
     * @param {number} planeMask
     * @returns {null}
     */
    function render(transform, drawableCollection, singlePath, invalidateCache, planeMask){
        
        var hasNeighborHigherResolution = [];
        // Calculation if neighbors levels 
        for (var i = 0; i < neighbors.length; i++){
            if (bvhRefiner.nodeList[neighbors[i]] !== undefined) {
                if (bvhRefiner.nodeList[neighbors[i]].ChildrenReady() && 
                    bvhRefiner.nodeList[neighbors[i]].hasHigherRenderLevel(drawableCollection))
                    hasNeighborHigherResolution.push(true);
                else 
                    hasNeighborHigherResolution.push(false);
            }
            else {
                hasNeighborHigherResolution.push(false);
            }
        }
        
        var indiceNumber = 0;
        //hasNeighborHigherResolution --> 0=left, 1=right, 2=bottom, 3=top
        if (hasNeighborHigherResolution[3]) {
            if (hasNeighborHigherResolution[1]) {
                indiceNumber = 5;
            }
            else if (hasNeighborHigherResolution[0]) {
                indiceNumber = 6;
            }
            else {
                indiceNumber = 4;
            }
        }
        else if (hasNeighborHigherResolution[2]) {
            if (hasNeighborHigherResolution[1]) {
                indiceNumber = 8;
            }
            else if (hasNeighborHigherResolution[0]) {
                indiceNumber = 7;
            }
            else {
                indiceNumber = 3;
            }
        }
        else if (hasNeighborHigherResolution[0]) {
            indiceNumber = 1;
        }
        else if (hasNeighborHigherResolution[1]) {
            indiceNumber = 2;
        }
        
        if (lastIndice !== indiceNumber || triangulationAttributes === null){
            triangulationAttributes = shape._cf.geometry.node.getTriangulationAttributes(indiceNumber);
            lastIndice = indiceNumber;
        }
        shape._tessellationProperties = [ triangulationAttributes ];
        shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
    }



    /* 
     * Returns the volume of this node
     */
    this.getVolume = function() {
        // TODO; implement correctly, for now just use first shape as workaround
        return shape.getVolume();
    };
    
    
    
    this.Level = function() {
        return level;
    };


    var that = this;
    // initializes this node directly after creating
    initialize();
}




/*****************************************************************************************************************************
 *****************************************************************************************************************************
 ************************************************ QuadtreeNodeBin ************************************************************
 *****************************************************************************************************************************
 ****************************************************************************************************************************/

/*
 * Defines one node of a quadtree that represents a part (nxn vertices) of 
 * the whole mesh, that represents a binary geometry object.
 * @param {object} ctx context
 * @param {x3dom.nodeTypes.BVHRefiner} bvhRefiner root bvhRefiner node  
 * @param {number} level level of the node within the quadtree
 * @param {number} columnNr column number in the wmts matrix within the level
 * @param {number} rowNr row number in the wmts matrix within the level
 * @param {number} resizeFac defines the resizing factor. Can be null on init
 * @returns {QuadtreeNodeBin}
 */
function QuadtreeNodeBin(ctx, bvhRefiner, level, columnNr, rowNr, resizeFac)
{
    // object that stores all information to do a frustum culling
    var cullObject = {};
    // temporary variable to store the view matrix
    var mat_view;
    // temporary position of this node in view space
    var vPos;
    // temporary distance to camera in view space
    var distanceToCamera;
    // factor redefinition to get a view about the whole scene on level three
    var fac = ((1 / 4 * Math.pow(level, 2) + 1.5) * 0.1) * bvhRefiner._vf.factor;
    // array with the maximal four child nodes
    var children = [];
    // true if a file for the children is available
    var childrenExist = false;
    // true if this component is available and renderable
    var readyState = false;
    // checks if children are ready
    var childrenReadyState = false;
    // path to x3d-file that should be loaded
    var path = bvhRefiner._vf.url + "/" + level + "/" + columnNr + "/";
    // address of the image for the bvhRefiner height-data
    var file = path + rowNr + ".x3d";
     // position of the node in world space
    var position = new x3dom.fields.SFVec3f(0.0, 0.0, 0.0);
    // stores if file has been loaded
    var exists = false;
    // drawable component of this node
    var shape = new x3dom.nodeTypes.Shape(ctx);
    
    
    // loader for binary geometry files
    var xhr = new XMLHttpRequest();
    xhr.open("GET", file, false);
    // Try to load the binary geometry files
    try {
        xhr.send();

        var xmlDoc = xhr.responseXML;
        if (xmlDoc !== null) {
            var replacer = new RegExp("\"", "g");
            createGeometry(shape);
            initialize();
            exists = true;
        }
    }
    catch (exp) {
        x3dom.debug.logException("Error loading file '" + file + "': " + exp);
    }


    this.Exists = function () {
        return exists;
    };


    this.Shape = function () {
        return shape;
    };



    /*
    * creates the geometry of this node
    */
    function createGeometry(parent) {
        // definition of nameSpace
        this._nameSpace = new x3dom.NodeNameSpace("", bvhRefiner._nameSpace.doc);
        this._nameSpace.setBaseURL(bvhRefiner._nameSpace.baseURL + path);
        var tempShape = xmlDoc.getElementsByTagName("Shape")[0];
        shape = this._nameSpace.setupTree(tempShape);
        if (!bvhRefiner._vf.useNormals) {
            var appearance = new x3dom.nodeTypes.Appearance(ctx);
            var material = new x3dom.nodeTypes.Material(ctx);
            appearance.addChild(material);
            shape._cf.appearance = appearance;
        }
        position = x3dom.fields.SFVec3f.copy(shape._cf.geometry.node._vf.position);
    }



    /*
    * creates the appearance for this node and add it to the dom tree
    */
    function initialize() {

        // bind static cull-properties to cullObject
        cullObject.boundedNode = shape;
        cullObject.volume = shape.getVolume();
    }



    this.CreateChildren = function () {
        create();
    };



    /*
     * creates the four child-nodes
     */
    function create() {
        children.push(new QuadtreeNodeBin(ctx, bvhRefiner, (level + 1), (columnNr * 2), (rowNr * 2), resizeFac));
        children.push(new QuadtreeNodeBin(ctx, bvhRefiner, (level + 1), (columnNr * 2 + 1), (rowNr * 2), resizeFac));
        children.push(new QuadtreeNodeBin(ctx, bvhRefiner, (level + 1), (columnNr * 2), (rowNr * 2 + 1), resizeFac));
        children.push(new QuadtreeNodeBin(ctx, bvhRefiner, (level + 1), (columnNr * 2 + 1), (rowNr * 2 + 1), resizeFac));
    }
    
    
    
    /* 
    * Runs only local ready() method. This is needed from parent to ask if 
    * all children are ready to render or not 
    */
    this.Ready = function () {
        if (shape._webgl !== undefined && shape._webgl.internalDownloadCount !== undefined) {
            return ready();
        }

        return false;
    };



    /* 
    * Iterates through all textures of this node and sets readState parameter
    * to true if all textures have been loaded to gpu yet, false if not.
    */
    function ready() {
        readyState = true;

        if (shape._webgl.internalDownloadCount > 0) {
            readyState = false;
        }

        return readyState;
    }



    /* 
    * Updates the loading state of children and initializes this node
    * if this wasn't done before 
    */
    function updateLoadingState(drawableCollection, transform) {

        childrenReadyState = true;
        for (var i = 0; i < children.length; i++) {
            if (!children[i].Ready()) {
                childrenReadyState = false;
            }
        }
        
        if (childrenReadyState){
            for (var i = 0; i < children.length; i++){
                children[i].Shape()._vf.render = true;
            }
        }

        if (shape._cf.geometry.node !== null) {
            if (shape._webgl === undefined || shape._webgl.internalDownloadCount === undefined) {
                drawableCollection.context.setupShape(drawableCollection.gl,
                                                     { shape: shape, transform: transform },
                                                      drawableCollection.viewarea);
            }
            else {
                ready();
            }
        }
    }



    /* 
    * Decides to create new children and if the node shoud be drawn or not
    */
    this.collectDrawables = function (transform, drawableCollection, singlePath, invalidateCache, planeMask) {

        // THIS CALC IS ONLY FOR THE DEMO AND HAS TO BE DELETED AFTER IT
        fac = ((1 / 4 * Math.pow(level, 2) + 1.5) * 0.1) * bvhRefiner._vf.factor;

        // definition the actual transformation of the node
        cullObject.localMatrix = transform;

        // Checks the actual loading state of itself and children if something wasn't loaded in last frame
        if (!readyState || !childrenReadyState) { updateLoadingState(drawableCollection, transform); }

        if (readyState && exists && (planeMask = drawableCollection.cull(transform, cullObject, singlePath, planeMask)) > 0) {
            mat_view = drawableCollection.viewMatrix;
            vPos = mat_view.multMatrixPnt(transform.multMatrixPnt(position));
            distanceToCamera = Math.sqrt(Math.pow(vPos.x, 2) + Math.pow(vPos.y, 2) + Math.pow(vPos.z, 2));

            if ((distanceToCamera < Math.pow((bvhRefiner._vf.maxDepth - level), 2) / fac * 1000) || level < bvhRefiner._vf.minDepth) {
                if (bvhRefiner.view.isMovingOrAnimating() && level >= bvhRefiner._vf.interactionDepth) {
                    shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                }
                else {
                    if (children.length === 0) {
                        bvhRefiner.nodeProducer.AddNewNode(that, distanceToCamera);
                        shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                    else if (children.length === 0 && bvhRefiner.createChildren > 0) {
                        shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                    else {
                        if (!childrenExist) {
                            for (var i = 0; i < children.length; i++) {
                                if (children[i].Exists()) {
                                    childrenExist = true;
                                    break;
                                }
                            }
                        }
                        if (childrenExist && childrenReadyState) {
                            for (var i = 0; i < children.length; i++) {
                                children[i].collectDrawables(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                            }
                        }
                        else {
                            for (var i = 0; i < children.length; i++) {
                                children[i].collectDrawables(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                                children[i].Shape()._vf.render = false;
                            }
                            shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                        }
                    }
                }
            }
            else {
                shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
            }
        }
    };



    /*
    * Returns the volume of this node
    */
    this.getVolume = function () {
        // TODO; implement correctly, for now just use first shape as workaround
        return shape.getVolume();
    };



    this.Level = function () {
        return level;
    };


    var that = this;
    // initializes this node directly after creating
    initialize();
}




/*****************************************************************************************************************************
 *****************************************************************************************************************************
 ***************************************************** BVHNode ***************************************************************
 *****************************************************************************************************************************
 ****************************************************************************************************************************/

/*
 * Defines one node of an arbitrary tree that represents a part (nxn vertices)  
 * of the entire point cloud
 * @param {object} ctx context
 * @param {x3dom.nodeTypes.BVHRefiner} bvhRefiner root bvhRefiner node  
 * @param {number} level level of the node within the quadtree
 * @param {number} columnNr column number in the wmts matrix within the level
 * @param {number} rowNr row number in the wmts matrix within the level
 * @param {number} resizeFac defines the resizing factor. Can be null on init
 * @returns {OctreeNode}
 */
function BVHNode(ctx, bvhRefiner, level, path, imgNumber, count)
{
    // object that stores all information to do a frustum culling
    var cullObject = {};
    // temporary variable to store the view matrix
    var mat_view;
    // temporary position of this node in view space
    var vPos;
    // temporary distance to camera in view space
    var distanceToCamera;
    // factor redefinition to get a view about the whole scene on level three
    var fac = ((1/4 * Math.pow(level, 2) + 1.5) * 0.1) * bvhRefiner._vf.factor;
    // array with the maximal four child nodes
    var children = [];
    // true if a file for the children is available
    var childrenExist = false;
    // true if this component is available and renderable
    var readyState = false;
    // checks if children are ready
    var childrenReadyState = false;
    // address of the image for the bvhRefiner height-data
    var file = bvhRefiner._vf.url + path + imgNumber + ".x3d";
    // position of the node in world space
    var position = new x3dom.fields.SFVec3f(0.0, 0.0, 0.0);
    // stores if file has been loaded
    var exists = false;
    // drawable component of this node
    var shape = new x3dom.nodeTypes.Shape(ctx);
    
    
    this.RecalcFactor = function() {
        fac = ((1/4 * Math.pow(level, 2) + 1.5) * 0.1) * bvhRefiner._vf.factor;
        for (var i = 0; i < children.length; i++){
            children[i].RecalcFactor();
        }
    };
    
    
    
    // loader for binary geometry files
    var xhr = new XMLHttpRequest();
    xhr.open("GET", file, false);
    // Try to load the binary geometry files
    try {
        xhr.send();

        var xmlDoc = xhr.responseXML;
        if (xmlDoc !== null) {
            var replacer = new RegExp("\"", "g");
            createGeometry(shape);
            initialize();
            exists = true;
        }
    }
    catch (exp) {
        x3dom.debug.logException("Error loading file '" + file + "': " + exp);
    }
    
    
    this.Exists = function()
    {
        return exists;
    };
    
    
    this.Shape = function(){
        return shape;
    };



    /*
     * creates the geometry of this node
     */
    function createGeometry(parent) {
        // definition of nameSpace
        this._nameSpace = new x3dom.NodeNameSpace("", bvhRefiner._nameSpace.doc);
        this._nameSpace.setBaseURL(bvhRefiner._nameSpace.baseURL + bvhRefiner._vf.url + path);
        var tempShape = xmlDoc.getElementsByTagName("Shape")[0];
        shape = this._nameSpace.setupTree(tempShape);
        if (!bvhRefiner._vf.useNormals){
            var appearance = new x3dom.nodeTypes.Appearance(ctx);
            var material = new x3dom.nodeTypes.Material(ctx);
            appearance.addChild(material);
            shape._cf.appearance = appearance;
        }
        position = x3dom.fields.SFVec3f.copy(shape._cf.geometry.node._vf.position);
    }



    /*
     * creates the appearance for this node and add it to the dom tree
     */
    function initialize() {
       
        // bind static cull-properties to cullObject
        cullObject.boundedNode = shape; 
        cullObject.volume = shape.getVolume();
    }


    
    this.CreateChildren = function() {
        create();
    };
    
    
    
    /*
     * creates the four child-nodes
     */
    function create() {
        for (var i = 0; i < count; i++){
            children.push(new BVHNode(ctx, bvhRefiner, (level + 1),
                                      path + imgNumber + "/", 
                                      i + 1, count));
        }
    }
    
    
    
    /* 
     * Runs only local ready() method. This is needed from parent to ask if 
     * all children are ready to render or not 
     */
    this.Ready = function(){
        if (shape._webgl !== undefined && shape._webgl.internalDownloadCount !== undefined) {
                return ready();
        }
        
        return false;
    };
    
    
    
    /* 
     * Iterates through all textures of this node and sets readState parameter
     * to true if all textures have been loaded to gpu yet, false if not.
     */
    function ready() {
        return (shape._webgl.internalDownloadCount <= 0);
    }

    
    
    /* 
     * Updates the loading state of children and initializes this node
     * if this wasn't done before 
     */
    function updateLoadingState(drawableCollection, transform){
        
        for (var i = 0; i < children.length; i++) {
            childrenReadyState = true;
            if (!children[i].Ready()) {
                childrenReadyState = false;
            }
            else {
                children[i].Shape()._vf.render = true;
            }
        }

        if (shape._cf.geometry.node !== null) {
            if (shape._webgl === undefined || shape._webgl.internalDownloadCount === undefined) {
                drawableCollection.context.setupShape(drawableCollection.gl, 
                                                     {shape:shape, transform:transform}, 
                                                      drawableCollection.viewarea);
            }
            else {
                ready(); 
            }
        }
    }



    /* 
     * Decides to create new children and if the node shoud be drawn or not
     */
    this.collectDrawables = function (transform, drawableCollection, singlePath, invalidateCache, planeMask) {

        // THIS CALC IS ONLY FOR THE DEMO AND HAS TO BE DELETED AFTER IT
        fac = ((1/4 * Math.pow(level, 2) + 1.5) * 0.1) * bvhRefiner._vf.factor;

        // definition the actual transformation of the node
        cullObject.localMatrix = transform;

        // Checks the actual loading state of itself and children if something wasn't loaded in last frame
        if (!readyState || !childrenReadyState) { updateLoadingState(drawableCollection, transform); }

        if (readyState && exists && (planeMask = drawableCollection.cull(transform, cullObject, singlePath, planeMask)) > 0) {
            mat_view = drawableCollection.viewMatrix;
            vPos = mat_view.multMatrixPnt(transform.multMatrixPnt(position));
            distanceToCamera = Math.sqrt(Math.pow(vPos.x, 2) + Math.pow(vPos.y, 2) + Math.pow(vPos.z, 2));
                        
            if ((distanceToCamera < Math.pow((bvhRefiner._vf.maxDepth - level), 2) / fac) || level < bvhRefiner._vf.minDepth) {
                if (bvhRefiner.view.isMovingOrAnimating() && level >= bvhRefiner._vf.interactionDepth) {
                    shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                }
                else {
                    if (children.length === 0) {
                        bvhRefiner.nodeProducer.AddNewNode(that, distanceToCamera);
                        shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                    else if (children.length === 0 && bvhRefiner.createChildren > 0) {
                        shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                    else {
                        if (!childrenExist){
                            for (var i = 0; i < children.length; i++) {
                                if (children[i].Exists()) {
                                    childrenExist = true;
                                    break;
                                }
                            }
                        }
                        if (childrenExist && childrenReadyState){
                            for (var i = 0; i < children.length; i++) {
                                children[i].collectDrawables(transform, drawableCollection, singlePath, invalidateCache, planeMask);   
                            }
                        }
                        else {
                            for (var i = 0; i < children.length; i++) {
                                children[i].collectDrawables(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                                children[i].Shape()._vf.render = false;
                            }
                            shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
                        }
                    }
                }
            }
            else {
                shape.collectDrawableObjects(transform, drawableCollection, singlePath, invalidateCache, planeMask);
            }
        }
    };



    /*
     * Returns the volume of this node
     */
    this.getVolume = function() {
        // TODO; implement correctly, for now just use first shape as workaround
        return shape.getVolume();
    };
    
    
    
    this.Level = function() {
        return level;
    };


    var that = this;
    // initializes this node directly after creating
    initialize();
}





/*
 * Defines one 3D node (plane with displacement) of a quadtree that represents 
 * a part (nxn vertices) of the whole mesh.
 * @param {object} ctx context
 * @param {x3dom.nodeTypes.BVHRefiner} bvhRefiner root bvhRefiner node  
 * @param {number} level level of the node within the quadtree
 * @param {number} nodeNumber id of the node within the level
 * @param {x3dom.fields.SFMatrix4f} nodeTransformation transformation matrix that defines scale and position
 * @param {number} columnNr column number in the wmts matrix within the level
 * @param {number} rowNr row number in the wmts matrix within the level
 * @param {x3dom.nodeTypes.Plane} geometry plane
 * @returns {QuadtreeNode3D}
 */
function QuadtreeNode3D_NEW(ctx, bvhRefiner, level, nodeNumber, nodeTransformation, 
                        columnNr, rowNr, geometry)
{
    // array with the maximal four child nodes
    var children = [];
    // drawable component of this node
    var shape = new x3dom.nodeTypes.Shape();
    // position of the node in world space
    var position = null;
    // address of the image for the bvhRefiner surface
    var imageAddressColor = bvhRefiner._vf.textureUrl + "/" + level + "/" + 
                            columnNr + "/" + rowNr + "." + 
                            (bvhRefiner._vf.textureFormat).toLowerCase();
    // address of the image for the bvhRefiner height-data
    var imageAddressHeight = bvhRefiner._vf.elevationUrl + "/" + level + "/" + 
                             columnNr + "/" + rowNr + "." + 
                             (bvhRefiner._vf.elevationFormat).toLowerCase();
    // address of the image for the bvhRefiner normal-data
    var imageAddressNormal = bvhRefiner._vf.normalUrl + "/" + level + "/" + 
                             columnNr + "/" + rowNr + "." + 
                             (bvhRefiner._vf.normalFormat).toLowerCase();
    // true if components are available and renderable
    var exists = true;
    // defines the resizing factor
    var resizeFac = (bvhRefiner._vf.size.x + bvhRefiner._vf.size.y) / 2.0;
    // object that stores all information to do a frustum culling
    var cullObject = {};



    /* 
     * Initializes all nodeTypes that are needed to create the drawable
     * component for this node
     */
    function initialize() {

        // appearance of the drawable component of this node
        var appearance = new x3dom.nodeTypes.Appearance(ctx);
        // multiTexture to get heightmap and colormap to gpu
        var shader = new x3dom.nodeTypes.CommonSurfaceShader(ctx);
        var ssTexColor = new x3dom.nodeTypes.SurfaceShaderTexture(ctx);
        // texture that should represent the surface-data of this node
        var colorTexture = new x3dom.nodeTypes.ImageTexture(ctx);
        var ssTexDisplace = new x3dom.nodeTypes.SurfaceShaderTexture(ctx);
        // texture that should represent the height-data of this node
        var heightTexture = new x3dom.nodeTypes.ImageTexture(ctx);

        // definition of the nameSpace of this shape
        shape._nameSpace = bvhRefiner._nameSpace;

        // calculate the average position of the node
        position = nodeTransformation.e3();
       
        shader._vf.displacementFactor = bvhRefiner._vf.maxElevation;
       
        // create texture-data of this node with url's of the texture data
        colorTexture._nameSpace = bvhRefiner._nameSpace;
        colorTexture._vf.url[0] = imageAddressColor;
        colorTexture._vf.repeatT = false;
        colorTexture._vf.repeatS = false;
        ssTexColor.addChild(colorTexture, 'texture');
        colorTexture.nodeChanged();
        shader.addChild(ssTexColor, 'diffuseTexture');
        ssTexColor.nodeChanged();

        // create height-data
        heightTexture._nameSpace = bvhRefiner._nameSpace;
        heightTexture._vf.url[0] = imageAddressHeight;
        heightTexture._vf.repeatT = false;
        heightTexture._vf.repeatS = false;
        ssTexDisplace.addChild(heightTexture, 'texture');
        heightTexture.nodeChanged();
        shader.addChild(ssTexDisplace, 'displacementTexture');
        heightTexture.nodeChanged(); 

        appearance.addChild(shader, 'shaders');
        shader.nodeChanged();

        // create shape with geometry and appearance data
        shape.addChild(appearance);
        appearance.nodeChanged();
        shape.addChild(geometry);
        geometry.nodeChanged();

        // add shape to bvhRefiner object
        bvhRefiner.addChild(shape);
        shape.nodeChanged();
        
        // definition the static properties of cullObject
        cullObject.boundedNode = shape;
        cullObject.volume = shape.getVolume();
        // setting max and min in z-direction to get the complete volume
        cullObject.volume.max.z = Math.round(bvhRefiner._vf.maxElevation / 2);
        cullObject.volume.min.z = -cullObject.volume.max.z;
    }



    /* 
     * Creates the code for the vertex shader
     * @returns {String} code of the vertex shader 
     */
    function createVertexShader() {
        return "attribute vec3 position;\n" +
            "attribute vec3 texcoord;\n" +
            "uniform mat4 modelViewMatrix;\n" +
            "uniform mat4 modelViewProjectionMatrix;\n" +
            "uniform sampler2D texColor;\n" +
            "uniform sampler2D texHeight;\n" +
            "uniform float maxElevation;\n" +
            "uniform sampler2D texNormal;\n" +
            "varying vec2 texC;\n" +
            "varying vec3 vLight;\n" +
            "const float shininess = 32.0;\n" + 
            "\n" +
            "void main(void) {\n" +
            "    vec3 uLightPosition = vec3(160.0, -9346.0, 4806.0);\n" +
            "    vec4 colr = texture2D(texColor, vec2(texcoord[0], 1.0-texcoord[1]));\n" +
            "    vec3 uAmbientMaterial = vec3(1.0, 1.0, 0.9);" +
            "    vec3 uAmbientLight = vec3(0.5, 0.5, 0.5);" +
            "    vec3 uDiffuseMaterial = vec3(0.7, 0.7, 0.7);" +
            "    vec3 uDiffuseLight = vec3(1.0, 1.0, 1.0);" +
            "    vec4 vertexPositionEye4 = modelViewMatrix * vec4(position, 1.0);" +
            "    vec3 vertexPositionEye3 = vec3((modelViewMatrix * vec4(vertexPositionEye4.xyz, 1.0)).xyz);" +
            "    vec3 vectorToLightSource = normalize(uLightPosition - vertexPositionEye3);" +
            "    vec4 height = texture2D(texHeight, vec2(texcoord[0], 1.0 - texcoord[1]));\n" +
            "    vec4 normalEye = 2.0 * texture2D(texNormal, vec2(texcoord[0], 1.0-texcoord[1])) - 1.0;\n" +
            "    float diffuseLightWeighting = max(dot(normalEye.xyz, vectorToLightSource), 0.0);" +
            "    texC = vec2(texcoord[0], 1.0-texcoord[1]);\n" +
            "    vec3 diffuseReflectance = uDiffuseMaterial * uDiffuseLight * diffuseLightWeighting;" +
            "    vec3 uSpecularMaterial = vec3(0.0, 0.0, 0.0);" +
            "    vec3 uSpecularLight = vec3(1.0, 1.0, 1.0);" +
            "    vec3 reflectionVector = normalize(reflect(-vectorToLightSource, normalEye.xyz));" +
            "    vec3 viewVectorEye = -normalize(vertexPositionEye3);" +
            "    float rdotv = max(dot(reflectionVector, viewVectorEye), 0.0);" +
            "    float specularLightWeight = pow(rdotv, shininess);" +
            "    vec3 specularReflection = uSpecularMaterial * uSpecularLight * specularLightWeight;" +
            "    vLight = vec4(uAmbientMaterial * uAmbientLight + diffuseReflectance + specularReflection, 1.0).xyz;" +
            "    gl_Position = modelViewProjectionMatrix * vec4(position.xy, height.x * maxElevation, 1.0);\n" +
            "}\n";
    }


    
    /* 
     * Creates the code for the fragment shader
     * @returns {String} code of the fragment shader 
     */
    function createFragmentShader() {
        return "#ifdef GL_ES\n" +
            "precision highp float;\n" +
            "#endif\n" +
            "uniform sampler2D texColor;\n" +
            "uniform sampler2D texNormal;\n" +
            "varying vec2 texC;\n" +
            "varying vec3 vLight;\n" +
            "\n" +
            "\n" +
            "void main(void) {\n" +
            "    vec4 normal = 2.0 * texture2D(texNormal, texC) - 1.0;\n" +
            "    vec4 colr = texture2D(texColor, texC);\n" +
            "    gl_FragColor = vec4(colr.xyz * vLight, colr.w);\n" +
            "}\n";
    }



    /* 
     * Creates the four children 
     */
    function create() {
        
        // calculation of children number nodeNumber within their level
        var deltaR = Math.sqrt(Math.pow(4, level));
        var deltaR1 = Math.sqrt(Math.pow(4, level + 1));
        var lt = Math.floor(nodeNumber / deltaR) * 4 * deltaR + 
                           (nodeNumber % deltaR) * 2;
        var rt = lt + 1;
        var lb = lt + deltaR1;
        var rb = lb + 1;
        
        // calculation of the scaling factor
        var s = (bvhRefiner._vf.size).multiply(0.25);

        // creation of all children
        children.push(new QuadtreeNode3D_NEW(ctx, bvhRefiner, (level + 1), lt,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2), (rowNr * 2), geometry));
        children.push(new QuadtreeNode3D_NEW(ctx, bvhRefiner, (level + 1), rt,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2 + 1), (rowNr * 2), geometry));
        children.push(new QuadtreeNode3D_NEW(ctx, bvhRefiner, (level + 1), lb,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, -s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2), (rowNr * 2 + 1), geometry));
        children.push(new QuadtreeNode3D_NEW(ctx, bvhRefiner, (level + 1), rb,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, -s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2 + 1), (rowNr * 2 + 1), geometry));
    }



    /* 
     * Decides to create new children and if the node shoud be drawn or not
     */
    this.collectDrawables = function (transform, drawableCollection, singlePath, invalidateCache, planeMask) {

        // definition the actual transformation of the node
        cullObject.localMatrix = nodeTransformation;
        
        if (exists && (planeMask = drawableCollection.cull(transform, cullObject, singlePath, planeMask)) > 0) {
            var mat_view = drawableCollection.viewMatrix;
            var vPos = mat_view.multMatrixPnt(transform.multMatrixPnt(position));
            var distanceToCamera = Math.sqrt(Math.pow(vPos.x, 2) + Math.pow(vPos.y, 2) + Math.pow(vPos.z, 2));
            if ((distanceToCamera < Math.pow((bvhRefiner._vf.maxDepth - level), 2) * resizeFac / bvhRefiner._vf.factor)) {
                if (children.length === 0 && bvhRefiner.createChildren === 0) {
                    bvhRefiner.createChildren++;
                    create();
                    shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                }
                else if (children.length === 0 && bvhRefiner.createChildren > 0) {
                    shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                }
                else {
                    for (var i = 0; i < children.length; i++) {
                        children[i].collectDrawables(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                }
            }
            else {
                shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
            }
        }
    };



    /* 
     * Returns the volume of this node
     */
    this.getVolume = function() {
        // TODO; implement correctly, for now just use first shape as workaround
        return shape.getVolume();
    };



    // initializes this node directly after creating
    initialize();
}




/*
 * Defines one node of an octree that represents a part (nxn vertices) of 
 * the whole point cloud
 * @param {object} ctx context
 * @param {x3dom.nodeTypes.BVHRefiner} bvhRefiner root bvhRefiner node  
 * @param {number} level level of the node within the quadtree
 * @param {number} columnNr column number in the wmts matrix within the level
 * @param {number} rowNr row number in the wmts matrix within the level
 * @param {number} resizeFac defines the resizing factor. Can be null on init
 * @returns {QuadtreeNodeBin}
 */
function OctreeNode(ctx, bvhRefiner, level, nodeTransformation)
{
    // array with the maximal four child nodes
    var children = [];
    // position of the node in world space
    var position = nodeTransformation.e3();
    // drawable component of this node
    var shape = new x3dom.nodeTypes.Shape(ctx);
    // object that stores all information to do a frustum culling
    var cullObject = {};
    // defines the resizing factor
    var resizeFac = (bvhRefiner._vf.octSize.x + bvhRefiner._vf.octSize.y + bvhRefiner._vf.octSize.z) / 3.0;
    
    

    /*
     * creates the appearance for this node and add it to the dom tree
     */
    function initialize() {

        // appearance of the drawable component of this node
        var appearance = new x3dom.nodeTypes.Appearance(ctx);
        var geometry = new x3dom.nodeTypes.Box(ctx);
        
        geometry._vf.size = bvhRefiner._vf.octSize;
        geometry.fieldChanged('size');
        
        // definition of nameSpace
        shape._nameSpace = new x3dom.NodeNameSpace("", bvhRefiner._nameSpace.doc);
        shape._nameSpace.setBaseURL(bvhRefiner._nameSpace.baseURL);

        shape.addChild(appearance);
        appearance.nodeChanged();
        shape.addChild(geometry);
        geometry.nodeChanged();

        //bvhRefiner.addChild(shape);
        shape.nodeChanged();
        
        // bind static cull-properties to cullObject
        cullObject.boundedNode = shape; 
        cullObject.volume = shape.getVolume();
    }



    /*
     * creates the four child-nodes
     */
    function create() {
        // calculation of the scaling factor
        var s = bvhRefiner._vf.octSize.multiply(0.25);

        // creation of all children
        children.push(new OctreeNode(ctx, bvhRefiner, (level + 1), 
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, s.y, s.z))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 0.5)))));
        children.push(new OctreeNode(ctx, bvhRefiner, (level + 1),
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, s.y, s.z))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 0.5)))));
        children.push(new OctreeNode(ctx, bvhRefiner, (level + 1),
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, -s.y, s.z))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 0.5)))));
        children.push(new OctreeNode(ctx, bvhRefiner, (level + 1),
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, -s.y, s.z))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 0.5)))));
        children.push(new OctreeNode(ctx, bvhRefiner, (level + 1), 
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, s.y, -s.z))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 0.5)))));
        children.push(new OctreeNode(ctx, bvhRefiner, (level + 1),
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, s.y, -s.z))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 0.5)))));
        children.push(new OctreeNode(ctx, bvhRefiner, (level + 1),
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, -s.y, -s.z))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 0.5)))));
        children.push(new OctreeNode(ctx, bvhRefiner, (level + 1),
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, -s.y, -s.z))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 0.5)))));
    }



    /* 
     * Decides to create new children and if the node shoud be drawn or not
     */
    this.collectDrawables = function (transform, drawableCollection, singlePath, invalidateCache, planeMask) {
        
        // definition the actual transformation of the node
        cullObject.localMatrix = nodeTransformation;
        
        if ((planeMask = drawableCollection.cull(transform, cullObject, singlePath, planeMask)) > 0) {
        
            var mat_view = drawableCollection.viewMatrix;
            var vPos = mat_view.multMatrixPnt(transform.multMatrixPnt(position));
            var distanceToCamera = Math.sqrt(Math.pow(vPos.x, 2) + Math.pow(vPos.y, 2) + Math.pow(vPos.z, 2));

            // bvhRefiner._vf.factor instead (level * 16)
            if ((distanceToCamera < Math.pow((bvhRefiner._vf.maxDepth - level), 2) * resizeFac / bvhRefiner._vf.factor)) {
                if (children.length === 0){
                    create();
                }
                else {
                    for (var i = 0; i < children.length; i++) {
                        children[i].collectDrawables(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                }
            }
            else {
                shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
            }
        }
    };



    /*
     * Returns the volume of this node
     */
    this.getVolume = function() {
        // TODO; implement correctly, for now just use first box as workaround
        return shape.getVolume();
    };



    // initializes this node directly after creating
    initialize();
}



/*
 * Defines one 3D node (plane with displacement) of a quadtree that represents 
 * a part (nxn vertices) of the whole mesh.
 * @param {object} ctx context
 * @param {x3dom.nodeTypes.BVHRefiner} bvhRefiner root bvhRefiner node  
 * @param {number} level level of the node within the quadtree
 * @param {number} nodeNumber id of the node within the level
 * @param {x3dom.fields.SFMatrix4f} nodeTransformation transformation matrix that defines scale and position
 * @param {number} columnNr column number in the wmts matrix within the level
 * @param {number} rowNr row number in the wmts matrix within the level
 * @param {x3dom.nodeTypes.Plane} geometry plane
 * @returns {QuadtreeNode3D}
 */
function QuadtreeNode3D_32bit(ctx, bvhRefiner, level, nodeNumber, nodeTransformation, 
                              columnNr, rowNr, geometry)
{
    // array with the maximal four child nodes
    var children = [];
    // drawable component of this node
    var shape = new x3dom.nodeTypes.Shape();
    // position of the node in world space
    var position = null;
    // address of the image for the bvhRefiner surface
    var imageAddressColor = bvhRefiner._vf.textureUrl + "/" + level + "/" + 
                            columnNr + "/" + rowNr + "." + 
                            (bvhRefiner._vf.textureFormat).toLowerCase();
    // address of the image for the bvhRefiner height-data
    var imageAddressHeight = bvhRefiner._vf.elevationUrl + "/" + level + "/" + 
                             columnNr + "/" + rowNr + "." + 
                             (bvhRefiner._vf.elevationFormat).toLowerCase();
    // address of the image for the bvhRefiner normal-data
    var imageAddressNormal = bvhRefiner._vf.normalUrl + "/" + level + "/" + 
                             columnNr + "/" + rowNr + "." + 
                             (bvhRefiner._vf.normalFormat).toLowerCase();
    // true if components are available and renderable
    var exists = true;
    // defines the resizing factor
    var resizeFac = (bvhRefiner._vf.size.x + bvhRefiner._vf.size.y) / 2.0;
    // object that stores all information to do a frustum culling
    var cullObject = {};



    /* 
     * Initializes all nodeTypes that are needed to create the drawable
     * component for this node
     */
    function initialize() {

        // appearance of the drawable component of this node
        var appearance = new x3dom.nodeTypes.Appearance(ctx);
        // multiTexture to get heightmap and colormap to gpu
        var textures = new x3dom.nodeTypes.MultiTexture(ctx);
        // texture that should represent the surface-data of this node
        var colorTexture = new x3dom.nodeTypes.ImageTexture(ctx);
        // texture that should represent the height-data of this node
        var heightTexture = new x3dom.nodeTypes.ImageTexture(ctx);
        // texture that should represent the normal-data of this node
        var normalTexture = new x3dom.nodeTypes.ImageTexture(ctx);
        // creating the special shader for these nodes
        var composedShader = new x3dom.nodeTypes.ComposedShader(ctx);

        // definition of the nameSpace of this shape
        shape._nameSpace = bvhRefiner._nameSpace;

        // calculate the average position of the node
        position = nodeTransformation.e3();
        
        // creating the special vertex-shader for bvhRefiner-nodes
        var vertexShader = new x3dom.nodeTypes.ShaderPart(ctx);
        vertexShader._vf.type = 'vertex';
        vertexShader._vf.url[0] = createVertexShader();

        // creating the special fragment-shader for bvhRefiner-nodes
        var fragmentShader = new x3dom.nodeTypes.ShaderPart(ctx);
        fragmentShader._vf.type = 'fragment';
        fragmentShader._vf.url[0] = createFragmentShader();

        // create complete-shader with vertex- and fragment-shader
        composedShader.addChild(vertexShader, 'parts');
        composedShader.addChild(fragmentShader, 'parts');

        // create texture-data of this node with url's of the texture data
        colorTexture._nameSpace = bvhRefiner._nameSpace;
        colorTexture._vf.url[0] = imageAddressColor;
        colorTexture._vf.repeatT = false;
        colorTexture._vf.repeatS = false;
        colorTexture._vf.generateMipMaps = false;
        textures.addChild(colorTexture, 'texture');
        colorTexture.nodeChanged();
        var colorTextureField = new x3dom.nodeTypes.Field(ctx);
        colorTextureField._vf.name = 'texColor';
        colorTextureField._vf.type = 'SFInt32';
        colorTextureField._vf.value = 0;
        composedShader.addChild(colorTextureField, 'fields');
        colorTextureField.nodeChanged();

        // create height-data
        heightTexture._nameSpace = bvhRefiner._nameSpace;
        heightTexture._vf.url[0] = imageAddressHeight;
        heightTexture._vf.repeatT = false;
        heightTexture._vf.repeatS = false;
        
        /*heightTexture._cf.textureProperties.node = new x3dom.nodeTypes.TextureProperties(ctx);
        heightTexture._cf.textureProperties.node._vf.minificationFilter = 'NEAREST';
        heightTexture._cf.textureProperties.node._vf.magnificationFilter = 'NEAREST';
        heightTexture._cf.textureProperties.node._vf.generateMipMaps = false;
        heightTexture._cf.textureProperties.node._vf.boundaryModeS = 'MIRRORED_REPEAT';
        heightTexture._cf.textureProperties.node._vf.boundaryModeT = 'MIRRORED_REPEAT';
        heightTexture._cf.textureProperties.node._vf.boundaryModeR = 'MIRRORED_REPEAT';*/
        
        textures.addChild(heightTexture, 'texture');
        heightTexture.nodeChanged();
        var heightTextureField = new x3dom.nodeTypes.Field(ctx);
        heightTextureField._vf.name = 'texHeight';
        heightTextureField._vf.type = 'SFInt32';
        heightTextureField._vf.value = 1;
        composedShader.addChild(heightTextureField, 'fields');
        heightTextureField.nodeChanged();

        // create normal-data
        normalTexture._nameSpace = bvhRefiner._nameSpace;
        normalTexture._vf.url[0] = imageAddressNormal;
        normalTexture._vf.repeatT = false;
        normalTexture._vf.repeatS = false;
        textures.addChild(normalTexture, 'texture');
        normalTexture.nodeChanged();
        var normalTextureField = new x3dom.nodeTypes.Field(ctx);
        normalTextureField._vf.name = 'texNormal';
        normalTextureField._vf.type = 'SFInt32';
        normalTextureField._vf.value = 2;
        composedShader.addChild(normalTextureField, 'fields');
        normalTextureField.nodeChanged();
        
        // transmit maximum elevation value to gpu
        var maxHeight = new x3dom.nodeTypes.Field(ctx);
        maxHeight._vf.name = 'maxElevation';
        maxHeight._vf.type = 'SFFloat';
        maxHeight._vf.value = bvhRefiner._vf.maxElevation;
        composedShader.addChild(maxHeight, 'fields');
        maxHeight.nodeChanged();

        // add textures to the appearence of this node
        appearance.addChild(textures);
        textures.nodeChanged();
        appearance.addChild(composedShader);
        composedShader.nodeChanged();

        // create shape with geometry and appearance data
        shape.addChild(appearance);
        appearance.nodeChanged();
        shape.addChild(geometry);
        geometry.nodeChanged();

        // add shape to bvhRefiner object
        bvhRefiner.addChild(shape);
        shape.nodeChanged();
        
        // definition the static properties of cullObject
        cullObject.boundedNode = shape;
        cullObject.volume = shape.getVolume();
        // setting max and min in z-direction to get the complete volume
        cullObject.volume.max.z = Math.round(bvhRefiner._vf.maxElevation);
        cullObject.volume.min.z = -cullObject.volume.max.z;
    }



    /* 
     * Creates the code for the vertex shader
     * @returns {String} code of the vertex shader 
     */
    function createVertexShader() {
        return "attribute vec3 position;\n" +
            "attribute vec3 texcoord;\n" +
            "uniform mat4 modelViewMatrix;\n" +
            "uniform mat4 modelViewProjectionMatrix;\n" +
            "uniform sampler2D texColor;\n" +
            "uniform sampler2D texHeight;\n" +
            "uniform float maxElevation;\n" +
            "uniform sampler2D texNormal;\n" +
            "varying vec2 texC;\n" +
            "varying vec3 vLight;\n" +
            "const float shininess = 32.0;\n" + 
            "\n" +
            "void main(void) {\n" +
            "    vec3 uLightPosition = vec3(160.0, -9346.0, 4806.0);\n" +
            "    vec4 colr = texture2D(texColor, vec2(texcoord[0], 1.0-texcoord[1]));\n" +
            "    vec3 uAmbientMaterial = vec3(1.0, 1.0, 0.9);" +
            "    vec3 uAmbientLight = vec3(0.5, 0.5, 0.5);" +
            "    vec3 uDiffuseMaterial = vec3(0.7, 0.7, 0.7);" +
            "    vec3 uDiffuseLight = vec3(1.0, 1.0, 1.0);" +
            "    vec4 vertexPositionEye4 = modelViewMatrix * vec4(position, 1.0);" +
            "    vec3 vertexPositionEye3 = vec3((modelViewMatrix * vec4(vertexPositionEye4.xyz, 1.0)).xyz);" +
            "    vec3 vectorToLightSource = normalize(uLightPosition - vertexPositionEye3);" +
            "    vec4 height = texture2D(texHeight, vec2(texcoord[0], 1.0 - texcoord[1]));\n" +
            "    vec4 normalEye = 2.0 * texture2D(texNormal, vec2(texcoord[0], 1.0-texcoord[1])) - 1.0;\n" +
            "    float diffuseLightWeighting = max(dot(normalEye.xyz, vectorToLightSource), 0.0);" +
            "    texC = vec2(texcoord[0], 1.0-texcoord[1]);\n" +
            "    vec3 diffuseReflectance = uDiffuseMaterial * uDiffuseLight * diffuseLightWeighting;" +
            "    vec3 uSpecularMaterial = vec3(0.0, 0.0, 0.0);" +
            "    vec3 uSpecularLight = vec3(1.0, 1.0, 1.0);" +
            "    vec3 reflectionVector = normalize(reflect(-vectorToLightSource, normalEye.xyz));" +
            "    vec3 viewVectorEye = -normalize(vertexPositionEye3);" +
            "    float rdotv = max(dot(reflectionVector, viewVectorEye), 0.0);" +
            "    float specularLightWeight = pow(rdotv, shininess);" +
            "    vec3 specularReflection = uSpecularMaterial * uSpecularLight * specularLightWeight;" +
            "    vLight = vec4(uAmbientMaterial * uAmbientLight + diffuseReflectance + specularReflection, 1.0).xyz;" +
            "    gl_Position = modelViewProjectionMatrix * vec4(position.xy, ((height.g * 256.0)+height.b) * maxElevation, 1.0);\n" +
            "}\n";
    }


    
    /* 
     * Creates the code for the fragment shader
     * @returns {String} code of the fragment shader 
     */
    function createFragmentShader() {
        return "#ifdef GL_ES\n" +
            "precision highp float;\n" +
            "#endif\n" +
            "uniform sampler2D texColor;\n" +
            "uniform sampler2D texNormal;\n" +
            "varying vec2 texC;\n" +
            "varying vec3 vLight;\n" +
            "\n" +
            "\n" +
            "void main(void) {\n" +
            "    vec4 normal = 2.0 * texture2D(texNormal, texC) - 1.0;\n" +
            "    vec4 colr = texture2D(texColor, texC);\n" +
            "    float coler = ((colr.g * 256.0)+colr.b);" +
            "    gl_FragColor = vec4(vLight * coler, 1.0);\n" +
            "}\n";
    }



    /* 
     * Creates the four children 
     */
    function create() {
        
        // calculation of children number nodeNumber within their level
        var deltaR = Math.sqrt(Math.pow(4, level));
        var deltaR1 = Math.sqrt(Math.pow(4, level + 1));
        var lt = Math.floor(nodeNumber / deltaR) * 4 * deltaR + 
                           (nodeNumber % deltaR) * 2;
        var rt = lt + 1;
        var lb = lt + deltaR1;
        var rb = lb + 1;
        
        // calculation of the scaling factor
        var s = (bvhRefiner._vf.size).multiply(0.25);

        // creation of all children
        children.push(new QuadtreeNode3D_32bit(ctx, bvhRefiner, (level + 1), lt,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2), (rowNr * 2), geometry));
        children.push(new QuadtreeNode3D_32bit(ctx, bvhRefiner, (level + 1), rt,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2 + 1), (rowNr * 2), geometry));
        children.push(new QuadtreeNode3D_32bit(ctx, bvhRefiner, (level + 1), lb,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(-s.x, -s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2), (rowNr * 2 + 1), geometry));
        children.push(new QuadtreeNode3D_32bit(ctx, bvhRefiner, (level + 1), rb,
            nodeTransformation.mult(x3dom.fields.SFMatrix4f.translation(
                    new x3dom.fields.SFVec3f(s.x, -s.y, 0.0))).mult(x3dom.fields.SFMatrix4f.scale(
                    new x3dom.fields.SFVec3f(0.5, 0.5, 1.0))), (columnNr * 2 + 1), (rowNr * 2 + 1), geometry));
    }



    /* 
     * Decides to create new children and if the node shoud be drawn or not
     */
    this.collectDrawables = function (transform, drawableCollection, singlePath, invalidateCache, planeMask) {

        // definition the actual transformation of the node
        cullObject.localMatrix = nodeTransformation;
        
        if (exists && (planeMask = drawableCollection.cull(transform, cullObject, singlePath, planeMask)) > 0) {
            var mat_view = drawableCollection.viewMatrix;
            var vPos = mat_view.multMatrixPnt(transform.multMatrixPnt(position));
            var distanceToCamera = Math.sqrt(Math.pow(vPos.x, 2) + Math.pow(vPos.y, 2) + Math.pow(vPos.z, 2));
            if ((distanceToCamera < Math.pow((bvhRefiner._vf.maxDepth - level), 2) * resizeFac / bvhRefiner._vf.factor)) {
                if (children.length === 0 && bvhRefiner.createChildren === 0) {
                    bvhRefiner.createChildren++;
                    create();
                    shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                }
                else if (children.length === 0 && bvhRefiner.createChildren > 0) {
                    shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                }
                else {
                    for (var i = 0; i < children.length; i++) {
                        children[i].collectDrawables(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
                    }
                }
            }
            else {
                shape.collectDrawableObjects(nodeTransformation, drawableCollection, singlePath, invalidateCache, planeMask);
            }
        }
    };


    /* 
     * Returns the volume of this node
     */
    this.getVolume = function() {
        // TODO; implement correctly, for now just use first shape as workaround
        return shape.getVolume();
    };


    // initializes this node directly after creating
    initialize();
}

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/* ### Snout ### */
x3dom.registerNodeType(
    "Snout",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Snout.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'dbottom', 1.0); // Diameter of bottom surface
            this.addField_SFFloat(ctx, 'dtop', 0.5);    // Diameter of top surface
            this.addField_SFFloat(ctx, 'height', 1.0);  // Perpendicular distance between surfaces
            this.addField_SFFloat(ctx, 'xoff', 0.25);   // Displacement of axes along X-axis
            this.addField_SFFloat(ctx, 'yoff', 0.25);   // Displacement of axes along Y-axis
            this.addField_SFBool(ctx, 'bottom', true);
            this.addField_SFBool(ctx, 'top', true);
            this.addField_SFFloat(ctx, 'subdivision', 32);

            this.rebuildGeometry();
        },
        {
            rebuildGeometry: function()
            {
                this._mesh._positions[0] = [];
                this._mesh._normals[0]   = [];
                this._mesh._texCoords[0] = [];
                this._mesh._indices[0]   = [];

                var bottomRadius = this._vf.dbottom / 2, height = this._vf.height;
                var topRadius = this._vf.dtop / 2, sides = this._vf.subdivision;

                var beta, x, z;
                var delta = 2.0 * Math.PI / sides;

                var incl = (bottomRadius - topRadius) / height;
                var nlen = 1.0 / Math.sqrt(1.0 + incl * incl);

                var j = 0, k = 0;
                var h, base;

                if (height > 0) {
                    var px = 0, pz = 0;

                    for (j = 0, k = 0; j <= sides; j++) {
                        beta = j * delta;
                        x = Math.sin(beta);
                        z = -Math.cos(beta);

                        if (topRadius > x3dom.fields.Eps) {
                            px = x * topRadius + this._vf.xoff;
                            pz = z * topRadius + this._vf.yoff;
                        }

                        this._mesh._positions[0].push(px, height / 2, pz);
                        this._mesh._normals[0].push(x / nlen, incl / nlen, z / nlen);
                        this._mesh._texCoords[0].push(1.0 - j / sides, 1);

                        this._mesh._positions[0].push(x * bottomRadius, -height / 2, z * bottomRadius);
                        this._mesh._normals[0].push(x / nlen, incl / nlen, z / nlen);
                        this._mesh._texCoords[0].push(1.0 - j / sides, 0);

                        if (j > 0) {
                            this._mesh._indices[0].push(k    );
                            this._mesh._indices[0].push(k + 2);
                            this._mesh._indices[0].push(k + 1);

                            this._mesh._indices[0].push(k + 1);
                            this._mesh._indices[0].push(k + 2);
                            this._mesh._indices[0].push(k + 3);

                            k += 2;
                        }
                    }
                }

                if (bottomRadius > 0 && this._vf.bottom) {
                    base = this._mesh._positions[0].length / 3;

                    for (j = sides - 1; j >= 0; j--) {
                        beta = j * delta;
                        x = bottomRadius * Math.sin(beta);
                        z = -bottomRadius * Math.cos(beta);

                        this._mesh._positions[0].push(x, -height / 2, z);
                        this._mesh._normals[0].push(0, -1, 0);
                        this._mesh._texCoords[0].push(x / bottomRadius / 2 + 0.5, z / bottomRadius / 2 + 0.5);
                    }

                    h = base + 1;

                    for (j = 2; j < sides; j++) {
                        this._mesh._indices[0].push(h);
                        this._mesh._indices[0].push(base);

                        h = base + j;
                        this._mesh._indices[0].push(h);
                    }
                }

                if (topRadius > x3dom.fields.Eps && this._vf.top) {
                    base = this._mesh._positions[0].length / 3;

                    for (j = sides - 1; j >= 0; j--) {
                        beta = j * delta;
                        x =  topRadius * Math.sin(beta);
                        z = -topRadius * Math.cos(beta);

                        this._mesh._positions[0].push(x + this._vf.xoff, height / 2, z + this._vf.yoff);
                        this._mesh._normals[0].push(0, 1, 0);
                        this._mesh._texCoords[0].push(x / topRadius / 2 + 0.5, 1.0 - z / topRadius / 2 + 0.5);
                    }

                    h = base + 1;

                    for (j = 2; j < sides; j++) {
                        this._mesh._indices[0].push(base);
                        this._mesh._indices[0].push(h);

                        h = base + j;
                        this._mesh._indices[0].push(h);
                    }
                }

                this.invalidateVolume();
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;
            },

            fieldChanged: function (fieldName)
            {
                if (fieldName == "dtop" || fieldName == "dbottom" ||
                    fieldName == "height" || fieldName == "subdivision" ||
                    fieldName == "xoff" || fieldName == "yoff" ||
                    fieldName == "bottom" || fieldName == "top")
                {
                    this.rebuildGeometry();

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);

/* ### Dish ### */
x3dom.registerNodeType(
    "Dish",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Dish.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'diameter', 2); 	//Diameter of base
            this.addField_SFFloat(ctx, 'height', 1);	//Maximum height of dished surface above base (section if < r)
            this.addField_SFFloat(ctx, 'radius', this._vf.diameter / 2);  //Third semi-principal axes of ellipsoid
            this.addField_SFBool(ctx, 'bottom', true);
            this.addField_SFVec2f(ctx, 'subdivision', 24, 24);

            this.rebuildGeometry();
        },
        {
            rebuildGeometry: function()
            {
                this._mesh._positions[0] = [];
                this._mesh._normals[0]   = [];
                this._mesh._texCoords[0] = [];
                this._mesh._indices[0]   = [];

                var twoPi = Math.PI * 2, halfPi = Math.PI / 2;
                var halfDia = this._vf.diameter / 2;

                // If r is 0 or half of diameter, treat as section of sphere, else half of ellipsoid
                var r = this._vf.radius;
                r = (r == 0 || Math.abs(halfDia - r) <= x3dom.fields.Eps) ? halfDia : r;

                // height defines sectional part taken from half of ellipsoid (sphere if r==halfDia)
                var h = Math.min(this._vf.height, r);
                var offset = r - h;

                var a = halfDia;    // 1st semi-principal axes along x
                var b = r;          // 2nd semi-principal axes along y
                var c = halfDia;    // 3rd semi-principal axes along z

                var latitudeBands = this._vf.subdivision.x, longitudeBands = this._vf.subdivision.y;
                var latNumber, longNumber;

                var segTheta = halfPi - Math.asin(1 - h / r);
                var segL = Math.ceil(latitudeBands / halfPi * segTheta);

                var theta, sinTheta, cosTheta;
                var phi, sinPhi, cosPhi;
                var x, y, z, u, v;
                var tmpPosArr = [], tmpTcArr = [];

                for (latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                    if (segL == latNumber) {
                        theta = segTheta;
                    }
                    else {
                        theta = (latNumber * halfPi) / latitudeBands;
                    }
                    sinTheta = Math.sin(theta);
                    cosTheta = Math.cos(theta);

                    for (longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                        phi = (longNumber * twoPi) / longitudeBands;
                        sinPhi = Math.sin(phi);
                        cosPhi = Math.cos(phi);

                        x = a * (-cosPhi * sinTheta);
                        y = b *            cosTheta;
                        z = c * (-sinPhi * sinTheta);

                        u = 0.25 - (longNumber / longitudeBands);
                        v = latNumber / latitudeBands;

                        this._mesh._positions[0].push(x, y - offset, z);
                        this._mesh._texCoords[0].push(u, v);
                        this._mesh._normals[0].push(x/(a*a), y/(b*b), z/(c*c));

                        if ((latNumber == latitudeBands) || (segL == latNumber)) {
                            tmpPosArr.push(x, y - offset, z);
                            tmpTcArr.push(u, v);
                        }
                    }

                    if (segL == latNumber)
                        break;
                }

                for (latNumber = 0; latNumber < latitudeBands; latNumber++) {
                    if (segL == latNumber)
                        break;

                    for (longNumber = 0; longNumber < longitudeBands; longNumber++) {
                        var first = (latNumber * (longitudeBands + 1)) + longNumber;
                        var second = first + longitudeBands + 1;

                        this._mesh._indices[0].push(first + 1);
                        this._mesh._indices[0].push(second);
                        this._mesh._indices[0].push(first);

                        this._mesh._indices[0].push(first + 1);
                        this._mesh._indices[0].push(second + 1);
                        this._mesh._indices[0].push(second);
                    }
                }

                if (this._vf.bottom)
                {
                    var origPos = this._mesh._positions[0].length / 3;
                    var t = origPos + 1;

                    for (var i=0, m=tmpPosArr.length/3; i<m; i++) {
                        var j = 3 * i;
                        this._mesh._positions[0].push(tmpPosArr[j  ]);
                        this._mesh._positions[0].push(tmpPosArr[j+1]);
                        this._mesh._positions[0].push(tmpPosArr[j+2]);
                        j = 2 * i;
                        this._mesh._texCoords[0].push(tmpTcArr[j  ]);
                        this._mesh._texCoords[0].push(tmpTcArr[j+1]);
                        this._mesh._normals[0].push(0, -1, 0);

                        if (i >= 2) {
                            this._mesh._indices[0].push(origPos);
                            this._mesh._indices[0].push(t);

                            t = origPos + i;
                            this._mesh._indices[0].push(t);
                        }
                    }
                }

                this.invalidateVolume();
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;
            },

            fieldChanged: function(fieldName)
            {
                 if (fieldName == "radius" || fieldName == "height" || fieldName == "diameter" ||
                     fieldName == "subdivision" || fieldName == "bottom")
                 {
                     this.rebuildGeometry();

                     Array.forEach(this._parentNodes, function (node) {
                         node.setAllDirty();
                         node.invalidateVolume();
                     });
                }
            }
        }
    )
);

/* ### Pyramid ### */
x3dom.registerNodeType(
    "Pyramid",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Pyramid.superClass.call(this, ctx);
            
            this.addField_SFFloat(ctx, 'xbottom', 1);	//Dimension of bottom parallel to X-axis
            this.addField_SFFloat(ctx, 'ybottom', 1);	//Dimension of bottom parallel to Y-axis
            this.addField_SFFloat(ctx, 'xtop', 0.5);		//Dimension of top parallel to X-axis
            this.addField_SFFloat(ctx, 'ytop', 0.5);		//Dimension of top parallel to Y-axis
            this.addField_SFFloat(ctx, 'height', 1);	//Height between top and bottom surface
            this.addField_SFFloat(ctx, 'xoff', 0.25);		//Displacement of axes along X-axis
            this.addField_SFFloat(ctx, 'yoff', 0.25);		//Displacement of axes along Y-axis
            
            var xTop = this._vf.xtop / 2;
            var yTop = this._vf.ytop / 2;
            var xBot = this._vf.xbottom / 2;
            var yBot = this._vf.ybottom / 2;
            var xOff = this._vf.xoff;
            var yOff = this._vf.yoff;
            var sy = this._vf.height / 2;

            this._mesh._positions[0] = [
                -xBot,       -sy, -yBot,        -xTop + xOff, sy, -yTop + yOff,  xTop + xOff, sy, -yTop + yOff,  xBot,       -sy, -yBot,
                -xBot,       -sy,  yBot,        -xTop + xOff, sy,  yTop + yOff,  xTop + xOff, sy,  yTop + yOff,  xBot,       -sy,  yBot,
                -xBot,       -sy, -yBot,        -xBot,       -sy,  yBot,        -xTop + xOff, sy,  yTop + yOff, -xTop + xOff, sy, -yTop + yOff,
                 xBot,       -sy, -yBot,         xBot,       -sy,  yBot,         xTop + xOff, sy,  yTop + yOff,  xTop + xOff, sy, -yTop + yOff,
                -xTop + xOff, sy, -yTop + yOff, -xTop + xOff, sy,  yTop + yOff,  xTop + xOff, sy,  yTop + yOff,  xTop + xOff, sy, -yTop + yOff,
                -xBot,       -sy, -yBot,        -xBot,       -sy,  yBot,         xBot,       -sy,  yBot,         xBot,       -sy, -yBot
            ];
            this._mesh._texCoords[0] = [
                1, 0, 1, 1, 0, 1, 0, 0,
                0, 0, 0, 1, 1, 1, 1, 0,
                0, 0, 1, 0, 1, 1, 0, 1,
                1, 0, 0, 0, 0, 1, 1, 1,
                0, 1, 0, 0, 1, 0, 1, 1,
                0, 0, 0, 1, 1, 1, 1, 0
            ];
            this._mesh._indices[0] = [
                0, 1, 2, 2, 3, 0,
                6, 5, 4, 4, 7, 6,
                8, 9, 10, 10, 11, 8,
                12, 15, 14, 14, 13, 12,
                16, 17, 18, 18, 19, 16,
                20, 23, 22, 22, 21, 20
            ];

            // attention, we share per side, therefore creaseAngle > 0
            this._mesh.calcNormals(Math.PI, this._vf.ccw);

            this._mesh._invalidate = true;
            this._mesh._numFaces = 12;
            this._mesh._numCoords = 24;
        },
        {
            fieldChanged: function(fieldName)
            {
                if (fieldName == "xbottom" || fieldName == "ybottom" ||
                    fieldName == "xtop" || fieldName == "ytop" ||
                    fieldName == "xoff" || fieldName == "yoff" || fieldName == "height")
                {
                    var xTop = this._vf.xtop / 2;
                    var yTop = this._vf.ytop / 2;
                    var xBot = this._vf.xbottom / 2;
                    var yBot = this._vf.ybottom / 2;
                    var xOff = this._vf.xoff;
                    var yOff = this._vf.yoff;
                    var sy = this._vf.height / 2;

                    this._mesh._positions[0] = [
                        -xBot,       -sy, -yBot,        -xTop + xOff, sy, -yTop + yOff,  xTop + xOff, sy, -yTop + yOff,  xBot,       -sy, -yBot,
                        -xBot,       -sy,  yBot,        -xTop + xOff, sy,  yTop + yOff,  xTop + xOff, sy,  yTop + yOff,  xBot,       -sy,  yBot,
                        -xBot,       -sy, -yBot,        -xBot,       -sy,  yBot,        -xTop + xOff, sy,  yTop + yOff, -xTop + xOff, sy, -yTop + yOff,
                         xBot,       -sy, -yBot,         xBot,       -sy,  yBot,         xTop + xOff, sy,  yTop + yOff,  xTop + xOff, sy, -yTop + yOff,
                        -xTop + xOff, sy, -yTop + yOff, -xTop + xOff, sy,  yTop + yOff,  xTop + xOff, sy,  yTop + yOff,  xTop + xOff, sy, -yTop + yOff,
                        -xBot,       -sy, -yBot,        -xBot,       -sy,  yBot,         xBot,       -sy,  yBot,         xBot,       -sy, -yBot
                    ];

                    this._mesh._normals[0] = [];
                    this._mesh.calcNormals(Math.PI, this._vf.ccw);

                    this.invalidateVolume();

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);

/* ### RectangularTorus ### */
x3dom.registerNodeType(
    "RectangularTorus",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.RectangularTorus.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'innerRadius', 0.5); //Inside radius
            this.addField_SFFloat(ctx, 'outerRadius', 1);	//Outside radius
            this.addField_SFFloat(ctx, 'height', 1);	    //Height of rectangular section
            this.addField_SFFloat(ctx, 'angle', 2 * Math.PI);	//Subtended angle
            this.addField_SFBool(ctx, 'caps', true);        //Show side caps
            this.addField_SFFloat(ctx, 'subdivision', 32);

            this._origCCW = this._vf.ccw;

            this.rebuildGeometry();
        },
        {
            rebuildGeometry: function()
            {
                this._mesh._positions[0] = [];
                this._mesh._normals[0]   = [];
                this._mesh._texCoords[0] = [];
                this._mesh._indices[0]   = [];

                var twoPi = 2.0 * Math.PI;

                this._vf.ccw = !this._origCCW;

                // assure that angle in [0, 2 * PI]
                if (this._vf.angle < 0)
                    this._vf.angle = 0;
                else if (this._vf.angle > twoPi)
                    this._vf.angle = twoPi;

                // assure that innerRadius < outerRadius
                if (this._vf.innerRadius > this._vf.outerRadius)
                {
                    var tmp = this._vf.innerRadius;
                    this._vf.innerRadius = this._vf.outerRadius;
                    this._vf.outerRadius = tmp;
                }

                var innerRadius = this._vf.innerRadius;
                var outerRadius = this._vf.outerRadius;
                var height = this._vf.height / 2;
                var angle = this._vf.angle;
                var sides = this._vf.subdivision;

                var beta, x, z, k, j, nx, nz;
                var delta = angle / sides;

                //Outer Side
                for (j=0, k=0; j<=sides; j++)
                {
                    beta = j * delta;
                    nx =  Math.cos(beta);
                    nz = -Math.sin(beta);

                    x = outerRadius * nx;
                    z = outerRadius * nz;

                    this._mesh._positions[0].push(x, -height, z);
                    this._mesh._normals[0].push(nx, 0, nz);

                    this._mesh._positions[0].push(x, height, z);
                    this._mesh._normals[0].push(nx, 0, nz);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k    );
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 3);

                        k += 2;
                    }
                }

                //Inner Side
                for (j=0, k=k+2; j<=sides; j++)
                {
                    beta = j * delta;
                    nx =  Math.cos(beta);
                    nz = -Math.sin(beta);

                    x = innerRadius * nx;
                    z = innerRadius * nz;

                    this._mesh._positions[0].push(x, -height, z);
                    this._mesh._normals[0].push(-nx, 0, -nz);

                    this._mesh._positions[0].push(x, height, z);
                    this._mesh._normals[0].push(-nx, 0, -nz);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k    );

                        this._mesh._indices[0].push(k + 3);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        k += 2;
                    }
                }

                //Top Side
                for (j=0, k=k+2; j<=sides; j++)
                {
                    beta = j * delta;
                    nx =  Math.cos(beta);
                    nz = -Math.sin(beta);

                    x = outerRadius * nx;
                    z = outerRadius * nz;

                    this._mesh._positions[0].push(x, height, z);
                    this._mesh._normals[0].push(0, 1, 0);

                    x = innerRadius * nx;
                    z = innerRadius * nz;

                    this._mesh._positions[0].push(x, height, z);
                    this._mesh._normals[0].push(0, 1, 0);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k    );
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 3);

                        k += 2;
                    }
                }

                //Bottom Side
                for (j=0, k=k+2; j<=sides; j++)
                {
                    beta = j * delta;
                    nx =  Math.cos(beta);
                    nz = -Math.sin(beta);

                    x = outerRadius * nx;
                    z = outerRadius * nz;

                    this._mesh._positions[0].push(x, -height, z);
                    this._mesh._normals[0].push(0, -1, 0);

                    x = innerRadius * nx;
                    z = innerRadius * nz;

                    this._mesh._positions[0].push(x, -height, z);
                    this._mesh._normals[0].push(0, -1, 0);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k    );

                        this._mesh._indices[0].push(k + 3);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        k += 2;
                    }
                }

                //Create Caps
                if (angle < twoPi && this._vf.caps == true)
                {
                    //First Cap
                    k += 2;

                    x = outerRadius;
                    z = 0;

                    this._mesh._positions[0].push(x, height, z);
                    this._mesh._normals[0].push(0, 0, 1);
                    this._mesh._positions[0].push(x, -height, z);
                    this._mesh._normals[0].push(0, 0, 1);

                    x = innerRadius;
                    z = 0;

                    this._mesh._positions[0].push(x, height, z);
                    this._mesh._normals[0].push(0, 0, 1);
                    this._mesh._positions[0].push(x, -height, z);
                    this._mesh._normals[0].push(0, 0, 1);

                    this._mesh._indices[0].push(k    );
                    this._mesh._indices[0].push(k + 1);
                    this._mesh._indices[0].push(k + 2);

                    this._mesh._indices[0].push(k + 2);
                    this._mesh._indices[0].push(k + 1);
                    this._mesh._indices[0].push(k + 3);

                    //Second Cap
                    k+=4;

                    nx =  Math.cos(angle);
                    nz = -Math.sin(angle);

                    x = outerRadius * nx;
                    z = outerRadius * nz;

                    this._mesh._positions[0].push(x, height, z);
                    this._mesh._normals[0].push(nz, 0, -nx);
                    this._mesh._positions[0].push(x, -height, z);
                    this._mesh._normals[0].push(nz, 0, -nx);

                    x = innerRadius * nx;
                    z = innerRadius * nz;

                    this._mesh._positions[0].push(x, height, z);
                    this._mesh._normals[0].push(nz, 0, -nx);
                    this._mesh._positions[0].push(x, -height, z);
                    this._mesh._normals[0].push(nz, 0, -nx);

                    this._mesh._indices[0].push(k + 2);
                    this._mesh._indices[0].push(k + 1);
                    this._mesh._indices[0].push(k    );

                    this._mesh._indices[0].push(k + 3);
                    this._mesh._indices[0].push(k + 1);
                    this._mesh._indices[0].push(k + 2);
                }

                this.invalidateVolume();
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;
            },

            fieldChanged: function(fieldName)
            {
                if (fieldName == "innerRadius" || fieldName == "outerRadius" ||
                    fieldName == "height" || fieldName == "angle" ||
                    fieldName == "subdivision" || fieldName == "caps")
                {
                    this.rebuildGeometry();

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);

/* ### SlopedCylinder ### */
x3dom.registerNodeType(
    "SlopedCylinder",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.SlopedCylinder.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'radius', 1.0);
            this.addField_SFFloat(ctx, 'height', 2.0);
            this.addField_SFBool(ctx, 'bottom', true);
            this.addField_SFBool(ctx, 'top', true);
            this.addField_SFFloat(ctx, 'xtshear', 0.26179);
            this.addField_SFFloat(ctx, 'ytshear', 0.0);
            this.addField_SFFloat(ctx, 'xbshear', 0.26179);
            this.addField_SFFloat(ctx, 'ybshear', 0.0);
            this.addField_SFFloat(ctx, 'subdivision', 32);

            this.rebuildGeometry();
        },
        {
            rebuildGeometry: function()
            {
                this._mesh._positions[0] = [];
                this._mesh._normals[0]   = [];
                this._mesh._texCoords[0] = [];
                this._mesh._indices[0]   = [];

                var topSlopeX = this._vf.xtshear;
                var topSlopeY = this._vf.ytshear;
                var botSlopeX = this._vf.xbshear;
                var botSlopeY = this._vf.ybshear;
                var sides = this._vf.subdivision;

                var radius = this._vf.radius;
                var height = this._vf.height / 2;

                var delta = 2.0 * Math.PI / sides;
                var beta, x, y, z;
                var j, k;

                for (j=0, k=0; j<=sides; j++)
                {
                    beta = j * delta;
                    x =  Math.sin(beta);
                    z = -Math.cos(beta);

                    this._mesh._positions[0].push(x * radius, -height + x * botSlopeX + z * botSlopeY, z * radius);
                    this._mesh._texCoords[0].push(1.0 - j / sides, 0);

                    this._mesh._positions[0].push(x * radius,  height + x * topSlopeX + z * topSlopeY, z * radius);
                    this._mesh._texCoords[0].push(1.0 - j / sides, 1);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k    );
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 3);

                        k += 2;
                    }
                }

                var h, base;

                if (this._vf.top && radius > 0)
                {
                    base = this._mesh._positions[0].length / 3;

                    for (j=sides-1; j>=0; j--)
                    {
                        k = 6 * j;
                        x = this._mesh._positions[0][k+3];
                        y = this._mesh._positions[0][k+4];
                        z = this._mesh._positions[0][k+5];

                        this._mesh._positions[0].push(x, y, z);
                        this._mesh._texCoords[0].push(x / 2 + 0.5, -z / 2 + 0.5);
                    }

                    h = base + 1;

                    for (j=2; j<sides; j++)
                    {
                        this._mesh._indices[0].push(base);
                        this._mesh._indices[0].push(h);

                        h = base + j;
                        this._mesh._indices[0].push(h);
                    }
                }

                if (this._vf.bottom && radius > 0)
                {
                    base = this._mesh._positions[0].length / 3;

                    for (j=sides-1; j>=0; j--)
                    {
                        k = 6 * j;
                        x = this._mesh._positions[0][k  ];
                        y = this._mesh._positions[0][k+1];
                        z = this._mesh._positions[0][k+2];

                        this._mesh._positions[0].push(x, y, z);
                        this._mesh._texCoords[0].push(x / 2 + 0.5, z / 2 + 0.5);
                    }

                    h = base + 1;

                    for (j=2; j<sides; j++)
                    {
                        this._mesh._indices[0].push(h);
                        this._mesh._indices[0].push(base);

                        h = base + j;
                        this._mesh._indices[0].push(h);
                    }
                }

                // calculate normals and adjust them at seam
                this._mesh.calcNormals(Math.PI, this._vf.ccw);

                var n0b = new x3dom.fields.SFVec3f(this._mesh._normals[0][0],
                                                   this._mesh._normals[0][1],
                                                   this._mesh._normals[0][2]);
                var n0t = new x3dom.fields.SFVec3f(this._mesh._normals[0][3],
                                                   this._mesh._normals[0][4],
                                                   this._mesh._normals[0][5]);
                k = 6 * sides;
                var n1b = new x3dom.fields.SFVec3f(this._mesh._normals[0][k  ],
                                                   this._mesh._normals[0][k+1],
                                                   this._mesh._normals[0][k+2]);
                var n1t = new x3dom.fields.SFVec3f(this._mesh._normals[0][k+3],
                                                   this._mesh._normals[0][k+4],
                                                   this._mesh._normals[0][k+5]);

                var nb = n0b.add(n1b).normalize();
                var nt = n0t.add(n1t).normalize();

                this._mesh._normals[0][0] = nb.x;
                this._mesh._normals[0][1] = nb.y;
                this._mesh._normals[0][2] = nb.z;
                this._mesh._normals[0][3] = nt.x;
                this._mesh._normals[0][4] = nt.y;
                this._mesh._normals[0][5] = nt.z;

                this._mesh._normals[0][k  ] = nb.x;
                this._mesh._normals[0][k+1] = nb.y;
                this._mesh._normals[0][k+2] = nb.z;
                this._mesh._normals[0][k+3] = nt.x;
                this._mesh._normals[0][k+4] = nt.y;
                this._mesh._normals[0][k+5] = nt.z;

                this.invalidateVolume();
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;
            },

            fieldChanged: function(fieldName)
            {
                if (fieldName == "xtshear" || fieldName == "ytshear" ||
                    fieldName == "xbshear" || fieldName == "ybshear" ||
                    fieldName == "radius" || fieldName == "height" ||
                    fieldName == "bottom" || fieldName == "top" || fieldName == "subdivision")
                {
                    this.rebuildGeometry();
                    
                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);

/* ### Nozzle ### */
x3dom.registerNodeType(
    "Nozzle",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Nozzle.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'nozzleHeight', 0.1);
            this.addField_SFFloat(ctx, 'nozzleRadius', 0.6);
            this.addField_SFFloat(ctx, 'height', 1.0);
            this.addField_SFFloat(ctx, 'outerRadius', 0.5);
            this.addField_SFFloat(ctx, 'innerRadius', 0.4);
            this.addField_SFFloat(ctx, 'subdivision', 32);

            this.rebuildGeometry();
        },
        {
            rebuildGeometry: function()
            {
                this._mesh._positions[0] = [];
                this._mesh._normals[0]   = [];
                this._mesh._texCoords[0] = [];
                this._mesh._indices[0]   = [];

                var twoPi = 2.0 * Math.PI;
                var sides = this._vf.subdivision;

                var height = this._vf.height;
                var center = height / 2;

                if (this._vf.innerRadius > this._vf.outerRadius)
                {
                    var tmp = this._vf.innerRadius;
                    this._vf.innerRadius = this._vf.outerRadius;
                    this._vf.outerRadius = tmp;
                }
                var innerRadius = this._vf.innerRadius;
                var outerRadius = this._vf.outerRadius;

                if (this._vf.nozzleRadius < outerRadius)
                {
                    this._vf.nozzleRadius = outerRadius;
                }
                var nozzleRadius = this._vf.nozzleRadius;

                if (this._vf.nozzleHeight > height)
                {
                    this._vf.nozzleHeight = height;
                }
                var nozzleHeight = this._vf.nozzleHeight;

                var beta, delta, x, z, k, j, nx, nz;
                delta = twoPi / sides;

                //Outer Stem Side
                for (j=0, k=0; j<=sides; j++)
                {
                    beta = j * delta;
                    nx =  Math.sin(beta);
                    nz = -Math.cos(beta);

                    x = outerRadius * nx;
                    z = outerRadius * nz;

                    this._mesh._positions[0].push(x, -center, z);
                    this._mesh._normals[0].push(nx, 0, nz);

                    this._mesh._positions[0].push(x, (height-nozzleHeight)-center, z);
                    this._mesh._normals[0].push(nx, 0, nz);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k    );
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 3);

                        k += 2;
                    }
                }

                //Inner Stem Side
                for (j=0, k=k+2; j<=sides; j++)
                {
                    beta = j * delta;
                    nx =  Math.sin(beta);
                    nz = -Math.cos(beta);

                    x = innerRadius * nx;
                    z = innerRadius * nz;

                    this._mesh._positions[0].push(x, -center, z);
                    this._mesh._normals[0].push(-nx, 0, -nz);

                    this._mesh._positions[0].push(x, (height-nozzleHeight)-center, z);
                    this._mesh._normals[0].push(-nx, 0, -nz);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k    );

                        this._mesh._indices[0].push(k + 3);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        k += 2;
                    }
                }

                //Stem Bottom Side
                for (j=0, k=k+2; j<=sides; j++)
                {
                    beta = j * delta;
                    nx =  Math.sin(beta);
                    nz = -Math.cos(beta);

                    x = outerRadius * nx;
                    z = outerRadius * nz;

                    this._mesh._positions[0].push(x, -center, z);
                    this._mesh._normals[0].push(0, -1, 0);

                    x = innerRadius * nx;
                    z = innerRadius * nz;

                    this._mesh._positions[0].push(x, -center, z);
                    this._mesh._normals[0].push(0, -1, 0);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k    );

                        this._mesh._indices[0].push(k + 3);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        k += 2;
                    }
                }

                //Outer Nozzle Side
                for (j=0, k=k+2; j<=sides; j++)
                {
                    beta = j * delta;
                    nx =  Math.sin(beta);
                    nz = -Math.cos(beta);

                    x = nozzleRadius * nx;
                    z = nozzleRadius * nz;

                    this._mesh._positions[0].push(x, (height-nozzleHeight)-center, z);
                    this._mesh._normals[0].push(nx, 0, nz);

                    this._mesh._positions[0].push(x, center, z);
                    this._mesh._normals[0].push(nx, 0, nz);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k    );
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 3);

                        k += 2;
                    }
                }

                //Inner Nozzle Side
                for (j=0, k=k+2; j<=sides; j++)
                {
                    beta = j * delta;
                    nx =  Math.sin(beta);
                    nz = -Math.cos(beta);

                    x = innerRadius * nx;
                    z = innerRadius * nz;

                    this._mesh._positions[0].push(x, (height-nozzleHeight)-center, z);
                    this._mesh._normals[0].push(-nx, 0, -nz);

                    this._mesh._positions[0].push(x, center, z);
                    this._mesh._normals[0].push(-nx, 0, -nz);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k    );

                        this._mesh._indices[0].push(k + 3);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        k += 2;
                    }
                }

                //Nozzle Bottom Side
                for (j=0, k=k+2; j<=sides; j++)
                {
                    beta = j * delta;
                    nx =  Math.sin(beta);
                    nz = -Math.cos(beta);

                    x = nozzleRadius * nx;
                    z = nozzleRadius * nz;

                    this._mesh._positions[0].push(x, (height-nozzleHeight)-center, z);
                    this._mesh._normals[0].push(0, -1, 0);

                    x = outerRadius * nx;
                    z = outerRadius * nz;

                    this._mesh._positions[0].push(x, (height-nozzleHeight)-center, z);
                    this._mesh._normals[0].push(0, -1, 0);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k    );

                        this._mesh._indices[0].push(k + 3);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        k += 2;
                    }
                }

                //Nozzle Top Side
                for (j=0, k=k+2; j<=sides; j++)
                {
                    beta = j * delta;
                    nx =  Math.sin(beta);
                    nz = -Math.cos(beta);

                    x = nozzleRadius * nx;
                    z = nozzleRadius * nz;

                    this._mesh._positions[0].push(x, center, z);
                    this._mesh._normals[0].push(0, 1, 0);

                    x = innerRadius * nx;
                    z = innerRadius * nz;

                    this._mesh._positions[0].push(x, center, z);
                    this._mesh._normals[0].push(0, 1, 0);

                    if (j > 0)
                    {
                        this._mesh._indices[0].push(k    );
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 2);

                        this._mesh._indices[0].push(k + 2);
                        this._mesh._indices[0].push(k + 1);
                        this._mesh._indices[0].push(k + 3);

                        k += 2;
                    }
                }

                this.invalidateVolume();
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;
            },

            fieldChanged: function(fieldName) 
			{
                if (fieldName == "nozzleHeight" || fieldName == "nozzleRadius" || fieldName == "height" ||
                    fieldName == "outerRadius" || fieldName == "innerRadius" || fieldName == "subdivision")
                {
                    this.rebuildGeometry();

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                        node.invalidateVolume();
                    });
                }
        	}
		}
    )
);

/* ### SolidOfRevolution ### */
x3dom.registerNodeType(
    "SolidOfRevolution",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.SolidOfRevolution.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'creaseAngle', 0);
            this.addField_MFVec2f(ctx, 'crossSection', []);
            this.addField_SFFloat(ctx, 'angle', 2*Math.PI);
            this.addField_SFBool(ctx, 'caps', true);
            this.addField_SFFloat(ctx, 'subdivision', 32);

            this._origCCW = this._vf.ccw;

            this.rebuildGeometry();
        },
        {
            rebuildGeometry: function()
            {
                this._mesh._positions[0] = [];
                this._mesh._normals[0]   = [];
                this._mesh._texCoords[0] = [];
                this._mesh._indices[0]   = [];

                // assure that angle in [-2.Pi, 2.PI]
                var twoPi = 2.0 * Math.PI;
                if (this._vf.angle < -twoPi)
                    this._vf.angle = -twoPi;
                else if (this._vf.angle > twoPi)
                    this._vf.angle = twoPi;

                var crossSection = this._vf.crossSection, angle = this._vf.angle, steps = this._vf.subdivision;
                var i, j, k, l, m, n = crossSection.length;

                if (n < 1) {
                    x3dom.debug.logWarning("SolidOfRevolution requires crossSection curve.");
                    return;
                }

                var loop = (n > 2) ? crossSection[0].equals(crossSection[n-1], x3dom.fields.Eps) : false;
                var fullRevolution = (twoPi - Math.abs(angle) <= x3dom.fields.Eps);

                var alpha, delta = angle / steps;
                var positions = [], baseCurve = [];

                // fix wrong face orientation in case of clockwise rotation
                this._vf.ccw = (angle < 0) ? this._origCCW : !this._origCCW;

                // check if side caps are required
                if (!loop)
                {
                    if (Math.abs(crossSection[n-1].y) > x3dom.fields.Eps) {
                        crossSection.push(new x3dom.fields.SFVec2f(crossSection[n-1].x, 0));
                    }
                    if (Math.abs(crossSection[0].y) > x3dom.fields.Eps) {
                        crossSection.unshift(new x3dom.fields.SFVec2f(crossSection[0].x, 0));
                    }
                    n = crossSection.length;
                }

                // check curvature, starting from 2nd segment, and adjust base curve
                var pos = null, lastPos = null, penultimatePos = null;
                var duplicate = [];    // to be able to sort out duplicates for caps

                for (j=0; j<n; j++)
                {
                    if (pos) {
                        if (lastPos) {
                            penultimatePos = lastPos;
                        }
                        lastPos = pos;
                    }

                    pos = new x3dom.fields.SFVec3f(crossSection[j].x, 0, crossSection[j].y);

                    if (j >= 2)
                    {
                        alpha = pos.subtract(lastPos).normalize();
                        alpha = alpha.dot(lastPos.subtract(penultimatePos).normalize());
                        alpha = Math.abs(Math.cos(alpha));

                        if (alpha > this._vf.creaseAngle)
                        {
                            baseCurve.push(x3dom.fields.SFVec3f.copy(lastPos));
                            duplicate.push(true);
                        }
                        // TODO; handle case that curve is loop and angle smaller creaseAngle
                    }

                    baseCurve.push(pos);
                    duplicate.push(false);
                }

                n = baseCurve.length;

                // generate body of revolution (with rotation around x-axis)
                for (i=0, alpha=0; i<=steps; i++, alpha+=delta)
                {
                    var mat = x3dom.fields.SFMatrix4f.rotationX(alpha);

                    for (j=0; j<n; j++)
                    {
                        pos = mat.multMatrixPnt(baseCurve[j]);
                        positions.push(pos);

                        this._mesh._positions[0].push(pos.x, pos.y, pos.z);

                        if (i > 0 && j > 0)
                        {
                            this._mesh._indices[0].push((i-1)*n+(j-1), (i-1)*n+ j   ,  i   *n+ j   );
                            this._mesh._indices[0].push( i   *n+ j   ,  i   *n+(j-1), (i-1)*n+(j-1));
                        }
                    }
                }

                if (!fullRevolution && this._vf.caps == true)
                {
                    // add first cap
                    var linklist = new x3dom.DoublyLinkedList();
                    m = this._mesh._positions[0].length / 3;

                    for (j=0, i=0; j<n; j++)
                    {
                        if (!duplicate[j])
                        {
                            // Tessellation leads to errors with duplicated vertices if polygon not convex
                            linklist.appendNode(new x3dom.DoublyLinkedList.ListNode(positions[j], i++));

                            pos = positions[j];
                            this._mesh._positions[0].push(pos.x, pos.y, pos.z);
                        }
                    }

                    var linklist_indices = x3dom.EarClipping.getIndexes(linklist);

                    for (j=linklist_indices.length-1; j>=0; j--)
                    {
                        this._mesh._indices[0].push(m + linklist_indices[j]);
                    }

                    // second cap
                    m = this._mesh._positions[0].length / 3;

                    for (j=0; j<n; j++)
                    {
                        if (!duplicate[j])
                        {
                            pos = positions[n * steps + j];
                            this._mesh._positions[0].push(pos.x, pos.y, pos.z);
                        }
                    }

                    for (j=0; j<linklist_indices.length; j++)
                    {
                        this._mesh._indices[0].push(m + linklist_indices[j]);
                    }
                }

                // calculate and readjust normals if full revolution
                this._mesh.calcNormals(Math.PI, this._vf.ccw);

                if (fullRevolution)
                {
                    m = 3 * n * steps;

                    for (j=0; j<n; j++)
                    {
                        k = 3 * j;
                        this._mesh._normals[0][m+k  ] = this._mesh._normals[0][k  ];
                        this._mesh._normals[0][m+k+1] = this._mesh._normals[0][k+1];
                        this._mesh._normals[0][m+k+2] = this._mesh._normals[0][k+2];
                    }
                }

                this._mesh.calcTexCoords("");

                this.invalidateVolume();
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;
            },

            fieldChanged: function(fieldName)
            {
                if (fieldName == "crossSection" || fieldName == "angle" || fieldName == "caps" ||
                    fieldName == "subdivision" || fieldName == "creaseAngle")
                {
                    this.rebuildGeometry();

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);


/* ### SphereSegment ### */
x3dom.registerNodeType(
    "SphereSegment",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DSpatialGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.SphereSegment.superClass.call(this, ctx);

            this.addField_SFFloat(ctx, 'radius', 1);
            this.addField_MFFloat(ctx, 'longitude', []);
            this.addField_MFFloat(ctx, 'latitude', []);
            this.addField_SFVec2f(ctx, 'stepSize', 1, 1);

            var r = this._vf.radius;
            var longs = this._vf.longitude;
            var lats = this._vf.latitude;

            var subx = longs.length, suby = lats.length;
            var first, second;

            var latNumber, longNumber;
            var latitudeBands = suby;
            var longitudeBands = subx;

            var theta, sinTheta, cosTheta;
            var phi, sinPhi, cosPhi;
            var x, y, z, u, v;

            for (latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                theta = ((lats[latNumber]+90) * Math.PI) / 180;
                sinTheta = Math.sin(theta);
                cosTheta = Math.cos(theta);

                for (longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                    phi = ((longs[longNumber]) * Math.PI) / 180;

                    sinPhi = Math.sin(phi);
                    cosPhi = Math.cos(phi);

                    x = -cosPhi * sinTheta;
                    y = -cosTheta;
                    z = -sinPhi * sinTheta;

                    u = longNumber / (longitudeBands-1);
                    v = latNumber / (latitudeBands-1);

                    this._mesh._positions[0].push(r * x, r * y, r * z);
                    this._mesh._normals[0].push(x, y, z);
                    this._mesh._texCoords[0].push(u, v);
                }
            }

            for (latNumber = 0; latNumber < latitudeBands; latNumber++) {
                for (longNumber = 0; longNumber < longitudeBands; longNumber++) {
                    first = (latNumber * (longitudeBands + 1)) + longNumber;
                    second = first + longitudeBands + 1;

                    this._mesh._indices[0].push(first);
                    this._mesh._indices[0].push(second);
                    this._mesh._indices[0].push(first + 1);

                    this._mesh._indices[0].push(second);
                    this._mesh._indices[0].push(second + 1);
                    this._mesh._indices[0].push(first + 1);
                }
            }

            this._mesh._invalidate = true;
            this._mesh._numFaces = this._mesh._indices[0].length / 3;
            this._mesh._numCoords = this._mesh._positions[0].length / 3;
        }
    )
);

/* ### ElevationGrid ### */
x3dom.registerNodeType(
    "ElevationGrid",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.ElevationGrid.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'colorPerVertex', true);
            this.addField_SFBool(ctx, 'normalPerVertex', true);
            this.addField_SFFloat(ctx, 'creaseAngle', 0);

            this.addField_MFNode('attrib', x3dom.nodeTypes.X3DVertexAttributeNode);
            this.addField_SFNode('normal', x3dom.nodeTypes.Normal);
            this.addField_SFNode('color', x3dom.nodeTypes.X3DColorNode);
            this.addField_SFNode('texCoord', x3dom.nodeTypes.X3DTextureCoordinateNode);

            this.addField_MFFloat(ctx, 'height', []);
            this.addField_SFInt32(ctx, 'xDimension', 0);
            this.addField_SFFloat(ctx, 'xSpacing', 1.0);
            this.addField_SFInt32(ctx, 'zDimension', 0);
            this.addField_SFFloat(ctx, 'zSpacing', 1.0);
        },
        {
            nodeChanged: function()
            {
                this._mesh._indices[0] = [];
                this._mesh._positions[0] = [];
                this._mesh._normals[0] = [];
                this._mesh._texCoords[0] = [];
                this._mesh._colors[0] = [];

                var x = 0, y = 0;
                var subx = this._vf.xDimension-1;
                var suby = this._vf.zDimension-1;

                var h = this._vf.height;

                x3dom.debug.assert((h.length === this._vf.xDimension*this._vf.zDimension));

                var normals = null, texCoords = null, colors = null;

                if (this._cf.normal.node) {
                    normals = this._cf.normal.node._vf.vector;
                }

                var numTexComponents = 2;

                var texCoordNode = this._cf.texCoord.node;
                if (x3dom.isa(texCoordNode, x3dom.nodeTypes.MultiTextureCoordinate)) {
                    if (texCoordNode._cf.texCoord.nodes.length)
                        texCoordNode = texCoordNode._cf.texCoord.nodes[0];
                }

                if (texCoordNode) {
                    if (texCoordNode._vf.point) {
                        texCoords = texCoordNode._vf.point;
                        if (x3dom.isa(texCoordNode, x3dom.nodeTypes.TextureCoordinate3D)) {
                            numTexComponents = 3;
                        }
                    }
                }

                var numColComponents = 3;
                if (this._cf.color.node) {
                    colors = this._cf.color.node._vf.color;
                    if (x3dom.isa(this._cf.color.node, x3dom.nodeTypes.ColorRGBA)) {
                        numColComponents = 4;
                    }
                }

                var c = 0;

                for (y = 0; y <= suby; y++)
                {
                    for (x = 0; x <= subx; x++)
                    {
                        this._mesh._positions[0].push(x * this._vf.xSpacing);
                        this._mesh._positions[0].push(h[c]);
                        this._mesh._positions[0].push(y * this._vf.zSpacing);

                        if (normals) {
                            this._mesh._normals[0].push(normals[c].x);
                            this._mesh._normals[0].push(normals[c].y);
                            this._mesh._normals[0].push(normals[c].z);
                        }

                        if (texCoords) {
                            this._mesh._texCoords[0].push(texCoords[c].x);
                            this._mesh._texCoords[0].push(texCoords[c].y);
                            if (numTexComponents === 3) {
                                this._mesh._texCoords[0].push(texCoords[c].z);
                            }
                        }
                        else {
                            this._mesh._texCoords[0].push(x / subx);
                            this._mesh._texCoords[0].push(y / suby);
                        }

                        if (colors) {
                            this._mesh._colors[0].push(colors[c].r);
                            this._mesh._colors[0].push(colors[c].g);
                            this._mesh._colors[0].push(colors[c].b);
                            if (numColComponents === 4) {
                                this._mesh._colors[0].push(colors[c].a);
                            }
                        }

                        c++;
                    }
                }

                for (y = 1; y <= suby; y++) {
                    for (x = 0; x < subx; x++) {
                        this._mesh._indices[0].push((y - 1) * (subx + 1) + x);
                        this._mesh._indices[0].push(y * (subx + 1) + x);
                        this._mesh._indices[0].push((y - 1) * (subx + 1) + x + 1);

                        this._mesh._indices[0].push(y * (subx + 1) + x);
                        this._mesh._indices[0].push(y * (subx + 1) + x + 1);
                        this._mesh._indices[0].push((y - 1) * (subx + 1) + x + 1);
                    }
                }

                // TODO; handle at least per quad normals
                //       (corresponds to creaseAngle = 0)
                //this._mesh.calcNormals(this._vf.creaseAngle, this._vf.ccw);
                if (!normals)
                    this._mesh.calcNormals(Math.PI, this._vf.ccw);

                this.invalidateVolume();
                this._mesh._numTexComponents = numTexComponents;
                this._mesh._numColComponents = numColComponents;
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;
            },

            fieldChanged: function(fieldName)
            {
                var normals = null;

                if (this._cf.normal.node) {
                    normals = this._cf.normal.node._vf.vector;
                }

                if (fieldName == "height")
                {
                    var i, n = this._mesh._positions[0].length / 3;
                    var h = this._vf.height;

                    for (i=0; i<n; i++) {
                        this._mesh._positions[0][3*i+1] = h[i];
                    }

                    if (!normals) {
                        this._mesh._normals[0] = [];
                        this._mesh.calcNormals(Math.PI, this._vf.ccw);
                    }

                    this.invalidateVolume();

                    Array.forEach(this._parentNodes, function (node) {
                        node._dirty.positions = true;
                        if (!normals)
                            node._dirty.normals = true;
                        node.invalidateVolume();
                    });
                }
                // TODO: handle other cases!
            }
        }
    )
);

/* ### Extrusion ### */
x3dom.registerNodeType(
    "Extrusion",
    "Geometry3D",
    defineClass(x3dom.nodeTypes.X3DGeometryNode,
        function (ctx) {
            x3dom.nodeTypes.Extrusion.superClass.call(this, ctx);

            this.addField_SFBool(ctx, 'beginCap', true);
            this.addField_SFBool(ctx, 'endCap', true);
            this.addField_SFBool(ctx, 'convex', true);
            this.addField_SFFloat(ctx, 'creaseAngle', 0);
            this.addField_MFVec2f(ctx, 'crossSection', [ new x3dom.fields.SFVec2f(1, 1), 
                                                         new x3dom.fields.SFVec2f(1, -1), 
                                                         new x3dom.fields.SFVec2f(-1, -1), 
                                                         new x3dom.fields.SFVec2f(-1, 1), 
                                                         new x3dom.fields.SFVec2f(1, 1) 
                                                        ]);
            this.addField_MFRotation(ctx, 'orientation', [ new x3dom.fields.Quaternion(0, 0, 0, 1) ]);
            this.addField_MFVec2f(ctx, 'scale', [ new x3dom.fields.SFVec2f(1, 1) ]);
            this.addField_MFVec3f(ctx, 'spine', [ new x3dom.fields.SFVec3f(0, 0, 0), 
                                                  new x3dom.fields.SFVec3f(0, 1, 0)
                                                ]);
            this.addField_SFFloat(ctx, 'height', 0); // convenience field for setting default spine

            // http://www.web3d.org/files/specifications/19775-1/V3.3/Part01/components/geometry3D.html#Extrusion
            // http://accad.osu.edu/~pgerstma/class/vnv/resources/info/AnnotatedVrmlRef/ch3-318.htm
            this.rebuildGeometry();
        },
        {
            rebuildGeometry: function()
            {
                this._mesh._positions[0] = [];
                this._mesh._normals[0]   = [];
                this._mesh._texCoords[0] = [];
                this._mesh._indices[0]   = [];

                var i, j, n, m, len, sx = 1, sy = 1;
                var spine = this._vf.spine,
                    scale = this._vf.scale,
                    orientation = this._vf.orientation,
                    crossSection = this._vf.crossSection;
                var positions = [], index = 0;

                m = spine.length;
                n = crossSection.length;

                if (/*m == 0 &&*/ this._vf.height > 0) {
                    spine[0] = new x3dom.fields.SFVec3f(0, 0, 0);
                    spine[1] = new x3dom.fields.SFVec3f(0, this._vf.height, 0);
                    m = 2;
                }

                var x, y, z;
                var last_z = new x3dom.fields.SFVec3f(0, 0, 1);

                if (m > 2) {
                    for (i = 1; i < m - 1; i++) {
                        var last_z_candidate = spine[i + 1].subtract(spine[i]).cross(spine[i - 1].subtract(spine[i]));
                        if (last_z_candidate.length() > x3dom.fields.Eps) {
                            last_z = x3dom.fields.SFVec3f.copy(last_z_candidate.normalize());
                            break;
                        }
                    }
                }

                var texCoordV = 0;
                var texCoordsV = [ 0 ];

                for (i=1; i<m; i++) {
                    var v = spine[i].subtract(spine[i-1]).length();
                    texCoordV = texCoordV + v;
                    texCoordsV[i] = texCoordV;
                }

                var texCoordU = 0;
                var texCoordsU = [ 0 ];

                var maxTexU_x = 0, minTexU_x = 0;
                var maxTexU_z = 0, minTexU_z = 0;

                for (j=1; j<n; j++) {
                    var u = crossSection[j].subtract(crossSection[j-1]).length();
                    texCoordU = texCoordU + u;
                    texCoordsU[j] = texCoordU;

                    if (j==1) {
                        maxTexU_x = minTexU_x = crossSection[j-1].x;
                        maxTexU_z = minTexU_z = crossSection[j-1].y;
                    }

                    if (maxTexU_x < crossSection[j].x) {
                        maxTexU_x = crossSection[j].x;
                    }
                    if (minTexU_x > crossSection[j].x) {
                        minTexU_x = crossSection[j].x;
                    }
                    if (maxTexU_z < crossSection[j].y) {
                        maxTexU_z = crossSection[j].y;
                    }
                    if (minTexU_z > crossSection[j].y) {
                        minTexU_z = crossSection[j].y;
                    }
                }

                if (Math.abs(maxTexU_x - minTexU_x) < Math.abs(maxTexU_z - minTexU_z)) {
                    var helpMax = maxTexU_x;
                    var helpMin = minTexU_x;
                    maxTexU_x = maxTexU_z;
                    minTexU_x = minTexU_z;
                    maxTexU_z = helpMax;
                    minTexU_z = helpMin;
                }

                var diffTexU_x = Math.abs(maxTexU_x - minTexU_x);
                var diffTexU_z = Math.abs(maxTexU_z - minTexU_z);

                var spineClosed = (m > 2) ? spine[0].equals(spine[spine.length-1], x3dom.fields.Eps) : false;

                for (i=0; i<m; i++) {
                    if ((len = scale.length) > 0) {
                        if (i < len) {
                            sx = scale[i].x;
                            sy = scale[i].y;
                        }
                        else {
                            sx = scale[len-1].x;
                            sy = scale[len-1].y;
                        }
                    }

                    for (j=0; j<n; j++) {
                        var pos = new x3dom.fields.SFVec3f(
                            crossSection[j].x * sx + spine[i].x,
                            spine[i].y,
                            crossSection[j].y * sy + spine[i].z);

                        if (m > 2) {
                            if (i == 0) {
                                if (spineClosed) {
                                    y = spine[1].subtract(spine[m-2]);
                                    z = spine[1].subtract(spine[0]).cross(spine[m-2].subtract(spine[0]));
                                }
                                else {
                                    y = spine[1].subtract(spine[0]);
                                    z = spine[2].subtract(spine[1]).cross(spine[0].subtract(spine[1]));
                                }
                                if (z.length() > x3dom.fields.Eps) {
                                  last_z = x3dom.fields.SFVec3f.copy(z);
                                }
                            }
                            else if (i == m-1) {
                                if (spineClosed) {
                                    y = spine[1].subtract(spine[m-2]);
                                    z = spine[1].subtract(spine[0]).cross(spine[m-2].subtract(spine[0]));
                                }
                                else {
                                    y = spine[m-1].subtract(spine[m-2]);
                                    z = x3dom.fields.SFVec3f.copy(last_z);
                                }
                            }
                            else {
                                y = spine[i+1].subtract(spine[i-1]);
                                z = y.cross(spine[i-1].subtract(spine[i]));
                            }
                            if (z.dot(last_z) < 0) {
                                z = z.negate();
                            }

                            y = y.normalize();
                            z = z.normalize();
                            
                            if (z.length() <= x3dom.fields.Eps)	{
                                z = x3dom.fields.SFVec3f.copy(last_z);
                            }

                            if (i != 0) {
                                last_z = x3dom.fields.SFVec3f.copy(z);
                            }
                            x = y.cross(z).normalize();

                            var baseMat = x3dom.fields.SFMatrix4f.identity();
                            baseMat.setValue(x, y, z);
                            var rotMat = (i < orientation.length) ? orientation[i].toMatrix() :
                                ( (orientation.length > 0) ? orientation[orientation.length-1].toMatrix() :
                                                             x3dom.fields.SFMatrix4f.identity() );

                            pos = pos.subtract(spine[i]);
                            pos = baseMat.multMatrixPnt(rotMat.multMatrixPnt(pos));
                            pos = pos.add(spine[i]);
                        }
                        pos.crossSection = crossSection[j];
                        positions.push(pos);

                        if (this._vf.creaseAngle <= x3dom.fields.Eps) {
                            if (i > 0 && j > 0) {
                                var iPos = (i-1)*n+(j-1);
                                this._mesh._positions[0].push(positions[iPos].x, positions[iPos].y, positions[iPos].z);
                                this._mesh._texCoords[0].push(texCoordsU[j-1]/texCoordU, texCoordsV[i-1]/texCoordV);
                                iPos = (i-1)*n+j;
                                this._mesh._positions[0].push(positions[iPos].x, positions[iPos].y, positions[iPos].z);
                                this._mesh._texCoords[0].push(texCoordsU[j]/texCoordU, texCoordsV[i-1]/texCoordV);
                                iPos = i*n+j;
                                this._mesh._positions[0].push(positions[iPos].x, positions[iPos].y, positions[iPos].z);
                                this._mesh._texCoords[0].push(texCoordsU[j]/texCoordU, texCoordsV[i]/texCoordV);

                                this._mesh._indices[0].push(index++, index++, index++);

                                this._mesh._positions[0].push(positions[iPos].x, positions[iPos].y, positions[iPos].z);
                                this._mesh._texCoords[0].push(texCoordsU[j]/texCoordU, texCoordsV[i]/texCoordV);
                                iPos = i*n+(j-1);
                                this._mesh._positions[0].push(positions[iPos].x, positions[iPos].y, positions[iPos].z);
                                this._mesh._texCoords[0].push(texCoordsU[j-1]/texCoordU, texCoordsV[i]/texCoordV);
                                iPos = (i-1)*n+(j-1);
                                this._mesh._positions[0].push(positions[iPos].x, positions[iPos].y, positions[iPos].z);
                                this._mesh._texCoords[0].push(texCoordsU[j-1]/texCoordU, texCoordsV[i-1]/texCoordV);

                                this._mesh._indices[0].push(index++, index++, index++);
                            }
                        }
                        else {
                            this._mesh._positions[0].push(pos.x, pos.y, pos.z);
                            this._mesh._texCoords[0].push(texCoordsU[j]/texCoordU, texCoordsV[i]/texCoordV);

                            if (i > 0 && j > 0) {
                                this._mesh._indices[0].push((i-1)*n+(j-1), (i-1)*n+ j   ,  i   *n+ j   );
                                this._mesh._indices[0].push( i   *n+ j   ,  i   *n+(j-1), (i-1)*n+(j-1));
                            }
                        }
                    }

                    if (i == m-1) {
                        var p0, l, startPos;
                        var linklist, linklist_indices;

                        // add bottom (1st cross-section)
                        if (this._vf.beginCap) {
                            linklist = new x3dom.DoublyLinkedList();
                            l = this._mesh._positions[0].length / 3;

                            for (j=0; j<n; j++) {
                                linklist.appendNode(new x3dom.DoublyLinkedList.ListNode(positions[j], j));

                                if (this._vf.creaseAngle > x3dom.fields.Eps) {
                                    p0 = positions[j];
                                    this._mesh._positions[0].push(p0.x, p0.y, p0.z);
                                    this._mesh._texCoords[0].push((p0.crossSection.x - minTexU_x)/diffTexU_x,
                                                                  (p0.crossSection.y - minTexU_z)/diffTexU_z);

                                }
                            }

                            linklist_indices = x3dom.EarClipping.getIndexes(linklist);

                            for (j=linklist_indices.length-1; j>=0; j--) {
                                if (this._vf.creaseAngle > x3dom.fields.Eps) {
                                    this._mesh._indices[0].push(l + linklist_indices[j]);
                                }
                                else {
                                    p0 = positions[linklist_indices[j]];
                                    this._mesh._positions[0].push(p0.x, p0.y, p0.z);
                                    this._mesh._texCoords[0].push((p0.crossSection.x - minTexU_x)/diffTexU_x,
                                                                  (p0.crossSection.y - minTexU_z)/diffTexU_z);
                                    this._mesh._indices[0].push(index++);
                                }
                            }
                        }

                        // add top (last cross-section)
                        if (this._vf.endCap) {
                            linklist = new x3dom.DoublyLinkedList();
                            startPos = (m - 1) * n;
                            l = this._mesh._positions[0].length / 3;

                            for (j=0; j<n; j++) {
                                linklist.appendNode(new x3dom.DoublyLinkedList.ListNode(positions[startPos+j], startPos+j));

                                if (this._vf.creaseAngle > x3dom.fields.Eps) {
                                    p0 = positions[startPos+j];
                                    this._mesh._positions[0].push(p0.x, p0.y, p0.z);
                                    this._mesh._texCoords[0].push((p0.crossSection.x - minTexU_x)/diffTexU_x,
                                                                  (p0.crossSection.y - minTexU_z)/diffTexU_z);
                                }
                            }

                            linklist_indices = x3dom.EarClipping.getIndexes(linklist);

                            for (j=0; j<linklist_indices.length; j++) {
                                if (this._vf.creaseAngle > x3dom.fields.Eps) {
                                    this._mesh._indices[0].push(l + (linklist_indices[j] - startPos));
                                }
                                else {
                                    p0 = positions[linklist_indices[j]];
                                    this._mesh._positions[0].push(p0.x, p0.y, p0.z);
                                    this._mesh._texCoords[0].push((p0.crossSection.x - minTexU_x)/diffTexU_x,
                                                                  (p0.crossSection.y - minTexU_z)/diffTexU_z);
                                    this._mesh._indices[0].push(index++);
                                }
                            }
                        }
                    }
                }

                this._mesh.calcNormals(this._vf.creaseAngle, this._vf.ccw);

                this.invalidateVolume();
                this._mesh._numFaces = this._mesh._indices[0].length / 3;
                this._mesh._numCoords = this._mesh._positions[0].length / 3;
            },

            fieldChanged: function(fieldName)
            {
                if (fieldName == "beginCap" || fieldName == "endCap" ||
                    fieldName == "crossSection" || fieldName == "orientation" ||
                    fieldName == "scale" || fieldName == "spine" ||
                    fieldName == "height" || fieldName == "creaseAngle")
                {
                    this.rebuildGeometry();

                    Array.forEach(this._parentNodes, function (node) {
                        node.setAllDirty();
                        node.invalidateVolume();
                    });
                }
            }
        }
    )
);

/*
 * HAnim Humanoid Animation component, X3D extension to the
 * X3DOM JavaScript Library
 * http://x3dom.org
 *
 * Closely adapted from the code for the Grouping and CAD components in X3D as
 * implemented in X3DOM
 
 Dual licensed under the MIT and GPL.
 http://x3dom.org/download/dev/docs/html/license.html
 
 * Based on code originally provided by
 *  Philip Taylor: http://philip.html5.org
 
 * 30 NOV 2013  Don Brutzman
 */


// H-Anim (Humanoid Animation) Component
// http://www.web3d.org/files/specifications/19775-1/V3.3/Part01/components/hanim.html
// http://www.web3d.org/files/specifications/19774/V1.0/HAnim/HAnim.html

// ### HAnimDisplacer ###
x3dom.registerNodeType(
    "HAnimDisplacer",
    "H-Anim",
    defineClass(x3dom.nodeTypes.X3DGeometricPropertyNode,
        function (ctx) {
            x3dom.nodeTypes.HAnimDisplacer.superClass.call(this, ctx);

            this.addField_SFString(ctx,'name', "");
            this.addField_SFFloat(ctx, 'weight', 0);
            this.addField_MFInt32(ctx, 'coordIndex', []);
            this.addField_MFVec3f(ctx, 'displacements', []);

            // TODO displacement (add functionality e.g. via matrix palette skinning in shader)
            x3dom.debug.logWarning("HAnimDisplacer NYI!");
        }
    )
);

// ### HAnimJoint ###
x3dom.registerNodeType(
    "HAnimJoint",
    "H-Anim",
    defineClass(x3dom.nodeTypes.Transform,
        function (ctx) {
            x3dom.nodeTypes.HAnimJoint.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'name', "");
            this.addField_MFNode('displacers', x3dom.nodeTypes.HAnimDisplacer);
            
            this.addField_SFRotation(ctx, 'limitOrientation', 0, 0, 1, 0);
            this.addField_MFFloat(ctx, 'llimit', []);
            this.addField_MFFloat(ctx, 'ulimit', []);
            this.addField_MFInt32(ctx, 'skinCoordIndex', []);
            this.addField_MFFloat(ctx, 'skinCoordWeight', []);
        }
    )
);

// ### HAnimSegment ###
x3dom.registerNodeType(
    "HAnimSegment",
    "H-Anim",
    defineClass(x3dom.nodeTypes.X3DGroupingNode,
        function (ctx) {
            x3dom.nodeTypes.HAnimSegment.superClass.call(this, ctx);

            this.addField_SFString(ctx,'name', "");
            this.addField_SFVec3f(ctx, 'centerOfMass', 0, 0, 0);
            this.addField_SFFloat(ctx, 'mass', 0);
            this.addField_MFFloat(ctx, 'momentsOfInertia', [0, 0, 0, 0, 0, 0, 0, 0, 0]);

            this.addField_SFNode('coord', x3dom.nodeTypes.X3DCoordinateNode);
            this.addField_MFNode('displacers', x3dom.nodeTypes.HAnimDisplacer);
        },
        {
            // TODO coord      add functionality
            // TODO displacers add functionality
        }
    )
);

// ### HAnimSite ###
x3dom.registerNodeType(
    "HAnimSite",
    "H-Anim",
    defineClass(x3dom.nodeTypes.Transform,
        function (ctx) {
            x3dom.nodeTypes.HAnimSite.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'name', "");
        }
    )
);

// ### HAnimHumanoid ###
x3dom.registerNodeType(
    "HAnimHumanoid",
    "H-Anim",
    defineClass(x3dom.nodeTypes.Transform,
        function (ctx) {
            x3dom.nodeTypes.HAnimHumanoid.superClass.call(this, ctx);

            this.addField_SFString(ctx, 'name', "");
            this.addField_SFString(ctx, 'version', "");
            this.addField_MFString(ctx, 'info', []);

            this.addField_MFNode('joints', x3dom.nodeTypes.HAnimJoint);
            this.addField_MFNode('segments', x3dom.nodeTypes.HAnimSegment);
            this.addField_MFNode('sites', x3dom.nodeTypes.HAnimSite);
            this.addField_MFNode('skeleton', x3dom.nodeTypes.HAnimJoint);
            this.addField_MFNode('skin', x3dom.nodeTypes.X3DChildNode);
            this.addField_MFNode('skinCoord', x3dom.nodeTypes.X3DCoordinateNode);
            this.addField_MFNode('skinNormal', x3dom.nodeTypes.X3DNormalNode);
            this.addField_MFNode('viewpoints', x3dom.nodeTypes.HAnimSite);
        },
        {
            // TODO skeleton   contains the HumanoidRoot Joint object functionality: map similar to children of Group
            // TODO skeleton   add functionality for HAnimSite also (unaffected by internal transformations)
            // TODO joints     add functionality
            // TODO segments   add functionality
            // TODO sites      add functionality
            // TODO skin...    add functionality
            // TODO viewpoints add functionality
        }
    )
);

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


/**
 *  Moveable interface, wraps x3d bounded node with SpaceSensor-like movement functionality,
 *  therefore attaches event handlers, thus to be called earliest in document.onload method.
 *
 *  Cleanup backrefs and listeners on delete by explicitly calling detachHandlers()
 */
x3dom.Moveable = function(x3domElem, boundedObj, callback, gridSize, mode) {
    this._x3domRoot = x3domElem;
    this._runtime = x3domElem.runtime;

    // callback function for notifying changes
    this._callback = callback;

    // snap to grid of given size (0, no grid, if undefined)
    this._gridSize = gridSize ? gridSize : 0;

    this._moveable = boundedObj;
    this._drag = false;

    this._w = 0;
    this._h = 0;

    this._uPlane = null;
    this._vPlane = null;
    this._pPlane = null;

    this._isect = null;

    this._translationOffset = null;
    this._rotationOffset = null;
    this._scaleOffset = null;

    this._lastX = 0;
    this._lastY = 0;
    this._buttonState = 0;

    this._mode = (mode && mode.length) ? mode.toLowerCase() : "translation"; //"all";

    this._firstRay = null;
    this._matrixTrafo = null;

    this._navType = "examine";

    this.attachHandlers();
};

// grid size setter, for snapping
x3dom.Moveable.prototype.setGridSize = function(gridSize) {
    this._gridSize = gridSize;
};

// interaction mode setter, for translation and/or rotation
x3dom.Moveable.prototype.setMode = function(mode) {
    this._mode = mode.toLowerCase();
};

x3dom.Moveable.prototype.attachHandlers = function() {
    // add backref to movable object (for member access and wrapping)
    this._moveable._iMove = this;

    // add backref to <x3d> element
    if (!this._x3domRoot._iMove)
        this._x3domRoot._iMove = [];
    this._x3domRoot._iMove.push(this);

    // mouse events
    this._moveable.addEventListener('mousedown', this.start, false);
    this._moveable.addEventListener('mouseover', this.over, false);
    this._moveable.addEventListener('mouseout', this.out, false);

    if (this._x3domRoot._iMove.length == 1) {
        // more mouse events
        this._x3domRoot.addEventListener('mouseup', this.stop, false);
        this._x3domRoot.addEventListener('mouseout', this.stop, false);
        this._x3domRoot.addEventListener('mousemove', this.move, true);

        if (!this._runtime.canvas.disableTouch) {
            // mozilla touch events
            this._x3domRoot.addEventListener('MozTouchDown', this.touchStartHandlerMoz, false);
            this._x3domRoot.addEventListener('MozTouchMove', this.touchMoveHandlerMoz, true);
            this._x3domRoot.addEventListener('MozTouchUp', this.touchEndHandlerMoz, false);
            // w3c / apple touch events
            this._x3domRoot.addEventListener('touchstart', this.touchStartHandler, false);
            this._x3domRoot.addEventListener('touchmove', this.touchMoveHandler, true);
            this._x3domRoot.addEventListener('touchend', this.touchEndHandler, false);
        }
    }
};

x3dom.Moveable.prototype.detachHandlers = function() {
    // remove backref to <x3d> element
    var iMove = this._x3domRoot._iMove;
    if (iMove) {
        for (var i=0, n=iMove.length; i<n; i++) {
            if (iMove[i] == this) {
                iMove.splice(i, 1);
                break;
            }
        }
    }

    // mouse events
    this._moveable.removeEventListener('mousedown', this.start, false);
    this._moveable.removeEventListener('mouseover', this.over, false);
    this._moveable.removeEventListener('mouseout', this.out, false);

    if (iMove.length == 0) {
        // more mouse events
        this._x3domRoot.removeEventListener('mouseup', this.stop, false);
        this._x3domRoot.removeEventListener('mouseout', this.stop, false);
        this._x3domRoot.removeEventListener('mousemove', this.move, true);

        if (!this._runtime.canvas.disableTouch) {
            // touch events
            this._x3domRoot.removeEventListener('MozTouchDown', this.touchStartHandlerMoz, false);
            this._x3domRoot.removeEventListener('MozTouchMove', this.touchMoveHandlerMoz, true);
            this._x3domRoot.removeEventListener('MozTouchUp', this.touchEndHandlerMoz, false);
            // mozilla version
            this._x3domRoot.removeEventListener('touchstart', this.touchStartHandler, false);
            this._x3domRoot.removeEventListener('touchmove', this.touchMoveHandler, true);
            this._x3domRoot.removeEventListener('touchend', this.touchEndHandler, false);
        }
    }

    // finally remove backref to movable object
    if (this._moveable._iMove)
        delete this._moveable._iMove;
};

// calculate viewing plane
x3dom.Moveable.prototype.calcViewPlane = function(origin) {
    // init width and height
    this._w = this._runtime.getWidth();
    this._h = this._runtime.getHeight();

    //bottom left of viewarea
    var ray = this._runtime.getViewingRay(0, this._h - 1);
    var r = ray.pos.add(ray.dir);

    //bottom right of viewarea
    ray = this._runtime.getViewingRay(this._w - 1, this._h - 1);
    var s = ray.pos.add(ray.dir);

    //top left of viewarea
    ray = this._runtime.getViewingRay(0, 0);
    var t = ray.pos.add(ray.dir);

    this._uPlane = s.subtract(r).normalize();
    this._vPlane = t.subtract(r).normalize();

    if (arguments.length === 0)
        this._pPlane = r;
    else
        this._pPlane = x3dom.fields.SFVec3f.copy(origin);
};

// helper method to obtain determinant
x3dom.Moveable.prototype.det = function(mat) {
    return mat[0][0] * mat[1][1] * mat[2][2] + mat[0][1] * mat[1][2] * mat[2][0] +
           mat[0][2] * mat[2][1] * mat[1][0] - mat[2][0] * mat[1][1] * mat[0][2] -
           mat[0][0] * mat[2][1] * mat[1][2] - mat[1][0] * mat[0][1] * mat[2][2];
};

// Translation along plane parallel to viewing plane E:x=p+t*u+s*v
x3dom.Moveable.prototype.translateXY = function(l) {
    var track = null;
    var z = [], n = [];

    for (var i = 0; i < 3; i++) {
        z[i] = [];
        n[i] = [];

        z[i][0] = this._uPlane.at(i);
        n[i][0] = z[i][0];

        z[i][1] = this._vPlane.at(i);
        n[i][1] = z[i][1];

        z[i][2] = (l.pos.subtract(this._pPlane)).at(i);
        n[i][2] = -l.dir.at(i);
    }

    // get intersection line-plane with Cramer's rule
    var s = this.det(n);

    if (s !== 0) {
        var t = this.det(z) / s;
        track = l.pos.addScaled(l.dir, t);
    }

    if (track) {
        if (this._isect) {
            // calc offset from first click position
            track = track.subtract(this._isect);
        }
        track = track.add(this._translationOffset);
    }

    return track;
};

// Translation along picking ray
x3dom.Moveable.prototype.translateZ = function(l, currY) {
    var vol = this._runtime.getSceneBBox();

    var sign = (currY < this._lastY) ? 1 : -1;
    var fact = sign * (vol.max.subtract(vol.min)).length() / 100;

    this._translationOffset = this._translationOffset.addScaled(l.dir, fact);

    return this._translationOffset;
};

x3dom.Moveable.prototype.rotate = function(posX, posY) {
    var twoPi = 2 * Math.PI;
    var alpha = ((posY - this._lastY) * twoPi) / this._w;
    var beta  = ((posX - this._lastX) * twoPi) / this._h;

    var q = x3dom.fields.Quaternion.axisAngle(this._uPlane, alpha);
    var h = q.toMatrix();
    this._rotationOffset = h.mult(this._rotationOffset);

    q = x3dom.fields.Quaternion.axisAngle(this._vPlane, beta);
    h = q.toMatrix();
    this._rotationOffset = h.mult(this._rotationOffset);

    var mat = this._rotationOffset.mult(x3dom.fields.SFMatrix4f.scale(this._scaleOffset));
    var rot = new x3dom.fields.Quaternion(0, 0, 1, 0);
    rot.setValue(mat);

    return rot;
};

x3dom.Moveable.prototype.over = function(event) {
    var that = this._iMove;

    that._runtime.getCanvas().style.cursor = "crosshair";
};

x3dom.Moveable.prototype.out = function(event) {
    var that = this._iMove;

    if (!that._drag)
        that._runtime.getCanvas().style.cursor = "pointer";
};

// start object movement, switch from navigation to interaction
x3dom.Moveable.prototype.start = function(event) {
    var that = this._iMove;

    // use mouse button to distinguish between parallel or orthogonal movement or rotation
    switch (that._mode) {
        case "translation":
            that._buttonState = (event.button == 4) ? 1 : (event.button & 3);
            break;
        case "rotation":
            that._buttonState = 4;
            break;
        case "all":
        default:
            that._buttonState = event.button;
            break;
    }

    if (!that._drag && that._buttonState) {
        that._lastX = event.layerX;
        that._lastY = event.layerY;

        that._drag = true;

        // temporarily disable navigation
        that._navType = that._runtime.navigationType();
        that._runtime.noNav();

        // calc view-aligned plane through original pick position
        that._isect = new x3dom.fields.SFVec3f(event.worldX, event.worldY, event.worldZ);
        that.calcViewPlane(that._isect);

        that._firstRay = that._runtime.getViewingRay(event.layerX, event.layerY);

        var mTrans = that._moveable.getAttribute("translation");
        that._matrixTrafo = null;

        if (mTrans) {
            that._translationOffset = x3dom.fields.SFVec3f.parse(mTrans);

            var mRot = that._moveable.getAttribute("rotation");
            mRot = mRot ? x3dom.fields.Quaternion.parseAxisAngle(mRot) : new x3dom.fields.Quaternion(0,0,1,0);
            that._rotationOffset = mRot.toMatrix();

            var mScal = that._moveable.getAttribute("scale");
            that._scaleOffset = mScal ? x3dom.fields.SFVec3f.parse(mScal) : new x3dom.fields.SFVec3f(1, 1, 1);
        }
        else {
            mTrans = that._moveable.getAttribute("matrix");

            if (mTrans) {
                that._matrixTrafo = x3dom.fields.SFMatrix4f.parse(mTrans).transpose();

                var translation = new x3dom.fields.SFVec3f(0,0,0),
                    scaleFactor = new x3dom.fields.SFVec3f(1,1,1);
                var rotation = new x3dom.fields.Quaternion(0,0,1,0),
                    scaleOrientation = new x3dom.fields.Quaternion(0,0,1,0);

                that._matrixTrafo.getTransform(translation, rotation, scaleFactor, scaleOrientation);

                //that._translationOffset = that._matrixTrafo.e3();
                that._translationOffset = translation;
                that._rotationOffset = rotation.toMatrix();
                that._scaleOffset = scaleFactor;
            }
            else {
                that._translationOffset = new x3dom.fields.SFVec3f(0, 0, 0);
                that._rotationOffset = new x3dom.fields.SFMatrix4f();
                that._scaleOffset = new x3dom.fields.SFVec3f(1, 1, 1);
            }
        }

        that._runtime.getCanvas().style.cursor = "crosshair";
    }
};

x3dom.Moveable.prototype.move = function(event) {
    for (var i=0, n=this._iMove.length; i<n; i++) {
        var that = this._iMove[i];

        if (that._drag) {
            var pos = that._runtime.mousePosition(event);
            var ray = that._runtime.getViewingRay(pos[0], pos[1]);

            var track = null;

            // zoom with right mouse button (2), pan with left (1)
            if (that._buttonState == 2)
                track = that.translateZ(that._firstRay, pos[1]);
            else if (that._buttonState == 1)
                track = that.translateXY(ray);
            else  // middle button: 4
                track = that.rotate(pos[0], pos[1]);

            if (track) {
                if (that._gridSize > 0 && that._buttonState != 4) {
                    var x = that._gridSize * Math.round(track.x / that._gridSize);
                    var y = that._gridSize * Math.round(track.y / that._gridSize);
                    var z = that._gridSize * Math.round(track.z / that._gridSize);
                    track = new x3dom.fields.SFVec3f(x, y, z);
                }

                if (!that._matrixTrafo) {
                    if (that._buttonState == 4) {
                        that._moveable.setAttribute("rotation", track.toAxisAngle().toString());
                    }
                    else {
                        that._moveable.setAttribute("translation", track.toString());
                    }
                }
                else {
                    if (that._buttonState == 4) {
                        that._matrixTrafo.setRotate(track);
                    }
                    else {
                        that._matrixTrafo.setTranslate(track);
                    }
                    that._moveable.setAttribute("matrix", that._matrixTrafo.toGL().toString());
                }

                if (that._callback) {
                    that._callback(that._moveable, track);
                }
            }

            that._lastX = pos[0];
            that._lastY = pos[1];
        }
    }
};

// stop object movement, switch from interaction to navigation
x3dom.Moveable.prototype.stop = function(event) {
    for (var i=0, n=this._iMove.length; i<n; i++) {
        var that = this._iMove[i];

        if (that._drag) {
            that._lastX = event.layerX;
            that._lastY = event.layerY;

            that._isect = null;
            that._drag = false;

            // we're done, re-enable navigation
            var navi = that._runtime.canvas.doc._scene.getNavigationInfo();
            navi.setType(that._navType);

            that._runtime.getCanvas().style.cursor = "pointer";
        }
    }
};

// TODO: impl. special (multi-)touch event stuff
// === Touch Start (W3C) ===
x3dom.Moveable.prototype.touchStartHandler = function (evt) {
    evt.preventDefault();
};

// === Touch Start Moz (Firefox has other touch interface) ===
x3dom.Moveable.prototype.touchStartHandlerMoz = function (evt) {
    evt.preventDefault();
};

// === Touch Move ===
x3dom.Moveable.prototype.touchMoveHandler = function (evt) {
    evt.preventDefault();
};

// === Touch Move Moz ===
x3dom.Moveable.prototype.touchMoveHandlerMoz = function (evt) {
    evt.preventDefault();
};

// === Touch End ===
x3dom.Moveable.prototype.touchEndHandler = function (evt) {
    if (this._iMove.length) {
        var that = this._iMove[0];
        // mouse start code is called, but not stop
        that.stop.apply(that._x3domRoot, [evt]);
    }
    evt.preventDefault();
};

// === Touch End Moz ===
x3dom.Moveable.prototype.touchEndHandlerMoz = function (evt) {
    if (this._iMove.length) {
        var that = this._iMove[0];
        that.stop.apply(that._x3domRoot, [evt]);
    }
    evt.preventDefault();
};

/*
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 *
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 *
 * Based on code originally provided by
 * Philip Taylor: http://philip.html5.org
 */


// This module adds documentation related functionality
// to the library.

/** @namespace The x3dom.docs namespace. */
x3dom.docs = {};


x3dom.docs.specURLMap = {
    CADGeometry: "CADGeometry.html",
    Core: "core.html",
    DIS: "dis.html",
    CubeMapTexturing: "env_texture.html",
    EnvironmentalEffects: "enveffects.html",
    EnvironmentalSensor: "envsensor.html",
    Followers: "followers.html",
    Geospatial: "geodata.html",
    Geometry2D: "geometry2D.html",
    Geometry3D: "geometry3D.html",
    Grouping: "group.html",
    "H-Anim": "hanim.html",
    Interpolation: "interp.html",
    KeyDeviceSensor: "keyboard.html",
    Layering: "layering.html",
    Layout: "layout.html",
    Lighting: "lighting.html",
    Navigation: "navigation.html",
    Networking: "networking.html",
    NURBS: "nurbs.html",
    ParticleSystems: "particle_systems.html",
    Picking: "picking.html",
    PointingDeviceSensor: "pointingsensor.html",
    Rendering: "rendering.html",
    RigidBodyPhysics: "rigid_physics.html",
    Scripting: "scripting.html",
    Shaders: "shaders.html",
    Shape: "shape.html",
    Sound: "sound.html",
    Text: "text.html",
    Texturing3D: "texture3D.html",
    Texturing: "texturing.html",
    Time: "time.html",
    EventUtilities: "utils.html",
    VolumeRendering: "volume.html"
};

x3dom.docs.specBaseURL = "http://www.web3d.org/x3d/specifications/ISO-IEC-19775-1.2-X3D-AbstractSpecification/Part01/components/";


// the dump-nodetype tree functionality in a function
x3dom.docs.getNodeTreeInfo = function() {

    // Create the nodetype hierarchy
    var tn, t;
    var types = "";

    var objInArray = function(array, obj) {
        for(var i=0; i<array.length; i++) {
            if (array[i] === obj) {
                return true;
            }
        }
        return false;
    };

    var dump = function(t, indent) {
        for (var i=0; i<indent; i++) {
            types += "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
        }

        types += "<a href='" +
                        x3dom.docs.specBaseURL + x3dom.docs.specURLMap[x3dom.nodeTypes[t]._compName] + "#" + t +
                        "' style='color:black; text-decoration:none; font-weight:bold;'>" +
                        t + "</a> &nbsp; <a href='" +
                        x3dom.docs.specBaseURL + x3dom.docs.specURLMap[x3dom.nodeTypes[t]._compName] +
                        "' style='color:black; text-decoration:none; font-style:italic;'>" +
                        x3dom.nodeTypes[t]._compName + "</a><br/>";

        for (var i in x3dom.nodeTypes[t].childTypes[t]) {
            dump(x3dom.nodeTypes[t].childTypes[t][i], indent+1);
        }
    };

    for (tn in x3dom.nodeTypes) {
     var t = x3dom.nodeTypes[tn];
         if (t.childTypes === undefined) {
             t.childTypes = {};
         }

         while (t.superClass) {
             if (t.superClass.childTypes[t.superClass._typeName] === undefined) {
                 t.superClass.childTypes[t.superClass._typeName] = [];
             }
             if (!objInArray(t.superClass.childTypes[t.superClass._typeName], t._typeName)) {
                 t.superClass.childTypes[t.superClass._typeName].push(t._typeName);
             }
             t = t.superClass;
         }
     }

    dump("X3DNode", 0);

    return "<div class='x3dom-doc-nodes-tree'>" + types + "</div>";
};


x3dom.docs.getComponentInfo = function() {
    // Dump nodetypes by component
    // but first sort alphabetically
    var components = [];
    var component;
    var result = "";
    var c, cn;

    for (c in x3dom.components) {
        components.push(c);
    }
    components.sort();

    //for (var c in x3dom.components) {
    for (cn in components) {
        c = components[cn];
        component = x3dom.components[c];
        result += "<h2><a href='" +
            x3dom.docs.specBaseURL + x3dom.docs.specURLMap[c] +
            "' style='color:black; text-decoration:none; font-style:italic;'>" +
            c + "</a></h2>";

        result += "<ul style='list-style-type:circle;'>";

        //var $ul = $("#components ul:last");
        for (var t in component) {
            result += "<li><a href='" +
                x3dom.docs.specBaseURL + x3dom.docs.specURLMap[c] + "#" + t +
                    "' style='color:black; text-decoration:none; font-weight:bold;'>" +
                    t + "</a></li>";
        }
        result += "</ul>";
    }

    return result;
};


x3dom.versionInfo = {
    version:  '1.6.0-dev',
    revision: 'fa599b611f4a3dc0d32ecf6dd20fad6bf3390fee',
    date:     'Tue Dec 10 16:10:30 2013 +0100'
};


/*
 * 
 *                  xxxxxxx      xxxxxxx
 *                   x:::::x    x:::::x 
 *                    x:::::x  x:::::x  
 *                     x:::::xx:::::x   
 *                      x::::::::::x    
 *                       x::::::::x     
 *                       x::::::::x     
 *                      x::::::::::x    
 *                     x:::::xx:::::x   
 *                    x:::::x  x:::::x  
 *                   x:::::x    x:::::x 
 *              THE xxxxxxx      xxxxxxx TOOLKIT
 *                    
 *                  http://www.goXTK.com
 *                   
 * Copyright (c) 2012 The X Toolkit Developers <dev@goXTK.com>
 *                   
 *    The X Toolkit (XTK) is licensed under the MIT License:
 *      http://www.opensource.org/licenses/mit-license.php
 * 
 *      "Free software" is a matter of liberty, not price.
 *      "Free" as in "free speech", not as in "free beer".
 *                                         - Richard M. Stallman
 * 
 * FUELED BY:
 *  - the wonderful Constructive Solid Geometry library by Evan Wallace (http://madebyevan.com)
 *    LICENSE: https://raw.github.com/xtk/X/master/lib/csg/LICENSE
 *
 *  - parts of the Google Closure Library (http://code.google.com/closure/library)
 *    LICENSE: https://raw.github.com/xtk/google-closure-library/master/LICENSE
 *
 *  - zlib.js, the ultimate gzip/zlib javascript implementation (https://github.com/imaya/zlib.js)
 *    LICENSE: https://raw.github.com/imaya/zlib.js/master/LICENSE
 *
 * MORE CREDITS: https://raw.github.com/xtk/X/master/LICENSE
 *
 */
function m(a){throw a;}var p=void 0,q=!0,t=null,u=!1;function ea(){return function(){}}function fa(a){return function(b){this[a]=b}}function v(a){return function(){return this[a]}}var w,ga=this;function ha(){}
function ia(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function ja(a){return a!==p}function la(a){return"array"==ia(a)}function ma(a){var b=ia(a);return"array"==b||"object"==b&&"number"==typeof a.length}function na(a){return"string"==typeof a}function x(a){return"number"==typeof a}function oa(a){return"function"==ia(a)}function pa(a){var b=typeof a;return"object"==b&&a!=t||"function"==b}function qa(a){return a[ra]||(a[ra]=++sa)}var ra="closure_uid_"+(1E9*Math.random()>>>0),sa=0;
function ta(a,b,c){return a.call.apply(a.bind,arguments)}function ua(a,b,c){a||m(Error());if(2<arguments.length){var e=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,e);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function va(a,b,c){va=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ta:ua;return va.apply(t,arguments)}
function wa(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=Array.prototype.slice.call(arguments);b.unshift.apply(b,c);return a.apply(this,b)}}var xa=Date.now||function(){return+new Date};function B(a,b){var c=a.split("."),e=ga;!(c[0]in e)&&e.execScript&&e.execScript("var "+c[0]);for(var d;c.length&&(d=c.shift());)!c.length&&ja(b)?e[d]=b:e=e[d]?e[d]:e[d]={}}
function C(a,b){function c(){}c.prototype=b.prototype;a.z=b.prototype;a.prototype=new c;a.prototype.constructor=a};function ya(a,b,c){this.Ta=this.Sa=this.Ra=0;3==arguments.length?(this.Ra=Number(a),this.Sa=Number(b),this.Ta=Number(c)):a instanceof ya?(this.Ra=Number(a.x()),this.Sa=Number(a.y()),this.Ta=Number(a.d())):(this.Ra=Number(a[0]),this.Sa=Number(a[1]),this.Ta=Number(a[2]))}
ya.prototype={l:function(){return new ya(this.Ra,this.Sa,this.Ta)},Xb:function(a){return this.Ra*a.x()+this.Sa*a.y()+this.Ta*a.d()},ke:function(a,b){return Aa(this,Ba(Ca(a,this),b))},length:function(){return Math.sqrt(this.Xb(this))},ic:function(a){return new ya(this.Sa*a.d()-this.Ta*a.y(),this.Ta*a.x()-this.Ra*a.d(),this.Ra*a.y()-this.Sa*a.x())},x:v("Ra"),y:v("Sa"),d:v("Ta")};function Da(a){var b=a.length();return new ya(a.Ra/b,a.Sa/b,a.Ta/b)}
function Ba(a,b){return new ya(a.Ra*b,a.Sa*b,a.Ta*b)}function Ca(a,b){return new ya(a.Ra-b.x(),a.Sa-b.y(),a.Ta-b.d())}function Aa(a,b){return new ya(a.Ra+b.x(),a.Sa+b.y(),a.Ta+b.d())}function Fa(a){return new ya(-a.Ra,-a.Sa,-a.Ta)};var D=D||{};D.Nj=q;D.Ya=function(a){eval("X.DEV === undefined")||window.console.time(a)};D.Ua=function(a){eval("X.DEV === undefined")||window.console.timeEnd(a)};window["X.counter"]=new function(){this.Eh=0;this.Jj=function(){return this.Eh++}};function Ga(a,b){for(var c in b){var e=b.__lookupGetter__(c),d=b.__lookupSetter__(c);c in a||(e||d?(e&&a.__defineGetter__(c,e),d&&a.__defineSetter__(c,d)):a[c]=b[c])}}var Ha=window.th;
Function.prototype.bind||(Function.prototype.bind=function(a){function b(){return f.apply(this instanceof c?this:a||window,d.concat(e.call(arguments)))}function c(){}"function"!==typeof this&&m(new TypeError("Function.prototype.bind - what is trying to be bound is not callable"));var e=Array.prototype.slice,d=e.call(arguments,1),f=this;c.prototype=this.prototype;b.prototype=new c;return b});
for(var Ia=0,Ja=["ms","moz","webkit","o"],Ka=0;Ka<Ja.length&&!window.requestAnimationFrame;++Ka)window.requestAnimationFrame=window[Ja[Ka]+"RequestAnimationFrame"],window.cancelAnimationFrame=window[Ja[Ka]+"CancelAnimationFrame"]||window[Ja[Ka]+"CancelRequestAnimationFrame"];window.requestAnimationFrame||(window.requestAnimationFrame=function(a){var b=Date.now(),c=Math.max(0,16-(b-Ia)),e=window.setTimeout(function(){a(b+c)},c);Ia=b+c;return e});
window.cancelAnimationFrame||(window.cancelAnimationFrame=function(a){clearTimeout(a)});
"slice"in ArrayBuffer.prototype||(ArrayBuffer.prototype.slice=function(a,b){a===p&&m(Error("Not enough arguments."));var c=b||this.byteLength;0>a&&(a=this.byteLength+a);0>c&&(c=this.byteLength+c);c<a&&(c=a=0);0>a&&(a=0);0>c&&(c=0);a>this.byteLength&&(a=this.byteLength);c>this.byteLength&&(c=this.byteLength);for(var e=new ArrayBuffer(c-a),d=new Uint8Array(this),f=new Uint8Array(e),g=a,h=0;g<c;++g,++h)f[h]=d[g];return e});B("$",Ha);B("Function.prototype.bind",Function.prototype.bind);
B("window.requestAnimationFrame",window.requestAnimationFrame);B("window.cancelAnimationFrame",window.cancelAnimationFrame);var La=0;function Ma(){}w=Ma.prototype;w.key=0;w.mc=u;w.Zd=u;w.wa=function(a,b,c,e,d,f){oa(a)?this.Jg=q:a&&a.handleEvent&&oa(a.handleEvent)?this.Jg=u:m(Error("Invalid listener argument"));this.Yb=a;this.$g=b;this.src=c;this.type=e;this.capture=!!d;this.gf=f;this.Zd=u;this.key=++La;this.mc=u};w.handleEvent=function(a){return this.Jg?this.Yb.call(this.gf||this.src,a):this.Yb.handleEvent.call(this.Yb,a)};function Na(a,b){for(var c in a)b.call(p,a[c],c,a)}function Oa(a){var b=[],c=0,e;for(e in a)b[c++]=a[e];return b}var Pa="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function Ra(a,b){for(var c,e,d=1;d<arguments.length;d++){e=arguments[d];for(c in e)a[c]=e[c];for(var f=0;f<Pa.length;f++)c=Pa[f],Object.prototype.hasOwnProperty.call(e,c)&&(a[c]=e[c])}};function Sa(a){if(!Ta.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(Ua,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(Va,"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(Wa,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(Xa,"&quot;"));return a}var Ua=/&/g,Va=/</g,Wa=/>/g,Xa=/\"/g,Ta=/[&<>\"]/;var Ya,Za,$a,ab,bb,cb,eb;function fb(){return ga.navigator?ga.navigator.userAgent:t}function gb(){return ga.navigator}ab=$a=Za=Ya=u;var hb;if(hb=fb()){var ib=gb();Ya=0==hb.indexOf("Opera");Za=!Ya&&-1!=hb.indexOf("MSIE");$a=!Ya&&-1!=hb.indexOf("WebKit");ab=!Ya&&!$a&&"Gecko"==ib.product}var jb=Ya,J=Za,lb=ab,mb=$a,ob,pb=gb();ob=pb&&pb.platform||"";bb=-1!=ob.indexOf("Mac");cb=-1!=ob.indexOf("Win");eb=-1!=ob.indexOf("Linux");var qb=!!gb()&&-1!=(gb().appVersion||"").indexOf("X11");
function rb(){var a=ga.document;return a?a.documentMode:p}var vb;a:{var wb="",xb;if(jb&&ga.opera)var yb=ga.opera.version,wb="function"==typeof yb?yb():yb;else if(lb?xb=/rv\:([^\);]+)(\)|;)/:J?xb=/MSIE\s+([^\);]+)(\)|;)/:mb&&(xb=/WebKit\/(\S+)/),xb)var zb=xb.exec(fb()),wb=zb?zb[1]:"";if(J){var Ab=rb();if(Ab>parseFloat(wb)){vb=String(Ab);break a}}vb=wb}var Bb={};
function Cb(a){var b;if(!(b=Bb[a])){b=0;for(var c=String(vb).replace(/^[\s\xa0]+|[\s\xa0]+$/g,"").split("."),e=String(a).replace(/^[\s\xa0]+|[\s\xa0]+$/g,"").split("."),d=Math.max(c.length,e.length),f=0;0==b&&f<d;f++){var g=c[f]||"",h=e[f]||"",l=RegExp("(\\d*)(\\D*)","g"),j=RegExp("(\\d*)(\\D*)","g");do{var k=l.exec(g)||["","",""],n=j.exec(h)||["","",""];if(0==k[0].length&&0==n[0].length)break;b=((0==k[1].length?0:parseInt(k[1],10))<(0==n[1].length?0:parseInt(n[1],10))?-1:(0==k[1].length?0:parseInt(k[1],
10))>(0==n[1].length?0:parseInt(n[1],10))?1:0)||((0==k[2].length)<(0==n[2].length)?-1:(0==k[2].length)>(0==n[2].length)?1:0)||(k[2]<n[2]?-1:k[2]>n[2]?1:0)}while(0==b)}b=Bb[a]=0<=b}return b}var Db=ga.document,Eb=!Db||!J?p:rb()||("CSS1Compat"==Db.compatMode?parseInt(vb,10):5);var Fb=!J||J&&9<=Eb,Gb=J&&!Cb("9");!mb||Cb("528");lb&&Cb("1.9b")||J&&Cb("8")||jb&&Cb("9.5")||mb&&Cb("528");lb&&!Cb("8")||J&&Cb("9");var Hb=Array.prototype,Ib=Hb.indexOf?function(a,b,c){return Hb.indexOf.call(a,b,c)}:function(a,b,c){c=c==t?0:0>c?Math.max(0,a.length+c):c;if(na(a))return!na(b)||1!=b.length?-1:a.indexOf(b,c);for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},Jb=Hb.forEach?function(a,b,c){Hb.forEach.call(a,b,c)}:function(a,b,c){for(var e=a.length,d=na(a)?a.split(""):a,f=0;f<e;f++)f in d&&b.call(c,d[f],f,a)},Lb=Hb.map?function(a,b,c){return Hb.map.call(a,b,c)}:function(a,b,c){for(var e=a.length,d=Array(e),f=
na(a)?a.split(""):a,g=0;g<e;g++)g in f&&(d[g]=b.call(c,f[g],g,a));return d},Mb=Hb.some?function(a,b,c){return Hb.some.call(a,b,c)}:function(a,b,c){for(var e=a.length,d=na(a)?a.split(""):a,f=0;f<e;f++)if(f in d&&b.call(c,d[f],f,a))return q;return u};function Nb(a,b){var c=Ib(a,b);0<=c&&Hb.splice.call(a,c,1)}function Ob(a,b,c){return 2>=arguments.length?Hb.slice.call(a,b):Hb.slice.call(a,b,c)};function Pb(){0!=Qb&&(this.Lk=Error().stack,qa(this))}var Qb=0;function Rb(a,b){this.type=a;this.currentTarget=this.target=b}w=Rb.prototype;w.lc=u;w.defaultPrevented=u;w.oe=q;w.stopPropagation=function(){this.lc=q};w.preventDefault=function(){this.defaultPrevented=q;this.oe=u};function Sb(a){Sb[" "](a);return a}Sb[" "]=ha;function Tb(a,b){a&&this.wa(a,b)}C(Tb,Rb);w=Tb.prototype;w.target=t;w.relatedTarget=t;w.offsetX=0;w.offsetY=0;w.clientX=0;w.clientY=0;w.screenX=0;w.screenY=0;w.button=0;w.keyCode=0;w.charCode=0;w.ctrlKey=u;w.altKey=u;w.shiftKey=u;w.metaKey=u;w.pj=u;w.jb=t;
w.wa=function(a,b){var c=this.type=a.type;Rb.call(this,c);this.target=a.target||a.srcElement;this.currentTarget=b;var e=a.relatedTarget;if(e){if(lb){var d;a:{try{Sb(e.nodeName);d=q;break a}catch(f){}d=u}d||(e=t)}}else"mouseover"==c?e=a.fromElement:"mouseout"==c&&(e=a.toElement);this.relatedTarget=e;this.offsetX=mb||a.offsetX!==p?a.offsetX:a.layerX;this.offsetY=mb||a.offsetY!==p?a.offsetY:a.layerY;this.clientX=a.clientX!==p?a.clientX:a.pageX;this.clientY=a.clientY!==p?a.clientY:a.pageY;this.screenX=
a.screenX||0;this.screenY=a.screenY||0;this.button=a.button;this.keyCode=a.keyCode||0;this.charCode=a.charCode||("keypress"==c?a.keyCode:0);this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;this.metaKey=a.metaKey;this.pj=bb?a.metaKey:a.ctrlKey;this.state=a.state;this.jb=a;a.defaultPrevented&&this.preventDefault();delete this.lc};w.stopPropagation=function(){Tb.z.stopPropagation.call(this);this.jb.stopPropagation?this.jb.stopPropagation():this.jb.cancelBubble=q};
w.preventDefault=function(){Tb.z.preventDefault.call(this);var a=this.jb;if(a.preventDefault)a.preventDefault();else if(a.returnValue=u,Gb)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};w.ki=v("jb");var Ub={},Vb={},Wb={},Xb={};function L(a,b,c,e,d){if(la(b)){for(var f=0;f<b.length;f++)L(a,b[f],c,e,d);return t}a=Yb(a,b,c,u,e,d);b=a.key;Ub[b]=a;return b}
function Yb(a,b,c,e,d,f){b||m(Error("Invalid event type"));d=!!d;var g=Vb;b in g||(g[b]={ja:0,Ia:0});g=g[b];d in g||(g[d]={ja:0,Ia:0},g.ja++);var g=g[d],h=qa(a),l;g.Ia++;if(g[h]){l=g[h];for(var j=0;j<l.length;j++)if(g=l[j],g.Yb==c&&g.gf==f){if(g.mc)break;e||(l[j].Zd=u);return l[j]}}else l=g[h]=[],g.ja++;var k=Zb,n=Fb?function(a){return k.call(n.src,n.Yb,a)}:function(a){a=k.call(n.src,n.Yb,a);if(!a)return a},j=n,g=new Ma;g.wa(c,j,a,b,d,f);g.Zd=e;j.src=a;j.Yb=g;l.push(g);Wb[h]||(Wb[h]=[]);Wb[h].push(g);
a.addEventListener?(a==ga||!a.customEvent_)&&a.addEventListener(b,j,d):a.attachEvent(b in Xb?Xb[b]:Xb[b]="on"+b,j);return g}function $b(a,b,c,e,d){if(la(b))for(var f=0;f<b.length;f++)$b(a,b[f],c,e,d);else a=Yb(a,b,c,q,e,d),Ub[a.key]=a}function ac(a,b,c,e,d){if(la(b))for(var f=0;f<b.length;f++)ac(a,b[f],c,e,d);else{e=!!e;a:{f=Vb;if(b in f&&(f=f[b],e in f&&(f=f[e],a=qa(a),f[a]))){a=f[a];break a}a=t}if(a)for(f=0;f<a.length;f++)if(a[f].Yb==c&&a[f].capture==e&&a[f].gf==d){bc(a[f].key);break}}}
function bc(a){var b=Ub[a];if(!b||b.mc)return u;var c=b.src,e=b.type,d=b.$g,f=b.capture;c.removeEventListener?(c==ga||!c.customEvent_)&&c.removeEventListener(e,d,f):c.detachEvent&&c.detachEvent(e in Xb?Xb[e]:Xb[e]="on"+e,d);c=qa(c);Wb[c]&&(d=Wb[c],Nb(d,b),0==d.length&&delete Wb[c]);b.mc=q;if(b=Vb[e][f][c])b.Rg=q,cc(e,f,c,b);delete Ub[a];return q}
function cc(a,b,c,e){if(!e.le&&e.Rg){for(var d=0,f=0;d<e.length;d++)e[d].mc?e[d].$g.src=t:(d!=f&&(e[f]=e[d]),f++);e.length=f;e.Rg=u;0==f&&(delete Vb[a][b][c],Vb[a][b].ja--,0==Vb[a][b].ja&&(delete Vb[a][b],Vb[a].ja--),0==Vb[a].ja&&delete Vb[a])}}function dc(a,b){var c=qa(a),e=Wb[c];if(e){var d=ja(b),f=ja(p);return d&&f?(e=Vb[b],!!e&&!!e[p]&&c in e[p]):!d&&!f?q:Mb(e,function(a){return d&&a.type==b||f&&a.capture==p})}return u}
function ec(a,b,c,e,d){var f=1;b=qa(b);if(a[b]){var g=--a.Ia,h=a[b];h.le?h.le++:h.le=1;try{for(var l=h.length,j=0;j<l;j++){var k=h[j];k&&!k.mc&&(f&=fc(k,d)!==u)}}finally{a.Ia=Math.max(g,a.Ia),h.le--,cc(c,e,b,h)}}return Boolean(f)}function fc(a,b){a.Zd&&bc(a.key);return a.handleEvent(b)}
function Zb(a,b){if(a.mc)return q;var c=a.type,e=Vb;if(!(c in e))return q;var e=e[c],d,f;if(!Fb){var g;if(!(g=b))a:{g=["window","event"];for(var h=ga;d=g.shift();)if(h[d]!=t)h=h[d];else{g=t;break a}g=h}d=g;g=q in e;h=u in e;if(g){if(0>d.keyCode||d.returnValue!=p)return q;a:{var l=u;if(0==d.keyCode)try{d.keyCode=-1;break a}catch(j){l=q}if(l||d.returnValue==p)d.returnValue=q}}l=new Tb;l.wa(d,this);d=q;try{if(g){for(var k=[],n=l.currentTarget;n;n=n.parentNode)k.push(n);f=e[q];f.Ia=f.ja;for(var r=k.length-
1;!l.lc&&0<=r&&f.Ia;r--)l.currentTarget=k[r],d&=ec(f,k[r],c,q,l);if(h){f=e[u];f.Ia=f.ja;for(r=0;!l.lc&&r<k.length&&f.Ia;r++)l.currentTarget=k[r],d&=ec(f,k[r],c,u,l)}}else d=fc(a,l)}finally{k&&(k.length=0)}return d}c=new Tb(b,this);return d=fc(a,c)}var gc=0;function hc(a){return a+"_"+gc++};function ic(){Pb.call(this);this.Pk={};this.Jk=this}C(ic,Pb);ic.prototype.customEvent_=q;w=ic.prototype;w.Af=t;w.Ff=fa("Af");w.addEventListener=function(a,b,c,e){L(this,a,b,c,e)};w.removeEventListener=function(a,b,c,e){ac(this,a,b,c,e)};
w.dispatchEvent=function(a){var b=a.type||a,c=Vb;if(b in c){if(na(a))a=new Rb(a,this);else if(a instanceof Rb)a.target=a.target||this;else{var e=a;a=new Rb(b,this);Ra(a,e)}var e=1,d,c=c[b],b=q in c,f;if(b){d=[];for(f=this;f;f=f.Af)d.push(f);f=c[q];f.Ia=f.ja;for(var g=d.length-1;!a.lc&&0<=g&&f.Ia;g--)a.currentTarget=d[g],e&=ec(f,d[g],a.type,q,a)&&a.oe!=u}if(u in c)if(f=c[u],f.Ia=f.ja,b)for(g=0;!a.lc&&g<d.length&&f.Ia;g++)a.currentTarget=d[g],e&=ec(f,d[g],a.type,u,a)&&a.oe!=u;else for(d=this;!a.lc&&
d&&f.Ia;d=d.Af)a.currentTarget=d,e&=ec(f,d,a.type,u,a)&&a.oe!=u;a=Boolean(e)}else a=q;return a};function O(){ic.call(this);this.g="base";this.ta=window["X.counter"].Jj();this.j=u}C(O,ic);O.prototype.__defineGetter__("classname",v("g"));O.prototype.__defineGetter__("id",v("ta"));B("X.base",O);function jc(a,b){this.Qa=new ya(a);this.ra=new ya(b)}jc.prototype={l:function(){return new jc(this.Qa.l(),this.ra.l())},kc:function(){this.ra=Fa(this.ra)}};function kc(a,b){this.ra=a;this.Cd=b}kc.prototype={l:function(){return new kc(this.ra.l(),this.Cd)},kc:function(){this.ra=Fa(this.ra);this.Cd=-this.Cd}};function lc(a,b){this.Eb=a;this.ue=b;var c=a[0].Qa,e=a[2].Qa,e=Da(Ca(a[1].Qa,c).ic(Ca(e,c)));this.Pa=new kc(e,e.Xb(c))}lc.prototype={l:function(){var a=this.Eb.map(function(a){return a.l()});return new lc(a,this.ue)},kc:function(){this.Eb.reverse().map(function(a){a.kc()});this.Pa.kc()}};
function mc(a,b,c,e,d,f){for(var g=0,h=[],l=0;l<a.Eb.length;l++){var j=b.ra.Xb(a.Eb[l].Qa)-b.Cd,j=-1E-5>j?2:1E-5<j?1:0,g=g|j;h.push(j)}switch(g){case 0:(0<b.ra.Xb(a.Pa.ra)?c:e).push(a);break;case 1:d.push(a);break;case 2:f.push(a);break;case 3:c=[];e=[];for(l=0;l<a.Eb.length;l++){var k=(l+1)%a.Eb.length,j=h[l],n=h[k],g=a.Eb[l],k=a.Eb[k];2!=j&&c.push(g);1!=j&&e.push(2!=j?g.l():g);3==(j|n)&&(j=(b.Cd-b.ra.Xb(g.Qa))/b.ra.Xb(Ca(k.Qa,g.Qa)),j=new jc(g.Qa.ke(k.Qa,j),g.ra.ke(k.ra,j)),c.push(j),e.push(j.l()))}3<=
c.length&&d.push(new lc(c,a.ue));3<=e.length&&f.push(new lc(e,a.ue))}};function nc(a){this.ua=this.va=this.Pa=t;this.V=[];a&&oc(this,a)}nc.prototype={l:function(){var a=new nc,b=this.Pa&&this.Pa.l();a.Pa=b;b=this.va&&this.va.l();a.va=b;b=this.ua&&this.ua.l();a.ua=b;a.te(this.V.map(function(a){return a.l()}));return a},U:function(){for(var a=0;a<this.V.length;a++)this.V[a].kc();this.Pa.kc();this.va&&this.va.U();this.ua&&this.ua.U();a=this.va;this.va=this.ua;this.ua=a},te:fa("V")};
function oc(a,b){if(b.length){a.Pa||(a.Pa=b[0].Pa.l());for(var c=[],e=[],d=0;d<b.length;d++)mc(b[d],a.Pa,a.V,a.V,c,e);c.length&&(a.va||(a.va=new nc),oc(a.va,c));e.length&&(a.ua||(a.ua=new nc),oc(a.ua,e))}}function pc(a){var b=a.V.slice();a.va&&(b=b.concat(pc(a.va)));a.ua&&(b=b.concat(pc(a.ua)));return b}function qc(a,b){a.V=rc(b,a.V);a.va&&qc(a.va,b);a.ua&&qc(a.ua,b)}
function rc(a,b){if(!a.Pa)return b.slice();for(var c=[],e=[],d=0;d<b.length;d++)mc(b[d],a.Pa,c,e,c,e);a.va&&(c=rc(a.va,c));e=a.ua?rc(a.ua,e):[];return c.concat(e)};function sc(){this.V=[]}function tc(a){var b=new sc;b.te(a);return b}
sc.prototype={l:function(){var a=new sc;a.te(this.V.map(function(a){return a.l()}));return a},Mf:function(a){var b=new nc(this.l().V);a=new nc(a.l().V);qc(b,a);qc(a,b);a.U();qc(a,b);a.U();oc(b,pc(a));return tc(pc(b))},Ea:function(a){var b=new nc(this.l().V);a=new nc(a.l().V);b.U();qc(b,a);qc(a,b);a.U();qc(a,b);a.U();oc(b,pc(a));b.U();return tc(pc(b))},jf:function(a){var b=new nc(this.l().V);a=new nc(a.l().V);b.U();qc(a,b);a.U();qc(b,a);qc(a,b);oc(b,pc(a));b.U();return tc(pc(b))},inverse:function(){var a=
this.l();a.V.map(function(a){a.kc()});return a},te:fa("V")};function uc(){O.call(this);this.g="indexer";this.Se=[];this.Ek=[];this.Fa={}}C(uc,O);uc.prototype.add=function(a){a==t&&m(Error("Invalid object."));var b=window.JSON.stringify(a);b in this.Fa||(this.Fa[b]=this.Se.length,this.Se.push(a));return this.Fa[b]};uc.prototype.unique=v("Se");function vc(a){O.call(this);this.g="file";this.Sd=a;this.j=q}C(vc,O);function wc(){this.mb=this.r=t}wc.prototype.__defineSetter__("file",function(a){if(a==t||la(a)&&0==a.length)this.r=t;else{if(la(a)){if(1==a.length){this.r=new vc(a[0]);return}this.r=Lb(a,function(a){var c=new Q;c.r=new vc(a);return c})}else this.r=new vc(a);this.mb=t}});wc.prototype.__defineGetter__("file",function(){return!this.r?"":la(this.r)?this.r.map(function(a){return a.r.Sd}):this.r.Sd});
wc.prototype.__defineGetter__("filedata",function(){return la(this.r)?this.r.map(function(a){return a.mb}):this.mb});wc.prototype.__defineSetter__("filedata",function(a){if(a==t||la(a)&&0==a.length)this.mb=t;if(la(a))if(1==a.length)this.mb=a[0];else{var b=this.r.length,c;for(c=0;c<b;c++)this.r[c].mb=a[c]}else this.mb=a});function xc(a){if("function"==typeof a.sd)return a.sd();if(na(a))return a.split("");if(ma(a)){for(var b=[],c=a.length,e=0;e<c;e++)b.push(a[e]);return b}return Oa(a)};function yc(a,b){this.$={};this.Q=[];var c=arguments.length;if(1<c){c%2&&m(Error("Uneven number of arguments"));for(var e=0;e<c;e+=2)this.set(arguments[e],arguments[e+1])}else a&&this.Ue(a)}w=yc.prototype;w.ja=0;w.Of=0;w.ee=v("ja");w.sd=function(){zc(this);for(var a=[],b=0;b<this.Q.length;b++)a.push(this.$[this.Q[b]]);return a};function Ac(a){for(var b=0;b<a.Q.length;b++){var c=a.Q[b];if(Bc(a.$,c)&&a.$[c]==u)return q}return u}w.clear=function(){this.$={};this.Of=this.ja=this.Q.length=0};
w.remove=function(a){return Bc(this.$,a)?(delete this.$[a],this.ja--,this.Of++,this.Q.length>2*this.ja&&zc(this),q):u};function zc(a){if(a.ja!=a.Q.length){for(var b=0,c=0;b<a.Q.length;){var e=a.Q[b];Bc(a.$,e)&&(a.Q[c++]=e);b++}a.Q.length=c}if(a.ja!=a.Q.length){for(var d={},c=b=0;b<a.Q.length;)e=a.Q[b],Bc(d,e)||(a.Q[c++]=e,d[e]=1),b++;a.Q.length=c}}w.get=function(a,b){return Bc(this.$,a)?this.$[a]:b};w.set=function(a,b){Bc(this.$,a)||(this.ja++,this.Q.push(a),this.Of++);this.$[a]=b};
w.Ue=function(a){var b;if(a instanceof yc)zc(a),b=a.Q.concat(),a=a.sd();else{b=[];var c=0,e;for(e in a)b[c++]=e;a=Oa(a)}for(c=0;c<b.length;c++)this.set(b[c],a[c])};w.l=function(){return new yc(this)};w.Lf=function(){for(var a=new yc,b=0;b<this.Q.length;b++){var c=this.Q[b];a.set(this.$[c],c)}return a};function Bc(a,b){return Object.prototype.hasOwnProperty.call(a,b)};function Cc(){O.call(this);this.g="colortable";this.Fa=new yc;Ga(this,new wc)}C(Cc,O);Cc.prototype.add=function(a,b,c,e,d,f){(!x(a)||!x(c)||!x(e)||!x(d)||!x(f))&&m(Error("Invalid color table entry."));this.Fa.set(a,[b,c,e,d,f]);this.j=q};Cc.prototype.get=function(a){return this.Fa.get(a)};B("X.colortable.prototype.get",Cc.prototype.get);function Dc(a,b,c){this.x=ja(a)?a:0;this.y=ja(b)?b:0;this.d=ja(c)?c:0}Dc.prototype.l=function(){return new Dc(this.x,this.y,this.d)};function U(a,b,c){this.x=a;this.y=b;this.d=c}C(U,Dc);w=U.prototype;w.l=function(){return new U(this.x,this.y,this.d)};w.Bb=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.d*this.d)};w.scale=function(a){this.x*=a;this.y*=a;this.d*=a;return this};w.U=function(){this.x=-this.x;this.y=-this.y;this.d=-this.d;return this};w.normalize=function(){return this.scale(1/this.Bb())};w.add=function(a){this.x+=a.x;this.y+=a.y;this.d+=a.d;return this};
w.Ea=function(a){this.x-=a.x;this.y-=a.y;this.d-=a.d;return this};function Ec(a,b){var c=a.x-b.x,e=a.y-b.y,d=a.d-b.d;return Math.sqrt(c*c+e*e+d*d)}function Fc(a,b){var c=a.x-b.x,e=a.y-b.y,d=a.d-b.d;return c*c+e*e+d*d}function Gc(a,b){return new U(a.x+b.x,a.y+b.y,a.d+b.d)}function Hc(a,b){return new U(a.y*b.d-a.d*b.y,a.d*b.x-a.x*b.d,a.x*b.y-a.y*b.x)};D.m=U;w=D.m.prototype;w.l=U.prototype.l;w.Bb=U.prototype.Bb;w.scale=U.prototype.scale;w.U=U.prototype.U;w.add=U.prototype.add;w.Ea=U.prototype.Ea;w.normalize=function(){var a=this.Bb();return 0==a?this.scale(0):this.scale(1/a)};D.m.Xb=function(a,b){return a.x*b.x+a.y*b.y+a.d*b.d};D.m.ic=Hc;D.m.ff=Ec;D.m.ke=function(a,b,c){return new U(a.x+c*(b.x-a.x),a.y+c*(b.y-a.y),a.d+c*(b.d-a.d))};D.m.prototype.__defineGetter__("xx",v("x"));D.m.prototype.__defineGetter__("yy",v("y"));
D.m.prototype.__defineGetter__("zz",v("d"));B("X.vector",D.m);B("X.vector.prototype.clone",D.m.prototype.l);B("X.vector.prototype.magnitude",D.m.prototype.Bb);B("X.vector.prototype.scale",D.m.prototype.scale);B("X.vector.prototype.invert",D.m.prototype.U);B("X.vector.prototype.normalize",D.m.prototype.normalize);B("X.vector.prototype.add",D.m.prototype.add);B("X.vector.prototype.subtract",D.m.prototype.Ea);B("X.vector.dot",D.m.Xb);B("X.vector.cross",D.m.ic);B("X.vector.distance",D.m.ff);
B("X.vector.lerp",D.m.ke);function Ic(a){this.length=a.length||a;for(var b=0;b<this.length;b++)this[b]=a[b]||0}Ic.prototype.BYTES_PER_ELEMENT=8;Ic.prototype.set=function(a,b){b=b||0;for(var c=0;c<a.length&&b+c<this.length;c++)this[b+c]=a[c]};Ic.prototype.toString=Array.prototype.join;if("undefined"==typeof Float64Array){try{Ic.BYTES_PER_ELEMENT=8}catch(Jc){}Ic.prototype.BYTES_PER_ELEMENT=Ic.prototype.BYTES_PER_ELEMENT;Ic.prototype.set=Ic.prototype.set;Ic.prototype.toString=Ic.prototype.toString;B("Float64Array",Ic)};function Kc(a){this.length=a.length||a;for(var b=0;b<this.length;b++)this[b]=a[b]||0}Kc.prototype.BYTES_PER_ELEMENT=4;Kc.prototype.set=function(a,b){b=b||0;for(var c=0;c<a.length&&b+c<this.length;c++)this[b+c]=a[c]};Kc.prototype.toString=Array.prototype.join;"undefined"==typeof Float32Array&&(Kc.BYTES_PER_ELEMENT=4,Kc.prototype.BYTES_PER_ELEMENT=Kc.prototype.BYTES_PER_ELEMENT,Kc.prototype.set=Kc.prototype.set,Kc.prototype.toString=Kc.prototype.toString,B("Float32Array",Kc));function Lc(){return new Float32Array(3)}function Mc(a,b,c){var e=Lc();e[0]=a;e[1]=b;e[2]=c;return e}function Nc(a,b){var c=a[0],e=a[1],d=a[2],c=1/Math.sqrt(c*c+e*e+d*d);b[0]=a[0]*c;b[1]=a[1]*c;b[2]=a[2]*c};function Oc(){return new Float32Array(4)}function Pc(a,b,c,e){var d=Oc();d[0]=a;d[1]=b;d[2]=c;d[3]=e;return d};function Qc(){return new Float32Array(16)}function Rc(){var a=Qc();a[0]=a[5]=a[10]=a[15]=1;return a}function Sc(a,b,c,e,d,f,g,h,l,j,k,n,r,s,z,y,E){a[0]=b;a[1]=c;a[2]=e;a[3]=d;a[4]=f;a[5]=g;a[6]=h;a[7]=l;a[8]=j;a[9]=k;a[10]=n;a[11]=r;a[12]=s;a[13]=z;a[14]=y;a[15]=E;return a}function Uc(a,b,c){b*=4;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3]}function Vc(a,b,c){b*=4;c[0]=a[b];c[1]=a[b+1];c[2]=a[b+2];c[3]=a[b+3]}function V(a,b,c,e,d,f){a[b]=c;a[b+4]=e;a[b+8]=d;a[b+12]=f}
function Wc(a,b,c){a[b]=c[0];a[b+4]=c[1];a[b+8]=c[2];a[b+12]=c[3]}function Xc(a,b,c){c[0]=a[b];c[1]=a[b+4];c[2]=a[b+8];c[3]=a[b+12]}
function Yc(a,b,c){var e=a[0],d=a[1],f=a[2],g=a[3],h=a[4],l=a[5],j=a[6],k=a[7],n=a[8],r=a[9],s=a[10],z=a[11],y=a[12],E=a[13],F=a[14];a=a[15];var K=b[0],A=b[1],G=b[2],I=b[3],H=b[4],R=b[5],N=b[6],S=b[7],ba=b[8],aa=b[9],ca=b[10],M=b[11],T=b[12],P=b[13],Ea=b[14];b=b[15];c[0]=e*K+h*A+n*G+y*I;c[1]=d*K+l*A+r*G+E*I;c[2]=f*K+j*A+s*G+F*I;c[3]=g*K+k*A+z*G+a*I;c[4]=e*H+h*R+n*N+y*S;c[5]=d*H+l*R+r*N+E*S;c[6]=f*H+j*R+s*N+F*S;c[7]=g*H+k*R+z*N+a*S;c[8]=e*ba+h*aa+n*ca+y*M;c[9]=d*ba+l*aa+r*ca+E*M;c[10]=f*ba+j*aa+s*
ca+F*M;c[11]=g*ba+k*aa+z*ca+a*M;c[12]=e*T+h*P+n*Ea+y*b;c[13]=d*T+l*P+r*Ea+E*b;c[14]=f*T+j*P+s*Ea+F*b;c[15]=g*T+k*P+z*Ea+a*b;return c}
function Zc(a,b){var c=a[0],e=a[1],d=a[2],f=a[3],g=a[4],h=a[5],l=a[6],j=a[7],k=a[8],n=a[9],r=a[10],s=a[11],z=a[12],y=a[13],E=a[14],F=a[15],K=c*h-e*g,A=c*l-d*g,G=c*j-f*g,I=e*l-d*h,H=e*j-f*h,R=d*j-f*l,N=k*y-n*z,S=k*E-r*z,ba=k*F-s*z,aa=n*E-r*y,ca=n*F-s*y,M=r*F-s*E,T=K*M-A*ca+G*aa+I*ba-H*S+R*N;if(0==T)return u;T=1/T;b[0]=(h*M-l*ca+j*aa)*T;b[1]=(-e*M+d*ca-f*aa)*T;b[2]=(y*R-E*H+F*I)*T;b[3]=(-n*R+r*H-s*I)*T;b[4]=(-g*M+l*ba-j*S)*T;b[5]=(c*M-d*ba+f*S)*T;b[6]=(-z*R+E*G-F*A)*T;b[7]=(k*R-r*G+s*A)*T;b[8]=(g*ca-
h*ba+j*N)*T;b[9]=(-c*ca+e*ba-f*N)*T;b[10]=(z*H-y*G+F*K)*T;b[11]=(-k*H+n*G-s*K)*T;b[12]=(-g*aa+h*S-l*N)*T;b[13]=(c*aa-e*S+d*N)*T;b[14]=(-z*I+y*A-E*K)*T;b[15]=(k*I-n*A+r*K)*T;return q}function $c(a,b,c){var e=b[0],d=b[1];b=b[2];c[0]=e*a[0]+d*a[4]+b*a[8]+a[12];c[1]=e*a[1]+d*a[5]+b*a[9]+a[13];c[2]=e*a[2]+d*a[6]+b*a[10]+a[14]}
function ad(a,b,c){var e=b[0],d=b[1],f=b[2];b=b[3];c[0]=e*a[0]+d*a[4]+f*a[8]+b*a[12];c[1]=e*a[1]+d*a[5]+f*a[9]+b*a[13];c[2]=e*a[2]+d*a[6]+f*a[10]+b*a[14];c[3]=e*a[3]+d*a[7]+f*a[11]+b*a[15];return c}function bd(a,b,c,e){var d=a[1]*b+a[5]*c+a[9]*e+a[13],f=a[2]*b+a[6]*c+a[10]*e+a[14],g=a[3]*b+a[7]*c+a[11]*e+a[15];a[12]=a[0]*b+a[4]*c+a[8]*e+a[12];a[13]=d;a[14]=f;a[15]=g;return a}new Float64Array(3);new Float64Array(3);new Float64Array(4);new Float64Array(4);new Float64Array(4);new Float64Array(16);D.f={};D.f.Mg=function(a,b,c,e){c=c.Ea(b);c.normalize();e=D.m.ic(c,e);e.normalize();var d=D.m.ic(e,c);d.normalize();c.U();V(a,0,e.x,e.y,e.d,0);V(a,1,d.x,d.y,d.d,0);V(a,2,c.x,c.y,c.d,0);bd(a,-b.x,-b.y,-b.d);return a};D.f.X=function(a,b,c,e){var d=1/(b*a[3]+c*a[7]+e*a[11]+a[15]);return new D.m((b*a[0]+c*a[4]+e*a[8]+a[12])*d,(b*a[1]+c*a[5]+e*a[9]+a[13])*d,(b*a[2]+c*a[6]+e*a[10]+a[14])*d)};D.f.Hj=function(a,b,c){var e=new Float32Array(4),d=new Float32Array(4);Xc(a,b,e);Xc(a,c,d);Wc(a,b,d);Wc(a,c,e);return a};
D.f.Gj=function(a,b,c){var e=new Float32Array(4),d=new Float32Array(4);Vc(a,b,e);Vc(a,c,d);Uc(a,b,d);Uc(a,c,e);return a};D.f.td=Rc;D.f.l=function(a){var b=Qc();b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b};
D.f.Lf=function(a,b){if(b==a){var c=a[1],e=a[2],d=a[3],f=a[6],g=a[7],h=a[11];b[1]=a[4];b[2]=a[8];b[3]=a[12];b[4]=c;b[6]=a[9];b[7]=a[13];b[8]=e;b[9]=f;b[11]=a[14];b[12]=d;b[13]=g;b[14]=h}else b[0]=a[0],b[1]=a[4],b[2]=a[8],b[3]=a[12],b[4]=a[1],b[5]=a[5],b[6]=a[9],b[7]=a[13],b[8]=a[2],b[9]=a[6],b[10]=a[10],b[11]=a[14],b[12]=a[3],b[13]=a[7],b[14]=a[11],b[15]=a[15];return b};
D.f.$h=function(a){var b=a[0],c=a[1],e=a[2],d=a[3],f=a[4],g=a[5],h=a[6],l=a[7],j=a[8],k=a[9],n=a[10],r=a[11],s=a[12],z=a[13],y=a[14];a=a[15];return(b*g-c*f)*(n*a-r*y)-(b*h-e*f)*(k*a-r*z)+(b*l-d*f)*(k*y-n*z)+(c*h-e*g)*(j*a-r*s)-(c*l-d*g)*(j*y-n*s)+(e*l-d*h)*(j*z-k*s)};D.f.U=Zc;D.f.mf=function(a,b,c,e,d){var f=b/2;b=d-e;var g=Math.sin(f);if(0==b||0==g||0==c)return a;f=Math.cos(f)/g;return Sc(a,f/c,0,0,0,0,f,0,0,0,0,-(d+e)/b,-1,0,0,-(2*e*d)/b,0)};
D.f.Fi=function(a,b,c,e,d,f,g){return Sc(a,2*f/(c-b),0,0,0,0,2*f/(d-e),0,0,(c+b)/(c-b),(d+e)/(d-e),-(g+f)/(g-f),-1,0,0,-(2*g*f)/(g-f),0)};D.f.Gi=function(a,b,c,e,d,f,g){return Sc(a,2/(c-b),0,0,0,0,2/(d-e),0,0,0,0,-2/(g-f),0,-(c+b)/(c-b),-(d+e)/(d-e),-(g+f)/(g-f),1)};D.f.multiply=Yc;D.f.Qg=ad;D.f.translate=bd;D.f.scale=function(a,b,c,e){return Sc(a,a[0]*b,a[1]*b,a[2]*b,a[3]*b,a[4]*c,a[5]*c,a[6]*c,a[7]*c,a[8]*e,a[9]*e,a[10]*e,a[11]*e,a[12],a[13],a[14],a[15])};
D.f.rotate=function(a,b,c,e,d){var f=a[0],g=a[1],h=a[2],l=a[3],j=a[4],k=a[5],n=a[6],r=a[7],s=a[8],z=a[9],y=a[10],E=a[11],F=Math.cos(b),K=Math.sin(b),A=1-F;b=c*c*A+F;var G=c*e*A+d*K,I=c*d*A-e*K,H=c*e*A-d*K,R=e*e*A+F,N=e*d*A+c*K,S=c*d*A+e*K;c=e*d*A-c*K;d=d*d*A+F;return Sc(a,f*b+j*G+s*I,g*b+k*G+z*I,h*b+n*G+y*I,l*b+r*G+E*I,f*H+j*R+s*N,g*H+k*R+z*N,h*H+n*R+y*N,l*H+r*R+E*N,f*S+j*c+s*d,g*S+k*c+z*d,h*S+n*c+y*d,l*S+r*c+E*d,a[12],a[13],a[14],a[15])};
D.f.pe=function(a,b){var c=a[4],e=a[5],d=a[6],f=a[7],g=a[8],h=a[9],l=a[10],j=a[11],k=Math.cos(b),n=Math.sin(b);a[4]=c*k+g*n;a[5]=e*k+h*n;a[6]=d*k+l*n;a[7]=f*k+j*n;a[8]=c*-n+g*k;a[9]=e*-n+h*k;a[10]=d*-n+l*k;a[11]=f*-n+j*k;return a};D.f.qe=function(a,b){var c=a[0],e=a[1],d=a[2],f=a[3],g=a[8],h=a[9],l=a[10],j=a[11],k=Math.cos(b),n=Math.sin(b);a[0]=c*k+g*-n;a[1]=e*k+h*-n;a[2]=d*k+l*-n;a[3]=f*k+j*-n;a[8]=c*n+g*k;a[9]=e*n+h*k;a[10]=d*n+l*k;a[11]=f*n+j*k;return a};
D.f.re=function(a,b){var c=a[0],e=a[1],d=a[2],f=a[3],g=a[4],h=a[5],l=a[6],j=a[7],k=Math.cos(b),n=Math.sin(b);a[0]=c*k+g*n;a[1]=e*k+h*n;a[2]=d*k+l*n;a[3]=f*k+j*n;a[4]=c*-n+g*k;a[5]=e*-n+h*k;a[6]=d*-n+l*k;a[7]=f*-n+j*k;return a};B("X.matrix.identity",D.f.td);B("X.matrix.clone",D.f.l);B("X.matrix.transpose",D.f.Lf);B("X.matrix.determinant",D.f.$h);B("X.matrix.invert",D.f.U);B("X.matrix.multiply",D.f.multiply);B("X.matrix.multiplyByVector",D.f.X);B("X.matrix.multiplyByVec4",D.f.Qg);
B("X.matrix.makePerspective",D.f.mf);B("X.matrix.makeFrustum",D.f.Fi);B("X.matrix.makeOrtho",D.f.Gi);B("X.matrix.makeLookAt",D.f.Mg);B("X.matrix.translate",D.f.translate);B("X.matrix.scale",D.f.scale);B("X.matrix.rotate",D.f.rotate);B("X.matrix.rotateX",D.f.pe);B("X.matrix.rotateY",D.f.qe);B("X.matrix.rotateZ",D.f.re);B("X.matrix.swapRows",D.f.Hj);B("X.matrix.swapCols",D.f.Gj);function cd(){O.call(this);this.g="transform";this.N=D.f.td()}C(cd,O);cd.prototype.__defineGetter__("matrix",v("N"));cd.prototype.__defineSetter__("matrix",function(a){(a==t||!(a instanceof Float32Array))&&m(Error("Invalid matrix."));this.N=a;this.p()});w=cd.prototype;w.pe=function(a){(!x(a)||-360>a||360<a)&&m(Error("Invalid angle."));D.f.pe(this.N,a*Math.PI/180);this.p()};w.qe=function(a){(!x(a)||-360>a||360<a)&&m(Error("Invalid angle."));D.f.qe(this.N,a*Math.PI/180);this.p()};
w.re=function(a){(!x(a)||-360>a||360<a)&&m(Error("Invalid angle."));D.f.re(this.N,a*Math.PI/180);this.p()};w.nh=function(a){x(a)||m(Error("Invalid distance."));D.f.translate(this.N,a,0,0);this.p()};w.oh=function(a){x(a)||m(Error("Invalid distance."));D.f.translate(this.N,0,a,0);this.p()};w.ph=function(a){x(a)||m(Error("Invalid distance."));D.f.translate(this.N,0,0,a);this.p()};function dd(a,b,c){a.N[b+4*c]*=-1;a.p()}w.gi=function(){dd(this,0,0)};w.hi=function(){dd(this,1,1)};
w.ii=function(){dd(this,2,2)};w.p=function(){this.j=q};B("X.transform",cd);B("X.transform.prototype.rotateX",cd.prototype.pe);B("X.transform.prototype.rotateY",cd.prototype.qe);B("X.transform.prototype.rotateZ",cd.prototype.re);B("X.transform.prototype.translateX",cd.prototype.nh);B("X.transform.prototype.translateY",cd.prototype.oh);B("X.transform.prototype.translateZ",cd.prototype.ph);B("X.transform.prototype.flipX",cd.prototype.gi);B("X.transform.prototype.flipY",cd.prototype.hi);
B("X.transform.prototype.flipZ",cd.prototype.ii);B("X.transform.prototype.modified",cd.prototype.p);function ed(){O.call(this);this.g="texture";this.Tb=this.Jb=this.r=t;this.Me=this.Ne=0;this.Xf=u;Ga(this,new wc)}C(ed,O);ed.prototype.__defineSetter__("rawData",function(a){this.Tb=a;this.j=q});ed.prototype.__defineSetter__("rawDataHeight",function(a){this.Me=a;this.j=q});ed.prototype.__defineSetter__("rawDataWidth",function(a){this.Ne=a;this.j=q});ed.prototype.__defineSetter__("grayscale",function(a){this.Xf=a;this.j=q});B("X.texture",ed);function W(a,b){O.call(this);this.g="triplets";this.eb=Infinity;this.$a=-Infinity;this.fb=Infinity;this.ab=-Infinity;this.gb=Infinity;this.bb=-Infinity;this.Hd=[0,0,0];this.Wf=q;this.R=0;this.Y=new Float32Array(a);b!=t&&(this.Y=b.Y.subarray(0,b.Y.length),this.R=this.Y.length,this.eb=b.eb,this.$a=b.$a,this.fb=b.fb,this.ab=b.ab,this.gb=b.gb,this.bb=b.bb,this.Hd=b.Hd.slice(),this.Wf=u)}C(W,O);w=W.prototype;
w.add=function(a,b,c){this.eb=Math.min(this.eb,a);this.$a=Math.max(this.$a,a);this.fb=Math.min(this.fb,b);this.ab=Math.max(this.ab,b);this.gb=Math.min(this.gb,c);this.bb=Math.max(this.bb,c);this.Hd=[(this.eb+this.$a)/2,(this.fb+this.ab)/2,(this.gb+this.bb)/2];this.Wf=u;this.j=q;this.Y[this.R++]=a;this.Y[this.R++]=b;this.Y[this.R++]=c;return this.R/3};w.Cb=function(){if(this.R!=this.Y.length){var a=new Float32Array(this.R);a.set(this.Y.subarray(0,this.R));this.Y=a}};
w.get=function(a){a*=3;return[this.Y[a],this.Y[a+1],this.Y[a+2]]};w.remove=function(){m(Error("Not implemented."))};w.clear=function(){this.Y=new Float32Array(this.Y.length);this.j=q};W.prototype.__defineGetter__("count",function(){this.Cb();return this.Y.length/3});W.prototype.__defineGetter__("length",function(){this.Cb();return this.Y.length});B("X.triplets",W);B("X.triplets.prototype.add",W.prototype.add);B("X.triplets.prototype.resize",W.prototype.Cb);B("X.triplets.prototype.get",W.prototype.get);
B("X.triplets.prototype.remove",W.prototype.remove);B("X.triplets.prototype.clear",W.prototype.clear);function fd(){this.Da=gd;this.ca=new cd;this.u=[1,1,1];this.Fc=this.C=this.la=this.q=this.h=t;this.Ac=[];this.L=q;this.zc=this.ad=1;this.qc=t;this.Sc=u;this.qa=1;this.sa=0;this.$c=q}var gd="TRIANGLES";fd.prototype.__defineSetter__("type",function(a){return this.Da=a});fd.prototype.__defineGetter__("type",v("Da"));fd.prototype.__defineGetter__("texture",function(){this.C||(this.C=new ed);return this.C});fd.prototype.__defineGetter__("transform",v("ca"));fd.prototype.__defineGetter__("points",v("h"));
fd.prototype.__defineSetter__("points",fa("h"));fd.prototype.__defineGetter__("normals",v("q"));fd.prototype.__defineSetter__("normals",fa("q"));fd.prototype.__defineGetter__("colors",v("la"));fd.prototype.__defineSetter__("colors",fa("la"));fd.prototype.__defineGetter__("color",v("u"));fd.prototype.__defineSetter__("color",function(a){(a==t||!la(a)||3!=a.length)&&m(Error("Invalid color."));for(var b=this.c,c=b.length,e=0,e=0;e<c;e++)b[e].color=a;this.u=a;this.j=q});
fd.prototype.__defineGetter__("opacity",v("qa"));fd.prototype.__defineSetter__("opacity",function(a){(!x(a)||1<a||0>a)&&m(Error("Invalid opacity."));for(var b=this.c,c=b.length,e=0,e=0;e<c;e++)b[e]!=t&&(b[e].opacity=a);this.qa=a;this.j=q});fd.prototype.__defineGetter__("caption",v("qc"));fd.prototype.__defineSetter__("caption",function(a){this.qc=a;this.j=q});fd.prototype.__defineGetter__("visible",v("L"));
fd.prototype.__defineSetter__("visible",function(a){for(var b=this.c,c=b.length,e=0,e=0;e<c;e++)b[e]!=t&&(b[e].visible=a);this.L=a;this.j=q});fd.prototype.__defineGetter__("pointsize",v("ad"));fd.prototype.__defineSetter__("pointsize",function(a){x(a)||m(Error("Invalid point size."));this.ad=a;this.j=q});fd.prototype.__defineGetter__("magicmode",v("Sc"));fd.prototype.__defineSetter__("magicmode",function(a){"boolean"!=typeof a&&m(Error("Invalid magic mode setting."));this.Sc=a;this.j=q});
fd.prototype.__defineGetter__("linewidth",v("zc"));fd.prototype.__defineSetter__("linewidth",function(a){x(a)||m(Error("Invalid line width."));this.zc=a;this.j=q});fd.prototype.__defineGetter__("pickable",v("$c"));fd.prototype.__defineSetter__("pickable",function(a){"boolean"!=typeof a&&m(Error("Invalid pickable setting."));this.$c=a;this.j=q});fd.prototype.__defineGetter__("textureCoordinateMap",v("Fc"));fd.prototype.__defineSetter__("textureCoordinateMap",fa("Hk"));function hd(){this.cb=Infinity;this.fa=this.ma=-Infinity;this.ga=Infinity;this.Ob=[0,0,0];this.Mb=[1,1,1]}hd.prototype.__defineGetter__("lowerThreshold",v("fa"));hd.prototype.__defineSetter__("lowerThreshold",fa("fa"));hd.prototype.__defineGetter__("upperThreshold",v("ga"));hd.prototype.__defineSetter__("upperThreshold",fa("ga"));hd.prototype.__defineGetter__("min",v("cb"));hd.prototype.__defineGetter__("max",v("ma"));hd.prototype.__defineGetter__("minColor",v("Ob"));
hd.prototype.__defineSetter__("minColor",function(a){(a==t||!la(a)||3!=a.length)&&m(Error("Invalid min. color."));this.Ob=a});hd.prototype.__defineGetter__("maxColor",v("Mb"));hd.prototype.__defineSetter__("maxColor",function(a){(a==t||!la(a)||3!=a.length)&&m(Error("Invalid max. color."));this.Mb=a});function id(){O.call(this);this.g="scalars";this.Pc=this.F=t;this.jg=q;this.Be=0;Ga(this,new wc);Ga(this,new hd);this.Ob=[0,1,0];this.Mb=[1,0,0]}C(id,O);id.prototype.__defineGetter__("array",v("F"));id.prototype.__defineSetter__("array",function(a){this.Pc=this.F=a;this.j=q});id.prototype.__defineGetter__("interpolation",v("Be"));id.prototype.__defineSetter__("interpolation",fa("Be"));B("X.scalars",id);function Y(a){O.call(this);this.g="object";this.c=[];this.G=this.Aa=t;Ga(this,new fd);a!=t&&this.gc(a)}C(Y,O);
Y.prototype.gc=function(a){this.Da=a.Da;this.ca=new cd;this.ca.N=new Float32Array(a.ca.N);this.u=a.u.slice();a.h&&(this.h=new W(a.h.length,a.h));a.q&&(this.q=new W(a.q.length,a.q));a.la&&(this.la=new W(a.la.length,a.la));this.C=a.C;this.Fc=a.Fc;a.r&&(this.r=new vc((new String(a.r.Sd)).toString()));this.qa=a.qa;this.c.length=0;var b=a.c;if(b)for(var c=b.length,e=0,e=0;e<c;e++)this.c.push(new D[b[e].g](b[e]));this.L=a.L;this.ad=a.ad;this.zc=a.zc;a.qc&&(this.qc=(new String(a.qc)).toString());this.Sc=
a.Sc;this.$c=a.$c;this.Ac=a.Ac.slice();this.j=q};Y.prototype.__defineGetter__("colortable",function(){this.Aa||(this.Aa=new Cc);return this.Aa});Y.prototype.__defineGetter__("scalars",function(){this.G||(this.G=new id);return this.G});Y.prototype.__defineGetter__("children",v("c"));Y.prototype.p=function(){var a=new jd;a.K=this;this.dispatchEvent(a)};Y.prototype.remove=function(){var a=new kd;a.K=this;this.dispatchEvent(a)};
function ld(a,b){(a==t||b==t||!(a instanceof Y)||!(b instanceof Y))&&m(Error("Fatal: Two valid X.objects are required for comparison."));return 1==a.qa?-1:1==b.qa?1:a.sa!=t&&b.sa!=t&&a.sa>b.sa?-1:1}B("X.object",Y);B("X.object.prototype.modified",Y.prototype.p);B("X.object.prototype.remove",Y.prototype.remove);function md(){}function nd(a){for(var b=a.h.count,c=[],e=0,e=0;e<b;e+=3){var d=a.h.get(e),f=a.h.get(e+1),g=a.h.get(e+2),h=a.q.get(e),l=a.q.get(e+1),j=a.q.get(e+2),k=a.u;a.la&&0<a.la.length&&(k=a.la.get(e));var n=[];n.push(new jc(d,h));n.push(new jc(f,l));n.push(new jc(g,j));c.push(new lc(n,k))}return tc(c)}
function od(a,b){(b==t||!(b instanceof sc))&&m(Error("Invalid CSG object."));var c=new uc,e=[];Lb(b.V,function(a){var b=[],g=a.ue,b=Lb(a.Eb,function(a){a.color=g;return c.add(a)});for(a=a=2;a<b.length;a++)e.push([b[0],b[a-1],b[a]])}.bind(a));a.Dh=Lb(c.unique(),function(a){return[a.Qa.x(),a.Qa.y(),a.Qa.d()]});a.Ch=Lb(c.unique(),function(a){return[a.ra.x(),a.ra.y(),a.ra.d()]});a.Bh=Lb(c.unique(),function(a){return!a.color?t:[a.color[0],a.color[1],a.color[2]]});a.h=new W(9*e.length);a.q=new W(9*e.length);
a.la=new W(9*e.length);Lb(e,function(a){var b=a[0],c=a[1];a=a[2];var e=this.Dh,l=this.Ch,j=this.Bh;this.h.add(e[b][0],e[b][1],e[b][2]);this.h.add(e[c][0],e[c][1],e[c][2]);this.h.add(e[a][0],e[a][1],e[a][2]);this.q.add(l[b][0],l[b][1],l[b][2]);this.q.add(l[c][0],l[c][1],l[c][2]);this.q.add(l[a][0],l[a][1],l[a][2]);j[b]&&this.la.add(j[b][0],j[b][1],j[b][2]);j[c]&&this.la.add(j[c][0],j[c][1],j[c][2]);j[a]&&this.la.add(j[a][0],j[a][1],j[a][2])}.bind(a));0==a.la.R&&(a.la=t);a.Da=gd}
md.prototype.Mf=function(a){(a==t||!(a instanceof sc)&&!(a instanceof Y))&&m(Error("Invalid object."));var b=a;a instanceof Y&&(b=nd(b));a=new Y;Ga(a,new md);od(a,nd(this).Mf(b));return a};md.prototype.Ea=function(a){(a==t||!(a instanceof sc)&&!(a instanceof Y))&&m(Error("Invalid object."));var b=a;a instanceof Y&&(b=nd(b));a=new Y;Ga(a,new md);od(a,nd(this).Ea(b));return a};
md.prototype.jf=function(a){(a==t||!(a instanceof sc)&&!(a instanceof Y))&&m(Error("Invalid object."));var b=a;a instanceof Y&&(b=nd(b));a=new Y;Ga(a,new md);od(a,nd(this).jf(b));return a};md.prototype.inverse=function(){var a=new Y;Ga(a,new md);od(a,nd(this).inverse());return a};B("X.constructable",md);B("X.constructable.prototype.intersect",md.prototype.jf);B("X.constructable.prototype.inverse",md.prototype.inverse);B("X.constructable.prototype.subtract",md.prototype.Ea);
B("X.constructable.prototype.union",md.prototype.Mf);function pd(a){Rb.call(this,a);this.g="event"}C(pd,Rb);var qd=hc("pan"),rd=hc("rotate"),sd=hc("zoom"),td=hc("scroll");hc("render");var ud=hc("resetview"),vd=hc("windowlevel"),wd=hc("modified"),xd=hc("remove"),yd=hc("progress"),zd=hc("hover"),Ad=hc("hover_end"),Bd=hc("computing"),Cd=hc("computing_end"),Dd=hc("computing_progress");function Ed(){pd.call(this,vd);this.Ge=this.Te=0}C(Ed,pd);function Fd(){pd.call(this,qd);this.sa=new D.m(0,0,0)}C(Fd,pd);
function Gd(){pd.call(this,rd);this.sa=new D.m(0,0,0)}C(Gd,pd);function Hd(){pd.call(this,sd);this.Za=this.nb=u}C(Hd,pd);function Id(){pd.call(this,td);this.Z=u}C(Id,pd);function Jd(){pd.call(this,zd);this.Yd=this.Xd=0}C(Jd,pd);function Kd(){pd.call(this,Ad)}C(Kd,pd);function Ld(){pd.call(this,ud)}C(Ld,pd);function jd(){pd.call(this,wd);this.B=this.K=t}C(jd,pd);function kd(){pd.call(this,xd);this.B=this.K=t}C(kd,pd);function Md(){pd.call(this,yd);this.od=0}C(Md,pd);
function Nd(){pd.call(this,Bd);this.K=t}C(Nd,pd);function Od(){pd.call(this,Dd);this.od=0}C(Od,pd);function Pd(){pd.call(this,Cd);this.K=t}C(Pd,pd);B("X.event.events.PAN",qd);B("X.event.events.ROTATE",rd);B("X.event.events.ZOOM",sd);B("X.event.events.SCROLL",td);function Qd(a,b,c){a==t&&m(Error("Invalid GL Buffer."));b==t&&m(Error("Invalid number of items."));c==t&&m(Error("Invalid item size."));O.call(this);this.g="buffer";this.M=a;this.Kb=b;this.Lb=c}C(Qd,O);var Rd;function Sd(a,b){var c;c=a.className;c=na(c)&&c.match(/\S+/g)||[];for(var e=Ob(arguments,1),d=c.length+e.length,f=c,g=0;g<e.length;g++)0<=Ib(f,e[g])||f.push(e[g]);a.className=c.join(" ");return c.length==d};function Td(a,b){this.width=a;this.height=b}w=Td.prototype;w.l=function(){return new Td(this.width,this.height)};w.ceil=function(){this.width=Math.ceil(this.width);this.height=Math.ceil(this.height);return this};w.floor=function(){this.width=Math.floor(this.width);this.height=Math.floor(this.height);return this};w.round=function(){this.width=Math.round(this.width);this.height=Math.round(this.height);return this};w.scale=function(a,b){var c=x(b)?b:a;this.width*=a;this.height*=c;return this};var Ud=!J||J&&9<=Eb;!lb&&!J||J&&J&&9<=Eb||lb&&Cb("1.9.1");J&&Cb("9");function Vd(a,b){this.x=ja(a)?a:0;this.y=ja(b)?b:0}w=Vd.prototype;w.l=function(){return new Vd(this.x,this.y)};function Wd(a,b){return new Vd(a.x-b.x,a.y-b.y)}w.ceil=function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this};w.floor=function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this};w.round=function(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this};
w.translate=function(a,b){a instanceof Vd?(this.x+=a.x,this.y+=a.y):(this.x+=a,x(b)&&(this.y+=b));return this};w.scale=function(a,b){var c=x(b)?b:a;this.x*=a;this.y*=c;return this};function Xd(a){return a?new Yd(Zd(a)):Rd||(Rd=new Yd)}function $d(a){return na(a)?document.getElementById(a):a}var ae={cellpadding:"cellPadding",cellspacing:"cellSpacing",colspan:"colSpan",frameborder:"frameBorder",height:"height",maxlength:"maxLength",role:"role",rowspan:"rowSpan",type:"type",usemap:"useMap",valign:"vAlign",width:"width"};function be(a,b,c){return ce(document,arguments)}
function ce(a,b){var c=b[0],e=b[1];if(!Ud&&e&&(e.name||e.type)){c=["<",c];e.name&&c.push(' name="',Sa(e.name),'"');if(e.type){c.push(' type="',Sa(e.type),'"');var d={};Ra(d,e);delete d.type;e=d}c.push(">");c=c.join("")}var f=a.createElement(c);e&&(na(e)?f.className=e:la(e)?Sd.apply(t,[f].concat(e)):Na(e,function(a,b){"style"==b?f.style.cssText=a:"class"==b?f.className=a:"for"==b?f.htmlFor=a:b in ae?f.setAttribute(ae[b],a):0==b.lastIndexOf("aria-",0)||0==b.lastIndexOf("data-",0)?f.setAttribute(b,a):
f[b]=a}));if(2<b.length){e=function(b){b&&f.appendChild(na(b)?a.createTextNode(b):b)};for(c=2;c<b.length;c++){var g=b[c];if(ma(g)&&!(pa(g)&&0<g.nodeType)){var d=Jb,h;a:{if((h=g)&&"number"==typeof h.length){if(pa(h)){h="function"==typeof h.item||"string"==typeof h.item;break a}if(oa(h)){h="function"==typeof h.item;break a}}h=u}if(h)if(h=g.length,0<h){for(var l=Array(h),j=0;j<h;j++)l[j]=g[j];g=l}else g=[];d(g,e)}else e(g)}}return f}function de(a){a&&a.parentNode&&a.parentNode.removeChild(a)}
function ee(a){for(;a&&1!=a.nodeType;)a=a.nextSibling;return a}function fe(a,b){if(a.contains&&1==b.nodeType)return a==b||a.contains(b);if("undefined"!=typeof a.compareDocumentPosition)return a==b||Boolean(a.compareDocumentPosition(b)&16);for(;b&&a!=b;)b=b.parentNode;return b==a}function Zd(a){return 9==a.nodeType?a:a.ownerDocument||a.document}function Yd(a){this.da=a||ga.document||document}w=Yd.prototype;w.fe=Xd;w.s=function(a){return na(a)?this.da.getElementById(a):a};w.th=Yd.prototype.s;
w.Ic=function(a,b,c){return ce(this.da,arguments)};w.createElement=function(a){return this.da.createElement(a)};w.createTextNode=function(a){return this.da.createTextNode(String(a))};function ge(a){return"CSS1Compat"==a.da.compatMode}function he(a){var b=a.da;a=!mb&&"CSS1Compat"==b.compatMode?b.documentElement:b.body;b=b.parentWindow||b.defaultView;return J&&Cb("10")&&b.pageYOffset!=a.scrollTop?new Vd(a.scrollLeft,a.scrollTop):new Vd(b.pageXOffset||a.scrollLeft,b.pageYOffset||a.scrollTop)}
w.appendChild=function(a,b){a.appendChild(b)};w.contains=fe;function ie(a,b,c,e){this.top=a;this.right=b;this.bottom=c;this.left=e}w=ie.prototype;w.l=function(){return new ie(this.top,this.right,this.bottom,this.left)};w.contains=function(a){return!this||!a?u:a instanceof ie?a.left>=this.left&&a.right<=this.right&&a.top>=this.top&&a.bottom<=this.bottom:a.x>=this.left&&a.x<=this.right&&a.y>=this.top&&a.y<=this.bottom};
w.ceil=function(){this.top=Math.ceil(this.top);this.right=Math.ceil(this.right);this.bottom=Math.ceil(this.bottom);this.left=Math.ceil(this.left);return this};w.floor=function(){this.top=Math.floor(this.top);this.right=Math.floor(this.right);this.bottom=Math.floor(this.bottom);this.left=Math.floor(this.left);return this};w.round=function(){this.top=Math.round(this.top);this.right=Math.round(this.right);this.bottom=Math.round(this.bottom);this.left=Math.round(this.left);return this};
w.translate=function(a,b){a instanceof Vd?(this.left+=a.x,this.right+=a.x,this.top+=a.y,this.bottom+=a.y):(this.left+=a,this.right+=a,x(b)&&(this.top+=b,this.bottom+=b));return this};w.scale=function(a,b){var c=x(b)?b:a;this.left*=a;this.right*=a;this.top*=c;this.bottom*=c;return this};function je(a,b,c,e){this.left=a;this.top=b;this.width=c;this.height=e}w=je.prototype;w.l=function(){return new je(this.left,this.top,this.width,this.height)};w.Ig=function(a){var b=Math.max(this.left,a.left),c=Math.min(this.left+this.width,a.left+a.width);if(b<=c){var e=Math.max(this.top,a.top);a=Math.min(this.top+this.height,a.top+a.height);if(e<=a)return this.left=b,this.top=e,this.width=c-b,this.height=a-e,q}return u};
w.contains=function(a){return a instanceof je?this.left<=a.left&&this.left+this.width>=a.left+a.width&&this.top<=a.top&&this.top+this.height>=a.top+a.height:a.x>=this.left&&a.x<=this.left+this.width&&a.y>=this.top&&a.y<=this.top+this.height};function ke(a,b){var c=b.x<a.left?a.left-b.x:Math.max(b.x-(a.left+a.width),0),e=b.y<a.top?a.top-b.y:Math.max(b.y-(a.top+a.height),0);return c*c+e*e}w.ff=function(a){return Math.sqrt(ke(this,a))};
w.ceil=function(){this.left=Math.ceil(this.left);this.top=Math.ceil(this.top);this.width=Math.ceil(this.width);this.height=Math.ceil(this.height);return this};w.floor=function(){this.left=Math.floor(this.left);this.top=Math.floor(this.top);this.width=Math.floor(this.width);this.height=Math.floor(this.height);return this};w.round=function(){this.left=Math.round(this.left);this.top=Math.round(this.top);this.width=Math.round(this.width);this.height=Math.round(this.height);return this};
w.translate=function(a,b){a instanceof Vd?(this.left+=a.x,this.top+=a.y):(this.left+=a,x(b)&&(this.top+=b));return this};w.scale=function(a,b){var c=x(b)?b:a;this.left*=a;this.width*=a;this.top*=c;this.height*=c;return this};function le(a,b){var c=Zd(a);return c.defaultView&&c.defaultView.getComputedStyle&&(c=c.defaultView.getComputedStyle(a,t))?c[b]||c.getPropertyValue(b)||"":""}function me(a,b){return le(a,b)||(a.currentStyle?a.currentStyle[b]:t)||a.style&&a.style[b]}function ne(a){a=a?Zd(a):document;return J&&!(J&&9<=Eb)&&!ge(Xd(a))?a.body:a.documentElement}
function oe(a){var b=a.getBoundingClientRect();J&&(a=a.ownerDocument,b.left-=a.documentElement.clientLeft+a.body.clientLeft,b.top-=a.documentElement.clientTop+a.body.clientTop);return b}
function pe(a){if(J&&!(J&&8<=Eb))return a.offsetParent;var b=Zd(a),c=me(a,"position"),e="fixed"==c||"absolute"==c;for(a=a.parentNode;a&&a!=b;a=a.parentNode)if(c=me(a,"position"),e=e&&"static"==c&&a!=b.documentElement&&a!=b.body,!e&&(a.scrollWidth>a.clientWidth||a.scrollHeight>a.clientHeight||"fixed"==c||"absolute"==c||"relative"==c))return a;return t}
function qe(a){for(var b=new ie(0,Infinity,Infinity,0),c=Xd(a),e=c.da.body,d=c.da.documentElement,f=!mb&&"CSS1Compat"==c.da.compatMode?c.da.documentElement:c.da.body;a=pe(a);)if((!J||0!=a.clientWidth)&&(!mb||0!=a.clientHeight||a!=e)&&a!=e&&a!=d&&"visible"!=me(a,"overflow")){var g=re(a),h;h=a;if(lb&&!Cb("1.9")){var l=parseFloat(le(h,"borderLeftWidth"));if(se(h))var j=h.offsetWidth-h.clientWidth-l-parseFloat(le(h,"borderRightWidth")),l=l+j;h=new Vd(l,parseFloat(le(h,"borderTopWidth")))}else h=new Vd(h.clientLeft,
h.clientTop);g.x+=h.x;g.y+=h.y;b.top=Math.max(b.top,g.y);b.right=Math.min(b.right,g.x+a.clientWidth);b.bottom=Math.min(b.bottom,g.y+a.clientHeight);b.left=Math.max(b.left,g.x)}e=f.scrollLeft;f=f.scrollTop;b.left=Math.max(b.left,e);b.top=Math.max(b.top,f);c=(c.da.parentWindow||c.da.defaultView||window).document;c="CSS1Compat"==c.compatMode?c.documentElement:c.body;c=new Td(c.clientWidth,c.clientHeight);b.right=Math.min(b.right,e+c.width);b.bottom=Math.min(b.bottom,f+c.height);return 0<=b.top&&0<=b.left&&
b.bottom>b.top&&b.right>b.left?b:t}
function re(a){var b,c=Zd(a),e=me(a,"position"),d=lb&&c.getBoxObjectFor&&!a.getBoundingClientRect&&"absolute"==e&&(b=c.getBoxObjectFor(a))&&(0>b.screenX||0>b.screenY),f=new Vd(0,0),g=ne(c);if(a==g)return f;if(a.getBoundingClientRect)b=oe(a),a=he(Xd(c)),f.x=b.left+a.x,f.y=b.top+a.y;else if(c.getBoxObjectFor&&!d)b=c.getBoxObjectFor(a),a=c.getBoxObjectFor(g),f.x=b.screenX-a.screenX,f.y=b.screenY-a.screenY;else{b=a;do{f.x+=b.offsetLeft;f.y+=b.offsetTop;b!=a&&(f.x+=b.clientLeft||0,f.y+=b.clientTop||0);
if(mb&&"fixed"==me(b,"position")){f.x+=c.body.scrollLeft;f.y+=c.body.scrollTop;break}b=b.offsetParent}while(b&&b!=a);if(jb||mb&&"absolute"==e)f.y-=c.body.offsetTop;for(b=a;(b=pe(b))&&b!=c.body&&b!=g;)if(f.x-=b.scrollLeft,!jb||"TR"!=b.tagName)f.y-=b.scrollTop}return f}
function te(a){var b=new Vd;if(1==a.nodeType){if(a.getBoundingClientRect){var c=oe(a);b.x=c.left;b.y=c.top}else{var c=he(Xd(a)),e=re(a);b.x=e.x-c.x;b.y=e.y-c.y}if(lb&&!Cb(12)){var d;J?d="-ms-transform":mb?d="-webkit-transform":jb?d="-o-transform":lb&&(d="-moz-transform");var f;d&&(f=me(a,d));f||(f=me(a,"transform"));f?(a=f.match(ue),a=!a?new Vd(0,0):new Vd(parseFloat(a[1]),parseFloat(a[2]))):a=new Vd(0,0);b=new Vd(b.x+a.x,b.y+a.y)}}else d=oa(a.ki),f=a,a.targetTouches?f=a.targetTouches[0]:d&&a.jb.targetTouches&&
(f=a.jb.targetTouches[0]),b.x=f.clientX,b.y=f.clientY;return b}function ve(a,b){"number"==typeof a&&(a=(b?Math.round(a):a)+"px");return a}function we(a){if("none"!=me(a,"display"))return xe(a);var b=a.style,c=b.display,e=b.visibility,d=b.position;b.visibility="hidden";b.position="absolute";b.display="inline";a=xe(a);b.display=c;b.position=d;b.visibility=e;return a}
function xe(a){var b=a.offsetWidth,c=a.offsetHeight,e=mb&&!b&&!c;return(!ja(b)||e)&&a.getBoundingClientRect?(a=oe(a),new Td(a.right-a.left,a.bottom-a.top)):new Td(b,c)}function ye(a,b){a.style.display=b?"":"none"}function se(a){return"rtl"==me(a,"direction")}function ze(a,b){if(/^\d+px?$/.test(b))return parseInt(b,10);var c=a.style.left,e=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;a.style.left=b;var d=a.style.pixelLeft;a.style.left=c;a.runtimeStyle.left=e;return d}
function Ae(a,b){var c=a.currentStyle?a.currentStyle[b]:t;return c?ze(a,c):0}var Be={thin:2,medium:4,thick:6};function Ce(a,b){if("none"==(a.currentStyle?a.currentStyle[b+"Style"]:t))return 0;var c=a.currentStyle?a.currentStyle[b+"Width"]:t;return c in Be?Be[c]:ze(a,c)}var ue=/matrix\([0-9\.\-]+, [0-9\.\-]+, [0-9\.\-]+, [0-9\.\-]+, ([0-9\.\-]+)p?x?, ([0-9\.\-]+)p?x?\)/;function De(a,b){ic.call(this);this.D=a;var c=pa(this.D)&&1==this.D.nodeType?this.D:this.D?this.D.body:t;this.Di=!!c&&se(c);this.Rk=L(this.D,lb?"DOMMouseScroll":"mousewheel",this,b)}C(De,ic);
De.prototype.handleEvent=function(a){var b=0,c=0,e=0;a=a.jb;if("mousewheel"==a.type){c=1;if(J||mb&&(cb||Cb("532.0")))c=40;e=Ee(-a.wheelDelta,c);ja(a.wheelDeltaX)?(b=Ee(-a.wheelDeltaX,c),c=Ee(-a.wheelDeltaY,c)):c=e}else e=a.detail,100<e?e=3:-100>e&&(e=-3),ja(a.axis)&&a.axis===a.HORIZONTAL_AXIS?b=e:c=e;x(this.Ng)&&(b=Math.min(Math.max(b,-this.Ng),this.Ng));x(this.Og)&&(c=Math.min(Math.max(c,-this.Og),this.Og));this.Di&&(b=-b);b=new Fe(e,a,b,c);this.dispatchEvent(b)};
function Ee(a,b){return mb&&(bb||eb)&&0!=a%b?a:a/b}function Fe(a,b,c,e){b&&this.wa(b,p);this.type="mousewheel";this.detail=a;this.Mk=c;this.Jc=e}C(Fe,Tb);J||mb&&Cb("525");function Ge(a){O.call(this);this.g="interactor";this.Ja=a;this.He=this.dg=this.cg=this.eg=this.bg=this.fg=t;this.Qd=q;this.Ub=this.Nb=this.ob=u;this.pa=[0,0];this.Ce=new D.m(0,0,0);this.Qc=new D.m(0,0,0);this.Kg=0;this.mg=this.Md=t;this.lg=u;this.O={MOUSEWHEEL_ENABLED:q,MOUSECLICKS_ENABLED:q,KEYBOARD_ENABLED:q,HOVERING_ENABLED:q,CONTEXTMENU_ENABLED:u,TOUCH_ENABLED:q,TOUCH_BOUNCING_ENABLED:u}}C(Ge,O);Ge.prototype.__defineGetter__("config",v("O"));Ge.prototype.__defineGetter__("leftButtonDown",v("ob"));
Ge.prototype.__defineGetter__("middleButtonDown",v("Nb"));Ge.prototype.__defineGetter__("rightButtonDown",v("Ub"));
Ge.prototype.wa=function(){this.O.MOUSEWHEEL_ENABLED?(this.He=new De(this.Ja),this.fg=L(this.He,"mousewheel",this.wd.bind(this))):(bc(this.fg),this.He=t);this.O.MOUSECLICKS_ENABLED?(this.bg=L(this.Ja,"mousedown",this.Pi.bind(this)),this.eg=L(this.Ja,"mouseup",this.Ui.bind(this))):(bc(this.bg),bc(this.eg));this.Ja.oncontextmenu=this.O.CONTEXTMENU_ENABLED?t:function(){return u};window.onkeydown=this.O.KEYBOARD_ENABLED?this.Ug.bind(this):t;this.O.TOUCH_ENABLED?(this.O.TOUCH_BOUNCING_ENABLED||document.body.addEventListener("touchmove",
function(a){a.preventDefault()},u),this.Lh=L(this.Ja,"touchstart",this.ij.bind(this)),this.Kh=L(this.Ja,"touchmove",this.gj.bind(this)),this.Jh=L(this.Ja,"touchend",this.cj.bind(this))):(bc(this.Lh),bc(this.Kh),bc(this.Jh));bc(this.cg);bc(this.dg);this.cg=L(this.Ja,"mousemove",this.Ri.bind(this));this.dg=L(this.Ja,"mouseout",this.Si.bind(this))};
Ge.prototype.Pi=function(a){0==a.button?this.ob=q:1==a.button?this.Nb=q:2==a.button&&(this.Ub=q);eval("this.onMouseDown("+this.ob+","+this.Nb+","+this.Ub+")");He(this);a.preventDefault()};Ge.prototype.Oi=ea();Ge.prototype.Ui=function(a){0==a.button?this.ob=u:1==a.button?this.Nb=u:2==a.button&&(this.Ub=u);eval("this.onMouseUp("+this.ob+","+this.Nb+","+this.Ub+")");He(this);a.preventDefault()};Ge.prototype.__defineGetter__("mousePosition",v("pa"));w=Ge.prototype;w.Ti=ea();
w.Si=function(a){this.Qd=u;this.O.KEYBOARD_ENABLED&&(window.onkeydown=t);this.Ub=this.Nb=this.ob=u;He(this);this.Ce=new D.m(0,0,0);a.preventDefault()};w.Qi=ea();w.ij=function(a){a.preventDefault();a.wa(a.jb.targetTouches[0],a.currentTarget);eval("this.onTouchStart("+a.clientX+","+a.clientY+")");this.Qc=new D.m(a.clientX,a.clientY,0);this.mg=setTimeout(this.ej.bind(this,a),500)};w.hj=ea();
w.ej=function(a){eval("this.onTouchHover("+a.clientX+","+a.clientY+")");a=new Hd;a.nb=q;a.Za=this instanceof Ie;this.dispatchEvent(a);this.Ud=q};w.dj=ea();function Je(a){clearTimeout(a.mg);if(a.Ud){var b=new Hd;b.nb=u;b.Za=a instanceof Ie;a.dispatchEvent(b)}a.Ud=u}w.cj=function(a){a.preventDefault();eval("this.onTouchEnd()");Je(this)};w.bj=ea();
w.gj=function(a){a.preventDefault();this.Ud||Je(this);this.touchmoveEvent=a=a.jb;eval("this.onTouchMove(this['touchmoveEvent'])");var b=a.targetTouches;if(1==b.length){a=b[0];var c=[a.clientX,a.clientY];a=new D.m(c[0],c[1],0);var b=c[0]>3*this.Ja.clientWidth/4,e=c[0]<this.Ja.clientWidth/4,d=c[1]<this.Ja.clientHeight/4,c=c[1]>3*this.Ja.clientHeight/4,c=!b&&!e&&!d&&!c,d=this.Qc.Ea(a);this.Qc=a.l();if(this.Ud)a=new Fd,5<d.x?d.x=1:-5>d.x&&(d.x=-1),5<d.y?d.y=1:-5>d.y&&(d.y=-1),a.sa=d,this.dispatchEvent(a);
else if(this instanceof Ke&&(b||e))a=new Id,a.Z=0>d.y,this.dispatchEvent(a);else if(this instanceof Ie||c)d.scale(3),a=new Gd,a.sa=d,this.dispatchEvent(a)}else 2==b.length&&(a=b[0],b=b[1],a=[a.clientX,a.clientY],b=[b.clientX,b.clientY],a=new D.m(a[0],a[1],0),b=new D.m(b[0],b[1],0),d=Fc(a,b),b=d-this.Kg,this.Kg=d,this.Qc.Ea(a),this.Qc=a.l(),10<Math.abs(b)&&(a=new Hd,a.nb=0<b,a.Za=this instanceof Ie,this.dispatchEvent(a)))};w.fj=ea();
w.Ri=function(a){this.mousemoveEvent=a;eval("this.onMouseMove(this['mousemoveEvent'])");this.Qd=q;this.O.KEYBOARD_ENABLED&&window.onkeydown==t&&(window.onkeydown=this.Ug.bind(this));a.preventDefault();var b=a.shiftKey;this.lg=b;this.pa=[a.offsetX,a.offsetY];var c=new D.m(this.pa[0],this.pa[1],0);a=this.Ce.Ea(c);this.Ce=c.l();this.O.HOVERING_ENABLED&&((0<Math.abs(a.x)||0<Math.abs(a.y)||this.Nb||this.ob||this.Ub)&&He(this),this.Md=setTimeout(function(){He(this);var a=new Jd;a.Xd=c.x;a.Yd=c.y;this.dispatchEvent(a);
this.Md=t}.bind(this),300));0!=a.Bb()&&(this.ob&&!b?(b=new Gd,a.scale(3),b.sa=a,this.dispatchEvent(b)):this.Nb||this.ob&&b?(b=new Fd,b.sa=a,this.dispatchEvent(b)):this.Ub&&(b=new Hd,b.nb=0<a.y,b.Za=u,this.dispatchEvent(b)))};function He(a){a.Md&&clearTimeout(a.Md);a.dispatchEvent(new Kd)}w.Vi=ea();w.wd=function(a){this.mouseWheelEvent=a;eval("this.onMouseWheel(this['mouseWheelEvent'])");He(this);a.preventDefault()};w.Mi=ea();
w.Ug=function(a){if(this.Qd){this.keyEvent=a;eval("this.onKey(this['keyEvent'])");He(this);var b=a.altKey,c=a.ctrlKey,e=a.metaKey,d=a.shiftKey,f=a.keyCode;82==f&&!b&&!c&&!e&&!d?(a.preventDefault(),a=new Ld,this.dispatchEvent(a)):37<=f&&40>=f&&(a.preventDefault(),d?a=new Fd:b?a=new Hd:(a=new Gd,this instanceof Ke&&(a=new Id)),a&&(c=new D.m(0,0,0),37==f?(c.x=5,a.Z=u,b&&(a.Z=q,a.nb=q,a.Za=u)):39==f?(c.x=-5,a.Z=q,b&&(a.nb=u,a.Za=u)):38==f?(c.y=5,a.Z=q,b&&(a.nb=q,a.Za=q)):40==f&&(c.y=-5,a.Z=u,b&&(a.nb=
u,a.Za=q)),a.sa=c,this.dispatchEvent(a)))}};B("X.interactor",Ge);B("X.interactor.prototype.init",Ge.prototype.wa);B("X.interactor.prototype.onMouseDown",Ge.prototype.Oi);B("X.interactor.prototype.onMouseUp",Ge.prototype.Ti);B("X.interactor.prototype.onMouseMove",Ge.prototype.Qi);B("X.interactor.prototype.onMouseWheel",Ge.prototype.Vi);B("X.interactor.prototype.onKey",Ge.prototype.Mi);B("X.interactor.prototype.onTouchStart",Ge.prototype.hj);B("X.interactor.prototype.onTouchMove",Ge.prototype.fj);
B("X.interactor.prototype.onTouchEnd",Ge.prototype.bj);B("X.interactor.prototype.onTouchHover",Ge.prototype.dj);function Ke(a){Ge.call(this,a);this.g="interactor2D"}C(Ke,Ge);Ke.prototype.wd=function(a){Ke.z.wd.call(this,a);var b=new Id;a.Jc==t&&(a.Jc=0);b.Z=0>a.Jc;this.dispatchEvent(b)};function Le(a){Y.call(this);this.g="slice";this.A=[0,0,0];this.tc=[0,0,1];this.Z=[0,1,0];this.Td=[1,0,0];this.v=this.H=10;this.Fc=[0,1,0,0,1,1,1,1,1,0,0,0];this.e=this.zb=t;this.ub=q;this.pc=[1,1,1];a!=t&&this.gc(a)}C(Le,Y);Le.prototype.gc=function(a){this.A=a.A.slice();this.tc=a.tc.slice();this.Z=a.Z.slice();this.H=a.H;this.v=a.v;this.zb=a.zb;this.e=a.e;this.ub=a.ub;this.pc=a.pc;this.Fh=a.Fh;Le.z.gc.call(this,a)};Le.prototype.__defineSetter__("height",fa("v"));
Le.prototype.__defineSetter__("width",fa("H"));Le.prototype.create=function(){this.hc()};
Le.prototype.hc=function(){var a=(new U(this.tc[0],this.tc[1],this.tc[2])).normalize(),b=new U(this.Z[0],this.Z[1],this.Z[2]),c=new U(this.Td[0],this.Td[1],this.Td[2]),e=new U(this.A[0],this.A[1],this.A[2]),d=Gc(c.l().U().scale(this.H/2),b.l().U().scale(this.v/2)),f=new U(d.x+e.x,d.y+e.y,d.d+e.d),d=Gc(c.l().U().scale(this.H/2),b.l().scale(this.v/2)),g=new U(d.x+e.x,d.y+e.y,d.d+e.d),d=Gc(c.l().scale(this.H/2),b.l().U().scale(this.v/2)),h=new U(d.x+e.x,d.y+e.y,d.d+e.d),d=Gc(c.l().scale(this.H/2),b.l().scale(this.v/
2)),b=new U(d.x+e.x,d.y+e.y,d.d+e.d);this.h=new W(18);this.q=new W(18);this.h.add(f.x,f.y,f.d);this.h.add(g.x,g.y,g.d);this.h.add(h.x,h.y,h.d);this.h.add(h.x,h.y,h.d);this.h.add(b.x,b.y,b.d);this.h.add(g.x,g.y,g.d);this.q.add(a.x,a.y,a.d);this.q.add(a.x,a.y,a.d);this.q.add(a.x,a.y,a.d);this.q.add(a.x,a.y,a.d);this.q.add(a.x,a.y,a.d);this.q.add(a.x,a.y,a.d);this.ub&&(a=new Y,a.h=new W(24),a.q=new W(24),a.h.add(f.x,f.y,f.d),a.h.add(g.x,g.y,g.d),a.h.add(g.x,g.y,g.d),a.h.add(b.x,b.y,b.d),a.h.add(b.x,
b.y,b.d),a.h.add(h.x,h.y,h.d),a.h.add(h.x,h.y,h.d),a.h.add(f.x,f.y,f.d),a.q.add(0,0,0),a.q.add(0,0,0),a.q.add(0,0,0),a.q.add(0,0,0),a.q.add(0,0,0),a.q.add(0,0,0),a.q.add(0,0,0),a.q.add(0,0,0),a.u=[this.pc[0],this.pc[1],this.pc[2]],a.Da="LINES",a.zc=2,this.c.push(a))};B("X.slice",Le);B("X.slice.prototype.create",Le.prototype.create);function Me(){O.call(this);this.g="parser";this.P=t;this.R=0;this.Hh=0<(new Int8Array((new Int16Array([1])).buffer))[0];this.Od=q;this.Gk=-Infinity;this.Fk=Infinity}C(Me,O);Me.prototype.parse=function(){m(Error("The function parse() should be overloaded."))};function Ne(a){for(var b=Infinity,c=-Infinity,e=a.length,d=0,d=0;d<e;d++)if(!isNaN(a[d]))var f=a[d],b=Math.min(b,f),c=Math.max(c,f);return[b,c]}
function Oe(a,b,c){b===p&&(b=0);c===p&&(c=a.length);for(var e="",d=0,d=b;d<c;++d)e+=String.fromCharCode(a[d]);return e}
function Z(a,b,c){c!=t||(c=1);var e=1,d=Uint8Array;switch(b){case "schar":d=Int8Array;break;case "ushort":d=Uint16Array;e=2;break;case "sshort":d=Int16Array;e=2;break;case "uint":d=Uint32Array;e=4;break;case "sint":d=Int32Array;e=4;break;case "float":d=Float32Array;e=4;break;case "complex":d=Float64Array;e=8;break;case "double":d=Float64Array,e=8}b=new d(a.P.slice(a.R,a.R+=c*e));if(a.Hh!=a.Od){a=b;b=new Uint8Array(a.buffer,a.byteOffset,a.byteLength);for(d=0;d<a.byteLength;d+=e)for(var f=d+e-1,g=d;f>
g;f--,g++){var h=b[g];b[g]=b[f];b[f]=h}b=a}return 1==c?b[0]:b}
function Pe(a,b){var c=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE],e=Pc(0,0,0,1),d=Oc();ad(a,e,d);c[0]=d[0]<c[0]?d[0]:c[0];c[1]=d[0]>c[1]?d[0]:c[1];c[2]=d[1]<c[2]?d[1]:c[2];c[3]=d[1]>c[3]?d[1]:c[3];c[4]=d[2]<c[4]?d[2]:c[4];c[5]=d[2]>c[5]?d[2]:c[5];e=Pc(0,0,b[2]-1,1);ad(a,e,d);c[0]=d[0]<c[0]?d[0]:c[0];c[1]=d[0]>c[1]?d[0]:c[1];c[2]=d[1]<c[2]?d[1]:c[2];c[3]=d[1]>c[3]?d[1]:c[3];c[4]=d[2]<c[4]?d[2]:c[4];c[5]=d[2]>c[5]?d[2]:c[5];e=Pc(0,b[1]-
1,0,1);ad(a,e,d);c[0]=d[0]<c[0]?d[0]:c[0];c[1]=d[0]>c[1]?d[0]:c[1];c[2]=d[1]<c[2]?d[1]:c[2];c[3]=d[1]>c[3]?d[1]:c[3];c[4]=d[2]<c[4]?d[2]:c[4];c[5]=d[2]>c[5]?d[2]:c[5];e=Pc(b[0]-1,0,0,1);ad(a,e,d);c[0]=d[0]<c[0]?d[0]:c[0];c[1]=d[0]>c[1]?d[0]:c[1];c[2]=d[1]<c[2]?d[1]:c[2];c[3]=d[1]>c[3]?d[1]:c[3];c[4]=d[2]<c[4]?d[2]:c[4];c[5]=d[2]>c[5]?d[2]:c[5];e=Pc(b[0]-1,b[1]-1,0,1);ad(a,e,d);c[0]=d[0]<c[0]?d[0]:c[0];c[1]=d[0]>c[1]?d[0]:c[1];c[2]=d[1]<c[2]?d[1]:c[2];c[3]=d[1]>c[3]?d[1]:c[3];c[4]=d[2]<c[4]?d[2]:c[4];
c[5]=d[2]>c[5]?d[2]:c[5];e=Pc(b[0]-1,0,b[2]-1,1);ad(a,e,d);c[0]=d[0]<c[0]?d[0]:c[0];c[1]=d[0]>c[1]?d[0]:c[1];c[2]=d[1]<c[2]?d[1]:c[2];c[3]=d[1]>c[3]?d[1]:c[3];c[4]=d[2]<c[4]?d[2]:c[4];c[5]=d[2]>c[5]?d[2]:c[5];e=Pc(0,b[1]-1,b[2]-1,1);ad(a,e,d);c[0]=d[0]<c[0]?d[0]:c[0];c[1]=d[0]>c[1]?d[0]:c[1];c[2]=d[1]<c[2]?d[1]:c[2];c[3]=d[1]>c[3]?d[1]:c[3];c[4]=d[2]<c[4]?d[2]:c[4];c[5]=d[2]>c[5]?d[2]:c[5];e=Pc(b[0]-1,b[1]-1,b[2]-1,1);ad(a,e,d);c[0]=d[0]<c[0]?d[0]:c[0];c[1]=d[0]>c[1]?d[0]:c[1];c[2]=d[1]<c[2]?d[1]:
c[2];c[3]=d[1]>c[3]?d[1]:c[3];c[4]=d[2]<c[4]?d[2]:c[4];c[5]=d[2]>c[5]?d[2]:c[5];return c}
function Qe(a,b){var c=Rc();if(!(a.length==b.length&&a[0]==b[0]&&a[1]==b[1]&&a[2]==b[2])){var e=Math.acos(a[2]),d=Lc(),f=a[0],g=a[1],h=a[2],l=b[0],j=b[1],k=b[2];d[0]=g*k-h*j;d[1]=h*l-f*k;d[2]=f*j-g*l;Nc(d,d);f=Math.cos(e/2);g=Math.sin(e/2)*d[0];h=Math.sin(e/2)*d[1];e=Math.sin(e/2)*d[2];V(c,0,f*f+g*g-h*h-e*e,2*(g*h-f*e),2*(g*e+f*h),0);V(c,1,2*(g*h+f*e),f*f+h*h-g*g-e*e,2*(h*e-f*g),0);V(c,2,2*(g*e-f*h),2*(h*e+f*g),f*f+e*e-h*h-g*g,0)}e=Qc();Zc(c,e);return[c,e]}
function Re(a,b,c,e,d,f,g,h,l){var j=new Le;Nc(c,c);for(var k=[],n=[],r=0;6>r;r++)for(var s=Math.floor(r/2),z=(s+1)%3,y=(s+2)%3,E=(4+2*s)%6,F=0;2>F;F++){var K=(2+F+2*s)%6,A=-(c[s]*(d[r]-a[s])+c[z]*(d[K]-a[z]))/c[y]+a[y];if(A>=d[E]&&A<=d[E+1]||A<=d[E]&&A>=d[E+1]){var G=[];G[s]=d[r];G[z]=d[K];G[y]=A;k.push(G)}else G=[],G[s]=d[r],G[z]=d[K],G[y]=A,n.push(G)}a=Mc(0,0,1);a=Qe(c,a);d=a[0];a=a[1];s=[];for(n=0;n<k.length;++n)r=Pc(k[n][0],k[n][1],k[n][2],1),z=Oc(),ad(d,r,z),s.push([z[0],z[1],z[2]]);d=Mc(1,
0,0);k=Lc();$c(a,d,k);n=Mc(0,1,0);d=Lc();$c(a,n,d);r=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];for(n=n=0;n<s.length;++n)s[n][0]<r[0]&&(r[0]=s[n][0]),s[n][0]>r[1]&&(r[1]=s[n][0]),s[n][1]<r[2]&&(r[2]=s[n][1]),s[n][1]>r[3]&&(r[3]=s[n][1]),s[n][2]<r[4]&&(r[4]=s[n][2]),s[n][2]>r[5]&&(r[5]=s[n][2]);n=Pc(r[0]+(r[1]-r[0])/2,r[2]+(r[3]-r[2])/2,r[4]+(r[5]-r[4])/2,0);s=Oc();Yc(a,n,s);z=Math.floor(r[0]);y=Math.ceil(r[1]);z==y&&y++;E=y-z;F=Math.floor(r[2]);
K=Math.ceil(r[3]);A=K-F;G=b[0];b=b[1];var n=Math.ceil(E/G),I=Math.ceil(A/b),H=new Uint8Array(4*n*I),R=new ed;R.Ne=n;R.Me=I;var I=Oc(),N=Pc(0,0,r[4],1),S=Qc();Yc(g.yh,a,S);for(var ba=K-1E-7,aa=y-1E-7,ca=0,M=0,T=0,P=F,P=F;P<=ba;P+=b){T++;M=0;N[1]=P;for(n=z;n<=aa;n+=G){M++;N[0]=n;ad(S,N,I);var Ea=4*ca,sb=Math.floor(I[2]),tb=Math.floor(I[1]),ub=Math.floor(I[0]);if(0<=ub&&ub<g.oa[0]&&0<=tb&&tb<g.oa[1]&&0<=sb&&sb<g.oa[2]){var kb=f[sb][tb][ub],Tc=ub=tb=sb=0;l?((kb=l.get(kb))||(kb=[0,0.61,0,0,1]),sb=255*
kb[1],tb=255*kb[2],ub=255*kb[3],Tc=255*kb[4]):(sb=tb=ub=255*(kb/g.ma),Tc=255);H[Ea]=sb;H[++Ea]=tb;H[++Ea]=ub;H[++Ea]=Tc}else H[Ea]=0,H[++Ea]=0,H[++Ea]=0,H[++Ea]=0;ca++}}R.Tb=H;j.C=R;j.Nh=r;j.Ah=a;j.zh=S;j.Gh=F;j.Dk=K;j.Mh=z;j.Ik=y;j.Zf=M;j.Yf=T;j.Hc=G;j.H=E;j.uc=b;j.v=A;j.A=[s[0],s[1],s[2]];j.tc=[c[0],c[1],c[2]];j.Td=[k[0],k[1],k[2]];j.Z=[d[0],d[1],d[2]];j.L=u;j.zb=g;j.ub=g.zb!=t&&!h?u:q;j.pc=e;j.hc();j.L=u;return j}
function Se(a,b,c,e){var d;d=e.ka;for(var f=[],g=[],h=0;6>h;h++){var l=Math.floor(h/2),j=(l+1)%3,k=(l+2)%3,n=(2+2*l)%6,r=(4+2*l)%6,s=(d[h]-b[l])*(1/c[l]);if(Infinity!=s&&-Infinity!=s){var z=b[j]+c[j]*s,s=b[k]+c[k]*s;z>=d[n]&&z<=d[n+1]&&s>=d[r]&&s<=d[r+1]?(n=[],n[l]=d[h],n[j]=z,n[k]=s,f.push(n)):(n=[],n[l]=d[h],n[j]=z,n[k]=s,g.push(n))}}d=[f,g];b=d[0];e.b[a].k=d;d=Ec(new U(b[0][0],b[0][1],b[0][2]),new U(b[1][0],b[1][1],b[1][2]));e.b[a].Ck=d;f=Mc(0,0,1);g=Qe(c,f)[0];h=Pc(e.ye[0],e.ye[1],e.ye[2],0);
f=Oc();ad(g,h,f);g=Oc();h=f[2];g[0]=c[0]*h;g[1]=c[1]*h;g[2]=c[2]*h;g[3]=c[3]*h;0.5>Math.abs(f[0])&&(f[0]=0.5);0.5>Math.abs(f[1])&&(f[1]=0.5);e.b[a].Ca=[Math.abs(f[0]),Math.abs(f[1])];e.b[a].Dc=f[2];e.b[a].w=g;d=Math.floor(Math.abs(d/f[2]));e.cd[a]=d+1;e.b[a].o=d+1;e.b[a].k[0][0][0]>e.b[a].k[0][1][0]?0<g[0]&&(d=e.b[a].k[0][0],e.b[a].k[0][0]=e.b[a].k[0][1],e.b[a].k[0][1]=d):e.b[a].k[0][0][0]<e.b[a].k[0][1][0]?0>g[0]&&(d=e.b[a].k[0][0],e.b[a].k[0][0]=e.b[a].k[0][1],e.b[a].k[0][1]=d):e.b[a].k[0][0][1]>
e.b[a].k[0][1][1]?0<g[1]&&(d=e.b[a].k[0][0],e.b[a].k[0][0]=e.b[a].k[0][1],e.b[a].k[0][1]=d):e.b[a].k[0][0][1]<e.b[a].k[0][1][1]?0>g[1]&&(d=e.b[a].k[0][0],e.b[a].k[0][0]=e.b[a].k[0][1],e.b[a].k[0][1]=d):e.b[a].k[0][0][2]>e.b[a].k[0][1][2]?0<g[2]&&(d=e.b[a].k[0][0],e.b[a].k[0][0]=e.b[a].k[0][1],e.b[a].k[0][1]=d):e.b[a].k[0][0][2]<e.b[a].k[0][1][2]&&0>g[2]&&(d=e.b[a].k[0][0],e.b[a].k[0][0]=e.b[a].k[0][1],e.b[a].k[0][1]=d);e.b[a].Je=-(c[0]*b[0][0]+c[1]*b[0][1]+c[2]*b[0][2])}
function Ve(a,b){var c;c=b.P;for(var e=b.oa,d=b.ma,f=Array(e[2]),g=Array(e[2]),h=e[1]*e[0],l=0,j=0,k=0,n=0,r=0,n=0;n<e[2];n++){var s=c.subarray(n*h,(n+1)*h),r=0;g[n]=Array(e[1]);f[n]=Array(e[1]);for(k=0;k<e[1];k++){g[n][k]=new c.constructor(e[0]);f[n][k]=new c.constructor(e[0]);for(j=0;j<e[0];j++)l=s[r],g[n][k][j]=255*(l/d),f[n][k][j]=l,r++}}c=[f,g];b.ba=c[0];b.Ak=c[1];D.Ya(a.g+".reslice");b.I=b.e!=t;b.Aa&&(b.Oc=b.Aa.Fa);b.Vk=[0,0,0];b.t=[b.ya[0]+(b.tb[0]-1)/2,b.ya[1]+(b.tb[1]-1)/2,b.ya[2]+(b.tb[2]-
1)/2];b.ka=[Math.min(b.ya[0],b.ya[0]+b.tb[0]-1),Math.max(b.ya[0],b.ya[0]+b.tb[0]-1),Math.min(b.ya[1],b.ya[1]+b.tb[1]-1),Math.max(b.ya[1],b.ya[1]+b.tb[1]-1),Math.min(b.ya[2],b.ya[2]+b.tb[2]-1),Math.max(b.ya[2],b.ya[2]+b.tb[2]-1)];b.b=[{},{},{}];c=Mc(b.t[0],b.t[1],b.t[2]);b.b[0].ed=c;e=Mc(1,0,0);Nc(e,e);b.b[0].i=e;d=[1,0,0];b.b[0].u=d;Se(0,c,e,b);b.c[0].c=Array(b.b[0].o);c[0]=b.b[0].k[0][0][0]+b.b[0].w[0]*Math.floor(b.b[0].o/2);c[1]=b.b[0].k[0][0][1]+b.b[0].w[1]*Math.floor(b.b[0].o/2);c[2]=b.b[0].k[0][0][2]+
b.b[0].w[2]*Math.floor(b.b[0].o/2);c=Re(c,b.b[0].Ca,b.b[0].i,b.b[0].u,b.ka,b.ba,b,b.I,b.Oc);b.I&&(c.e=b.e.c[0].c[Math.floor(b.b[0].o/2)].C);b.c[0].c[Math.floor(b.b[0].o/2)]=c;b.vb=Math.floor(b.b[0].o/2);b.vc=Math.floor(b.b[0].o/2);c=Mc(b.t[0],b.t[1],b.t[2]);b.b[1].ed=c;e=Mc(0,1,0);Nc(e,e);b.b[1].i=e;d=[0,1,0];b.b[1].u=d;Se(1,c,e,b);b.c[1].c=Array(b.b[1].o);c[0]=b.b[1].k[0][0][0]+b.b[1].w[0]*Math.floor(b.b[1].o/2);c[1]=b.b[1].k[0][0][1]+b.b[1].w[1]*Math.floor(b.b[1].o/2);c[2]=b.b[1].k[0][0][2]+b.b[1].w[2]*
Math.floor(b.b[1].o/2);c=Re(c,b.b[1].Ca,b.b[1].i,b.b[1].u,b.ka,b.ba,b,b.I,b.Oc);b.I&&(c.e=b.e.c[1].c[Math.floor(b.b[1].o/2)].C);b.c[1].c[Math.floor(b.b[1].o/2)]=c;b.wb=Math.floor(b.b[1].o/2);b.wc=Math.floor(b.b[1].o/2);c=Mc(b.t[0],b.t[1],b.t[2]);b.b[2].ed=c;e=Mc(0,0,1);Nc(e,e);b.b[2].i=e;d=[0,0.392,0.804];b.b[2].u=d;Se(2,c,e,b);b.c[2].c=Array(b.b[2].o);c[0]=b.b[2].k[0][0][0]+b.b[2].w[0]*Math.floor(b.b[2].o/2);c[1]=b.b[2].k[0][0][1]+b.b[2].w[1]*Math.floor(b.b[2].o/2);c[2]=b.b[2].k[0][0][2]+b.b[2].w[2]*
Math.floor(b.b[2].o/2);c=Re(c,b.b[2].Ca,b.b[2].i,b.b[2].u,b.ka,b.ba,b,b.I,b.Oc);b.I&&(c.e=b.e.c[2].c[Math.floor(b.b[2].o/2)].C);b.c[2].c[Math.floor(b.b[2].o/2)]=c;b.xb=Math.floor(b.b[2].o/2);b.xc=Math.floor(b.b[2].o/2);D.Ua(a.g+".reslice");return b.ba};function Q(a){Y.call(this);this.g="volume";this.A=[0,0,0];this.oa=[10,10,10];this.ka=[1,1,1];this.cd=[10,10,10];this.kd=[1,1,1];this.Jb=[];this.xc=this.xb=this.wc=this.wb=this.vc=this.vb=0;this.gd=new Y;this.hd=new Y;this.jd=new Y;this.Wd=this.Ma=u;this.T=-1;this.ng=[];this.e=t;this.ub=q;this.ia=Infinity;this.ha=-Infinity;this.kg=q;this.ma=0;this.P=t;Ga(this,new wc);Ga(this,new hd);a!=t&&this.gc(a)}C(Q,Y);
Q.prototype.gc=function(a){this.A=a.A.slice();this.oa=a.oa.slice();this.kd=a.kd.slice();this.vb=a.vb;this.vc=a.vc;this.wb=a.wb;this.wc=a.wc;this.xb=a.xb;this.xc=a.xc;this.Tf=a.Tf.slice();this.gd=new Y(a.gd);this.hd=new Y(a.hd);this.jd=new Y(a.jd);this.ma=a.ma;this.P=a.P;this.Ma=a.Ma;this.Wd=a.Wd;this.T=a.T;this.e=a.e;this.ub=a.ub;Q.z.gc.call(this,a)};
Q.prototype.hc=function(a){this.c.length=0;this.gd.c.length=0;this.hd.c.length=0;this.jd.c.length=0;this.c.push(this.gd);this.c.push(this.hd);this.c.push(this.jd);this.ya=a.Ed;this.ye=a.Fd;this.tb=a.Dd;this.oc=a.Fb;this.yh=a.Gb;this.ma=a.max;this.P=a.data;this.j=q};
Q.prototype.p=function(a){a="undefined"!==typeof a?a:q;if(0<this.c.length){this.Ma!=this.Wd&&(!this.Ma&&-1!=this.T&&(this.c[this.T].visible=u),this.j=q,this.Wd=this.Ma);if(!this.L)return;for(var b=0,b=0;3>b;b++){var c=this.c[b],e=0,d=0;0==b?(e=this.vb,d=this.vc,this.vc=this.vb):1==b?(e=this.wb,d=this.wc,this.wc=this.wb):2==b&&(e=this.xb,d=this.xc,this.xc=this.xb);if(this.c[b].c[parseInt(e,10)]==t){var f=Lc();f[0]=this.b[b].k[0][0][0]+this.b[b].w[0]*parseInt(e,10);f[1]=this.b[b].k[0][0][1]+this.b[b].w[1]*
parseInt(e,10);f[2]=this.b[b].k[0][0][2]+this.b[b].w[2]*parseInt(e,10);if(this.I){var g=Re(f,this.b[b].Ca,this.b[b].i,this.b[b].u,this.ka,this.e.ba,this.e,this.e.I,this.e.Aa.Fa);this.e.c[b].c[parseInt(e,10)]=g;this.e.c[b].p(q)}f=Re(f,this.b[b].Ca,this.b[b].i,this.b[b].u,this.ka,this.ba,this,q,t);this.I&&(f.e=f.C,f.e=this.e.c[b].c[parseInt(e,10)].C);c.c[parseInt(e,10)]=f;this.c[b].p(q)}d=c.c[parseInt(d,10)];this.Ma||(d.visible=u);c=c.c[parseInt(e,10)];c.visible=q;c.qa=1;this.Ma&&(c.c[0].L=u,b!=this.T&&
(c.visible=u,c.qa=0))}this.Ma&&-1!=this.T&&We(this,this.T)}a&&Q.z.p.call(this)};Q.prototype.__defineGetter__("dimensions",v("oa"));Q.prototype.__defineGetter__("bbox",v("ka"));Q.prototype.__defineGetter__("range",v("cd"));Q.prototype.__defineGetter__("dimensionsRAS",v("Tf"));Q.prototype.__defineGetter__("volumeRendering",v("Ma"));Q.prototype.__defineSetter__("volumeRendering",function(a){this.Ma=a;this.p(u)});Q.prototype.__defineGetter__("visible",v("L"));
Q.prototype.__defineSetter__("visible",function(a){if(a)this.L=a,this.p(u);else{for(var b=this.c,c=b.length,e=0,e=0;e<c;e++)b[e].visible=a;this.L=a;this.j=q}});Q.prototype.__defineGetter__("center",v("A"));Q.prototype.__defineSetter__("center",function(a){(a==t||!la(a)||3!=a.length)&&m(Error("Invalid center."));this.A=a});Q.prototype.__defineGetter__("image",v("Jb"));Q.prototype.__defineGetter__("labelmap",function(){this.e||(this.e=new Xe(this));return this.e});
Q.prototype.__defineGetter__("indexX",v("vb"));Q.prototype.__defineSetter__("indexX",function(a){x(a)&&(0<=a&&a<this.gd.c.length)&&(this.vb=a,this.p(u))});Q.prototype.__defineGetter__("indexY",v("wb"));Q.prototype.__defineSetter__("indexY",function(a){x(a)&&(0<=a&&a<this.hd.c.length)&&(this.wb=a,this.p(u))});Q.prototype.__defineGetter__("indexZ",v("xb"));Q.prototype.__defineSetter__("indexZ",function(a){x(a)&&(0<=a&&a<this.jd.c.length)&&(this.xb=a,this.p(u))});
Q.prototype.__defineGetter__("windowLow",v("ia"));Q.prototype.__defineSetter__("windowLow",fa("ia"));Q.prototype.__defineGetter__("windowHigh",v("ha"));Q.prototype.__defineSetter__("windowHigh",fa("ha"));Q.prototype.__defineGetter__("borders",v("ub"));Q.prototype.__defineSetter__("borders",fa("ub"));Q.prototype.__defineGetter__("reslicing",v("kg"));Q.prototype.__defineSetter__("reslicing",fa("kg"));Q.prototype.__defineSetter__("xNormX",function(a){this.b[0].i[0]=a});
Q.prototype.__defineGetter__("xNormX",function(){return this.b[0].i[0]});Q.prototype.__defineSetter__("xNormY",function(a){this.b[0].i[1]=a});Q.prototype.__defineGetter__("xNormY",function(){return this.b[0].i[1]});Q.prototype.__defineSetter__("xNormZ",function(a){this.b[0].i[2]=a});Q.prototype.__defineGetter__("xNormZ",function(){return this.b[0].i[2]});Q.prototype.__defineSetter__("xColor",function(a){this.b[0].u=a});Q.prototype.__defineGetter__("xColor",function(){return this.b[0].u});
Q.prototype.__defineSetter__("yNormX",function(a){this.b[1].i[0]=a});Q.prototype.__defineGetter__("yNormX",function(){return this.b[1].i[0]});Q.prototype.__defineSetter__("yNormY",function(a){this.b[1].i[1]=a});Q.prototype.__defineGetter__("yNormY",function(){return this.b[1].i[1]});Q.prototype.__defineSetter__("yNormZ",function(a){this.b[1].i[2]=a});Q.prototype.__defineGetter__("yNormZ",function(){return this.b[1].i[2]});Q.prototype.__defineSetter__("yColor",function(a){this.b[1].u=a});
Q.prototype.__defineGetter__("yColor",function(){return this.b[1].u});Q.prototype.__defineSetter__("zNormX",function(a){this.b[2].i[0]=a});Q.prototype.__defineGetter__("zNormX",function(){return this.b[2].i[0]});Q.prototype.__defineSetter__("zNormY",function(a){this.b[2].i[1]=a});Q.prototype.__defineGetter__("zNormY",function(){return this.b[2].i[1]});Q.prototype.__defineSetter__("zNormZ",function(a){this.b[2].i[2]=a});Q.prototype.__defineGetter__("zNormZ",function(){return this.b[2].i[2]});
Q.prototype.__defineSetter__("zColor",function(a){this.b[2].u=a});Q.prototype.__defineGetter__("zColor",function(){return this.b[2].u});
Q.prototype.zj=function(a){this.c[a].visible=u;for(var b=0;b<this.c[a].c.length;b++)"undefined"!=typeof this.c[a].c[b]&&(this.I&&(this.e.c[a].c[b].remove(),this.e.c[a].c[b]=t),this.c[a].c[b].remove(),this.c[a].c[b]=t);Nc(this.b[a].i,this.b[a].i);Se(a,this.b[a].ed,this.b[a].i,this);this.c[a].c=[];this.c[a].c=Array(this.b[a].o);this.I&&(b=Re(this.b[a].ed,this.b[a].Ca,this.b[a].i,this.b[a].u,this.ka,this.e.ba,this.e,this.e.I,this.e.Aa.Fa),this.e.c[a].c=[],this.e.c[a].c=Array(this.b[a].o),this.e.c[a].c[Math.floor(this.b[a].o/
2)]=b,this.e.c[a].p());b=Re(this.b[a].ed,this.b[a].Ca,this.b[a].i,this.b[a].u,this.ka,this.ba,this,q,t);this.I&&(b.e=b.C,b.e=this.e.c[a].c[Math.floor(this.b[a].o/2)].C);this.c[a].c[Math.floor(this.b[a].o/2)]=b;0==a?(this.vb=Math.floor(this.b[a].o/2),this.vc=Math.floor(this.b[a].o/2)):1==a?(this.wb=Math.floor(this.b[a].o/2),this.wc=Math.floor(this.b[a].o/2)):(this.xb=Math.floor(this.b[a].o/2),this.xc=Math.floor(this.b[a].o/2));this.c[a].p();this.c[a].c[Math.floor(this.b[a].o/2)].L=q};
function We(a,b){if(!a.Id)if(!a.Ma||!a.j&&b==a.T)a.T=b;else if(-1==a.ng.indexOf(b)){a.ng.push(b);a.Id=q;var c=new Nd;c.K=a;a.dispatchEvent(c);a.onComputing(b);setTimeout(function(){var a=t;0<=this.T&&(a=this.c[this.T],a.visible=u);var a=this.c[b],c=a.c.length,d=Math.floor(c/4),e;for(e=0;e<1*d;e++){if(a.c[e]==t){var j=Lc();j[0]=this.b[b].k[0][0][0]+this.b[b].w[0]*e;j[1]=this.b[b].k[0][0][1]+this.b[b].w[1]*e;j[2]=this.b[b].k[0][0][2]+this.b[b].w[2]*e;if(this.I){var k=Re(j,this.b[b].Ca,this.b[b].i,this.b[b].u,
this.ka,this.e.ba,this.e,this.e.I,this.e.Aa.Fa);this.e.c[b].c[e]=k;this.e.c[b].p(q)}j=Re(j,this.b[b].Ca,this.b[b].i,this.b[b].u,this.ka,this.ba,this,q,t);j.c[0].L=u;this.I&&(j.e=j.C,j.e=this.e.c[b].c[e].C);a.c[e]=j}a.c[e].L=q}Ye(this,0.25);setTimeout(function(){for(;e<2*d;e++){if(a.c[e]==t){var j=Lc();j[0]=this.b[b].k[0][0][0]+this.b[b].w[0]*e;j[1]=this.b[b].k[0][0][1]+this.b[b].w[1]*e;j[2]=this.b[b].k[0][0][2]+this.b[b].w[2]*e;if(this.I){var k=Re(j,this.b[b].Ca,this.b[b].i,this.b[b].u,this.ka,this.e.ba,
this.e,this.e.I,this.e.Aa.Fa);this.e.c[b].c[e]=k;this.e.c[b].p(q)}j=Re(j,this.b[b].Ca,this.b[b].i,this.b[b].u,this.ka,this.ba,this,q,t);j.c[0].L=u;this.I&&(j.e=j.C,j.e=this.e.c[b].c[e].C);a.c[e]=j}a.c[e].L=q}Ye(this,0.5);setTimeout(function(){for(;e<3*d;e++){if(a.c[e]==t){var j=Lc();j[0]=this.b[b].k[0][0][0]+this.b[b].w[0]*e;j[1]=this.b[b].k[0][0][1]+this.b[b].w[1]*e;j[2]=this.b[b].k[0][0][2]+this.b[b].w[2]*e;if(this.I){var k=Re(j,this.b[b].Ca,this.b[b].i,this.b[b].u,this.ka,this.e.ba,this.e,this.e.I,
this.e.Aa.Fa);this.e.c[b].c[e]=k;this.e.c[b].p(q)}j=Re(j,this.b[b].Ca,this.b[b].i,this.b[b].u,this.ka,this.ba,this,q,t);j.c[0].L=u;this.I&&(j.e=j.C,j.e=this.e.c[b].c[e].C);a.c[e]=j}a.c[e].L=q}Ye(this,0.75);setTimeout(function(){for(e=3*d;e<c;e++){if(a.c[e]==t){var j=Lc();j[0]=this.b[b].k[0][0][0]+this.b[b].w[0]*e;j[1]=this.b[b].k[0][0][1]+this.b[b].w[1]*e;j[2]=this.b[b].k[0][0][2]+this.b[b].w[2]*e;if(this.I){var k=Re(j,this.b[b].Ca,this.b[b].i,this.b[b].u,this.ka,this.e.ba,this.e,this.e.I,this.e.Aa.Fa);
this.e.c[b].c[e]=k;this.e.c[b].p(q)}j=Re(j,this.b[b].Ca,this.b[b].i,this.b[b].u,this.ka,this.ba,this,q,t);j.c[0].L=u;this.I&&(j.e=j.C,j.e=this.e.c[b].c[e].C);a.c[e]=j}a.c[e].L=q}Ye(this,1);setTimeout(function(){this.Id&&this.c[b].p(q);this.T=b;this.j=u;if(this.Id){var a=new Pd;a.K=this;this.dispatchEvent(a);this.onComputingEnd(b)}this.Id=u}.bind(this),10)}.bind(this),10)}.bind(this),10)}.bind(this),10)}.bind(a),10)}else{c=a.c[a.T];c.visible=u;var c=a.c[b],e=c.c.length,d;for(d=0;d<e;d++)c.c[d].L=q;
a.T=b;a.j=u}}function Ye(a,b){var c=new Od;c.od=b;a.dispatchEvent(c);a.onComputingProgress(100*b)}Q.prototype.sf=ea();Q.prototype.uf=ea();Q.prototype.tf=ea();B("X.volume",Q);B("X.volume.prototype.modified",Q.prototype.p);B("X.volume.prototype.sliceInfoChanged",Q.prototype.zj);B("X.volume.prototype.onComputing",Q.prototype.sf);B("X.volume.prototype.onComputingProgress",Q.prototype.uf);B("X.volume.prototype.onComputingEnd",Q.prototype.tf);function Ze(){Me.call(this);this.g="parserSTL"}C(Ze,Me);
Ze.prototype.parse=function(a,b,c){D.Ya(this.g+".parse");this.P=c;var e=b.h,d=b.q;if("solid"==Oe(Z(this,"uchar",5))){b.h=e=new W(c.byteLength);b.q=d=new W(c.byteLength);var f=e,e=d,d=Z(this,"uchar",c.byteLength-5);c=d.length;var g=u,h=u,l=0,j;for(j=0;j<c;j++)if(10==d[j]){if(g||h){var k=Oe(d,l,j).split(" "),h=parseFloat(k[0]),n=parseFloat(k[1]),k=parseFloat(k[2]);g?(e.add(h,n,k),e.add(h,n,k),e.add(h,n,k)):f.add(h,n,k);h=g=u}}else 32==d[j-1]&&(102==d[j]?(l=j+=13,g=q):118==d[j]&&(l=j+=7,h=q))}else{this.R=
80;f=Z(this,"uint");b.h=e=new W(9*f);b.q=d=new W(9*f);for(c=c=0;c<f;c++)g=Z(this,"float",12),l=g[0],j=g[1],h=g[2],d.add(l,j,h),d.add(l,j,h),d.add(l,j,h),e.add(g[3],g[4],g[5]),e.add(g[6],g[7],g[8]),e.add(g[9],g[10],g[11]),this.R+=2}D.Ua(this.g+".parse");f=new jd;f.K=b;f.B=a;this.dispatchEvent(f)};B("X.parserSTL",Ze);B("X.parserSTL.prototype.parse",Ze.prototype.parse);function $e(){Me.call(this);this.g="parserDCM"}C($e,Me);
$e.prototype.parse=function(a,b,c){b.nc={};b.nc.lf=0;this.yd(c,b);if(b.r.length==t||b.na.length==b.r.length){b.nc.lf=b.r.length;var e={};c={};for(var d=0;d<b.na.length;d++)e.hasOwnProperty(b.na[d].series_instance_uid)||(e[b.na[d].series_instance_uid]=[],c[b.na[d].series_instance_uid]={}),c[b.na[d].series_instance_uid].hasOwnProperty(b.na[d].sop_instance_uid)||(c[b.na[d].series_instance_uid][b.na[d].sop_instance_uid]=q,e[b.na[d].series_instance_uid].push(b.na[d]));var f=Object.keys(e)[0],d=e[f],g=
d.length;c={};var h="image_position_patient";1==g?(h="image_position_patient",e[f][0].dist=0):d[0].image_position_patient[0]!=d[1].image_position_patient[0]||d[0].image_position_patient[1]!=d[1].image_position_patient[1]||d[0].image_position_patient[2]!=d[1].image_position_patient[2]?(h="image_position_patient",e=new U(d[0].image_orientation_patient[0],d[0].image_orientation_patient[1],d[0].image_orientation_patient[2]),f=new U(d[0].image_orientation_patient[3],d[0].image_orientation_patient[4],d[0].image_orientation_patient[5]),
e=Hc(e,f),d.map(function(a,b){b.dist=b.image_position_patient[0]*a.x+b.image_position_patient[1]*a.y+b.image_position_patient[2]*a.d;return b}.bind(t,e)),d.sort(function(a,b){return a.dist-b.dist})):d[0].instance_number!=d[1].instance_number?(h="instance_number",d.sort(function(a,b){return a.instance_number-b.instance_number})):window.console.log("Could not resolve the ordering mode");isNaN(d[0].pixel_spacing[0])&&(d[0].pixel_spacing[0]=1);isNaN(d[0].pixel_spacing[1])&&(d[0].pixel_spacing[1]=1);if(1<
g)switch(h){case "image_position_patient":var l=d[0].image_position_patient,e=d[1].image_position_patient,f=e[0]-l[0],j=e[1]-l[1],k=e[2]-l[2];d[0].pixel_spacing[2]=Math.sqrt(f*f+j*j+k*k);break;case "instance_number":d[0].pixel_spacing[2]=1;break;default:window.console.log("Unkown ordering mode - returning: "+h)}else d[0].pixel_spacing[2]=1;e=1;switch(h){case "image_position_patient":var l=d[0].image_position_patient,n=d[g-1].image_position_patient,f=n[0]-l[0],j=n[1]-l[1],k=n[2]-l[2],f=Math.sqrt(f*
f+j*j+k*k),e=e+Math.round(f/d[0].pixel_spacing[2]);break;case "instance_number":e+=Math.abs(d[g-1].instance_number-d[0].instance_number);break;default:window.console.log("Unkown ordering mode - returning: "+h)}l=d[0].columns*d[0].rows;f=l*e;n=t;switch(d[0].Ve){case 8:n=new Uint8Array(f);break;case 16:n=new Uint16Array(f);break;case 32:n=new Uint32Array(f);default:window.console.log("Unknown number of bits allocated - using default: 32 bits")}b.kd=d[0].pixel_spacing;for(var r=0;r<g;r++){var s=d[r].data,
f=0;switch(h){case "image_position_patient":f=d[r].image_position_patient[0]-d[0].image_position_patient[0];j=d[r].image_position_patient[1]-d[0].image_position_patient[1];k=d[r].image_position_patient[2]-d[0].image_position_patient[2];f=Math.sqrt(f*f+j*j+k*k)/d[0].pixel_spacing[2];break;case "instance_number":f=d[r].instance_number-d[0].instance_number;break;default:window.console.log("Unkown ordering mode - returning: "+h)}n.set(s,f*l)}c.data=n;b.P=n;b.oa=[d[0].columns,d[0].rows,e];c.Nk=b.oa;e=
Ne(n);g=e[0];e=e[1];c.min=b.cb=b.ia=g;c.max=b.ma=b.ha=e;-Infinity==b.fa&&(b.fa=g);Infinity==b.ga&&(b.ga=e);j=d[0].image_position_patient;g=Qc();switch(h){case "image_position_patient":e=new U(d[0].image_orientation_patient[0],d[0].image_orientation_patient[1],d[0].image_orientation_patient[2]);f=new U(d[0].image_orientation_patient[3],d[0].image_orientation_patient[4],d[0].image_orientation_patient[5]);e=Hc(e,f);V(g,0,-d[0].image_orientation_patient[0]*d[0].pixel_spacing[0],-d[0].image_orientation_patient[3]*
d[0].pixel_spacing[1],-e.x*d[0].pixel_spacing[2],-j[0]);V(g,1,-d[0].image_orientation_patient[1]*d[0].pixel_spacing[0],-d[0].image_orientation_patient[4]*d[0].pixel_spacing[1],-e.y*d[0].pixel_spacing[2],-j[1]);V(g,2,d[0].image_orientation_patient[2]*d[0].pixel_spacing[0],d[0].image_orientation_patient[5]*d[0].pixel_spacing[1],e.d*d[0].pixel_spacing[2],j[2]);V(g,3,0,0,0,1);break;case "instance_number":V(g,0,-1,0,0,-j[0]);V(g,1,-0,-1,-0,-j[1]);V(g,2,0,0,1,j[2]);V(g,3,0,0,0,1);break;default:window.console.log("Unkown ordering mode - returning: "+
h)}c.Fb=g;c.Gb=Qc();Zc(c.Fb,c.Gb);h=Pc(0,0,0,1);d=Oc();ad(g,h,d);h=Pc(1,1,1,1);e=Oc();ad(g,h,e);c.Fd=[e[0]-d[0],e[1]-d[1],e[2]-d[2]];d=Pe(g,[b.oa[0],b.oa[1],b.oa[2]]);c.Dd=[d[1]-d[0]+1,d[3]-d[2]+1,d[5]-d[4]+1];c.Ed=[d[0],d[2],d[4]];b.hc(c);b.Jb=Ve(this,b)}c=new jd;c.K=b;c.B=a;this.dispatchEvent(c)};
function af(a,b,c,e){switch(c){case 16975:case 20819:case 20053:case 22351:c=function(a){for(var b="",c=128;1<=c;c/=2)b+=a&c?"1":"0";return b};e=a[b++];a=a[b++];e=parseInt(c((a&65280)>>8)+c(a&255)+(c((e&65280)>>8)+c(e&255)),2);4294967295==e&&(e=0);b+=e/2;break;default:b+=e/2}return b}
$e.prototype.yd=function(a,b){this.P=a;if("undefined"==typeof b.na||b.na==t)b.na=[];for(var c={pixel_spacing:[0.1,0.1,Infinity],image_orientation_patient:[1,0,0,0,1,0],image_position_patient:[0,0,0],transfer_syntax_uid:"no_transfer_syntax_uid"},e=Z(this,"ushort",this.P.byteLength),d=66,f=t,g=t,h=t,l=t;d<e.length;)switch(f=e[d++],g=e[d++],h=e[d++],l=e[d++],"1.2.840.10008.1.2"==c.transfer_syntax_uid&&0==l&&(l=h),f){case 2:switch(g){case 16:for(var j="",f=f=0;f<l/2;f++)h=e[d++],g=h&255,h=(h&65280)>>
8,j+=String.fromCharCode(g),j+=String.fromCharCode(h);c.transfer_syntax_uid=j.replace(/\0/g,"");break;default:d=af(e,d,h,l)}break;case 40:switch(g){case 16:c.rows=e[d];d+=l/2;break;case 17:c.columns=e[d];d+=l/2;break;case 256:c.Ve=e[d];d+=l/2;break;case 257:c.bits_stored=e[d];d+=l/2;break;case 2:c.number_of_images=e[d];d+=l/2;break;case 48:j="";for(f=0;f<l/2;f++)h=e[d++],g=h&255,h=(h&65280)>>8,j+=String.fromCharCode(g),j+=String.fromCharCode(h);j=j.split("\\");c.pixel_spacing=[parseFloat(j[0]),parseFloat(j[1]),
Infinity];break;default:d=af(e,d,h,l)}break;case 32:switch(g){case 14:c.series_instance_uid="";for(f=0;f<l/2;f++)h=e[d++],g=h&255,h=(h&65280)>>8,c.series_instance_uid+=String.fromCharCode(g),c.series_instance_uid+=String.fromCharCode(h);break;case 19:j="";for(f=0;f<l/2;f++)h=e[d++],g=h&255,h=(h&65280)>>8,j+=String.fromCharCode(g),j+=String.fromCharCode(h);c.instance_number=parseInt(j,10);break;case 50:j="";for(f=0;f<l/2;f++)h=e[d++],g=h&255,h=(h&65280)>>8,j+=String.fromCharCode(g),j+=String.fromCharCode(h);
j=j.split("\\");c.image_position_patient=[parseFloat(j[0]),parseFloat(j[1]),parseFloat(j[2])];break;case 55:j="";for(f=0;f<l/2;f++)h=e[d++],g=h&255,h=(h&65280)>>8,j+=String.fromCharCode(g),j+=String.fromCharCode(h);j=j.split("\\");c.image_orientation_patient=[parseFloat(j[0]),parseFloat(j[1]),parseFloat(j[2]),parseFloat(j[3]),parseFloat(j[4]),parseFloat(j[5])];break;default:d=af(e,d,h,l)}break;case 65534:switch(g){default:l=0,d+=l/2}break;case 8:switch(g){case 24:c.sop_instance_uid="";for(f=0;f<l/
2;f++)h=e[d++],g=h&255,h=(h&65280)>>8,c.sop_instance_uid+=String.fromCharCode(g),c.sop_instance_uid+=String.fromCharCode(h);break;default:d=af(e,d,h,l)}break;case 16:switch(g){case 8720:for(f=0;f<l/2;f++)d++;break;default:d=af(e,d,h,l)}break;default:d=af(e,d,h,l)}switch(c.Ve){case 8:c.data=new Uint8Array(c.columns*c.rows);break;case 16:c.data=new Uint16Array(c.columns*c.rows);break;case 32:c.data=new Uint32Array(c.columns*c.rows)}this.R=this.P.byteLength-2*c.columns*c.rows;e=t;switch(c.Ve){case 8:e=
Z(this,"uchar",c.columns*c.rows);break;case 16:e=Z(this,"ushort",c.columns*c.rows);break;case 32:e=Z(this,"uint",c.columns*c.rows)}c.data=e;b.na.push(c);return b};B("X.parserDCM",$e);B("X.parserDCM.prototype.parse",$e.prototype.parse);function bf(){Me.call(this);this.g="parserVTK"}C(bf,Me);
bf.prototype.parse=function(a,b,c){D.Ya(this.g+".parse");var e=b.h,d=b.q,f=new Uint8Array(c),g="";b.h=e=new W(c.byteLength);b.q=d=new W(c.byteLength);c=0;for(var h=f.length;c<h;c+=32768)g+=Oe(f,c,Math.min(c+32768,h));f=g.split("\n");g=f.length;this.md=this.nd=t;this.bc=[];this.Ka=gd;this.Ie=this.Qb=this.Ib=this.Rb=u;c=0;for(h=g%8;h--;)cf(this,f[c]),c++;for(h=0.125*g^0;h--;)cf(this,f[c]),c++,cf(this,f[c]),c++,cf(this,f[c]),c++,cf(this,f[c]),c++,cf(this,f[c]),c++,cf(this,f[c]),c++,cf(this,f[c]),c++,
cf(this,f[c]),c++;c=this.nd;var f=this.md,g=f.length,l=h=this.bc.length;do{var j=this.bc[h-l],k=j.length,n;for(n=0;n<k&&!("LINES"==this.Ka&&n+1>=k);n++){var r=parseInt(j[n],10),s=c.get(r);e.add(s[0],s[1],s[2]);var z=r,y=s;"LINES"==this.Ka?(z=parseInt(j[n+1],10),y=c.get(z),e.add(y[0],y[1],y[2])):"TRIANGLE_STRIPS"==this.Ka&&(0==n||n==k-1)&&e.add(s[0],s[1],s[2]);r<g?(y=f.get(r),d.add(y[0],y[1],y[2]),"LINES"==this.Ka?(z=f.get(z),d.add(z[0],z[1],z[2])):"TRIANGLE_STRIPS"==this.Ka&&(0==n||n==k-1)&&d.add(y[0],
y[1],y[2])):(z=new U(s[0],s[1],s[2]),z.normalize(),d.add(z.x,z.y,z.d),"LINES"==this.Ka?(z=new U(y[0],y[1],y[2]),z.normalize(),d.add(z.x,z.y,z.d)):"TRIANGLE_STRIPS"==this.Ka&&(0==n||n==k-1)&&d.add(z.x,z.y,z.d))}l--}while(0<l);b.Da=this.Ka;D.Ua(this.g+".parse");e=new jd;e.K=b;e.B=a;this.dispatchEvent(e)};
function cf(a,b){b=b.replace(/^\s+|\s+$/g,"");var c=b.split(" "),e=c.length,d=c[0];switch(d){case "POINTS":a.Rb=q;a.Ib=u;a.Qb=u;c=parseInt(c[1],10);a.nd=new W(3*c);a.md=new W(3*c);return;case "VERTICES":a.Ib=q;a.Rb=u;a.Qb=u;c=parseInt(c[1],10);3<=c?a.Ka=gd:1==c?a.Ka="POINTS":m(Error("This VTK file is not supported!"));a.bc=[];return;case "TRIANGLE_STRIPS":a.Ib=q;a.Rb=u;a.Qb=u;a.Ka="TRIANGLE_STRIPS";a.bc=[];return;case "LINES":a.Ib=q;a.Rb=u;a.Qb=u;a.Ka="LINES";a.bc=[];return;case "POLYGONS":a.Ib=q;
a.Rb=u;a.Qb=u;a.Ka="POLYGONS";a.bc=[];return;case "POINT_DATA":a.Qb=q;a.Rb=u;a.Ib=u;return}if(a.Rb)if(1==e||isNaN(parseFloat(d)))a.Rb=u;else{if(3<=e){var d=parseFloat(c[0]),f=parseFloat(c[1]),g=parseFloat(c[2]);a.nd.add(d,f,g)}6<=e&&(d=parseFloat(c[3]),f=parseFloat(c[4]),g=parseFloat(c[5]),a.nd.add(d,f,g));9<=e&&(e=parseFloat(c[6]),d=parseFloat(c[7]),c=parseFloat(c[8]),a.nd.add(e,d,c))}else a.Ib?1==e||isNaN(parseFloat(d))?a.Ib=u:(c=c.slice(1),a.bc.push(c)):a.Qb&&("NORMALS"==d?a.Ie=q:1==e||isNaN(parseFloat(d))?
(a.Qb=u,a.Ie=u):a.Ie&&(3<=e&&(d=parseFloat(c[0]),f=parseFloat(c[1]),g=parseFloat(c[2]),a.md.add(d,f,g)),6<=e&&(d=parseFloat(c[3]),f=parseFloat(c[4]),g=parseFloat(c[5]),a.md.add(d,f,g)),9<=e&&(e=parseFloat(c[6]),d=parseFloat(c[7]),c=parseFloat(c[8]),a.md.add(e,d,c))))}B("X.parserVTK",bf);B("X.parserVTK.prototype.parse",bf.prototype.parse);function df(){Me.call(this);this.g="parserFSM";this.Od=u}C(df,Me);
df.prototype.parse=function(a,b,c){D.Ya(this.g+".parse");this.P=c;var e=b.h,d=b.q;b.Ac=[];var f=b.Ac;c=0;var g;do g=Z(this,"uchar"),c++;while(200>c&&10!=g);Z(this,"uchar");d=Z(this,"uint");c=Z(this,"uint");var h=Z(this,"float",3*d);g=Z(this,"uint",3*c);var l=new Uint32Array(d),j=new Float32Array(9*c);b.h=e=new W(9*c);b.q=d=new W(9*c);var k;for(k=0;k<c;k++){var n=3*k,r=g[n],s=g[n+1],z=g[n+2];f.push(r);f.push(s);f.push(z);l[r]+=1;l[s]+=1;l[z]+=1;var n=3*r,y=3*s,E=3*z,F=h[n],K=h[n+1],A=h[n+2],s=h[y],
z=h[y+1],r=h[y+2],G=h[E],I=h[E+1],H=h[E+2];e.add(F,K,A);e.add(s,z,r);e.add(G,I,H);F=new U(F,K,A);G=new U(G,I,H);s=(new U(s,z,r)).l().Ea(F);z=G.l().Ea(F);s=Hc(s,z).normalize();j[n]+=s.x;j[n+1]+=s.y;j[n+2]+=s.d;j[y]+=s.x;j[y+1]+=s.y;j[y+2]+=s.d;j[E]+=s.x;j[E+1]+=s.y;j[E+2]+=s.d}for(k=0;k<c;k++)n=3*k,r=g[n],s=g[n+1],z=g[n+2],n=3*r,y=3*s,E=3*z,f=new U(j[y],j[y+1],j[y+2]),h=new U(j[E],j[E+1],j[E+2]),n=(new U(j[n],j[n+1],j[n+2])).scale(1/l[r]).normalize(),f=f.scale(1/l[s]).normalize(),h=h.scale(1/l[z]).normalize(),
d.add(n.x,n.y,n.d),d.add(f.x,f.y,f.d),d.add(h.x,h.y,h.d);c=Z(this,"uchar",this.P.byteLength-this.R);g=t;for(n=0;n<c.length;n++)if(99==c[n]&&114==c[n+1]&&97==c[n+2]&&115==c[n+3]){for(d=g=n+9;10!=c[n]&&n<c.length;)d++,n++;g=Oe(c.subarray(g,d)).split(" ");break}g&&(b.ca.nh(parseFloat(g[0])),b.ca.oh(parseFloat(g[1])),b.ca.ph(parseFloat(g[2])));b.Da=gd;D.Ua(this.g+".parse");c=new jd;c.K=b;c.B=a;this.dispatchEvent(c)};B("X.parserFSM",df);B("X.parserFSM.prototype.parse",df.prototype.parse);var ef={Ze:function(a,b,c){return ef.update(a,0,b,c)},update:function(a,b,c,e){var d=ef.uh,f="number"===typeof c?c:c=0;e="number"===typeof e?e:a.length;b^=4294967295;for(f=e&7;f--;++c)b=b>>>8^d[(b^a[c])&255];for(f=e>>3;f--;c+=8)b=b>>>8^d[(b^a[c])&255],b=b>>>8^d[(b^a[c+1])&255],b=b>>>8^d[(b^a[c+2])&255],b=b>>>8^d[(b^a[c+3])&255],b=b>>>8^d[(b^a[c+4])&255],b=b>>>8^d[(b^a[c+5])&255],b=b>>>8^d[(b^a[c+6])&255],b=b>>>8^d[(b^a[c+7])&255];return(b^4294967295)>>>0}};
ef.uh=new Uint32Array([0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,
3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,
366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,
3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,
1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,
1088359270,936918E3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117]);function ff(a){var b=a.length,c=0,e=Number.POSITIVE_INFINITY,d,f,g,h,l,j,k,n,r;for(n=0;n<b;++n)a[n]>c&&(c=a[n]),a[n]<e&&(e=a[n]);d=1<<c;f=new Uint32Array(d);g=1;h=0;for(l=2;g<=c;){for(n=0;n<b;++n)if(a[n]===g){j=0;k=h;for(r=0;r<g;++r)j=j<<1|k&1,k>>=1;for(r=j;r<d;r+=l)f[r]=g<<16|n;++h}++g;h<<=1;l<<=1}return[f,c,e]};function gf(a,b){this.We=[];this.Xe=32768;this.ib=this.pd=this.xa=this.Kf=0;this.input=new Uint8Array(a);this.pg=u;this.Ye=hf;this.Cb=u;if(b||!(b={}))b.index&&(this.xa=b.index),b.bufferSize&&(this.Xe=b.bufferSize),b.bufferType&&(this.Ye=b.bufferType),b.resize&&(this.Cb=b.resize);switch(this.Ye){case jf:this.ea=32768;this.Oa=new Uint8Array(32768+this.Xe+258);break;case hf:this.ea=0;this.Oa=new Uint8Array(this.Xe);this.jc=this.di;this.sg=this.Uh;this.ef=this.Yh;break;default:m(Error("invalid inflate mode"))}}
var jf=0,hf=1;
gf.prototype.rd=function(){for(;!this.pg;){var a=kf(this,3);a&1&&(this.pg=q);a>>>=1;switch(a){case 0:var a=this.input,b=this.xa,c=this.Oa,e=this.ea,d=p,f=p,g=p,h=c.length,d=p;this.ib=this.pd=0;d=a[b++];d===p&&m(Error("invalid uncompressed block header: LEN (first byte)"));f=d;d=a[b++];d===p&&m(Error("invalid uncompressed block header: LEN (second byte)"));f|=d<<8;d=a[b++];d===p&&m(Error("invalid uncompressed block header: NLEN (first byte)"));g=d;d=a[b++];d===p&&m(Error("invalid uncompressed block header: NLEN (second byte)"));g|=
d<<8;f===~g&&m(Error("invalid uncompressed block header: length verify"));b+f>a.length&&m(Error("input buffer is broken"));switch(this.Ye){case jf:for(;e+f>c.length;)d=h-e,f-=d,c.set(a.subarray(b,b+d),e),e+=d,b+=d,this.ea=e,c=this.jc(),e=this.ea;break;case hf:for(;e+f>c.length;)c=this.jc({yg:2});break;default:m(Error("invalid inflate mode"))}c.set(a.subarray(b,b+f),e);e+=f;this.xa=b+=f;this.ea=e;this.Oa=c;break;case 1:this.ef(lf,mf);break;case 2:nf(this);break;default:m(Error("unknown BTYPE: "+a))}}return this.sg()};
var of=new Uint16Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),pf=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258]),qf=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0]),rf=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577]),sf=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),tf=new Uint8Array(288),
uf,vf;uf=0;for(vf=tf.length;uf<vf;++uf)tf[uf]=143>=uf?8:255>=uf?9:279>=uf?7:8;var lf=ff(tf),wf=new Uint8Array(30),xf,yf;xf=0;for(yf=wf.length;xf<yf;++xf)wf[xf]=5;var mf=ff(wf);function kf(a,b){for(var c=a.pd,e=a.ib,d=a.input,f=a.xa,g;e<b;)g=d[f++],g===p&&m(Error("input buffer is broken")),c|=g<<e,e+=8;g=c&(1<<b)-1;a.pd=c>>>b;a.ib=e-b;a.xa=f;return g}
function zf(a,b){for(var c=a.pd,e=a.ib,d=a.input,f=a.xa,g=b[0],h=b[1],l;e<h;)l=d[f++],l===p&&m(Error("input buffer is broken")),c|=l<<e,e+=8;d=g[c&(1<<h)-1];g=d>>>16;a.pd=c>>g;a.ib=e-g;a.xa=f;return d&65535}
function nf(a){function b(a,b,c){var d,e,f;for(f=0;f<a;)switch(d=zf(this,b),d){case 16:for(d=3+kf(this,2);d--;)c[f++]=e;break;case 17:for(d=3+kf(this,3);d--;)c[f++]=0;e=0;break;case 18:for(d=11+kf(this,7);d--;)c[f++]=0;e=0;break;default:e=c[f++]=d}return c}var c=kf(a,5)+257,e=kf(a,5)+1,d=kf(a,4)+4,f=new Uint8Array(of.length),g;for(g=0;g<d;++g)f[of[g]]=kf(a,3);d=ff(f);f=new Uint8Array(c);g=new Uint8Array(e);a.ef(ff(b.call(a,c,d,f)),ff(b.call(a,e,d,g)))}w=gf.prototype;
w.ef=function(a,b){var c=this.Oa,e=this.ea;this.vg=a;for(var d=c.length-258,f,g,h;256!==(f=zf(this,a));)if(256>f)e>=d&&(this.ea=e,c=this.jc(),e=this.ea),c[e++]=f;else{f-=257;h=pf[f];0<qf[f]&&(h+=kf(this,qf[f]));f=zf(this,b);g=rf[f];0<sf[f]&&(g+=kf(this,sf[f]));e>=d&&(this.ea=e,c=this.jc(),e=this.ea);for(;h--;)c[e]=c[e++-g]}for(;8<=this.ib;)this.ib-=8,this.xa--;this.ea=e};
w.Yh=function(a,b){var c=this.Oa,e=this.ea;this.vg=a;for(var d=c.length,f,g,h;256!==(f=zf(this,a));)if(256>f)e>=d&&(c=this.jc(),d=c.length),c[e++]=f;else{f-=257;h=pf[f];0<qf[f]&&(h+=kf(this,qf[f]));f=zf(this,b);g=rf[f];0<sf[f]&&(g+=kf(this,sf[f]));e+h>d&&(c=this.jc(),d=c.length);for(;h--;)c[e]=c[e++-g]}for(;8<=this.ib;)this.ib-=8,this.xa--;this.ea=e};
w.jc=function(){var a=new Uint8Array(this.ea-32768),b=this.ea-32768,c=this.Oa;a.set(c.subarray(32768,a.length));this.We.push(a);this.Kf+=a.length;c.set(c.subarray(b,b+32768));this.ea=32768;return c};w.di=function(a){var b=this.input.length/this.xa+1|0,c=this.input,e=this.Oa;a&&("number"===typeof a.yg&&(b=a.yg),"number"===typeof a.Oh&&(b+=a.Oh));2>b?(a=(c.length-this.xa)/this.vg[2],a=258*(a/2)|0,a=a<e.length?e.length+a:e.length<<1):a=e.length*b;a=new Uint8Array(a);a.set(e);return this.Oa=a};
w.sg=function(){var a=0,b=this.Oa,c=this.We,e,d=new Uint8Array(this.Kf+(this.ea-32768)),f,g,h,l;if(0===c.length)return this.Oa.subarray(32768,this.ea);f=0;for(g=c.length;f<g;++f){e=c[f];h=0;for(l=e.length;h<l;++h)d[a++]=e[h]}f=32768;for(g=this.ea;f<g;++f)d[a++]=b[f];this.We=[];return this.buffer=d};w.Uh=function(){var a,b=this.ea;this.Cb?(a=new Uint8Array(b),a.set(this.Oa.subarray(0,b))):a=this.Oa.subarray(0,b);return this.buffer=a};new Uint8Array(256);var Af;for(Af=0;256>Af;++Af)for(var Bf=Af,Cf=7,Bf=Bf>>>1;Bf;Bf>>>=1)--Cf;var Df=[],Ef;for(Ef=0;288>Ef;Ef++)switch(q){case 143>=Ef:Df.push([Ef+48,8]);break;case 255>=Ef:Df.push([Ef-144+400,9]);break;case 279>=Ef:Df.push([Ef-256+0,7]);break;case 287>=Ef:Df.push([Ef-280+192,8]);break;default:m("invalid literal: "+Ef)}
function Ff(){var a=Gf;switch(q){case 3===a:return[257,a-3,0];case 4===a:return[258,a-4,0];case 5===a:return[259,a-5,0];case 6===a:return[260,a-6,0];case 7===a:return[261,a-7,0];case 8===a:return[262,a-8,0];case 9===a:return[263,a-9,0];case 10===a:return[264,a-10,0];case 12>=a:return[265,a-11,1];case 14>=a:return[266,a-13,1];case 16>=a:return[267,a-15,1];case 18>=a:return[268,a-17,1];case 22>=a:return[269,a-19,2];case 26>=a:return[270,a-23,2];case 30>=a:return[271,a-27,2];case 34>=a:return[272,a-
31,2];case 42>=a:return[273,a-35,3];case 50>=a:return[274,a-43,3];case 58>=a:return[275,a-51,3];case 66>=a:return[276,a-59,3];case 82>=a:return[277,a-67,4];case 98>=a:return[278,a-83,4];case 114>=a:return[279,a-99,4];case 130>=a:return[280,a-115,4];case 162>=a:return[281,a-131,5];case 194>=a:return[282,a-163,5];case 226>=a:return[283,a-195,5];case 257>=a:return[284,a-227,5];case 258===a:return[285,a-258,0];default:m("invalid length: "+a)}}var Hf=[],Gf,If;
for(Gf=3;258>=Gf;Gf++)If=Ff(),Hf[Gf]=If[2]<<24|If[1]<<16|If[0];new Uint32Array(Hf);function Jf(){};function Kf(a){this.input=a;this.xa=0;this.member=[]}
Kf.prototype.rd=function(){for(var a=this.input.length;this.xa<a;){var b=new Jf,c=p,e=p,d=p,f=c=d=p,g=p,c=c=p,h=this.input,e=this.xa;b.Eg=h[e++];b.Fg=h[e++];(31!==b.Eg||139!==b.Fg)&&m(Error("invalid file signature:",b.Eg,b.Fg));b.rg=h[e++];switch(b.rg){case 8:break;default:m(Error("unknown compression method: "+b.rg))}b.de=h[e++];c=h[e++]|h[e++]<<8|h[e++]<<16|h[e++]<<24;b.Tk=new Date(1E3*c);b.Xk=h[e++];b.Uk=h[e++];0<(b.de&4)&&(b.Kj=h[e++]|h[e++]<<8,e+=b.Kj);if(0<(b.de&8)){g=[];for(f=0;0<(c=h[e++]);)g[f++]=
String.fromCharCode(c);b.name=g.join("")}if(0<(b.de&16)){g=[];for(f=0;0<(c=h[e++]);)g[f++]=String.fromCharCode(c);b.comment=g.join("")}0<(b.de&2)&&(b.Vh=ef.Ze(h,0,e)&65535,b.Vh!==(h[e++]|h[e++]<<8)&&m(Error("invalid header crc16")));c=h[h.length-4]|h[h.length-3]<<8|h[h.length-2]<<16|h[h.length-1]<<24;h.length-e-4-4<512*c&&(d=c);e=new gf(h,{index:e,bufferSize:d});b.data=d=e.rd();e=e.xa;b.Kk=c=(h[e++]|h[e++]<<8|h[e++]<<16|h[e++]<<24)>>>0;ef.Ze(d)!==c&&m(Error("invalid CRC-32 checksum: 0x"+ef.Ze(d).toString(16)+
" / 0x"+c.toString(16)));b.Qk=c=(h[e++]|h[e++]<<8|h[e++]<<16|h[e++]<<24)>>>0;(d.length&4294967295)!==c&&m(Error("invalid input size: "+(d.length&4294967295)+" / "+c));this.member.push(b);this.xa=e}a=this.member;b=d=e=0;for(h=a.length;b<h;++b)d+=a[b].data.length;d=new Uint8Array(d);for(b=0;b<h;++b)d.set(a[b].data,e),e+=a[b].data.length;return d};function Lf(){Me.call(this);this.g="parserMGZ";this.Od=u}C(Lf,Me);
Lf.prototype.parse=function(a,b,c,e){D.Ya(this.g+".parse");e&&(c=(new Kf(new Uint8Array(c))).rd(),c=c.buffer);e=this.yd(c);var d=[e.of,e.pf,e.qf];b.oa=d;var f=e.qh;b.kd=f;c=e.min;var g=e.max;b.cb=b.ia=c;b.ma=b.ha=g;-Infinity==b.fa&&(b.fa=c);Infinity==b.ga&&(b.ga=g);c=Qc();V(c,0,e.Xa[0][0],e.Xa[1][0],e.Xa[2][0],0);V(c,1,e.Xa[0][1],e.Xa[1][1],e.Xa[2][1],0);V(c,2,e.Xa[0][2],e.Xa[1][2],e.Xa[2][2],0);V(c,3,0,0,0,1);for(var g=d[0]/2,h=d[1]/2,l=d[2]/2,d=[0,0,0],j=0;3>j;++j)d[j]=e.Xa[3][j]-(c[j+0]*f[0]*g+
c[j+4]*f[1]*h+c[j+8]*f[2]*l);f=d[1];g=d[2];c[12]=d[0];c[13]=f;c[14]=g;c[15]=1;e.Fb=c;e.Gb=Qc();Zc(e.Fb,e.Gb);d=Pc(0,0,0,1);f=Oc();ad(c,d,f);g=Pc(1,1,1,1);d=Oc();ad(c,g,d);c=Pe(c,b.oa);e.Fd=[d[0]-f[0],d[1]-f[1],d[2]-f[2]];e.Dd=[c[1]-c[0]+1,c[3]-c[2]+1,c[5]-c[4]+1];e.Ed=[c[0],c[2],c[4]];b.hc(e);D.Ua(this.g+".parse");b.Jb=Ve(this,b);e=new jd;e.K=b;e.B=a;this.dispatchEvent(e)};
Lf.prototype.yd=function(a){this.P=a;a={version:0,xh:0,vh:0,ji:0,wh:0,of:0,pf:0,qf:0,Ki:0,type:0,bi:0,hh:0,Qj:t,Xa:t,qh:t,data:t,min:Infinity,max:-Infinity};a.version=Z(this,"uint");a.of=Z(this,"uint");a.pf=Z(this,"uint");a.qf=Z(this,"uint");a.Ki=Z(this,"uint");a.type=Z(this,"uint");a.bi=Z(this,"uint");a.hh=Z(this,"ushort");if(0<a.hh){a.qh=Z(this,"float",3);var b=[];b.push(Z(this,"float",3));b.push(Z(this,"float",3));b.push(Z(this,"float",3));b.push(Z(this,"float",3));a.Xa=b}this.R=284;b=a.of*a.pf*
a.qf;switch(a.type){case 0:a.data=Z(this,"uchar",b);break;case 1:a.data=Z(this,"uint",b);break;case 3:a.data=Z(this,"float",b);break;case 4:a.data=Z(this,"ushort",b);break;default:m(Error("Unsupported MGH/MGZ data type: "+a.type))}b=Ne(a.data);a.min=b[0];a.max=b[1];this.R+16<this.P.byteLength&&(a.xh=Z(this,"float"),a.ji=Z(this,"float"),a.vh=Z(this,"float"),a.wh=Z(this,"float"));return a};B("X.parserMGZ",Lf);B("X.parserMGZ.prototype.parse",Lf.prototype.parse);function Mf(){Me.call(this);this.g="parserLBL"}C(Mf,Me);
Mf.prototype.parse=function(a,b,c){D.Ya(this.g+".parse");var e=b.Ac,d=e.length;0==d&&m(Error("No _pointIndices defined on the X.object."));this.P=c;var f=[],g=Z(this,"uchar",c.byteLength),h=g.length,l=u,j=0;for(c=1;c<h;c++)10==g[c-1]?(j=c,l=q):l&&32==g[c]&&(f.push(parseInt(Oe(g,j,c),10)),l=u);g=b.G.F?b.G.F:new Float32Array(d);h=f.length;for(c=0;c<h;c++)g[f[c]]=1;f=new Float32Array(3*d);for(c=h=0;c<d;c++)l=e[c],l>d&&m(Error("Could not find scalar for vertex.")),l=g[l],f[h++]=l,f[h++]=l,f[h++]=l;b.G.F=
g;b.G.Pc=f;b.G.j=q;D.Ua(this.g+".parse");e=new jd;e.K=b;e.B=a;this.dispatchEvent(e)};B("X.parserLBL",Mf);B("X.parserLBL.prototype.parse",Mf.prototype.parse);function Nf(){Me.call(this);this.g="parserCRV";this.Od=u}C(Nf,Me);
Nf.prototype.parse=function(a,b,c){D.Ya(this.g+".parse");var e=b.Ac;0==e.length&&m(Error("No _pointIndices defined on the X.object."));this.P=c;this.R=3;var d=Z(this,"uint");Z(this,"uint");Z(this,"uint");var f=0,g=0,h=0,l=0,j=0,k=0,n=0,r=0,s=0,z=0,y=0;c=Array(2);var E=Array(2),F=Z(this,"float",d),K;for(K=0;K<d;K++){var A=F[K];0==K&&(c[0]=E[0]=A);0<=A?(f++,l+=A):(g++,h+=A);s+=A;y++;E[0]=Math.max(A,E[0]);c[0]=Math.min(A,c[0]);F[K]=A}0!=f&&(j=l/f);0!=g&&(k=h/g);0!=y&&(z=s/y);for(y=s=h=l=0;y<d;y++)A=
F[y],K=0,0<=A?(K=Math.pow(A-j,2),l+=K):(K=Math.pow(A-k,2),h+=K),K=Math.pow(A-z,2),s+=K;1<f&&(n=Math.sqrt(l/(f-1)));1<g&&(r=Math.sqrt(h/(g-1)));c[1]=k-2.5*r;E[1]=j+2.5*n;d=e.length;f=new Float32Array(3*d);for(y=0;y<d;y++)g=F[e[y]],h=3*y,f[h]=g,f[h+1]=g,f[h+2]=g;b.G.cb=c[1];b.G.ma=E[1];-Infinity==b.G.fa&&(b.G.fa=c[1]);Infinity==b.G.ga&&(b.G.ga=E[1]);b.G.F=F;b.G.Pc=f;b.G.j=q;D.Ua(this.g+".parse");e=new jd;e.K=b;e.B=a;this.dispatchEvent(e)};B("X.parserCRV",Nf);B("X.parserCRV.prototype.parse",Nf.prototype.parse);function Of(){Me.call(this);this.g="parserTRK"}C(Of,Me);
Of.prototype.parse=function(a,b,c){D.Ya(this.g+".parse");var e=b.h,d=b.q,f=b.la;this.P=c;Z(this,"uchar",6);Z(this,"ushort",3);var g=Z(this,"float",3);Z(this,"float",3);var h=Z(this,"ushort");Z(this,"uchar",200);Z(this,"ushort");Z(this,"uchar",200);c=Z(this,"float",16);Z(this,"uchar",444);Z(this,"uchar",4);Z(this,"uchar",4);Z(this,"float",6);Z(this,"uchar",2);Z(this,"uchar");Z(this,"uchar");Z(this,"uchar");Z(this,"uchar");Z(this,"uchar");Z(this,"uchar");var l=Z(this,"uint");Z(this,"uint");var j=Z(this,
"uint"),k=[],n=[],r=Infinity,s=-Infinity,z=t,y=t,E=t,F=t,d=e=t,K=Z(this,"uint",(this.P.byteLength-1E3)/4);this.R=j;for(var A=Z(this,"float",(this.P.byteLength-1E3)/4),G=0,j=f=0;j<l;j++){for(var I=K[G],H=new W(3*I),R=0,N=0;N<I;N++){var S=A[G+3*N+N*h+1],ba=A[G+3*N+N*h+2],aa=A[G+3*N+N*h+3],S=S/g[0],ba=ba/g[1],aa=aa/g[2];H.add(S,ba,aa);if(0<N)var ca=H.get(N-1),R=R+Math.sqrt(Math.pow(S-ca[0],2)+Math.pow(ba-ca[1],2)+Math.pow(aa-ca[2],2));N<I-1&&(f+=6)}G+=3*I+I*h+1;N=H.eb;I=H.$a;S=H.fb;ba=H.ab;aa=H.gb;ca=
H.bb;if(!z||N<z)z=N;if(!y||I>y)y=I;if(!E||S<E)E=S;if(!F||ba>F)F=ba;if(!e||aa<e)e=aa;if(!d||ca>d)d=ca;k.push(H);n.push(R)}g=(z+y)/2;E=(E+F)/2;h=(e+d)/2;F=new Float32Array(f);b.h=e=new W(f);b.q=d=new W(f);b.la=f=new W(f);for(j=z=0;j<l;j++){y=k[j];K=y.count;R=n[j];r=Math.min(r,R);s=Math.max(s,R);for(N=0;N<K-1;N++){G=y.get(N);A=y.get(N+1);e.add(G[0],G[1],G[2]);e.add(A[0],A[1],A[2]);var H=G[0]-g,I=G[1]-E,S=G[2]-h,ba=Math.sqrt(H*H+I*I+S*S),aa=A[0]-g,ca=A[1]-E,M=A[2]-h,T=Math.sqrt(aa*aa+ca*ca+M*M);d.add(H/
ba,I/ba,S/ba);d.add(aa/T,ca/T,M/T);A=[Math.abs(A[0]-G[0]),Math.abs(A[1]-G[1]),Math.abs(A[2]-G[2])];G=Math.sqrt(A[0]*A[0]+A[1]*A[1]+A[2]*A[2]);A[0]/=G;A[1]/=G;A[2]/=G;f.add(A[0],A[1],A[2]);f.add(A[0],A[1],A[2]);F[z++]=R;F[z++]=R;F[z++]=R;F[z++]=R;F[z++]=R;F[z++]=R}}b.Da="LINES";l=new id;l.cb=r;l.ma=s;l.fa=r;l.ga=s;l.Pc=F;l.jg=u;l.j=q;b.G=l;D.Ua(this.g+".parse");D.f.Lf(c,b.ca.N);c=new jd;c.K=b;c.B=a;this.dispatchEvent(c)};B("X.parserTRK",Of);B("X.parserTRK.prototype.parse",Of.prototype.parse);function Pf(){Me.call(this);this.g="parserIMAGE"}C(Pf,Me);Pf.prototype.parse=function(a,b,c,e){c instanceof ArrayBuffer||m(Error());for(var d=new Uint8Array(c),f=d.length,g=Array(f);f--;)g[f]=String.fromCharCode(d[f]);d=window.btoa(g.join(""));f=new Image;$b(f,"load",this.nj.bind(this,f,a,b,c,e));f.src="data:image/"+e+";base64,"+d};Pf.prototype.nj=function(a,b,c){b.Jb=a;b.Tb=t;a=new jd;a.K=c;a.B=b;this.dispatchEvent(a)};B("X.parserIMAGE",Pf);B("X.parserIMAGE.prototype.parse",Pf.prototype.parse);function Qf(){Me.call(this);this.g="parserLUT"}C(Qf,Me);
Qf.prototype.parse=function(a,b,c){D.Ya(this.g+".parse");this.P=c;c=Z(this,"uchar",c.byteLength);var e=c.length,d=0,f;for(f=0;f<e;f++)if(10==c[f]){var g=Oe(c,d,f),d=f+1,g=g.replace(/^\s+|\s+$/g,"");"#"!=g[0]&&(g=g.split(" "),g=g.filter(function(a){return""!=a}),6==g.length&&(g[2]=parseInt(g[2],10)/255,g[3]=parseInt(g[3],10)/255,g[4]=parseInt(g[4],10)/255,g[5]=parseInt(g[5],10)/255,a.add(parseInt(g[0],10),g[1],g[2],g[3],g[4],g[5],10)))}D.Ua(this.g+".parse");c=new jd;c.K=b;c.B=a;this.dispatchEvent(c)};
B("X.parserLUT",Qf);B("X.parserLUT.prototype.parse",Qf.prototype.parse);function Rf(){Me.call(this);this.g="parserNRRD"}C(Rf,Me);
Rf.prototype.parse=function(a,b,c){D.Ya(this.g+".parse");this.P=c;c=Z(this,"uchar",c.byteLength);var e=c.length,d=t,f=0,g;for(g=1;g<e;g++)if(10==c[g-1]&&10==c[g]){d=Oe(c,0,g-2);f=g+1;break}var h,l,j,k,e=d.split(/\r?\n/),d=0;for(g=e.length;d<g;d++)if(h=e[d],h.match(/NRRD\d+/))this.Ci=q;else if(!h.match(/^#/)&&(k=h.match(/(.*):(.*)/)))l=k[1].trim(),h=k[2].trim(),(j=this.fi[l])?j.call(this,h):this[l]=h;this.Ci||m(Error("Not an NRRD file"));"raw"!==this.encoding&&("gzip"!==this.encoding&&"gz"!==this.encoding)&&
m(Error("Only raw or gz/gzip encoding is allowed"));if(!this.aa&&(this.aa=[new U(1,0,0),new U(0,1,0),new U(0,0,1)],this.If)){e=[];for(k=0;2>=k;k++)e.push(!isNaN(this.If[k])?this.aa[k].scale(this.If[k]):p)}f=c.subarray(f);if("gzip"==this.encoding||"gz"==this.encoding)f=(new Kf(new Uint8Array(f))).rd();f=f.buffer;c={data:t,min:Infinity,max:-Infinity};c.data=new this.Hb(f);k=Ne(c.data);f=c.min=k[0];k=c.max=k[1];b.cb=b.ia=f;b.ma=b.ha=k;b.oa=[this.Gf[0],this.Gf[1],this.Gf[2]];e=(new U(this.aa[0][0],this.aa[0][1],
this.aa[0][2])).Bb();d=(new U(this.aa[1][0],this.aa[1][1],this.aa[1][2])).Bb();g=(new U(this.aa[2][0],this.aa[2][1],this.aa[2][2])).Bb();b.kd=[e,d,g];-Infinity==b.fa&&(b.fa=f);Infinity==b.ga&&(b.ga=k);e=k=1;"left-posterior-superior"==this.Ej&&(e=k=-1);f=Rc();V(f,0,k*this.aa[0][0],k*this.aa[1][0],k*this.aa[2][0],k*this.Hf[0]);V(f,1,e*this.aa[0][1],e*this.aa[1][1],e*this.aa[2][1],e*this.Hf[1]);V(f,2,1*this.aa[0][2],1*this.aa[1][2],1*this.aa[2][2],1*this.Hf[2]);V(f,3,0,0,0,1);c.Fb=f;c.Gb=Qc();Zc(c.Fb,
c.Gb);e=Pc(0,0,0,1);k=Oc();ad(f,e,k);d=Pc(1,1,1,1);e=Oc();ad(f,d,e);f=Pe(f,b.oa);c.Fd=[e[0]-k[0],e[1]-k[1],e[2]-k[2]];c.Dd=[f[1]-f[0]+1,f[3]-f[2]+1,f[5]-f[4]+1];c.Ed=[f[0],f[2],f[4]];b.hc(c);D.Ua(this.g+".parse");b.Jb=Ve(this,b);c=new jd;c.K=b;c.B=a;this.dispatchEvent(c)};
Rf.prototype.fi={type:function(a){switch(a){case "uchar":case "unsigned char":case "uint8":case "uint8_t":this.Hb=Uint8Array;break;case "signed char":case "int8":case "int8_t":this.Hb=Int8Array;break;case "short":case "short int":case "signed short":case "signed short int":case "int16":case "int16_t":this.Hb=Int16Array;break;case "ushort":case "unsigned short":case "unsigned short int":case "uint16":case "uint16_t":this.Hb=Uint16Array;break;case "int":case "signed int":case "int32":case "int32_t":this.Hb=
Int32Array;break;case "uint":case "unsigned int":case "uint32":case "uint32_t":this.Hb=Uint32Array;break;case "float":this.Hb=Float32Array;break;case "double":this.Hb=Float64Array;break;default:m(Error("Unsupported NRRD data type: "+a))}return this.type=a},endian:function(a){return this.Ok=a},encoding:function(a){return this.encoding=a},dimension:function(a){return this.Vb=parseInt(a,10)},sizes:function(a){var b,c,e,d;e=a.split(/\s+/);d=[];b=0;for(c=e.length;b<c;b++)a=e[b],d.push(parseInt(a,10));
return this.Gf=d},space:function(a){return this.Ej=a},"space origin":function(a){return this.Hf=a.split("(")[1].split(")")[0].split(",")},"space directions":function(a){var b,c;a=a.match(/\(.*?\)/g);var e,d,f;f=[];e=0;for(d=a.length;e<d;e++)c=a[e],f.push(function(){var a,d,e,f;e=c.slice(1,-1).split(/,/);f=[];a=0;for(d=e.length;a<d;a++)b=e[a],f.push(parseFloat(b));return f}());return this.aa=f},spacings:function(a){var b;b=a.split(/\s+/);var c,e,d;d=[];c=0;for(e=b.length;c<e;c++)a=b[c],d.push(parseFloat(a));
return this.If=d}};B("X.parserNRRD",Rf);B("X.parserNRRD.prototype.parse",Rf.prototype.parse);function Sf(){Me.call(this);this.g="parserNII"}C(Sf,Me);
Sf.prototype.parse=function(a,b,c){var e=c,d=-1,d="undefined"==typeof DataView?(new Int32Array(c,0,1))[0]:(new DataView(c,0)).getInt32(0,q);348!=d&&(e=(new Kf(new Uint8Array(e))).rd(),e=e.buffer);c=this.yd(e);e=c.min;d=c.max;b.cb=b.ia=e;b.ma=b.ha=d;-Infinity==b.fa&&(b.fa=e);Infinity==b.ga&&(b.ga=d);e=Qc();V(e,3,0,0,0,1);if(0<c.Cf){var d=0,f=c.eh,g=c.fh,h=c.gh,l=1,j=1,k=1,n=c.ah,r=c.bh,s=c.dh,d=1-(f*f+g*g+h*h);1E-7>d?(d=1/Math.sqrt(f*f+g*g+h*h),f*=d,g*=d,h*=d,d=0):d=Math.sqrt(d);0<c.kb[1]&&(l=c.kb[1]);
0<c.kb[2]&&(j=c.kb[2]);0<c.kb[2]&&(k=c.kb[3]);0>c.kb[0]&&(k=-k);V(e,0,(d*d+f*f-g*g-h*h)*l,2*(f*g-d*h)*j,2*(f*h+d*g)*k,n);V(e,1,2*(f*g+d*h)*l,(d*d+g*g-f*f-h*h)*j,2*(g*h-d*f)*k,r);V(e,2,2*(f*h-d*g)*l,2*(g*h+d*f)*j,(d*d+h*h-g*g-f*f)*k,s)}else 0<c.ih?(d=c.kh,f=c.lh,g=c.mh,V(e,0,d[0],d[1],d[2],d[3]),V(e,1,f[0],f[1],f[2],f[3]),V(e,2,g[0],g[1],g[2],g[3])):0==c.Cf?(V(e,0,c.kb[1],0,0,0),V(e,1,0,c.kb[2],0,0),V(e,2,0,0,c.kb[3],0)):window.console.log("UNKNOWN METHOD IN PARSER NII");c.Fb=e;c.Gb=Qc();Zc(c.Fb,c.Gb);
f=Pc(0,0,0,1);d=Oc();ad(e,f,d);g=Pc(1,1,1,1);f=Oc();ad(e,g,f);g=[c.Vb[1],c.Vb[2],c.Vb[3]];e=Pe(e,g);c.Fd=[f[0]-d[0],f[1]-d[1],f[2]-d[2]];c.Dd=[e[1]-e[0]+1,e[3]-e[2]+1,e[5]-e[4]+1];c.Ed=[e[0],e[2],e[4]];b.oa=g;b.hc(c);b.Jb=Ve(this,b);c=new jd;c.K=b;c.B=a;this.dispatchEvent(c)};
Sf.prototype.yd=function(a){this.P=a;a={yj:0,Wh:t,Xh:t,ei:0,wj:0,rj:0,ai:t,Vb:t,yi:0,zi:0,Ai:0,wi:0,df:0,Rh:0,Dj:0,kb:t,rh:0,vj:0,uj:0,Cj:0,Aj:t,Lj:t,Sh:0,Th:0,Bj:0,Ij:0,li:0,mi:0,Zh:t,Qh:t,Cf:0,ih:0,eh:0,fh:0,gh:0,ah:0,bh:0,dh:0,kh:t,lh:t,mh:t,xi:t,Ei:t,data:t,min:Infinity,max:-Infinity};a.yj=Z(this,"uint");a.Wh=Z(this,"uchar",10);a.Xh=Z(this,"uchar",18);a.ei=Z(this,"uint");a.wj=Z(this,"ushort");a.rj=Z(this,"uchar");a.ai=Z(this,"uchar");a.Vb=Z(this,"ushort",8);a.yi=Z(this,"float");a.zi=Z(this,"float");
a.Ai=Z(this,"float");a.wi=Z(this,"ushort");a.df=Z(this,"ushort");a.Rh=Z(this,"ushort");a.Dj=Z(this,"ushort");a.kb=Z(this,"float",8);a.rh=Z(this,"float");a.vj=Z(this,"float");a.uj=Z(this,"float");a.Cj=Z(this,"ushort");a.Aj=Z(this,"uchar");a.Lj=Z(this,"uchar");a.Sh=Z(this,"float");a.Th=Z(this,"float");a.Bj=Z(this,"float");a.Ij=Z(this,"float");a.li=Z(this,"uint",1);a.mi=Z(this,"uint",1);a.Zh=Z(this,"uchar",80);a.Qh=Z(this,"uchar",24);a.Cf=Z(this,"ushort");a.ih=Z(this,"ushort");a.eh=Z(this,"float");a.fh=
Z(this,"float");a.gh=Z(this,"float");a.ah=Z(this,"float");a.bh=Z(this,"float");a.dh=Z(this,"float");a.kh=Z(this,"float",4);a.lh=Z(this,"float",4);a.mh=Z(this,"float",4);a.xi=Z(this,"uchar",16);a.Ei=Z(this,"uchar",4);this.R=parseInt(a.rh,10);var b=a.Vb[1]*a.Vb[2]*a.Vb[3];switch(a.df){case 2:a.data=Z(this,"uchar",b);break;case 4:a.data=Z(this,"sshort",b);break;case 8:a.data=Z(this,"sint",b);break;case 16:a.data=Z(this,"float",b);break;case 32:a.data=Z(this,"complex",b);break;case 64:a.data=Z(this,"double",
b);break;case 256:a.data=Z(this,"schar",b);break;case 512:a.data=Z(this,"ushort",b);break;case 768:a.data=Z(this,"uint",b);break;default:m(Error("Unsupported NII data type: "+a.df))}b=Ne(a.data);a.min=b[0];a.max=b[1];return a};B("X.parserNII",Sf);B("X.parserNII.prototype.parse",Sf.prototype.parse);function Tf(){Me.call(this);this.g="parserOBJ"}C(Tf,Me);
Tf.prototype.parse=function(a,b,c){D.Ya(this.g+".parse");this.P=c;c=c.byteLength;var e=Z(this,"uchar",c),d=[];b.h=new W(c);b.q=new W(c);var f=b.h,g=b.q,h=0,l;for(l=0;l<c;++l)if(10==e[l]){var j=Oe(e,h,l).replace(/\s{2,}/g," ").split(" ");if("v"==j[0])d.push([parseFloat(j[1]),parseFloat(j[2]),parseFloat(j[3])]);else if("f"==j[0]){var k=d[parseInt(j[1],10)-1],h=d[parseInt(j[2],10)-1],j=d[parseInt(j[3],10)-1];f.add(k[0],k[1],k[2]);f.add(h[0],h[1],h[2]);f.add(j[0],j[1],j[2]);k=new U(k[0],k[1],k[2]);j=
new U(j[0],j[1],j[2]);h=Hc((new U(h[0],h[1],h[2])).Ea(k),j.Ea(k));h.normalize();g.add(h.x,h.y,h.d);g.add(h.x,h.y,h.d);g.add(h.x,h.y,h.d)}h=l+1}D.Ua(this.g+".parse");c=new jd;c.K=b;c.B=a;this.dispatchEvent(c)};B("X.parserOBJ",Tf);B("X.parserOBJ.prototype.parse",Tf.prototype.parse);function Uf(){O.call(this);this.g="loader";this.yc=new yc;this.bd=0}C(Uf,O);function Vf(a,b){a.bd+=b/a.yc.ee()/3;a.bd=Math.min(1,a.bd);var c=new Md;c.od=a.bd;a.dispatchEvent(c)}function Wf(a){a=a.r.Sd;var b=a.split(".").pop().toUpperCase();b==a.toUpperCase()&&(b="");b in Xf||m(Error("The "+b+" file format is not supported."));return[a,b,Xf[b][0],Xf[b][1],Xf[b][2]]}
Uf.prototype.load=function(a,b){(!a||!b)&&m(Error("No container or object to load."));if(!Bc(this.yc.$,a.ta)||this.yc.get(a.ta)){this.yc.set(a.ta,u);var c=Wf(a)[0];if(a.mb!=t)this.parse(t,a,b);else{var e=new XMLHttpRequest;L(e,"abort",this.xg.bind(this,e,a,b));L(e,"error",this.xg.bind(this,e,a,b));L(e,"load",this.parse.bind(this,e,a,b));e.open("GET",c,q);e.responseType="arraybuffer";e.send(t)}}};
Uf.prototype.parse=function(a,b,c){Vf(this,1);setTimeout(function(){var e=Wf(b),d=e[3],e=new e[2];$b(e,wd,this.complete.bind(this));var f=b.mb;f==t&&(f=a.response,b.mb=f);e.parse(b,c,f,d)}.bind(this),100)};Uf.prototype.complete=function(a){Vf(this,1);setTimeout(function(){var b=a.B,c=a.K;b.r.j=u;b.j=q;c.p();this.yc.set(b.ta,q)}.bind(this),100)};Uf.prototype.xg=function(a,b,c){m(Error("Loading failed: ",b,c))};
var Xf={OBJ:[Tf,t],STL:[Ze,t],VTK:[bf,t],TRK:[Of,t],FSM:[df,t],INFLATED:[df,t],SMOOTHWM:[df,t],SPHERE:[df,t],PIAL:[df,t],ORIG:[df,t],NRRD:[Rf,t],NII:[Sf,t],GZ:[Sf,t],DCM:[$e,t],DICOM:[$e,t],"":[$e,t],CRV:[Nf,t],LABEL:[Mf,t],MGH:[Lf,u],MGZ:[Lf,q],TXT:[Qf,t],LUT:[Qf,t],PNG:[Pf,"png"],JPG:[Pf,"jpeg"],JPEG:[Pf,"jpeg"],GIF:[Pf,"gif"]};function Yf(a,b){(!x(a)||!x(b))&&m(Error("A camera needs valid width and height values."));O.call(this);this.g="camera";this.cc=new D.m(0,100,0);this.sc=new D.m(0,0,0);this.Z=new D.m(0,0,1);this.H=a;this.v=b;this.n=this.me(this.cc,this.sc)}C(Yf,O);Yf.prototype.observe=function(a){(a==t||!(a instanceof Ge))&&m(Error("Could not observe the interactor."));L(a,rd,this.Zi.bind(this));L(a,qd,this.Wi.bind(this));L(a,sd,this.lj.bind(this))};
Yf.prototype.Zi=function(a){a instanceof Gd||m(Error("Received no valid rotate event."));this.rotate(a.sa)};Yf.prototype.lj=function(a){a instanceof Hd||m(Error("Received no valid zoom event."));a.nb?this.Pf(a.Za):this.Qf(a.Za)};Yf.prototype.Wi=function(a){a instanceof Fd||m(Error("Received no valid pan event."));this.zf(a.sa)};Yf.prototype.__defineGetter__("view",v("n"));
Yf.prototype.__defineSetter__("view",function(a){(a==t||!(a instanceof Float32Array))&&m(Error("Invalid view matrix."));this.n=a});Yf.prototype.__defineGetter__("position",function(){return[this.cc.x,this.cc.y,this.cc.d]});Yf.prototype.__defineSetter__("position",function(a){(a==t||!la(a)||3!=a.length)&&m(Error("Invalid position."));this.cc=new D.m(a[0],a[1],a[2]);this.reset()});Yf.prototype.__defineGetter__("focus",function(){return[this.sc.x,this.sc.y,this.sc.d]});
Yf.prototype.__defineSetter__("focus",function(a){(a==t||!la(a)||3!=a.length)&&m(Error("Invalid focus"));this.sc=new D.m(a[0],a[1],a[2]);this.reset()});Yf.prototype.__defineGetter__("up",function(){return[this.Z.x,this.Z.y,this.Z.d]});Yf.prototype.__defineSetter__("up",function(a){(a==t||!la(a)||3!=a.length)&&m(Error("Invalid up vector."));this.Z=new D.m(a[0],a[1],a[2]);this.reset()});w=Yf.prototype;w.reset=function(){this.n=this.me(this.cc,this.sc)};
w.rotate=function(a){la(a)&&2==a.length?a=new D.m(a[0],a[1],0):a instanceof D.m||m(Error("Invalid distance vector for rotate operation."));return a};w.zf=function(a){la(a)&&2==a.length?a=new D.m(a[0],a[1],0):a instanceof D.m||m(Error("Invalid distance vector for pan operation."));this.n[12]-=a.x;this.n[13]+=a.y};w.Pf=function(a){var b=20;a!=t&&!a&&(b=1);this.n[14]+=b};w.Qf=function(a){var b=20;a!=t&&!a&&(b=1);this.n[14]-=b};
w.me=function(a,b){(!(a instanceof D.m)||!(b instanceof D.m))&&m(Error("3D vectors required for calculating the view."));return D.f.td()};B("X.camera",Yf);B("X.camera.prototype.pan",Yf.prototype.zf);B("X.camera.prototype.rotate",Yf.prototype.rotate);B("X.camera.prototype.zoomIn",Yf.prototype.Pf);B("X.camera.prototype.zoomOut",Yf.prototype.Qf);function Zf(a){function b(a,b,e){b=2*b*Math.PI;b=Aa(Ba(l,Math.cos(b)),Ba(j,Math.sin(b)));a=Aa(Aa(c,Ba(d,a)),Ba(b,f));e=Aa(Ba(b,1-Math.abs(e)),Ba(g,e));return new jc(a,e)}this.V=[];a=a||{};var c=new ya(a.start||[0,-1,0]),e=new ya(a.end||[0,1,0]),d=Ca(e,c),f=a.qb||1;a=a.na||16;for(var g=Da(d),h=0.5<Math.abs(g.y()),l=Da((new ya(h,!h,0)).ic(g)),j=Da(l.ic(g)),h=new jc(c,Fa(g)),e=new jc(e,Da(g)),k=[],n=0;n<a;n++){var r=n/a,s=(n+1)/a;k.push(new lc([h,b(0,r,-1),b(0,s,-1)]));k.push(new lc([b(0,s,0),b(0,r,
0),b(1,r,0),b(1,s,0)]));k.push(new lc([e,b(1,s,1),b(1,r,1)]))}return tc(k)}C(Zf,sc);function $f(){Y.call(this);this.g="cylinder";this.Re=[-10,-10,-10];this.Ae=[10,10,10];this.dc=10;this.Wa=32;Ga(this,new md)}C($f,Y);$f.prototype.__defineGetter__("start",v("Re"));$f.prototype.__defineSetter__("start",function(a){(a==t||!la(a)||3!=a.length)&&m(Error("Invalid start"));this.Re=a});$f.prototype.__defineGetter__("end",v("Ae"));$f.prototype.__defineSetter__("end",function(a){(a==t||!la(a)||3!=a.length)&&m(Error("Invalid end"));this.Ae=a});$f.prototype.__defineGetter__("radius",v("dc"));
$f.prototype.__defineSetter__("radius",function(a){x(a)||m(Error("Invalid radius."));this.dc=a});$f.prototype.p=function(){od(this,new Zf({start:this.Re,end:this.Ae,qb:this.dc,na:this.Wa}));$f.z.p.call(this)};B("X.cylinder",$f);B("X.cylinder.prototype.modified",$f.prototype.p);function ag(a){function b(a,b){a*=2*Math.PI;b*=Math.PI;var d=new ya(Math.cos(a)*Math.sin(b),Math.cos(b),Math.sin(a)*Math.sin(b));g.push(new jc(Aa(c,Ba(d,e)),d))}this.V=[];a=a||{};var c=new ya(a.$e||[0,0,0]),e=a.qb||1,d=a.na||16;a=a.Fj||8;for(var f=[],g=[],h=0;h<d;h++)for(var l=0;l<a;l++)g=[],b(h/d,l/a),0<l&&b((h+1)/d,l/a),l<a-1&&b((h+1)/d,(l+1)/a),b(h/d,(l+1)/a),f.push(new lc(g));return tc(f)}C(ag,sc);function bg(){Y.call(this);this.g="sphere";this.A=[0,0,0];this.dc=5;this.Wa=32;this.Ih=16;Ga(this,new md)}C(bg,Y);bg.prototype.__defineGetter__("center",v("A"));bg.prototype.__defineSetter__("center",function(a){(a==t||!la(a)||3!=a.length)&&m(Error("Invalid center"));this.A=a});bg.prototype.__defineGetter__("radius",v("dc"));bg.prototype.__defineSetter__("radius",function(a){x(a)||m(Error("Invalid radius."));this.dc=a});
bg.prototype.p=function(){od(this,new ag({$e:this.A,qb:this.dc,na:this.Wa,Fj:this.Ih}));bg.z.p.call(this)};B("X.sphere",bg);B("X.sphere.prototype.modified",bg.prototype.p);function Xe(a){Q.call(this);this.g="labelmap";this.zb=a;this.Qe=new Float32Array([-255,-255,-255,-255])}C(Xe,Q);Xe.prototype.p=function(){var a=new jd;a.K=this;this.dispatchEvent(a);this.zb.p()};Xe.prototype.__defineSetter__("showOnly",function(a){var b=[-1,-1,-1,-1];a!=t&&(la(a)&&4==a.length?b=a:(this.Aa||m(Error("No colortable assigned.")),b=this.Aa.Fa.get(a).slice(1,5)));this.Qe=new Float32Array([Math.floor(255*b[0]),Math.floor(255*b[1]),Math.floor(255*b[2]),Math.floor(255*b[3])])});
B("X.labelmap",Xe);function cg(a){this.V=[];a=a||{};var b=new ya(a.$e||[0,0,0]),c=!a.qb?[1,1,1]:a.qb.length?a.qb:[a.qb,a.qb,a.qb];return tc([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,1]]].map(function(a){return new lc(a[0].map(function(d){d=new ya(b.x()+c[0]*(2*!!(d&1)-1),b.y()+c[1]*(2*!!(d&2)-1),b.d()+c[2]*(2*!!(d&4)-1));return new jc(d,new ya(a[1]))}))}))}C(cg,sc);function dg(){Y.call(this);this.g="cube";this.A=[0,0,0];this.Fe=this.Ee=this.De=20;this.Fc=[0,1,1,1,1,0,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,0,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,0,0,1,1,0,0,0];Ga(this,new md)}C(dg,Y);dg.prototype.__defineGetter__("center",v("A"));dg.prototype.__defineSetter__("center",function(a){(a==t||!la(a)||3!=a.length)&&m(Error("Invalid center"));this.A=a});dg.prototype.__defineGetter__("lengthX",v("De"));
dg.prototype.__defineSetter__("lengthX",function(a){x(a)||m(Error("Invalid lengthX."));this.De=a});dg.prototype.__defineGetter__("lengthY",v("Ee"));dg.prototype.__defineSetter__("lengthY",function(a){x(a)||m(Error("Invalid lengthY."));this.Ee=a});dg.prototype.__defineGetter__("lengthZ",v("Fe"));dg.prototype.__defineSetter__("lengthZ",function(a){x(a)||m(Error("Invalid lengthZ."));this.Fe=a});dg.prototype.p=function(){od(this,new cg({$e:this.A,qb:[this.De/2,this.Ee/2,this.Fe/2]}));dg.z.p.call(this)};
B("X.cube",dg);B("X.cube.prototype.modified",dg.prototype.p);function Ie(a){Ge.call(this,a);this.g="interactor3D";this.Bk=u}C(Ie,Ge);Ie.prototype.wd=function(a){Ie.z.wd.call(this,a);var b=new Hd;a.Jc==t&&(a.Jc=0);b.nb=0>a.Jc;b.Za=q;this.dispatchEvent(b)};function eg(a){O.call(this);this.g="array";this.F=[];this.Rf=a}C(eg,O);function fg(a,b,c){for(var e=0;4>e;e++)if(a[e+0]!==b[e+c])return u;return q}eg.prototype.add=function(a){this.F.push(a);return q};eg.prototype.remove=function(a){a=this.F.indexOf(a);-1<a&&this.F.splice(a,1);return q};eg.prototype.clear=function(){this.F.length=0};
function gg(a,b,c){var e=c-b;if(!(2>e)){e=b+Math.floor(e/2);gg(a,b,e);for(gg(a,e,c);b<e;++b)if(0<a.Rf(a.F[b],a.F[e])){var d=a.F[b];a.F[b]=a.F[e];for(var f=a,g=e,h=c;g+1<h&&0>f.Rf(f.F[g+1],d);){var l=f,j=g+1,k=l.F[g];l.F[g]=l.F[j];l.F[j]=k;++g}f.F[g]=d}}}eg.prototype.sort=function(){gg(this,0,this.F.length)};function hg(a,b){Yf.call(this,a,b);this.g="camera2D"}C(hg,Yf);hg.prototype.rotate=function(a){a=hg.z.rotate.call(this,a);var b=new Ed;0<a.x?b.Te--:0>a.x&&b.Te++;0<a.y?b.Ge++:0>a.y&&b.Ge--;this.dispatchEvent(b)};hg.prototype.Pf=function(a){var b=20;a!=t&&!a&&(b=0.02);this.n[14]+=b};hg.prototype.Qf=function(a){var b=20;a!=t&&!a&&(b=0.02);this.n[14]-=b};
hg.prototype.zf=function(a){la(a)&&2==a.length?a=new D.m(a[0],a[1],0):a instanceof D.m||m(Error("Invalid distance vector for pan operation."));this.n[12]-=a.x/this.n[14];this.n[13]+=a.y/this.n[14]};function ig(a,b){Yf.call(this,a,b);this.g="camera3D";this.Uf=45;this.Le=D.f.mf(D.f.td(),this.Uf,a/b,1,1E4)}C(ig,Yf);ig.prototype.rotate=function(a){a=ig.z.rotate.call(this,a);var b=-a.x/5*Math.PI/180;a=-a.y/5*Math.PI/180;var c=new D.m(this.n[1],this.n[5],this.n[9]),e=new D.m(this.n[0],this.n[4],this.n[8]);c.normalize();e.normalize();D.f.rotate(this.n,b,c.x,c.y,c.d);D.f.rotate(this.n,a,e.x,e.y,e.d)};ig.prototype.me=function(a,b){var c=ig.z.me.call(this,a,b);D.f.Mg(c,a,b,this.Z);return c};
function jg(a,b,c,e){var d=new Float32Array(4),f=new Float32Array(4),g=new Float32Array(16),h=new Float32Array(16);new Float32Array(16);D.f.multiply(a.Le,a.n,h);D.f.U(h,g);d[0]=b;d[1]=c;d[2]=2*e-1;d[3]=1;D.f.Qg(g,d,f);f[3]=1/f[3];f[0]*=f[3];f[1]*=f[3];f[2]*=f[3];return f}B("X.camera3D",ig);function kg(a){Pb.call(this);this.Ab=a;this.Q=[]}C(kg,Pb);var lg=[];function mg(a,b,c,e,d){la(c)||(lg[0]=c,c=lg);for(var f=0;f<c.length;f++){var g=L(b,c[f],e||a,d||u,a.Ab||a);a.Q.push(g)}}kg.prototype.Df=function(){Jb(this.Q,bc);this.Q.length=0};kg.prototype.handleEvent=function(){m(Error("EventHandler.handleEvent not implemented"))};function ng(){}ng.zg=function(){return ng.Hg?ng.Hg:ng.Hg=new ng};ng.prototype.Ji=0;ng.zg();function og(a){ic.call(this);this.Wb=a||Xd();this.tj=pg}C(og,ic);og.prototype.ui=ng.zg();var pg=t;w=og.prototype;w.Gg=t;w.Lc=u;w.D=t;w.tj=t;w.xd=t;w.qd=t;w.af=t;w.s=v("D");w.Ff=function(a){this.xd&&this.xd!=a&&m(Error("Method not supported"));og.z.Ff.call(this,a)};w.fe=v("Wb");w.Ic=function(){this.D=this.Wb.createElement("div")};w.Zb=function(a){this.$b(a)};
w.$b=function(a,b){this.Lc&&m(Error("Component already rendered"));this.D||this.Ic();a?a.insertBefore(this.D,b||t):this.Wb.da.body.appendChild(this.D);(!this.xd||this.xd.Lc)&&this.be()};w.be=function(){function a(a){!a.Lc&&a.s()&&a.be()}this.Lc=q;this.qd&&Jb(this.qd,a,p)};w.ce=function(){function a(a){a.Lc&&a.ce()}this.qd&&Jb(this.qd,a,p);this.ni&&this.ni.Df();this.Lc=u};
w.removeChild=function(a,b){if(a){var c=na(a)?a:a.Gg||(a.Gg=":"+(a.ui.Ji++).toString(36)),e;this.af&&c?(e=this.af,e=(c in e?e[c]:p)||t):e=t;a=e;c&&a&&(e=this.af,c in e&&delete e[c],Nb(this.qd,a),b&&(a.ce(),a.D&&de(a.D)),c=a,c==t&&m(Error("Unable to set parent component")),c.xd=t,og.z.Ff.call(c,t))}a||m(Error("Child is not in parent component"));return a};function qg(){ic.call(this)}C(qg,ic);w=qg.prototype;w.Nf=0;w.vd=0;w.nf=100;w.wg=0;w.Jf=1;w.Bi=u;w.Ii=u;w.Bd=function(a){a=rg(this,a);this.Nf!=a&&(this.Nf=a+this.wg>this.nf?this.nf-this.wg:a<this.vd?this.vd:a,!this.Bi&&!this.Ii&&this.dispatchEvent("change"))};w.ie=function(){return rg(this,this.Nf)};w.he=function(){return rg(this,this.vd)};w.ge=function(){return rg(this,this.nf)};function rg(a,b){return a.Jf==t?b:a.vd+Math.round((b-a.vd)/a.Jf)*a.Jf};function sg(a){og.call(this,a);this.zd=new qg;L(this.zd,"change",this.oi,u,this)}C(sg,og);var ug={vertical:"progress-bar-vertical",horizontal:"progress-bar-horizontal"};w=sg.prototype;w.Ic=function(){this.rb=this.fe().Ic("div","progress-bar-thumb");var a=ug[this.Yg];this.D=this.fe().Ic("div",a,this.rb);vg(this);a=this.he();this.s().setAttribute("aria-valuemin",a);a=this.ge();this.s().setAttribute("aria-valuemax",a)};
w.be=function(){sg.z.be.call(this);J&&7>vb&&L(this.s(),"resize",this.we,u,this);this.we();var a=this.s();a.setAttribute("role","progressbar");a.setAttribute("aria-live","polite")};w.ce=function(){sg.z.ce.call(this);J&&7>vb&&ac(this.s(),"resize",this.we,u,this)};w.ie=function(){return this.zd.ie()};w.Bd=function(a){this.zd.Bd(a);this.s()&&vg(this)};function vg(a){var b=a.ie();a.s().setAttribute("aria-valuenow",b)}w.he=function(){return this.zd.he()};w.ge=function(){return this.zd.ge()};w.Yg="horizontal";
w.oi=function(){this.we();this.dispatchEvent("change")};w.we=function(){if(this.rb){var a=this.he(),b=this.ge(),a=(this.ie()-a)/(b-a),b=Math.round(100*a);"vertical"==this.Yg?J&&7>vb?(this.rb.style.top=0,this.rb.style.height="100%",b=this.rb.offsetHeight,a=Math.round(a*b),this.rb.style.top=b-a+"px",this.rb.style.height=a+"px"):(this.rb.style.top=100-b+"%",this.rb.style.height=b+"%"):this.rb.style.width=b+"%"}};function wg(a,b){a==t&&m(Error("No valid parent element."));b==t&&m(Error("Invalid initial value."));sg.call(this);this.g="progressbar";this.Va=a;this.Ke="";this.Jd=this.yb=t;this.ac=[];var c;c=".progress-bar-horizontal {\n  position: relative;\n  border: 1px solid #949dad;\n";c+="  background: white;\n";c+="  padding: 1px;\n";c+="  overflow: hidden;\n";c+="  margin: 2px;\n";c+="  width: 100px;\n";c+="  height: 5px;\n";c+="}";var e;e=".progress-bar-thumb {\n  position: relative;\n  background: #F62217;\n";
e+="  overflow: hidden;\n";e+="  width: 0%;\n";e+="  height: 100%;\n";e+="}";var d;d=".progress-bar-thumb-done {\n  background: #57E964;\n}";this.ac=[c,e,d];this.Bd(b);this.hf()}C(wg,sg);
wg.prototype.hf=function(){var a=le(this.Va,"position");if("static"==a||""==a)this.Ke=this.Va.style.position,this.Va.style.position="relative";var a=document.getElementsByTagName("head")[0],b=be("style");b.type="text/css";b.media="screen";var c=document.createTextNode(String(this.ac[0])),e=document.createTextNode(String(this.ac[1])),d=document.createTextNode(String(this.ac[2]));a.appendChild(b);b.appendChild(c);b.appendChild(e);b.appendChild(d);this.yb=b;this.Zb(this.Va);a=this.s();a.style.position=
"absolute";a.style.top=(this.Va.clientHeight-5)/2+"px";a.style.left=(this.Va.clientWidth-100)/2+"px";a.classList.add("xtk-progress-bar")};function xg(a){var b=a.s().style.top,c=a.s().style.left;de(a.s());var e=new wg(a.Va,100),d=e.s();d.style.position="absolute";d.style.top=b;d.style.left=c;d.classList.add("xtk-progress-bar");(d.firstElementChild!=p?d.firstElementChild:ee(d.firstChild)).classList.add("progress-bar-thumb-done");a.Jd=e}
wg.prototype.ud=function(){this.yb&&de(this.yb);this.s()&&de(this.s());this.Jd&&de(this.Jd.s());this.Jd=this.yb=t;this.Ke&&(this.Va.style.position=this.Ke)};function yg(a,b,c){oa(a)?c&&(a=va(a,c)):a&&"function"==typeof a.handleEvent?a=va(a.handleEvent,a):m(Error("Invalid listener argument"));return 2147483647<b?-1:ga.setTimeout(a,b||0)};function zg(){O.call(this);this.g="renderer";this.B=window.document.body;this.H=this.B.clientWidth;this.v=this.B.clientHeight;this.S=this.J=this.za=t;this.pb=new eg(ld);this.hb=[];this.W=t;this.Rd=this.Rc=this.Pd=u;this.a=this.Sb=this.Ga=t;this.O={PROGRESSBAR_ENABLED:q,INTERMEDIATE_RENDERING:u,SLICENAVIGATORS:q};this.xe=-1;window.console.log("XTK release 10 -- 2013-11-07 14:57:41 -- http://www.goXTK.com -- @goXTK")}C(zg,O);w=zg.prototype;
w.sf=function(){window.cancelAnimationFrame(this.xe);this.O.PROGRESSBAR_ENABLED&&(this.Sb=new wg(this.B,3))};w.tf=function(){this.O.PROGRESSBAR_ENABLED&&this.Sb&&(xg(this.Sb),this.Gd=yg(function(){this.Gd=t;this.Sb&&(this.Sb.ud(),this.Sb=t);this.Rc=this.Rd=q;this.Zb()}.bind(this),700))};w.uf=function(a){this.Sb&&this.Sb.Bd(100*a.od)};w.Xi=function(a){this.Ga&&this.Ga.Bd(100*a.od)};w.Ni=function(a){a!=t&&a instanceof jd&&a.K&&this.sb(a.K)};w.Yi=function(a){a!=t&&a instanceof kd&&a.K&&this.remove(a.K)};
w.wf=function(a){(a==t||!(a instanceof Jd))&&m(Error("Invalid hover event."))};w.xf=function(){var a=$d(this.B);this.H=a.clientWidth;this.v=a.clientHeight;a=$d(this.za);a.width=this.H;a.height=this.v;"renderer3D"==this.g&&(this.a.viewport(0,0,this.H,this.v),this.J.Le=D.f.mf(D.f.td(),this.J.Uf,this.za.width/this.za.height,1,1E4))};w.yf=function(a){(a==t||!(a instanceof Id))&&m(Error("Invalid scroll event."))};zg.prototype.__defineGetter__("config",v("O"));
zg.prototype.__defineGetter__("interactor",v("S"));zg.prototype.__defineGetter__("camera",v("J"));zg.prototype.__defineGetter__("loadingCompleted",v("Rc"));zg.prototype.__defineGetter__("container",v("B"));zg.prototype.__defineSetter__("container",function(a){a==t&&m(Error("An ID to a valid container (<div>..) is required."));var b=a;na(b)&&(b=$d(a));pa(b)&&1==b.nodeType||m(Error("Could not find the given container."));this.B=b});w=zg.prototype;w.Ad=function(){this.J.reset()};
w.wa=function(a){var b=be("canvas");this.B.appendChild(b);this.H=this.B.clientWidth;this.v=this.B.clientHeight;b.width=this.H;b.height=this.v;try{var c=b.getContext(a);c||m(Error())}catch(e){var d="Sorry, "+a+' context is <strong>not supported</strong> on this machine! See <a href="http://crash.goXTK.com" target="_blank">http://crash.goXTK.com</a> for requirements..';this.B.innerHTML='<h3 style="color:red;font-family:sans-serif;">Oooops..</h3><p style="color:red;font-family:sans-serif;">'+d+"</p>";
m(Error(d))}this.W=new Uf;L(this.W,yd,this.Xi.bind(this));this.za=b;this.a=c;b=new Ie(this.za);"2d"==a&&(b=new Ke(this.za));b.wa();L(b,ud,this.Ad.bind(this));L(b,zd,this.wf.bind(this));L(b,td,this.yf.bind(this));this.S=b;b=new ig(this.H,this.v);"2d"==a&&(b=new hg(this.H,this.v));b.observe(this.S);this.J=b;L(window,"resize",this.xf,u,this)};w.add=function(a){(a instanceof dg||a instanceof bg||a instanceof $f)&&a.p();this.hb.push(a);this.sb(a)};
w.remove=function(a){(!this.za||!this.a)&&m(Error("The renderer was not initialized properly."));if(a!=t){var b=0;if(a!=t){if(a=qa(a),Wb[a]){a=Wb[a];for(var c=a.length-1;0<=c;c--)bc(a[c].key),b++}}else Na(Ub,function(a,c){bc(c);b++})}return u};
w.sb=function(a){(!this.za||!this.a)&&m(Error("The renderer was not initialized properly."));a!=t&&(dc(a,wd)||L(a,wd,this.Ni.bind(this)),dc(a,xd)||L(a,xd,this.Yi.bind(this)),dc(a,Bd)||L(a,Bd,this.sf.bind(this)),dc(a,Dd)||L(a,Dd,this.uf.bind(this)),dc(a,Cd)||L(a,Cd,this.tf.bind(this)))};w.get=function(a){a==t&&m(Error("Invalid object id."));for(var b=this.pb.F,c=b.length,e=0,e=0;e<c;e++)if(b[e].ta==a)return b[e];return t};
w.Zb=function(){(!this.za||!this.a)&&m(Error("The renderer was not initialized properly."));if(this.ig==t){if(Ac(this.W.yc)){if(this.O.PROGRESSBAR_ENABLED&&!this.Ga&&(this.Ga=new wg(this.B,3)),this.Rd=this.Rc=u,this.ig=yg(function(){this.ig=t;this.Zb()}.bind(this),100),!this.O.INTERMEDIATE_RENDERING)return}else if(!this.Rc&&!this.Rd&&(this.Rd=q,eval("this.onShowtime()"),this.Rc=q),this.Ga){this.O.PROGRESSBAR_ENABLED&&(this.Ga&&!this.Gd)&&(xg(this.Ga),this.Gd=yg(function(){this.Gd=t;this.Ga&&(this.Ga.ud(),
this.Ga=t);this.Zb()}.bind(this),700));return}this.xe=window.requestAnimationFrame(this.Zb.bind(this));eval("this.onRender()");this.$b(u,q)}};w.Xg=ea();w.Vg=ea();w.$b=ea();w.$d=function(){window.cancelAnimationFrame(this.xe);this.W&&(delete this.W,this.W=t);this.Ga&&(this.Ga.ud(),delete this.Ga,this.Ga=t);this.pb.clear();delete this.pb;this.hb.length=0;delete this.hb;delete this.W;this.W=t;delete this.J;this.J=t;delete this.S;this.S=t;delete this.a;this.a=t;de(this.za);delete this.za;this.za=t};function Ag(){O.call(this);this.g="shaders";this.Vd="";var a;a="precision mediump float;\n\n";a+="attribute vec3 vertexPosition;\n";a+="attribute vec3 vertexNormal;\n";a+="attribute vec3 vertexColor;\n";a+="attribute vec2 vertexTexturePos;\n";a+="attribute float vertexScalar;\n";a+="\n";a+="uniform mat4 view;\n";a+="uniform mat4 perspective;\n";a+="uniform vec3 center;\n";a+="uniform mat4 objectTransform;\n";a+="uniform bool useObjectColor;\n";a+="uniform bool useScalars;\n";a+="uniform bool scalarsReplaceMode;\n";
a+="uniform float scalarsMin;\n";a+="uniform float scalarsMax;\n";a+="uniform vec3 scalarsMinColor;\n";a+="uniform vec3 scalarsMaxColor;\n";a+="uniform float scalarsMinThreshold;\n";a+="uniform float scalarsMaxThreshold;\n";a+="uniform int scalarsInterpolation;\n";a+="uniform vec3 objectColor;\n";a+="uniform float pointSize;\n";a+="\n";a+="varying float fDiscardNow;\n";a+="varying vec4 fVertexPosition;\n";a+="varying vec3 fragmentColor;\n";a+="varying vec2 fragmentTexturePos;\n";a+="varying vec3 fVertexNormal;\n";
a+="varying vec3 fTransformedVertexNormal;\n";a+="\n";a+="void main(void) {\n";a+="  fTransformedVertexNormal = mat3(view[0].xyz,view[1].xyz,view[2].xyz) * ";a+="mat3(objectTransform[0].xyz,objectTransform[1].xyz,objectTransform[2].xyz) * ";a+="vertexNormal;\n";a+="  fVertexNormal = vertexNormal;\n";a+="  fDiscardNow = 0.0;\n";a+="  vec3 vertexPosition2 = vertexPosition - center;\n";a+="  fVertexPosition = view * objectTransform * vec4(vertexPosition2, 1.0);\n";a+="  fragmentTexturePos = vertexTexturePos;\n";
a+="  if (useScalars) {\n";a+="    float scalarValue = vertexScalar;\n";a+="    if (scalarValue < scalarsMinThreshold || scalarValue > scalarsMaxThreshold) {\n";a+="      if (scalarsReplaceMode) {\n";a+="        fragmentColor = objectColor;\n";a+="      } else {\n";a+="        fDiscardNow = 1.0;\n";a+="      }\n";a+="    } else {\n";a+="      if (scalarsReplaceMode) {\n";a+="        if (scalarsInterpolation == 1) {\n";a+="            vec3 zeroMaxColor;\n";a+="            vec3 zeroMinColor;\n";a+=
"            zeroMaxColor[0] = scalarsMaxColor[0]*0.33;\n";a+="            zeroMaxColor[1] = scalarsMaxColor[1]*0.33;\n";a+="            zeroMaxColor[2] = scalarsMaxColor[2]*0.33;\n";a+="            zeroMinColor[0] = scalarsMinColor[0]*0.33;\n";a+="            zeroMinColor[1] = scalarsMinColor[1]*0.33;\n";a+="            zeroMinColor[2] = scalarsMinColor[2]*0.33;\n";a+="            if(scalarValue < 0.0) {fragmentColor = scalarValue/(scalarsMin) * scalarsMinColor + (1.0 - scalarValue/(scalarsMin)) * (zeroMinColor);}\n";
a+="            else {fragmentColor = scalarValue/(scalarsMax) * scalarsMaxColor + (1.0 - scalarValue/(scalarsMax)) * (zeroMaxColor);}\n";a+="        } else {\n";a+="            fragmentColor = scalarValue * scalarsMaxColor + (1.0 - scalarValue) * scalarsMinColor;\n";a+="          }\n";a+="      } else {\n";a+="        fragmentColor = vertexColor;\n";a+="      }\n";a+="    }\n";a+="  } else if (useObjectColor) {\n";a+="    fragmentColor = objectColor;\n";a+="  } else {\n";a+="    fragmentColor = vertexColor;\n";
a+="  }\n";a+="  gl_PointSize = pointSize;\n";a+="  gl_Position = perspective * fVertexPosition;\n";this.Vd=a+="}\n";this.Kd="";a="precision mediump float;\n\n";a+="uniform bool usePicking;\n";a+="uniform bool useTexture;\n";a+="uniform bool volumeTexture;\n";a+="uniform bool useLabelMapTexture;\n";a+="uniform sampler2D textureSampler;\n";a+="uniform sampler2D textureSampler2;\n";a+="uniform float objectOpacity;\n";a+="uniform float labelmapOpacity;\n";a+="uniform vec4 labelmapColor;\n";a+="uniform float volumeLowerThreshold;\n";
a+="uniform float volumeUpperThreshold;\n";a+="uniform float volumeScalarMin;\n";a+="uniform float volumeScalarMax;\n";a+="uniform vec3 volumeScalarMinColor;\n";a+="uniform vec3 volumeScalarMaxColor;\n";a+="uniform float volumeWindowLow;\n";a+="uniform float volumeWindowHigh;\n";a+="\n";a+="varying float fDiscardNow;\n";a+="varying vec4 fVertexPosition;\n";a+="varying vec3 fragmentColor;\n";a+="varying vec2 fragmentTexturePos;\n";a+="varying vec3 fVertexNormal;\n";a+="varying vec3 fTransformedVertexNormal;\n";
a+="\n";a+="void main(void) {\n";a+=" if (fDiscardNow > 0.0) {\n";a+="   discard;\n";a+=" }\n";a+=" if (usePicking) {\n";a+="   gl_FragColor = vec4(fragmentColor, 1.0);\n";a+=" } else if (useTexture) {\n";a+="   vec4 texture1 = texture2D(textureSampler,fragmentTexturePos);\n";a+="   vec4 textureSum = texture1;\n";a+="   if (volumeTexture) {\n";a+="     float _windowLow = (volumeWindowLow / volumeScalarMax);\n";a+="     float _windowHigh = (volumeWindowHigh / volumeScalarMax);\n";a+="     vec3 _minrange = vec3(_windowLow,_windowLow,_windowLow);\n";
a+="     vec3 _maxrange = vec3(_windowHigh,_windowHigh,_windowHigh);\n";a+="     vec3 fac = _maxrange - _minrange;\n";a+="     textureSum = vec4((textureSum.r - _minrange)/fac,1);\n";a+="     textureSum = textureSum.r * vec4(volumeScalarMaxColor,1) + (1.0 - textureSum.r) * vec4(volumeScalarMinColor,1);\n";a+="   }\n";a+="   if (useLabelMapTexture) {\n";a+="     vec4 texture2 = texture2D(textureSampler2,fragmentTexturePos);\n";a+="     if (texture2.a > 0.0) {\n";a+="         if (labelmapColor.a != -255.0) {\n";
a+="           if (all(equal(floor(texture2 * vec4(255)), labelmapColor))) {\n";a+="             if (labelmapOpacity < 1.0) {\n";a+="               textureSum = mix(texture2, textureSum, 1.0 - labelmapOpacity);\n";a+="             } else {\n";a+="               textureSum = texture2;\n";a+="             }\n";a+="           }\n";a+="         } else {\n";a+="           if (labelmapOpacity < 1.0) {\n";a+="             textureSum = mix(texture2, textureSum, 1.0 - labelmapOpacity);\n";a+="           } else {\n";
a+="             textureSum = texture2;\n";a+="           }\n";a+="         }\n";a+="     }\n";a+="   }\n";a+="   if (volumeTexture) {\n";a+="     float _volumeLowerThreshold = (volumeLowerThreshold / volumeScalarMax);\n";a+="     float _volumeUpperThreshold = (volumeUpperThreshold / volumeScalarMax);\n";a+="     if (texture1.r < _volumeLowerThreshold ||\n";a+="         texture1.r > _volumeUpperThreshold ||\n";a+="         texture1.a == 0.0 ) {\n";a+="       discard;\n";a+="     };\n";a+="   };\n";
a+="   gl_FragColor = textureSum;\n";a+="   gl_FragColor.a = objectOpacity;\n";a+=" } else {\n";a+="   vec3 nNormal = normalize(fTransformedVertexNormal);\n";a+="   if (fVertexNormal == vec3(0.0,0.0,0.0)) {\n";a+="     gl_FragColor = vec4(fragmentColor,1.0);\n";a+="     return;\n";a+="   }\n";a+="   vec3 light = vec3(0.0, 0.0, 1.0);\n";a+="   vec3 lightDirection = vec3(0,0,-10);\n";a+="   lightDirection = normalize(lightDirection);\n";a+="   vec3 eyeDirection = normalize(-fVertexPosition.xyz);\n";
a+="   vec3 reflectionDirection = reflect(-lightDirection, nNormal);\n";a+="   float specular = pow(max(dot(reflectionDirection, eyeDirection), 0.0), 10.0);\n";a+="   float diffuse = 0.8 * max(dot(nNormal, light), 0.0);\n";a+="   float ambient = 0.3;\n";a+="   gl_FragColor = vec4(fragmentColor * ambient +\n";a+="                       fragmentColor * diffuse +\n";a+="                       vec3(0.2, 0.2, 0.2) * specular,\n";a+="                       objectOpacity);\n";a+=" }\n";this.Kd=a+="}\n"}
C(Ag,O);
var Bg={nk:"vertexPosition",mk:"vertexNormal",lk:"vertexColor",pk:"vertexTexturePos",ok:"vertexScalar"},Cg={qk:"view",Vj:"perspective",Mj:"center",Uj:"objectTransform",hk:"useObjectColor",Sj:"objectColor",jk:"useScalars",dk:"scalarsReplaceMode",ak:"scalarsMin",Yj:"scalarsMax",bk:"scalarsMinColor",Zj:"scalarsMaxColor",ck:"scalarsMinThreshold",$j:"scalarsMaxThreshold",Xj:"scalarsInterpolation",Wj:"pointSize",Tj:"objectOpacity",Rj:"normal",ik:"usePicking",kk:"useTexture",gk:"useLabelMapTexture",Pj:"labelmapOpacity",
Oj:"labelmapColor",ek:"textureSampler",fk:"textureSampler2",rk:"volumeLowerThreshold",xk:"volumeUpperThreshold",uk:"volumeScalarMin",sk:"volumeScalarMax",vk:"volumeScalarMinColor",tk:"volumeScalarMaxColor",zk:"volumeWindowLow",yk:"volumeWindowHigh",wk:"volumeTexture"};function Dg(a,b,c,e,d,f,g,h){var l,j;if(l=c.offsetParent){var k="HTML"==l.tagName||"BODY"==l.tagName;if(!k||"static"!=me(l,"position"))j=re(l),k||(k=(k=se(l))&&lb?-l.scrollLeft:k&&(!J||!Cb("8"))&&"visible"!=me(l,"overflowX")?l.scrollWidth-l.clientWidth-l.scrollLeft:l.scrollLeft,j=Wd(j,new Vd(k,l.scrollTop)))}l=j||new Vd;j=re(a);k=we(a);j=new je(j.x,j.y,k.width,k.height);(k=qe(a))&&j.Ig(new je(k.left,k.top,k.right-k.left,k.bottom-k.top));var k=Xd(a),n=Xd(c);if(k.da!=n.da){var r=k.da.body,n=n.da.parentWindow||
n.da.defaultView,s=new Vd(0,0),z=Zd(r)?Zd(r).parentWindow||Zd(r).defaultView:window,y=r;do{var E=z==n?re(y):te(y);s.x+=E.x;s.y+=E.y}while(z&&z!=n&&(y=z.frameElement)&&(z=z.parent));r=Wd(s,re(r));J&&!ge(k)&&(r=Wd(r,he(k)));j.left+=r.x;j.top+=r.y}a=(b&4&&se(a)?b^2:b)&-5;b=new Vd(a&2?j.left+j.width:j.left,a&1?j.top+j.height:j.top);b=Wd(b,l);d&&(b.x+=(a&2?-1:1)*d.x,b.y+=(a&1?-1:1)*d.y);var F;if(g&&(F=qe(c)))F.top-=l.y,F.right-=l.x,F.bottom-=l.y,F.left-=l.x;return Eg(b,c,e,f,F,g,h)}
function Eg(a,b,c,e,d,f,g){a=a.l();var h=0,l=(c&4&&se(b)?c^2:c)&-5;c=we(b);g=g?g.l():c.l();if(e||0!=l)l&2?a.x-=g.width+(e?e.right:0):e&&(a.x+=e.left),l&1?a.y-=g.height+(e?e.bottom:0):e&&(a.y+=e.top);if(f){if(d){h=a;e=0;if(65==(f&65)&&(h.x<d.left||h.x>=d.right))f&=-2;if(132==(f&132)&&(h.y<d.top||h.y>=d.bottom))f&=-5;h.x<d.left&&f&1&&(h.x=d.left,e|=1);h.x<d.left&&(h.x+g.width>d.right&&f&16)&&(g.width=Math.max(g.width-(h.x+g.width-d.right),0),e|=4);h.x+g.width>d.right&&f&1&&(h.x=Math.max(d.right-g.width,
d.left),e|=1);f&2&&(e|=(h.x<d.left?16:0)|(h.x+g.width>d.right?32:0));h.y<d.top&&f&4&&(h.y=d.top,e|=2);h.y<=d.top&&(h.y+g.height<d.bottom&&f&32)&&(g.height=Math.max(g.height-(d.top-h.y),0),h.y=0,e|=8);h.y>=d.top&&(h.y+g.height>d.bottom&&f&32)&&(g.height=Math.max(g.height-(h.y+g.height-d.bottom),0),e|=8);h.y+g.height>d.bottom&&f&4&&(h.y=Math.max(d.bottom-g.height,d.top),e|=2);f&8&&(e|=(h.y<d.top?64:0)|(h.y+g.height>d.bottom?128:0));h=e}else h=256;if(h&496)return h}f=a;d=lb&&(bb||qb)&&Cb("1.9");f instanceof
Vd?(a=f.x,f=f.y):(a=f,f=p);b.style.left=ve(a,d);b.style.top=ve(f,d);if(!(c==g||(!c||!g?0:c.width==g.width&&c.height==g.height)))a=ge(Xd(Zd(b))),J&&(!a||!Cb("8"))?(c=b.style,a?(J?(a=Ae(b,"paddingLeft"),d=Ae(b,"paddingRight"),f=Ae(b,"paddingTop"),e=Ae(b,"paddingBottom"),a=new ie(f,d,e,a)):(a=le(b,"paddingLeft"),d=le(b,"paddingRight"),f=le(b,"paddingTop"),e=le(b,"paddingBottom"),a=new ie(parseFloat(f),parseFloat(d),parseFloat(e),parseFloat(a))),J?(d=Ce(b,"borderLeft"),f=Ce(b,"borderRight"),e=Ce(b,"borderTop"),
b=Ce(b,"borderBottom"),b=new ie(e,f,b,d)):(d=le(b,"borderLeftWidth"),f=le(b,"borderRightWidth"),e=le(b,"borderTopWidth"),b=le(b,"borderBottomWidth"),b=new ie(parseFloat(e),parseFloat(f),parseFloat(b),parseFloat(d))),c.pixelWidth=g.width-b.left-a.left-a.right-b.right,c.pixelHeight=g.height-b.top-a.top-a.bottom-b.bottom):(c.pixelWidth=g.width,c.pixelHeight=g.height)):(b=b.style,lb?b.MozBoxSizing="border-box":mb?b.WebkitBoxSizing="border-box":b.boxSizing="border-box",b.width=Math.max(g.width,0)+"px",
b.height=Math.max(g.height,0)+"px");return h};function Fg(){}Fg.prototype.lb=ea();function Gg(a,b){this.bf=a instanceof Vd?a:new Vd(a,b)}C(Gg,Fg);Gg.prototype.lb=function(a,b,c,e){Dg(ne(a),0,a,b,this.bf,c,t,e)};function Hg(a,b,c){this.element=a;this.ug=b;this.mj=c}C(Hg,Fg);Hg.prototype.lb=function(a,b,c){Dg(this.element,this.ug,a,b,p,c,this.mj)};function Ig(a,b){ic.call(this);this.Ab=new kg(this);this.Ef(a||t);b&&(this.Mc=b)}C(Ig,ic);w=Ig.prototype;w.D=t;w.Ph=q;w.og=t;w.Ha=u;w.xj=u;w.kf=-1;w.Lg=-1;w.ti=u;w.ci=q;w.Mc="toggle_display";w.s=v("D");w.Ef=function(a){this.Ha&&m(Error("Can not change this state of the popup while showing."));this.D=a};
function Jg(a,b){a.ve&&a.ve.stop();a.je&&a.je.stop();if(b){if(!a.Ha&&a.rf()){a.D||m(Error("Caller must call setElement before trying to show the popup"));a.lb();var c=Zd(a.D);a.ti&&mg(a.Ab,c,"keydown",a.Li,q);if(a.Ph)if(mg(a.Ab,c,"mousedown",a.Tg,q),J){var e;try{e=c.activeElement}catch(d){}for(;e&&"IFRAME"==e.nodeName;){try{var f=e.contentDocument||e.contentWindow.document}catch(g){break}c=f;e=c.activeElement}mg(a.Ab,c,"mousedown",a.Tg,q);mg(a.Ab,c,"deactivate",a.Sg)}else mg(a.Ab,c,"blur",a.Sg);"toggle_display"==
a.Mc?(a.D.style.visibility="visible",ye(a.D,q)):"move_offscreen"==a.Mc&&a.lb();a.Ha=q;a.ve?($b(a.ve,"end",a.Wg,u,a),a.ve.play()):a.Wg()}}else Kg(a)}w.lb=ha;function Kg(a,b){if(!a.Ha||!a.dispatchEvent({type:"beforehide",target:b}))return u;a.Ab&&a.Ab.Df();a.Ha=u;a.Lg=xa();a.je?($b(a.je,"end",wa(a.tg,b),u,a),a.je.play()):a.tg(b);return q}w.tg=function(a){"toggle_display"==this.Mc?this.xj?yg(this.Dg,0,this):this.Dg():"move_offscreen"==this.Mc&&(this.D.style.top="-10000px");this.vf(a)};
w.Dg=function(){this.D.style.visibility="hidden";ye(this.D,u)};w.rf=function(){return this.dispatchEvent("beforeshow")};w.Wg=function(){this.kf=xa();this.Lg=-1;this.dispatchEvent("show")};w.vf=function(a){this.dispatchEvent({type:"hide",target:a})};w.Tg=function(a){a=a.target;!fe(this.D,a)&&((!this.og||fe(this.og,a))&&!(150>xa()-this.kf))&&Kg(this,a)};w.Li=function(a){27==a.keyCode&&Kg(this,a.target)&&(a.preventDefault(),a.stopPropagation())};
w.Sg=function(a){if(this.ci){var b=Zd(this.D);if(J||jb){if(a=b.activeElement,!a||fe(this.D,a)||"BODY"==a.tagName)return}else if(a.target!=b)return;150>xa()-this.kf||Kg(this)}};function Lg(a,b){this.qj=4;this.ne=b||p;Ig.call(this,a)}C(Lg,Ig);Lg.prototype.lb=function(){if(this.ne){var a=!this.Ha&&"move_offscreen"!=this.Mc,b=this.s();a&&(b.style.visibility="hidden",ye(b,q));this.ne.lb(b,this.qj,this.Sk);a&&ye(b,u)}};function Mg(a){this.$=new yc;a&&this.Ue(a)}function Ng(a){var b=typeof a;return"object"==b&&a||"function"==b?"o"+qa(a):b.substr(0,1)+a}w=Mg.prototype;w.ee=function(){return this.$.ee()};w.add=function(a){this.$.set(Ng(a),a)};w.Ue=function(a){a=xc(a);for(var b=a.length,c=0;c<b;c++)this.add(a[c])};w.Df=function(a){a=xc(a);for(var b=a.length,c=0;c<b;c++)this.remove(a[c])};w.remove=function(a){return this.$.remove(Ng(a))};w.clear=function(){this.$.clear()};
w.contains=function(a){a=Ng(a);return Bc(this.$.$,a)};w.Ig=function(a){var b=new Mg;a=xc(a);for(var c=0;c<a.length;c++){var e=a[c];this.contains(e)&&b.add(e)}return b};w.sd=function(){return this.$.sd()};w.l=function(){return new Mg(this)};function Og(a,b,c){this.Wb=c||(a?Xd($d(a)):Xd());Lg.call(this,this.Wb.Ic("div",{style:"position:absolute;display:none;"}));this.cf=new Vd(1,1);this.ae=new Mg;a&&Pg(this,a);if(b!=t)if(a=this.s(),"textContent"in a)a.textContent=b;else if(a.firstChild&&3==a.firstChild.nodeType){for(;a.lastChild!=a.firstChild;)a.removeChild(a.lastChild);a.firstChild.data=b}else{for(;c=a.firstChild;)a.removeChild(c);a.appendChild(Zd(a).createTextNode(String(b)))}}C(Og,Lg);var Qg=[];w=Og.prototype;w.Na=t;w.className="goog-tooltip";
w.jh=500;w.si=0;w.fe=v("Wb");function Pg(a,b){b=$d(b);a.ae.add(b);L(b,"mouseover",a.ri,u,a);L(b,"mouseout",a.Ag,u,a);L(b,"mousemove",a.qi,u,a);L(b,"focus",a.pi,u,a);L(b,"blur",a.Ag,u,a)}w.Ef=function(a){var b=this.s();b&&de(b);Og.z.Ef.call(this,a);a&&(b=this.Wb.da.body,b.insertBefore(a,b.lastChild))};
w.rf=function(){if(!Ig.prototype.rf.call(this))return u;if(this.anchor)for(var a,b=0;a=Qg[b];b++)fe(a.s(),this.anchor)||Jg(a,u);0<=Ib(Qg,this)||Qg.push(this);a=this.s();a.className=this.className;Rg(this);L(a,"mouseover",this.Cg,u,this);L(a,"mouseout",this.Bg,u,this);Sg(this);return q};
w.vf=function(){Nb(Qg,this);for(var a=this.s(),b,c=0;b=Qg[c];c++)b.anchor&&fe(a,b.anchor)&&Jg(b,u);this.Zg&&Tg(this.Zg);ac(a,"mouseover",this.Cg,u,this);ac(a,"mouseout",this.Bg,u,this);this.anchor=p;if(0==(this.Db?this.Ha?4:1:this.Kc?3:this.Ha?2:0))this.se=u;Ig.prototype.vf.call(this)};w.Pg=function(a,b){this.anchor==a&&this.ae.contains(this.anchor)&&(this.se||!this.Wk?(Jg(this,u),this.Ha||(this.anchor=a,this.ne=b||Ug(this,0)||p,this.Ha&&this.lb(),Jg(this,q))):this.anchor=p);this.Db=p};
w.Hi=function(a){this.Kc=p;a==this.anchor&&(this.Na==t||this.Na!=this.s()&&!this.ae.contains(this.Na))&&(!this.qg||!this.qg.Na)&&Jg(this,u)};function Vg(a,b){var c=he(a.Wb);a.cf.x=b.clientX+c.x;a.cf.y=b.clientY+c.y}w.ri=function(a){var b=Wg(this,a.target);this.Na=b;Rg(this);b!=this.anchor&&(this.anchor=b,this.Db||(this.Db=yg(va(this.Pg,this,b,p),this.jh)),Xg(this),Vg(this,a))};function Wg(a,b){try{for(;b&&!a.ae.contains(b);)b=b.parentNode;return b}catch(c){return t}}
w.qi=function(a){Vg(this,a);this.se=q};w.pi=function(a){this.Na=a=Wg(this,a.target);this.se=q;if(this.anchor!=a){this.anchor=a;var b=Ug(this,1);Rg(this);this.Db||(this.Db=yg(va(this.Pg,this,a,b),this.jh));Xg(this)}};function Ug(a,b){if(0==b){var c=a.cf.l();return new Yg(c)}return new Zg(a.Na)}function Xg(a){if(a.anchor)for(var b,c=0;b=Qg[c];c++)fe(b.s(),a.anchor)&&(b.qg=a,a.Zg=b)}
w.Ag=function(a){var b=Wg(this,a.target),c=Wg(this,a.relatedTarget);b!=c&&(b==this.Na&&(this.Na=t),Sg(this),this.se=u,this.Ha&&(!a.relatedTarget||!fe(this.s(),a.relatedTarget))?Tg(this):this.anchor=p)};w.Cg=function(){var a=this.s();this.Na!=a&&(Rg(this),this.Na=a)};w.Bg=function(a){var b=this.s();if(this.Na==b&&(!a.relatedTarget||!fe(b,a.relatedTarget)))this.Na=t,Tg(this)};function Sg(a){a.Db&&(ga.clearTimeout(a.Db),a.Db=p)}
function Tg(a){if(2==(a.Db?a.Ha?4:1:a.Kc?3:a.Ha?2:0))a.Kc=yg(va(a.Hi,a,a.anchor),a.si)}function Rg(a){a.Kc&&(ga.clearTimeout(a.Kc),a.Kc=p)}function Yg(a,b){Gg.call(this,a,b)}C(Yg,Gg);Yg.prototype.lb=function(a,b,c){b=ne(a);b=qe(b);c=c?new ie(c.top+10,c.right,c.bottom,c.left+10):new ie(10,0,0,10);Eg(this.bf,a,4,c,b,9)&496&&Eg(this.bf,a,4,c,b,5)};function Zg(a){Hg.call(this,a,3)}C(Zg,Hg);
Zg.prototype.lb=function(a,b,c){var e=new Vd(10,0);Dg(this.element,this.ug,a,b,e,c,9)&496&&Dg(this.element,2,a,1,e,c,5)};function $g(a,b,c,e){a==t&&m(Error("No valid parent element."));(!x(b)||!x(c))&&m(Error("Invalid coordinates."));(e==t||!(e instanceof Ge))&&m(Error("Invalid interactor."));Og.call(this);this.g="caption";this.Va=a;this.Xd=b;this.Yd=c;this.S=e;this.yb=t;this.ac=[];a=".x-tooltip {\n  background: #C0C0FF;\n  color: #000000;\n";a+="  border: 1px solid infotext;\n";a+="  padding: 1px;\n";a+="  font-family: sans-serif;\n";a+="}";this.ac=[a];$b(e,Ad,this.ud.bind(this));this.hf()}C($g,Og);
$g.prototype.hf=function(){var a=le(this.Va,"position");if("static"==a||""==a)this.Va.style.position="relative";var a=document.getElementsByTagName("head")[0],b=be("style");b.type="text/css";b.media="screen";var c=document.createTextNode(String(this.ac[0]));a.appendChild(b);b.appendChild(c);this.yb=b;this.ne=new Gg(this.Xd,this.Yd)||p;this.Ha&&this.lb();Jg(this,q);Pg(this,this.Va);this.s().classList.add("x-tooltip")};
$g.prototype.ud=function(){Jg(this,u);this.yb&&de(this.yb);this.s()&&de(this.s());this.yb=t};function ah(){zg.call(this);this.g="renderer3D";this.Vc=this.Yc=this.Uc=this.Xc=this.Tc=this.Wc=this.Oe=this.Pe=t;this.A=[0,0,0];this.Nc=[0,0,0];this.gg=t;this.ze=new yc;this.ld=new yc;this.fc=new yc;this.Zc=new yc;this.rc=new yc;this.Bc=new yc;this.ec=new yc;this.Gc=new yc;this.O={PROGRESSBAR_ENABLED:q,PICKING_ENABLED:q,ORDERING_ENABLED:q,STATISTICS_ENABLED:u,INTERMEDIATE_RENDERING:u}}C(ah,zg);ah.prototype.__defineGetter__("config",v("O"));w=ah.prototype;
w.sj=function(){this.Vc=this.Yc=this.Uc=this.Xc=this.Tc=this.Wc=t;this.A=[0,0,0]};w.wf=function(a){ah.z.wf.call(this,a);var b=a.Xd;a=a.Yd;var c=this.Bf(b,a);if(c=this.get(c))if(c=c.qc){var e=te(this.B);(new $g(this.B,e.x+b+10,e.y+a+10,this.S)).s().innerHTML=c}};
w.wa=function(){ah.z.wa.call(this,"experimental-webgl");try{if(this.a.viewport(0,0,this.H,this.v),this.a.clearColor(this.Nc[0],this.Nc[1],this.Nc[2],0),this.a.enable(this.a.BLEND),this.a.blendEquation(this.a.FUNC_ADD),this.a.blendFunc(this.a.SRC_ALPHA,this.a.ONE_MINUS_SRC_ALPHA),this.a.enable(this.a.DEPTH_TEST),this.a.depthFunc(this.a.LEQUAL),this.a.clear(this.a.COLOR_BUFFER_BIT|this.a.DEPTH_BUFFER_BIT),this.O.PICKING_ENABLED){var a=this.a.createFramebuffer(),b=this.a.createRenderbuffer(),c=this.a.createTexture();
this.a.bindTexture(this.a.TEXTURE_2D,c);this.a.texImage2D(this.a.TEXTURE_2D,0,this.a.RGB,this.H,this.v,0,this.a.RGB,this.a.UNSIGNED_BYTE,t);this.a.texParameteri(this.a.TEXTURE_2D,this.a.TEXTURE_WRAP_S,this.a.CLAMP_TO_EDGE);this.a.texParameteri(this.a.TEXTURE_2D,this.a.TEXTURE_WRAP_T,this.a.CLAMP_TO_EDGE);this.a.texParameteri(this.a.TEXTURE_2D,this.a.TEXTURE_MAG_FILTER,this.a.NEAREST);this.a.texParameteri(this.a.TEXTURE_2D,this.a.TEXTURE_MIN_FILTER,this.a.NEAREST);this.a.bindFramebuffer(this.a.FRAMEBUFFER,
a);this.a.bindRenderbuffer(this.a.RENDERBUFFER,b);this.a.renderbufferStorage(this.a.RENDERBUFFER,this.a.DEPTH_COMPONENT16,this.H,this.v);this.a.bindRenderbuffer(this.a.RENDERBUFFER,t);this.a.framebufferTexture2D(this.a.FRAMEBUFFER,this.a.COLOR_ATTACHMENT0,this.a.TEXTURE_2D,c,0);this.a.framebufferRenderbuffer(this.a.FRAMEBUFFER,this.a.DEPTH_ATTACHMENT,this.a.RENDERBUFFER,b);this.a.bindFramebuffer(this.a.FRAMEBUFFER,t);this.gg=a}}catch(e){m(Error("Exception while accessing GL Context!\n"+e))}a=new Ag;
(this.za==t||this.a==t||this.J==t)&&m(Error("Renderer was not initialized properly."));(a==t||!(a instanceof Ag))&&m(Error("Could not add shaders."));b=Object.keys(Cg);Object.keys(Bg).every(function(a){a=Bg[a];return-1!=this.Vd.search(a)||-1!=this.Kd.search(a)}.bind(a))||m(Error("Could not find all attributes in the shader sources."));b.every(function(a){a=Cg[a];return-1!=this.Vd.search(a)||-1!=this.Kd.search(a)}.bind(a))||m(Error("Could not find all uniforms in the shader sources."));b=this.a.createShader(this.a.FRAGMENT_SHADER);
c=this.a.createShader(this.a.VERTEX_SHADER);this.a.shaderSource(b,a.Kd);this.a.shaderSource(c,a.Vd);this.a.compileShader(b);this.a.compileShader(c);this.a.getShaderParameter(b,this.a.COMPILE_STATUS)||m(Error("Fragement Shader compilation failed!\n"+this.a.getShaderInfoLog(b)));this.a.getShaderParameter(c,this.a.COMPILE_STATUS)||m(Error("Vertex Shader compilation failed!\n"+this.a.getShaderInfoLog(c)));var d=this.a.createProgram();this.a.attachShader(d,c);this.a.attachShader(d,b);this.a.linkProgram(d);
this.a.getProgramParameter(d,this.a.LINK_STATUS)||m(Error("Could not create shader program!\n"+this.a.getShaderInfoLog(b)+"\n"+this.a.getShaderInfoLog(c)+"\n"+this.a.getProgramInfoLog(d)));this.a.useProgram(d);this.Oe=d;Object.keys(Bg).forEach(function(a){a=Bg[a];this.ze.set(a,this.a.getAttribLocation(this.Oe,a));this.a.enableVertexAttribArray(this.ze.get(a))}.bind(this));Object.keys(Cg).forEach(function(a){a=Cg[a];this.ld.set(a,this.a.getUniformLocation(this.Oe,a))}.bind(this));this.Pe=a};
w.sb=function(a){ah.z.sb.call(this,a);var b=u;if(a!=t){this.get(a.ta)&&(b=q);var c=a.ta,e=a.h,d=a.q,f=a.la,g=a.C,h=a.r,l=a.ca,j=a.Aa,k=a.e,n=a.G;if(k!=t&&k.r!=t&&k.r.j)this.sb(k);else if(k!=t&&k.j&&this.sb(k),j!=t&&j.r!=t&&j.r.j)this.W.load(j,a);else if(g!=t&&g.r!=t&&g.r.j)this.W.load(g,a);else{if(h!=t&&la(h))if(a.nc!=t){if(a.nc.lf!=h.length||!a.j)return}else{b=0;c=h.length;for(b=0;b<c;b++)this.W.load(h[b],a);return}else{if(h!=t&&h.j){this.W.load(a,a);return}if(n!=t&&n.r!=t&&n.r.j){this.W.load(n,
a);return}}if(0<a.c.length){h=a.c;j=h.length;for(k=k=0;k<j;k++)this.sb(h[k])}if(e){for(h=0;this.Pd;)h++,window.console.log("Possible thread lock avoided: "+h);this.Pd=q;j=a instanceof Le&&a.zb instanceof Xe;b&&(g!=t&&g.j)&&(h=this.ec.get(c),h!=t&&this.a.isBuffer(h.M)&&this.a.deleteBuffer(h.M));h=t;g!=t&&(!b||g.j?(h=a.Fc,h==t&&m(Error("Can not add an object and texture without valid coordinate mapping! Set the textureCoordinateMap!")),k=u,g.Tb&&(k=q),this.a.pixelStorei(this.a.UNPACK_FLIP_Y_WEBGL,k),
k=this.a.createTexture(),k.vi=g.Jb,this.Gc.set(g.ta,k),this.a.bindTexture(this.a.TEXTURE_2D,k),g.Tb?(k=this.a.RGBA,g.Xf&&(k=this.a.LUMINANCE,this.a.pixelStorei(this.a.UNPACK_ALIGNMENT,1)),this.a.texImage2D(this.a.TEXTURE_2D,0,k,g.Ne,g.Me,0,k,this.a.UNSIGNED_BYTE,g.Tb)):this.a.texImage2D(this.a.TEXTURE_2D,0,this.a.RGBA,this.a.RGBA,this.a.UNSIGNED_BYTE,k.vi),this.a.texParameteri(this.a.TEXTURE_2D,this.a.TEXTURE_WRAP_S,this.a.CLAMP_TO_EDGE),this.a.texParameteri(this.a.TEXTURE_2D,this.a.TEXTURE_WRAP_T,
this.a.CLAMP_TO_EDGE),j?(this.a.texParameteri(this.a.TEXTURE_2D,this.a.TEXTURE_MAG_FILTER,this.a.NEAREST),this.a.texParameteri(this.a.TEXTURE_2D,this.a.TEXTURE_MIN_FILTER,this.a.NEAREST)):(this.a.texParameteri(this.a.TEXTURE_2D,this.a.TEXTURE_MAG_FILTER,this.a.LINEAR),this.a.texParameteri(this.a.TEXTURE_2D,this.a.TEXTURE_MIN_FILTER,this.a.LINEAR)),this.a.bindTexture(this.a.TEXTURE_2D,t),k=this.a.createBuffer(),this.a.bindBuffer(this.a.ARRAY_BUFFER,k),this.a.bufferData(this.a.ARRAY_BUFFER,new Float32Array(h),
this.a.STATIC_DRAW),h=new Qd(k,h.length,2),this.ec.set(c,h),g.j=u):h=this.ec.get(c));Vf(this.W,0.1);if(j)this.Pd=u,D.Ua(this.g+".update"),Vf(this.W,0.9);else{if(!b||e.j||l.j){j=l.N;g=D.f.X(j,e.eb,e.fb,e.gb);j=D.f.X(j,e.$a,e.ab,e.bb);if(this.Wc===t||g.x<this.Wc)this.Wc=g.x;if(this.Tc===t||j.x>this.Tc)this.Tc=j.x;if(this.Xc===t||g.y<this.Xc)this.Xc=g.y;if(this.Uc===t||j.y>this.Uc)this.Uc=j.y;if(this.Yc===t||g.d<this.Yc)this.Yc=g.d;if(this.Vc===t||j.d>this.Vc)this.Vc=j.d;this.A=[(this.Wc+this.Tc)/2,
(this.Xc+this.Uc)/2,(this.Yc+this.Vc)/2];l.j=u}b&&e.j&&(l=this.fc.get(c),l!=t&&this.a.isBuffer(l.M)&&this.a.deleteBuffer(l.M));l=t;!b||e.j?(l=this.a.createBuffer(),e.Cb(),this.a.bindBuffer(this.a.ARRAY_BUFFER,l),this.a.bufferData(this.a.ARRAY_BUFFER,e.Y,this.a.STATIC_DRAW),l=new Qd(l,e.count,3),e.j=u):l=this.fc.get(c);Vf(this.W,0.3);b&&d.j&&(g=this.fc.get(c),g!=t&&this.a.isBuffer(g.M)&&this.a.deleteBuffer(g.M));g=t;!b||d.j?(g=this.a.createBuffer(),d.Cb(),this.a.bindBuffer(this.a.ARRAY_BUFFER,g),this.a.bufferData(this.a.ARRAY_BUFFER,
d.Y,this.a.STATIC_DRAW),g=new Qd(g,d.count,3),d.j=u):g=this.Zc.get(c);Vf(this.W,0.3);b&&(f&&f.j)&&(d=this.rc.get(c),d!=t&&this.a.isBuffer(d.M)&&this.a.deleteBuffer(d.M));d=t;f&&(!b||f.j?(f.length!=e.length&&m(Error("Mismatch between points and point colors.")),d=this.a.createBuffer(),f.Cb(),this.a.bindBuffer(this.a.ARRAY_BUFFER,d),this.a.bufferData(this.a.ARRAY_BUFFER,f.Y,this.a.STATIC_DRAW),d=new Qd(d,f.count,3),f.j=u):d=this.rc.get(c));Vf(this.W,0.2);b&&(n&&n.j)&&(f=this.Bc.get(c),f!=t&&this.a.isBuffer(f.M)&&
this.a.deleteBuffer(f.M));f=t;n&&(f=n.Pc,!b||n.j?(f.length!=e.length&&m(Error("Mismatch between points and scalars.")),e=this.a.createBuffer(),this.a.bindBuffer(this.a.ARRAY_BUFFER,e),this.a.bufferData(this.a.ARRAY_BUFFER,f,this.a.STATIC_DRAW),f=new Qd(e,f.length,3),n.j=u):f=this.Bc.get(c));Vf(this.W,0.1);b||this.pb.add(a);this.fc.set(c,l);this.Zc.set(c,g);this.rc.set(c,d);this.ec.set(c,h);this.Bc.set(c,f);this.Pd=a.j=u}}else a.j=u}}};
w.Bf=function(a,b){if(this.O.PICKING_ENABLED){this.$b(q,u);var c=new Uint8Array(4);this.a.readPixels(a,this.v-b,1,1,this.a.RGBA,this.a.UNSIGNED_BYTE,c);return c[0]+255*c[1]+65025*c[2]}return-1};
w.$b=function(a,b){ah.z.$b.call(this,a,b);this.a.viewport(0,0,this.H,this.v);this.a.clear(this.a.COLOR_BUFFER_BIT|this.a.DEPTH_BUFFER_BIT);var c=this.pb.F,e=c.length;if(0!=e){a?this.a.bindFramebuffer(this.a.FRAMEBUFFER,this.gg):this.a.bindFramebuffer(this.a.FRAMEBUFFER,t);var d=this.J.Le,f=this.J.n;this.a.uniformMatrix4fv(this.ld.get("perspective"),u,d);this.a.uniformMatrix4fv(this.ld.get("view"),u,f);d=this.A;this.a.uniform3f(this.ld.get("center"),parseFloat(d[0]),parseFloat(d[1]),parseFloat(d[2]));
f=this.hb.length;for(d=0;d<f;++d){var g=this.hb[d];if(g instanceof Q){var h=D.f.X(this.J.n,g.t[0]+g.b[0].i[0],g.t[1]+g.b[0].i[1],g.t[2]+g.b[0].i[2]),l=D.f.X(this.J.n,g.t[0]-g.b[0].i[0],g.t[1]-g.b[0].i[1],g.t[2]-g.b[0].i[2]),j=Math.abs(h.d-l.d),h=D.f.X(this.J.n,g.t[0]+g.b[1].i[0],g.t[1]+g.b[1].i[1],g.t[2]+g.b[1].i[2]),l=D.f.X(this.J.n,g.t[0]-g.b[1].i[0],g.t[1]-g.b[1].i[1],g.t[2]+-g.b[1].i[2]),k=Math.abs(h.d-l.d),h=D.f.X(this.J.n,g.t[0]+g.b[2].i[0],g.t[1]+g.b[2].i[1],g.t[2]+g.b[2].i[2]),l=D.f.X(this.J.n,
g.t[0]-g.b[2].i[0],g.t[1]-g.b[2].i[1],g.t[2]-g.b[2].i[2]),h=Math.max(j,k,Math.abs(h.d-l.d));h==j?We(g,0):h==k?We(g,1):We(g,2)}}if(this.O.ORDERING_ENABLED){j=u;f=this.hb;g=f.length-1;do if(d=f[g],d instanceof Q&&d.Ma&&-1!=d.T){var j=d.c[d.T].c,k=d.T,h=D.f.X(this.J.n,d.t[0]+d.b[k].w[0],d.t[1]+d.b[k].w[1],d.t[2]+d.b[k].w[2]),l=D.f.X(this.J.n,d.t[0]-d.b[k].w[0],d.t[1]-d.b[k].w[1],d.t[2]-d.b[k].w[2]),h=h.d-l.d,l=Math.max(d.oc[d.T],Math.max(d.oc[d.T+4],d.oc[d.T+8])),n=Math.min(d.oc[d.T],Math.min(d.oc[d.T+
4],d.oc[d.T+8]));if(0>h*(l+n))for(h=h=0;h<d.cd[k]-1;h++)j[h]&&(j[h].qa=d.qa,j[h].sa=d.b[k].Dc*h);else for(h=d.cd[k]-1;0<=h;h--)j[h]&&(j[h].qa=d.qa,j[h].sa=(d.cd[k]-1)*d.b[k].Dc-d.b[k].Dc*h);j=q}while(g--);f=this.pb.F;g=f.length-1;do if(d=f[g],d.L&&!(1==d.qa||d instanceof Le))j=d,k=d.h.Hd,d=D.f.X(d.ca.N,k[0],k[1],k[2]),d=D.f.X(this.J.n,d.x,d.y,d.d),d=D.m.ff(this.J.cc,d),d=Math.round(1E3*d)/1E3,j.sa=d,j=q;while(g--);j&&this.pb.sort()}if(f=!a&&b!=t&&b&&this.O.STATISTICS_ENABLED)var r=0,s=0,z=0,y=0;var d=
this.ze,g=d.get("vertexPosition"),j=d.get("vertexNormal"),k=d.get("vertexColor"),h=d.get("vertexTexturePos"),l=d.get("vertexScalar"),d=this.ld,n=d.get("usePicking"),E=d.get("useObjectColor"),F=d.get("objectColor"),K=d.get("useScalars"),A=d.get("scalarsReplaceMode"),G=d.get("scalarsMin"),I=d.get("scalarsMax"),H=d.get("scalarsMinColor"),R=d.get("scalarsMaxColor"),N=d.get("scalarsInterpolation"),S=d.get("scalarsMinThreshold"),ba=d.get("scalarsMaxThreshold"),aa=d.get("objectOpacity"),ca=d.get("labelmapOpacity"),
M=d.get("labelmapColor"),T=d.get("useTexture"),P=d.get("useLabelMapTexture"),Ea=d.get("textureSampler"),sb=d.get("textureSampler2"),tb=d.get("volumeLowerThreshold"),ub=d.get("volumeUpperThreshold"),kb=d.get("volumeScalarMin"),Tc=d.get("volumeScalarMax"),eh=d.get("volumeWindowLow"),fh=d.get("volumeWindowHigh"),gh=d.get("volumeScalarMinColor"),hh=d.get("volumeScalarMaxColor"),tg=d.get("volumeTexture"),ih=d.get("objectTransform"),jh=d.get("pointSize"),d=e;do{var da=c[e-d];if(da){var ka=t;da instanceof
Le&&da.zb&&(ka=da.zb);if(da.L&&(!ka||ka.L)&&(!a||da.$c)){var za=da.ta,db=da.Sc,Qa=this.fc.get(za),nb=this.Zc.get(za),Te=this.rc.get(za),Kb=this.Bc.get(za),Ue=this.ec.get(za);this.a.bindBuffer(this.a.ARRAY_BUFFER,Qa.M);this.a.vertexAttribPointer(g,Qa.Lb,this.a.FLOAT,u,0,0);this.a.bindBuffer(this.a.ARRAY_BUFFER,nb.M);this.a.vertexAttribPointer(j,nb.Lb,this.a.FLOAT,u,0,0);a?this.a.uniform1i(n,q):this.a.uniform1i(n,u);Te&&!a&&!db?(this.a.uniform1i(E,u),this.a.bindBuffer(this.a.ARRAY_BUFFER,Te.M),this.a.vertexAttribPointer(k,
Te.Lb,this.a.FLOAT,u,0,0)):(nb=1,db&&!a&&(nb=0),this.a.uniform1i(E,nb),nb=da.u,a&&(nb=[Math.floor(za%65025%255)/255,Math.floor(za%65025/255)/255,Math.floor(za/65025)/255]),this.a.uniform3f(F,parseFloat(nb[0]),parseFloat(nb[1]),parseFloat(nb[2])),this.a.vertexAttribPointer(k,Qa.Lb,this.a.FLOAT,u,0,0));Kb&&!a&&!db?(this.a.uniform1i(K,q),this.a.uniform1i(A,da.G.jg),za=da.G.Ob,db=da.G.Mb,this.a.uniform3f(H,parseFloat(za[0]),parseFloat(za[1]),parseFloat(za[2])),this.a.uniform3f(R,parseFloat(db[0]),parseFloat(db[1]),
parseFloat(db[2])),this.a.uniform1f(S,parseFloat(da.G.fa)),this.a.uniform1f(ba,parseFloat(da.G.ga)),this.a.uniform1f(G,parseFloat(da.G.cb)),this.a.uniform1f(I,parseFloat(da.G.ma)),this.a.uniform1i(N,parseInt(da.G.Be,10)),this.a.bindBuffer(this.a.ARRAY_BUFFER,Kb.M),this.a.vertexAttribPointer(l,Kb.Lb,this.a.FLOAT,u,0,0)):(this.a.uniform1i(K,u),this.a.vertexAttribPointer(l,Qa.Lb,this.a.FLOAT,u,0,0));this.a.uniform1f(aa,parseFloat(da.qa));da.C&&Ue&&!a?(this.a.uniform1i(T,q),this.a.activeTexture(this.a.TEXTURE0),
this.a.bindTexture(this.a.TEXTURE_2D,this.Gc.get(da.C.ta)),this.a.uniform1i(Ea,0),this.a.bindBuffer(this.a.ARRAY_BUFFER,Ue.M),this.a.vertexAttribPointer(h,Ue.Lb,this.a.FLOAT,u,0,0),this.a.uniform1i(tg,u)):(this.a.uniform1i(T,u),this.a.vertexAttribPointer(h,Qa.Lb,this.a.FLOAT,u,0,0));ka&&(this.a.uniform1i(tg,q),this.a.uniform1f(tb,ka.fa),this.a.uniform1f(ub,ka.ga),this.a.uniform1f(kb,ka.cb),this.a.uniform1f(Tc,ka.ma),za=ka.Ob,db=ka.Mb,this.a.uniform3f(gh,parseFloat(za[0]),parseFloat(za[1]),parseFloat(za[2])),
this.a.uniform3f(hh,parseFloat(db[0]),parseFloat(db[1]),parseFloat(db[2])),this.a.uniform1f(eh,ka.ia),this.a.uniform1f(fh,ka.ha),Kb=ka.e,this.a.uniform1i(P,u),ka.Ma?this.a.uniform1f(aa,parseFloat(ka.qa)):Kb&&Kb.L&&(ka=da.e.ta,this.a.uniform1i(P,q),this.a.activeTexture(this.a.TEXTURE1),this.a.bindTexture(this.a.TEXTURE_2D,this.Gc.get(ka)),this.a.uniform1i(sb,1),this.a.uniform1f(ca,Kb.qa),this.a.uniform4fv(M,Kb.Qe)));this.a.uniformMatrix4fv(ih,u,da.ca.N);ka=1;"POINTS"==da.Da&&(ka=da.ad);this.a.uniform1f(jh,
ka);ka=-1;da.Da==gd?(ka=this.a.TRIANGLES,f&&(s+=Qa.Kb/3)):"LINES"==da.Da?(this.a.lineWidth(da.zc),ka=this.a.LINES,f&&(z+=Qa.Kb/2)):"POINTS"==da.Da?(ka=this.a.POINTS,f&&(y+=Qa.Kb)):"TRIANGLE_STRIPS"==da.Da?(ka=this.a.TRIANGLE_STRIP,f&&(s+=Qa.Kb/3)):"POLYGONS"==da.Da&&(ka=0==Qa.Kb%3?this.a.TRIANGLES:this.a.TRIANGLE_FAN,f&&(s+=Qa.Kb/3));f&&(r+=Qa.Kb);this.a.drawArrays(ka,0,Qa.Kb)}}}while(--d);f&&(c="Objects: "+e+" | "+("Vertices: "+r+" | "),c+="Triangles: "+Math.round(s)+" | ",c+="Lines: "+z+" | ",c+=
"Points: "+y+" | ",c+="Textures: "+this.Gc.ee(),window.console.log(c))}};
w.remove=function(a){ah.z.remove.call(this,a);if(0<a.c.length)for(var b=a.c,c=b.length,e=0,e=0;e<c;e++)this.remove(b[e]);b=a.ta;c=this.ec.get(b);c!=t&&this.a.isBuffer(c.M)&&this.a.deleteBuffer(c.M);if(a.C&&(c=this.Gc.get(a.C.ta)))this.a.deleteTexture(c),this.Gc.remove(a.C.ta);c=this.fc.get(b);c!=t&&this.a.isBuffer(c.M)&&this.a.deleteBuffer(c.M);c=this.Zc.get(b);c!=t&&this.a.isBuffer(c.M)&&this.a.deleteBuffer(c.M);c=this.rc.get(b);c!=t&&this.a.isBuffer(c.M)&&this.a.deleteBuffer(c.M);c=this.Bc.get(b);
c!=t&&this.a.isBuffer(c.M)&&this.a.deleteBuffer(c.M);this.fc.remove(b);this.Zc.remove(b);this.rc.remove(b);this.ec.remove(b);this.Bc.remove(b);this.pb.remove(a);return q};w.$d=function(){this.Pe=t;delete this.Pe;this.a.clear(this.a.COLOR_BUFFER_BIT|this.a.DEPTH_BUFFER_BIT);ah.z.$d.call(this)};ah.prototype.__defineGetter__("bgColor",v("Nc"));ah.prototype.__defineSetter__("bgColor",fa("Nc"));
ah.prototype.oj=function(a,b,c,e,d){c!=t||(c=4);e!=t||(e=2);if(d==t){d=this.Bf(a,b);if(-1==d)return t;d=this.get(d);if(!d)return t}var f=jg(this.J,2*(a/this.H)-1,2*((this.v-b)/this.v)-1,0);a=jg(this.J,2*(a/this.H)-1,2*((this.v-b)/this.v)-1,1);f[0]+=this.A[0];f[1]+=this.A[1];f[2]+=this.A[2];a[0]+=this.A[0];a[1]+=this.A[1];a[2]+=this.A[2];b=[d.h.eb,d.h.fb,d.h.gb];var g=[d.h.$a,d.h.fb,d.h.gb],h=[d.h.$a,d.h.ab,d.h.gb],l=[d.h.eb,d.h.ab,d.h.gb],j=[d.h.eb,d.h.ab,d.h.bb],k=[d.h.eb,d.h.fb,d.h.bb],n=[d.h.$a,
d.h.ab,d.h.bb],r=[d.h.$a,d.h.fb,d.h.bb];b=[D.f.X(d.ca.N,b[0],b[1],b[2]),D.f.X(d.ca.N,g[0],g[1],g[2]),D.f.X(d.ca.N,h[0],h[1],h[2]),D.f.X(d.ca.N,l[0],l[1],l[2]),D.f.X(d.ca.N,j[0],j[1],j[2]),D.f.X(d.ca.N,k[0],k[1],k[2]),D.f.X(d.ca.N,n[0],n[1],n[2]),D.f.X(d.ca.N,r[0],r[1],r[2])];var g=[Infinity,-Infinity,Infinity,-Infinity,Infinity,-Infinity],s;for(s in b)s=b[s],g=[Math.min(g[0],s.x),Math.max(g[1],s.x),Math.min(g[2],s.y),Math.max(g[3],s.y),Math.min(g[4],s.d),Math.max(g[5],s.d)];s=g;b=[];g=[];for(h=0;6>
h;h++){var l=Math.floor(h/2),j=(l+1)%3,k=(l+2)%3,r=(2+2*l)%6,z=(4+2*l)%6,y=(s[h]-f[l])*(1/a[l]);Infinity!=y&&-Infinity!=y&&(n=f[j]+a[j]*y,y=f[k]+a[k]*y,n>=s[r]&&n<=s[r+1]&&y>=s[z]&&y<=s[z+1]?(r=[],r[l]=s[h],r[j]=n,r[k]=y,b.push(r)):(r=[],r[l]=s[h],r[j]=n,r[k]=y,g.push(r)))}a=[b,g];a=a[0];if(0==a.length)return t;g=Array(2);for(s=0;2>s;s++)b=a[s],g[s]=Math.sqrt((b[0]-f[0])*(b[0]-f[0])+(b[1]-f[1])*(b[1]-f[1])+(b[2]-f[2])*(b[2]-f[2]));f=b=s=t;g[0]<g[1]?(s=a[0],b=a[1]):(s=a[1],b=a[0]);f=Math.sqrt((s[0]-
b[0])*(s[0]-b[0])+(s[1]-b[1])*(s[1]-b[1])+(s[2]-b[2])*(s[2]-b[2]));f/=c;a=s;s=[b[0]-s[0],b[1]-s[1],b[2]-s[2]];b=Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);g=[s[0]/b,s[1]/b,s[2]/b];h=d.h.Y;l=h.length;for(s=0;s<f;s+=c){a=[a[0]+c*g[0],a[1]+c*g[1],a[2]+c*g[2]];for(b=0;b<l;b+=3)if(j=h[b],k=h[b+1],n=h[b+2],r=new D.m(j,k,n),r=D.f.X(d.ca.N,j,k,n),Math.sqrt((a[0]-r.x)*(a[0]-r.x)+(a[1]-r.y)*(a[1]-r.y)+(a[2]-r.d)*(a[2]-r.d))<=e)return[r.x,r.y,r.d]}return t};B("X.renderer3D",ah);
B("X.renderer3D.prototype.init",ah.prototype.wa);B("X.renderer3D.prototype.add",ah.prototype.add);B("X.renderer3D.prototype.onShowtime",ah.prototype.Xg);B("X.renderer3D.prototype.onRender",ah.prototype.Vg);B("X.renderer3D.prototype.get",ah.prototype.get);B("X.renderer3D.prototype.render",ah.prototype.Zb);B("X.renderer3D.prototype.destroy",ah.prototype.$d);B("X.renderer3D.prototype.remove",ah.prototype.remove);B("X.renderer3D.prototype.resetBoundingBox",ah.prototype.sj);
B("X.renderer3D.prototype.resetViewAndRender",ah.prototype.Ad);B("X.renderer3D.prototype.pick",ah.prototype.Bf);B("X.renderer3D.prototype.pick3d",ah.prototype.oj);function bh(){Y.call(this);this.g="fibers";Ga(this,new wc)}C(bh,Y);B("X.fibers",bh);function ch(){zg.call(this);this.g="renderer2D";this.La=t;this.Ba=-1;this.Pb=[];this.$f=this.Nd=this.Vf=this.Ld=t;this.Cc=this.Ec=this.dd=this.fd=0;this.ha=this.ia=this.ga=this.fa=this.Sf=-1;this.ag=new Float32Array([-255,-255,-255,-255]);this.hg=q}C(ch,zg);ch.prototype.$i=ea();ch.prototype.jj=ea();ch.prototype.yf=function(a){ch.z.yf.call(this,a);var b=this.hb[0];if(b){var c="",c=0==this.Ba?"indexX":1==this.Ba?"indexY":"indexZ";b[c]=a.Z?b[c]+1:b[c]-1;eval("this.onScroll();")}};
ch.prototype.kj=function(a){var b=this.hb[0];if(b){var c=b.ha-b.ia,e=c/2,d=parseInt(c+c/15*-a.Te,10);a=parseInt(e+e/15*a.Ge,10);c==d&&d++;e==a&&a++;b.ia-=parseInt(e-a,10);b.ia-=parseInt(c-d,10);b.ia=Math.max(b.ia,b.cb);b.ha-=parseInt(e-a,10);b.ha+=parseInt(c-d,10);b.ha=Math.min(b.ha,b.ma);eval("this.onWindowLevel();")}};ch.prototype.__defineGetter__("orientation",v("La"));
ch.prototype.__defineSetter__("orientation",function(a){a=a.toUpperCase();"AXIAL"==a?(a="Z",this.Ba=2):"SAGITTAL"==a?(a="X",this.Ba=0):"CORONAL"==a&&(a="Y",this.Ba=1);"X"!=a&&("Y"!=a&&"Z"!=a)&&m(Error("Invalid orientation."));this.La=a});ch.prototype.__defineGetter__("radiological",v("hg"));ch.prototype.__defineSetter__("radiological",fa("hg"));w=ch.prototype;
w.wa=function(){this.La||m(Error("No 2D orientation set."));ch.z.wa.call(this,"2d");this.a.fillStyle="rgba(50,50,50,0)";this.a.fillRect(0,0,this.za.width,this.za.height);this.Ld=be("canvas");this.Nd=be("canvas");L(this.J,vd,this.kj.bind(this))};w.xf=function(){ch.z.xf.call(this);dh(this)};w.Ad=function(){ch.z.Ad.call(this);dh(this);var a=this.hb[0];a&&(a.ha=a.ma,a.ia=a.cb)};
w.sb=function(a){ch.z.sb.call(this,a);var b=u;this.get(a.ta)&&(b=q);if(a instanceof Q){var c=a.r,e=a.e,d=a.Aa;if(e!=t&&e.r!=t&&e.r.j)this.sb(e);else if(d!=t&&d.r!=t&&d.r.j)this.W.load(d,a);else{if(c!=t&&la(c))if(a.nc!=t){if(a.nc.lf!=c.length||b&&!a.j)return}else{b=0;e=c.length;for(b=0;b<e;b++)this.W.load(c[b],a);return}else if(c!=t&&c.j){this.W.load(a,a);return}this.Ba="X"==this.La?0:"Y"==this.La?1:2;this.Wa=a.c[this.Ba].c;d=t;d=0==this.Ba?a.indexX:1==this.Ba?a.indexY:a.indexZ;c=a.c[this.Ba].c[d].Zf;
e=a.c[this.Ba].c[d].Yf;this.Ec=a.c[this.Ba].c[d].Hc;this.Cc=a.c[this.Ba].c[d].uc;this.fd=c;this.dd=e;d=this.Ld;d.width=c;d.height=e;var f=this.Nd;f.width=c;f.height=e;this.Vf=d.getContext("2d");this.$f=f.getContext("2d");b||(this.pb.add(a),dh(this))}}};function dh(a){var b=Math.min(a.H/(a.fd*a.Ec),a.v/(a.dd*a.Cc));a.J.n[14]=b}w.aj=ea();
w.sh=function(a,b){var c=this.hb[0],e=this.J.n,d=t,f=this.fd,g=this.dd,h=t,l=t;if("Y"==this.La)d=this.Wa[parseInt(c.indexY,10)],h=d.Hc,l=d.uc,this.Pb[0]="red",this.Pb[1]="blue";else if("Z"==this.La)d=this.Wa[parseInt(c.indexZ,10)],h=d.Hc,l=d.uc,this.Pb[0]="red",this.Pb[1]="green";else{d=this.Wa[parseInt(c.indexX,10)];h=d.uc;l=d.Hc;this.Pb[0]="green";this.Pb[1]="blue";var j=f,f=g,g=j}var k=1*e[12],n=-1*e[13],j=Math.max(e[14],0.6),e=[this.H/2,this.v/2],h=f*h*j,l=g*l*j,r=e[0]-h/2,e=e[1]-l/2,r=r+k*j,
e=e+n*j;return a>r&&a<r+h&&b>e&&b<e+l?(k=(a-r)/h*f,n=(b-e)/l*g,l=d.Nh[4],"X"==this.La?(j=f-k,k=n,n=j):"Y"==this.La?k=f-k:"Z"==this.La&&(k=f-k,n=g-n),k=d.Mh+k*d.Hc,n=d.Gh+n*d.uc,k=Pc(k,n,l,1),f=Qc(),ad(d.zh,k,f),g=Qc(),ad(d.Ah,k,g),d=Math.round((c.b[0].i[0]*g[0]+c.b[0].i[1]*g[1]+c.b[0].i[2]*g[2]+c.b[0].Je)/c.b[0].Dc),d>=c.b[0].o?d=c.b[0].o-1:0>d&&(d=0),k=Math.round((c.b[1].i[0]*g[0]+c.b[1].i[1]*g[1]+c.b[1].i[2]*g[2]+c.b[1].Je)/c.b[1].Dc),k>=c.b[1].o?k=c.b[1].o-1:0>k&&(k=0),n=Math.round((c.b[2].i[0]*
g[0]+c.b[2].i[1]*g[1]+c.b[2].i[2]*g[2]+c.b[2].Je)/c.b[2].Dc),n>=c.b[2].o?n=c.b[2].o-1:0>n&&(n=0),[[d,k,n],[f[0],f[1],f[2]],[g[0],g[1],g[2]]]):t};
w.$b=function(a,b){ch.z.$b.call(this,a,b);if(0!=this.pb.F.length){var c=this.hb[0],e=t,e=0==this.Ba?c.indexX:1==this.Ba?c.indexY:c.indexZ,d=this.Wa[parseInt(e,10)].Zf,f=this.Wa[parseInt(e,10)].Yf;this.Ec=this.Wa[parseInt(e,10)].Hc;this.Cc=this.Wa[parseInt(e,10)].uc;this.fd=d;this.dd=f;var g=this.H,h=this.v,l=this.J.n;this.a.save();this.a.clearRect(-g,-h,2*g,2*h);this.a.restore();var j=Math.max(l[14],0.1);this.a.setTransform(j,0,0,j,0,0);var k=1*l[12],l=-1*l[13],n=t;c.e&&(n=c.e.Qe);var r=this.Wa[parseInt(e,
10)],s=r.C.Tb,r=r.e,z=t;r&&(z=r.Tb);var y=this.fd,E=this.dd,F=this.Vf,K=this.$f,A=F.getImageData(0,0,y,E),G=K.getImageData(0,0,y,E),I=A.data,H=G.data,R=I.length,N=c.ma,S=c.fa,ba=c.ga,aa=c.ia/N,ca=c.ha/N;if(this.Sf!=e||this.fa!=S||this.ga!=ba||this.ia!=aa||this.ha!=ca||n&&!fg(n,this.ag,0)){var M=this.Ld;M.width=d;M.height=f;M=this.Nd;M.width=d;M.height=f;d=0;do{var M=[0,0,0,0],f=[0,0,0,0],T=s[d]/255*N,P=s[d],P=(P/255-aa)/(ca-aa),P=255*P;T>=S&&T<=ba&&(M=new U(c.Ob[0],c.Ob[1],c.Ob[2]),M=(new U(c.Mb[0],
c.Mb[1],c.Mb[2])).scale(P).add(M.scale(255-P)),M=[Math.floor(M.x),Math.floor(M.y),Math.floor(M.d),255],r&&(-255==n[3]?f=[z[d],z[d+1],z[d+2],z[d+3]]:fg(n,z,d)&&(f=[z[d],z[d+1],z[d+2],z[d+3]])));"X"==this.La?(I[d]=M[0],I[d+1]=M[1],I[d+2]=M[2],I[d+3]=M[3],H[d]=f[0],H[d+1]=f[1],H[d+2]=f[2],H[d+3]=f[3]):"Y"==this.La?(P=Math.floor(d/(4*y)),P=4*P*y+(4*(y-1)-(d-4*P*y)),I[P]=M[0],I[P+1]=M[1],I[P+2]=M[2],I[P+3]=M[3],H[P]=f[0],H[P+1]=f[1],H[P+2]=f[2],H[P+3]=f[3]):(P=R-1-d,I[P-3]=M[0],I[P-2]=M[1],I[P-1]=M[2],
I[P]=M[3],H[P-3]=f[0],H[P-2]=f[1],H[P-1]=f[2],H[P]=f[3]);d+=4}while(d<R);F.putImageData(A,0,0);K.putImageData(G,0,0);this.Sf=e;this.fa=S;this.ga=ba;this.ia=aa;this.ha=ca;r&&(this.ag=n)}this.a.globalAlpha=1;this.a.translate(g/2/j,h/2/j);"X"==this.La&&(this.a.rotate(0.5*Math.PI),e=k,k=l,l=-e);k=-y*this.Ec/2+k;l=-E*this.Cc/2+l;this.a.drawImage(this.Ld,k,l,y*this.Ec,E*this.Cc);r&&c.e.L&&(this.a.globalAlpha=c.e.qa,this.a.drawImage(this.Nd,k,l,y*this.Ec,E*this.Cc));if(this.O.SLICENAVIGATORS&&(this.S.Qd&&
this.S.lg&&!this.S.ob)&&(k=this.S.pa,k=this.sh(k[0],k[1])))c.vb=k[0][0],c.wb=k[0][1],c.xb=k[0][2],c.p(u),this.onSliceNavigation(),this.a.setTransform(1,0,0,1,0,0),this.a.lineWidth=1,this.a.beginPath(),this.a.moveTo(this.S.pa[0],0),this.a.lineTo(this.S.pa[0],this.S.pa[1]-10),this.a.moveTo(this.S.pa[0],this.S.pa[1]+10),this.a.lineTo(this.S.pa[0],this.v),this.a.strokeStyle=this.Pb[0],this.a.stroke(),this.a.closePath(),this.a.beginPath(),this.a.moveTo(0,this.S.pa[1]),this.a.lineTo(this.S.pa[0]-10,this.S.pa[1]),
this.a.moveTo(this.S.pa[0]+10,this.S.pa[1]+0.5),this.a.lineTo(this.H,this.S.pa[1]),this.a.strokeStyle=this.Pb[1],this.a.stroke(),this.a.closePath(),this.a.font="10pt Arial",this.a.textAlign="left",this.a.textBaseline="top",this.a.fillStyle="white",this.a.fillText("RAS: "+k[2][0].toFixed(2)+", "+k[2][1].toFixed(2)+", "+k[2][2].toFixed(2),0,0),y=r=l="undefined","undefined"!=typeof c.ba[k[1][2].toFixed(0)]&&"undefined"!=typeof c.ba[k[1][2].toFixed(0)][k[1][1].toFixed(0)]&&(l=c.ba[k[1][2].toFixed(0)][k[1][1].toFixed(0)][k[1][0].toFixed(0)],
c.I&&(r=c.e.ba[k[1][2].toFixed(0)][k[1][1].toFixed(0)][k[1][0].toFixed(0)],c.e.Oc&&(y=c.e.Oc.get(r),"undefined"!=typeof y&&(y=y[0])))),this.a.fillText("Background:  "+l+" ("+k[1][0].toFixed(0)+", "+k[1][1].toFixed(0)+", "+k[1][2].toFixed(0)+")",0,15),c.I&&this.a.fillText("Labelmap:  "+y+" ("+r+")",0,30)}};B("X.renderer2D",ch);B("X.renderer2D.prototype.init",ch.prototype.wa);B("X.renderer2D.prototype.add",ch.prototype.add);B("X.renderer2D.prototype.onShowtime",ch.prototype.Xg);
B("X.renderer2D.prototype.onRender",ch.prototype.Vg);B("X.renderer2D.prototype.onScroll",ch.prototype.$i);B("X.renderer2D.prototype.onWindowLevel",ch.prototype.jj);B("X.renderer2D.prototype.get",ch.prototype.get);B("X.renderer2D.prototype.resetViewAndRender",ch.prototype.Ad);B("X.renderer2D.prototype.xy2ijk",ch.prototype.sh);B("X.renderer2D.prototype.render",ch.prototype.Zb);B("X.renderer2D.prototype.destroy",ch.prototype.$d);B("X.renderer2D.prototype.onSliceNavigation",ch.prototype.aj);function kh(){Y.call(this);this.g="mesh";Ga(this,new wc)}C(kh,Y);B("X.mesh",kh);

/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {

  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return {

    BREAK: {},

    extend: function(target) {

      this.each(ARR_SLICE.call(arguments, 1), function(obj) {

        for (var key in obj)
          if (!this.isUndefined(obj[key]))
            target[key] = obj[key];

      }, this);

      return target;

    },

    defaults: function(target) {

      this.each(ARR_SLICE.call(arguments, 1), function(obj) {

        for (var key in obj)
          if (this.isUndefined(target[key]))
            target[key] = obj[key];

      }, this);

      return target;

    },

    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },

    each: function(obj, itr, scope) {


      if (ARR_EACH && obj.forEach === ARR_EACH) {

        obj.forEach(itr, scope);

      } else if (obj.length === obj.length + 0) { // Is number but not NaN

        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK)
            return;

      } else {

        for (var key in obj)
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;

      }

    },

    defer: function(fnc) {
      setTimeout(fnc, 0);
    },

    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },

    isNull: function(obj) {
      return obj === null;
    },

    isNaN: function(obj) {
      return obj !== obj;
    },

    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },

    isObject: function(obj) {
      return obj === Object(obj);
    },

    isNumber: function(obj) {
      return obj === obj+0;
    },

    isString: function(obj) {
      return obj === obj+'';
    },

    isBoolean: function(obj) {
      return obj === false || obj === true;
    },

    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }

  };

})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     *
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     *
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
      }

    } else {

    	this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');



    dom.bind(this.__background, 'mousedown', onMouseDown);

    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);

      _this.setValue(
      	map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

	function map(v, i1, i2, o1, o2) {
		return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
	}

  return NumberControllerSlider;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {

        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.getValue().call(this.object);
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {

          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0]*255,
              g: original[1]*255,
              b: original[2]*255
            };
          },

          write: function(color) {
            return [color.r/255, color.g/255, color.b/255];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    function saveToLocalStorage() {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }

    var root = _this.getRoot();
    function resetWidth() {
	      var root = _this.getRoot();
	      root.width += 1;
	      common.defer(function() {
	        root.width -= 1;
	      });
	    }

	    if (!params.parent) {
	      resetWidth();
	    }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);

    if (params.color) {
      dom.addClass(li, 'string');
    } else {
      dom.addClass(li, typeof controller.getValue());
    }

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });


    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });

    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });

    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );

  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];

  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }

  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;



    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };

  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);

//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    any(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, function(value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(array, predicate) {
    var pass = [], fail = [];
    each(array, function(elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);

//     Backbone.js 1.1.1

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore'), $;
    try { $ = require('jquery'); } catch(e) {}
    factory(root, exports, _, $);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.1';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch =
    typeof window !== 'undefined' && !!window.ActiveXObject &&
      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?(.*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

// Backbone.Wreqr (Backbone.Marionette)
// ----------------------------------
// v1.0.0
//
// Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://github.com/marionettejs/backbone.wreqr


Backbone.Wreqr = (function(Backbone, Marionette, _){
  "use strict";
  var Wreqr = {};

  // Handlers
// --------
// A registry of functions to call, given a name

Wreqr.Handlers = (function(Backbone, _){
  "use strict";
  
  // Constructor
  // -----------

  var Handlers = function(options){
    this.options = options;
    this._wreqrHandlers = {};
    
    if (_.isFunction(this.initialize)){
      this.initialize(options);
    }
  };

  Handlers.extend = Backbone.Model.extend;

  // Instance Members
  // ----------------

  _.extend(Handlers.prototype, Backbone.Events, {

    // Add multiple handlers using an object literal configuration
    setHandlers: function(handlers){
      _.each(handlers, function(handler, name){
        var context = null;

        if (_.isObject(handler) && !_.isFunction(handler)){
          context = handler.context;
          handler = handler.callback;
        }

        this.setHandler(name, handler, context);
      }, this);
    },

    // Add a handler for the given name, with an
    // optional context to run the handler within
    setHandler: function(name, handler, context){
      var config = {
        callback: handler,
        context: context
      };

      this._wreqrHandlers[name] = config;

      this.trigger("handler:add", name, handler, context);
    },

    // Determine whether or not a handler is registered
    hasHandler: function(name){
      return !! this._wreqrHandlers[name];
    },

    // Get the currently registered handler for
    // the specified name. Throws an exception if
    // no handler is found.
    getHandler: function(name){
      var config = this._wreqrHandlers[name];

      if (!config){
        throw new Error("Handler not found for '" + name + "'");
      }

      return function(){
        var args = Array.prototype.slice.apply(arguments);
        return config.callback.apply(config.context, args);
      };
    },

    // Remove a handler for the specified name
    removeHandler: function(name){
      delete this._wreqrHandlers[name];
    },

    // Remove all handlers from this registry
    removeAllHandlers: function(){
      this._wreqrHandlers = {};
    }
  });

  return Handlers;
})(Backbone, _);

  // Wreqr.CommandStorage
// --------------------
//
// Store and retrieve commands for execution.
Wreqr.CommandStorage = (function(){
  "use strict";

  // Constructor function
  var CommandStorage = function(options){
    this.options = options;
    this._commands = {};

    if (_.isFunction(this.initialize)){
      this.initialize(options);
    }
  };

  // Instance methods
  _.extend(CommandStorage.prototype, Backbone.Events, {

    // Get an object literal by command name, that contains
    // the `commandName` and the `instances` of all commands
    // represented as an array of arguments to process
    getCommands: function(commandName){
      var commands = this._commands[commandName];

      // we don't have it, so add it
      if (!commands){

        // build the configuration
        commands = {
          command: commandName, 
          instances: []
        };

        // store it
        this._commands[commandName] = commands;
      }

      return commands;
    },

    // Add a command by name, to the storage and store the
    // args for the command
    addCommand: function(commandName, args){
      var command = this.getCommands(commandName);
      command.instances.push(args);
    },

    // Clear all commands for the given `commandName`
    clearCommands: function(commandName){
      var command = this.getCommands(commandName);
      command.instances = [];
    }
  });

  return CommandStorage;
})();

  // Wreqr.Commands
// --------------
//
// A simple command pattern implementation. Register a command
// handler and execute it.
Wreqr.Commands = (function(Wreqr){
  "use strict";

  return Wreqr.Handlers.extend({
    // default storage type
    storageType: Wreqr.CommandStorage,

    constructor: function(options){
      this.options = options || {};

      this._initializeStorage(this.options);
      this.on("handler:add", this._executeCommands, this);

      var args = Array.prototype.slice.call(arguments);
      Wreqr.Handlers.prototype.constructor.apply(this, args);
    },

    // Execute a named command with the supplied args
    execute: function(name, args){
      name = arguments[0];
      args = Array.prototype.slice.call(arguments, 1);

      if (this.hasHandler(name)){
        this.getHandler(name).apply(this, args);
      } else {
        this.storage.addCommand(name, args);
      }

    },

    // Internal method to handle bulk execution of stored commands
    _executeCommands: function(name, handler, context){
      var command = this.storage.getCommands(name);

      // loop through and execute all the stored command instances
      _.each(command.instances, function(args){
        handler.apply(context, args);
      });

      this.storage.clearCommands(name);
    },

    // Internal method to initialize storage either from the type's
    // `storageType` or the instance `options.storageType`.
    _initializeStorage: function(options){
      var storage;

      var StorageType = options.storageType || this.storageType;
      if (_.isFunction(StorageType)){
        storage = new StorageType();
      } else {
        storage = StorageType;
      }

      this.storage = storage;
    }
  });

})(Wreqr);

  // Wreqr.RequestResponse
// ---------------------
//
// A simple request/response implementation. Register a
// request handler, and return a response from it
Wreqr.RequestResponse = (function(Wreqr){
  "use strict";

  return Wreqr.Handlers.extend({
    request: function(){
      var name = arguments[0];
      var args = Array.prototype.slice.call(arguments, 1);

      return this.getHandler(name).apply(this, args);
    }
  });

})(Wreqr);

  // Event Aggregator
// ----------------
// A pub-sub object that can be used to decouple various parts
// of an application through event-driven architecture.

Wreqr.EventAggregator = (function(Backbone, _){
  "use strict";
  var EA = function(){};

  // Copy the `extend` function used by Backbone's classes
  EA.extend = Backbone.Model.extend;

  // Copy the basic Backbone.Events on to the event aggregator
  _.extend(EA.prototype, Backbone.Events);

  return EA;
})(Backbone, _);


  return Wreqr;
})(Backbone, Backbone.Marionette, _);
